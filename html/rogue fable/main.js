/*jshint esversion: 6*/
'use strict';

var WIDE_SCREEN = false;


if (WIDE_SCREEN) {
	var SCREEN_WIDTH = 1280; //1024;
	var SCREEN_HEIGHT = 720; //700;
	var NUM_SCREEN_TILES_X = 26;
	var NUM_SCREEN_TILES_Y = 20;
	
	var HUD_START_X = 976;
	var HUD_START_Y = 2;
}
else {
	var SCREEN_WIDTH = 1024;
	var SCREEN_HEIGHT = 700;
	var NUM_SCREEN_TILES_X = 20;
	var NUM_SCREEN_TILES_Y = 20;
	var HUD_START_X = 720;
}

var SHADOW_COLOR = '#030006';
var SCALE_FACTOR = 2;
var TILE_SIZE = 40;

var NUM_TILES_X = 40;
var NUM_TILES_Y = 40;

var LOS_DISTANCE = 8;
var ABILITY_RANGE = 7;

// TIMING:
// ************************************************************************************************
var FPS = 50;
var TIME_SCALAR = 60 / FPS;
var PROJECTILE_SPEED = 12 * TIME_SCALAR;
var MOVEMENT_SPEED = 7 * TIME_SCALAR;
var FAST_MOVEMENT_SPEED = 14 * TIME_SCALAR;
var KNOCK_BACK_SPEED = 14 * TIME_SCALAR;

// WORLD:
// ************************************************************************************************
var DANGER_LEVEL = {
	TIER_I:		[null,  1,  2,  3,  4],
	TIER_II:	[null,  5,  6,  7,  8],
	TIER_III:	[null, 9, 10, 11, 12],
	BRANCH_I:	[null, 9, 10, 11, 12],
	BRANCH_II:	[null, 11, 12, 13, 14],
	TIER_IV:	[null, 15, 16, 17, 18],
};

var NUM_NPCS = {
	TIER_I: 	[null, 10, 15, 15, 20],
	TIER_II:	[null, 10, 15, 15, 20],
	TIER_III:	[null, 15, 20, 20, 25],
	BRANCH_I:	[null, 15, 20, 20, 25],
	BRANCH_II:	[null, 15, 20, 20, 25],
	TIER_IV:	[null, 18, 22, 22, 30],
};

var TIER_II_ZONES = 	['TheSwamp', 'TheUnderGrove', 'TheSunlessDesert', 'TheOrcFortress', 'TheIronFortress'];
var TIER_III_ZONES =	['TheCrypt', 'TheDarkTemple'];
var BRANCH_I_ZONES =	['TheArcaneTower', 'TheSewers'];
var BRANCH_II_ZONES =	['TheCore', 'TheIceCaves'];

// PLAYER_BALANCE:
// ************************************************************************************************
var CLASS_LIST = ['Warrior', 'Barbarian', 'Rogue', 'Ranger', 'FireMage', 'StormMage', 'IceMage', 'Necromancer', 'Enchanter'];
var MAX_LEVEL = 20;
var MAX_SKILL = 20;
var PLAYER_INITIAL_MAX_FOOD = 20;
var SKILL_POINTS_PER_LEVEL = 1;
var MAX_DEFENSE = 0.75;
var MAX_RAGE = 5;
var RAGE_DECREASE_TURNS = 10;
var RAGE_POINT_PERCENT = 0.1;
var TALENT_POINT_LEVELS = 3; // At what levels does the player gain a new talent point
var MAX_ABILITIES = 8;
var TALENTS_PER_BOOK = 3;

// INVENTORY:
var INVENTORY_WIDTH = 6;
var INVENTORY_HEIGHT = 3;
var WEAPON_HOT_BAR_WIDTH = 3;
var WEAPON_HOT_BAR_HEIGHT = 2;
var CONSUMABLE_HOT_BAR_WIDTH = 7;
var CONSUMABLE_HOT_BAR_HEIGHT = 2;
var MERCHANT_INVENTORY_WIDTH = 6;
var MERCHANT_INVENTORY_HEIGHT = 10;

// PLAYER_STARTING_STATS:
// ************************************************************************************************
var PLAYER_INITIAL_HP = {
	Warrior: 24,
	Barbarian: 24,
	Ranger: 24,
	Rogue: 24,
	FireMage: 24,
	StormMage: 24,
	IceMage: 24,
	Necromancer: 24,
	Enchanter: 24,
	
};
var PLAYER_INITIAL_MP = {
	Warrior: 3,
	Barbarian: 3,
	Ranger: 3,
	Rogue: 3,
	FireMage: 3,
	StormMage: 3,
	IceMage: 3,
	Necromancer: 3,
	Enchanter: 3
};

var PLAYER_HP_PER_LEVEL = {
	Warrior: 		PLAYER_INITIAL_HP.Warrior / 19,
	Barbarian: 		PLAYER_INITIAL_HP.Barbarian / 19,
	Ranger: 		PLAYER_INITIAL_HP.Ranger / 19,
	Rogue: 			PLAYER_INITIAL_HP.Rogue / 19,
	FireMage: 		PLAYER_INITIAL_HP.FireMage / 19,
	StormMage: 		PLAYER_INITIAL_HP.StormMage / 19,
	Necromancer: 	PLAYER_INITIAL_HP.Necromancer / 19,
	IceMage:		PLAYER_INITIAL_HP.IceMage / 19,
	Enchanter: 		PLAYER_INITIAL_HP.IceMage / 19,
};
var PLAYER_MP_PER_LEVEL = {
	Warrior: 		0,//PLAYER_INITIAL_MP.Warrior / 19,
	Barbarian: 		0,//PLAYER_INITIAL_MP.Barbarian / 19,
	Ranger: 		0,//PLAYER_INITIAL_MP.Ranger / 19,
	Rogue: 			0,//PLAYER_INITIAL_MP.Rogue / 19,
	FireMage: 		0,//PLAYER_INITIAL_MP.FireMage / 19,
	StormMage: 		0,//PLAYER_INITIAL_MP.StormMage / 19,
	Necromancer: 	0,//PLAYER_INITIAL_MP.Necromancer / 19,
	IceMage:		0,
	Enchanter:		0,
};

// SKILL_BALANCE:
// ************************************************************************************************
var HP_PER_SKILL = 2;
var MP_PER_SKILL = 1;
var STEALTH_PER_SKILL = 1;
var SPELL_MULTIPLIER_PER_SKILL = 0.05;
var RANGE_MULTIPLIER_PER_SKILL = 0.05;
var SAVE_AMMO_PER_SKILL = 0.01;
var ITEM_ABILITY_MULTIPLIER_PER_LEVEL = 0.15;


var EVASION_PERCENT_PER_POINT = 0.05;
var MAX_EVASION_PERCENT = 0.75;

var REFLECTION_PERCENT_PER_POINT = 0.05;
var MAX_REFLECTION_PERCENT = 0.75;
var CRIT_PERCENT_PER_STEALTH = 0.05;

// SKILLS:
// ************************************************************************************************
var SKILL_NAMES = [
	'Melee', 
	'Fortitude', 
	'Range', 
	'Stealth',
	//'Evasion',
	'SpellCasting',
	'Focus'
];

var SKILL_DESC = {
	// Strength:
	Melee: 'Melee Skill:\n+1 Melee Power (5% Damage).',
	Fortitude: 'Fortitude Skill:\n+' + HP_PER_SKILL + ' hit points.',
	
	Range: 'Range Skill:\n+1 Range Power (5% Damage).',
	Stealth: 'Stealth Skill:\n+1 stealth which decreases the chance enemies will spot you.',
	Evasion: 'Evasion Skill:\n+1 Evasion (5% dodge chance).',
	
	// Intelligence:
	SpellCasting: 'Spell Casting Skill:\n+1 Spell Power (5% improvement).',
	Focus: 'Focus Skill:\n+' + MP_PER_SKILL + ' mana points.',
};

// NPC BALANCE:
// ************************************************************************************************
var NPC_INITIAL_HP = {LOW: 6, MLOW: 9, MEDIUM: 12, MHIGH: 18, HIGH: 24};
var NPC_MAX_HP = {LOW: 24, MLOW: 36, MEDIUM: 48, MHIGH: 72, HIGH: 96};
var NPC_HP_PER_LEVEL = {
	LOW: (NPC_MAX_HP.LOW - NPC_INITIAL_HP.LOW) / (MAX_LEVEL - 1),
	MLOW: (NPC_MAX_HP.MLOW - NPC_INITIAL_HP.MLOW) / (MAX_LEVEL - 1),
	MEDIUM: (NPC_MAX_HP.MEDIUM - NPC_INITIAL_HP.MEDIUM) / (MAX_LEVEL - 1),
	MHIGH: (NPC_MAX_HP.MHIGH - NPC_INITIAL_HP.MHIGH) / (MAX_LEVEL - 1),
	HIGH: (NPC_MAX_HP.HIGH - NPC_INITIAL_HP.HIGH) / (MAX_LEVEL - 1)
};

var NPC_INITIAL_DAMAGE = {LOW: 2, MLOW: 3, MEDIUM: 4, MHIGH: 6, HIGH: 8};
var NPC_MAX_DAMAGE = {LOW: 8, MLOW: 12, MEDIUM: 16, MHIGH: 24, HIGH: 32};
var NPC_DAMAGE_PER_LEVEL = {
	LOW: (NPC_MAX_DAMAGE.LOW - NPC_INITIAL_DAMAGE.LOW) / (MAX_LEVEL - 1),
	MLOW: (NPC_MAX_DAMAGE.MLOW - NPC_INITIAL_DAMAGE.MLOW) / (MAX_LEVEL - 1),
	MEDIUM: (NPC_MAX_DAMAGE.MEDIUM - NPC_INITIAL_DAMAGE.MEDIUM) / (MAX_LEVEL - 1),
	MHIGH: (NPC_MAX_DAMAGE.MHIGH - NPC_INITIAL_DAMAGE.MHIGH) / (MAX_LEVEL - 1),
	HIGH: (NPC_MAX_DAMAGE.HIGH - NPC_INITIAL_DAMAGE.HIGH) / (MAX_LEVEL - 1)
};



var NPC_COMMON_PERCENT = 70;
var NPC_UNCOMMON_PERCENT = 25;
var NPC_RARE_PERCENT  = 5;
var SPAWN_ENEMY_TURNS = 60; // How many turns between respawn
var SLEEPING_PERCENT = 0.1; // What is the chance for a mob to be spawned asleep
var MOB_WANDER_PERCENT = 0.20; // What is the chance for a mob to be spawned wandering


// NPC_AI:
// ************************************************************************************************
var FACTION = {
	NEUTRAL: 0,
	PLAYER: 1,
	HOSTILE: 2,
	DESTRUCTABLE: 3,
};

var MAX_AGRO_RANGE = LOS_DISTANCE;
var SHOUT_RANGE = 8;
var NPC_UNAGRO_TIME = 20;
var RANDOM_MOVE_PERCENT = 0.1;
var KITE_RANGE = 3.0;

// ITEMS_AND_EQUIPMENT:
// ************************************************************************************************
var COMMON_ITEM_PERCENT = 70;
var UNCOMMON_ITEM_PERCENT = 25; // 15 -> 25 (August 16 2018)
var RARE_ITEM_PERCENT = 5;
var NUM_EQUIPMENT_SLOTS = 14;
var SELL_ITEM_PERCENT = 0.25; // The percentage at which items are sold to merchants
var GOOD_DROP_TABLE_LIST = ['Melee', 'Staves', 'Armor', 'Shields', 'Rings', 'Charms', 'GoodScrolls']; // Used for monster zoos, drop wall rooms, branch ends etc.
var MAX_ENCHANTMENT = 5;
var EQUIPMENT_SLOT_NAMES = ['shield', 'body', 'head', 'hands', 'feet', 'ring', 'ring', 'charm'];
var LINEAR_MODDED_STATS = [
	'damage', 
	'stealth', 
	'protection', 
	'maxCharges', 
	'firePower',
	'coldPower',
	'toxicPower',
	'stormPower',
	'spellPower',
	'bonusMpRegenTime',
	'bonusHpRegenTime',
	'meleeLifeTap',
	'strength',
	'dexterity',
	'intelligence',
	'bonusMaxMp',
	'bonusReflection',
	'bonusEvasion',
	'meleePower',
	'rangePower'
];

// UI:
// ************************************************************************************************
var NUM_DAMAGE_TEXT_SPRITES = 10;
var MINI_MAP_TILE_SIZE = 6;
var MINI_MAP_SIZE_X = NUM_TILES_X;
var MINI_MAP_SIZE_Y = NUM_TILES_Y;
var MAX_STATUS_EFFECTS = 10;

// FONTS:
// ************************************************************************************************
var FONT_NAME = 'silkscreennormal'; // Inconsolata, Monospace

var SMALL_WHITE_FONT = {font: '14px ' + FONT_NAME, fill: '#ffffff'};
var LARGE_WHITE_FONT = {font: '16px ' + FONT_NAME, fill: '#ffffff'};
var LARGE_BOLD_WHITE_FONT = {font: '16px ' + FONT_NAME, fill: '#ffffff', stroke: '#000000', strokeThickness: 4};
var HUGE_WHITE_FONT = {font: '24px ' + FONT_NAME, fill: '#ffffff', stroke: '#000000', strokeThickness: 4};
var SMALL_GREEN_FONT = {font: '14px ' + FONT_NAME, fill: '#00ff00'};
var LARGE_RED_FONT = {font: '16px ' + FONT_NAME, fill: '#ff0000', stroke: '#000000', strokeThickness: 4};
var CHARACTER_HEALTH_FONT = {font: '14px ' + FONT_NAME, fill: '#00ff00', stroke: '#111111', strokeThickness: 3};
var CHARACTER_STATUS_FONT = {font: '14px ' + FONT_NAME, fill: '#ffffff', stroke: '#111111', strokeThickness: 3};

// GENERATION:
// ************************************************************************************************
var LOCKED_STAIRS_ROOM_CHANCE = 0.10;
var STATIC_LEVEL_CHANCE = 0.10; // 0.10 chance to spawn a static level instead of a generated level
var DOUBLE_GOLD_CHANCE = 0.10; // chance to spawn double max gold on a level
var MAX_MONSTER_ZOO_NPCS = 9;
var MAX_DROP_WALL_NPCS = 6;
var VAULT_ROOM_PERCENT = 0.5; // Chance a vault will potentially spawn in place of a standard room

// Floating Features:
var FLOATING_FEATURE_PERCENT = 0.25;

// Enchantment Table:
var ENCHANTMENT_TABLE_MIN_LEVEL = 5;
var ENCHANTMENT_TABLE_PERCENT = 4 / 28;

// Transferance Table:
var TRANSFERANCE_TABLE_MIN_LEVEL = 9;
var TRANSFERANCE_TABLE_PERCENT = 4 / 28;

// Altars:
var ALTER_MIN_LEVEL = 3;
var SPAWN_ALTER_PERCENT = 4 / 28; // 4 Altars in 28 dungeon levels

// Good Stuff (stuff that helps the player):
var NUM_CHESTS_PER_LEVEL = 2;
var NUM_GOLD_PER_LEVEL = 4;
var MAX_RECOVERY_MUSHROOMS = 5;
var NUM_FOUNTAINS_PER_LEVEL = 2;
var ITEM_ENCHANTED_PERCENT = 0.25;
var STANDARD_DROP_PERCENT = 0.25; // 0.30 What is the chance for an NPC to drop either gold or an item 0.25->0.40 Feb 19, 0.40->0.35Feb21
var DROP_GOLD_PERCENT = 0.75; // What is the chance to drop gold, otherwise drop an item

// Skill Trainer:
var SKILL_TRAINER_MIN_LEVEL = 9;
var SKILL_TRAINER_PERCENT = 0.10;

// Talent Trainer:
var TALENT_TRAINER_MIN_LEVEL = 9;
var TALENT_TRAINER_PERCENT = 0.10;

// PRIEST:
var PRIEST_MIN_LEVEL = 13;
var PRIEST_PERCENT = 0.25;

// Double Monsters:
var DOUBLE_MONSTER_MIN_LEVEL = 5;
var DOUBLE_MONSTER_CHANCE = 0.0;//0.10; // chance to spawn double max monsters on a level

// Merchant:
var MERCHANT_MIN_LEVEL = 5;
var MERCHANT_SPAWN_PERCENT = 0.10;

// Fire Mushrooms:
var MAX_FIRE_MUSHROOMS = 4;

// Streamers:
var STREAMER_MIN_LEVEL = 5;
var SPAWN_STREAMER_PERCENT = 0.05;
var DOUBLE_STREAMER_PERCENT = 0.25;
var MIN_STREAMER_LENGTH = 24;

// Vines:
var SPAWN_VINE_PERCENT = 0.50;
var MAX_VINES = 4;
var SUPER_VINE_PERCENT = 0.05;

// Ice:
var MAX_ICE = 4;
var SUPER_ICE_PERCENT = 0.05;

// Water:
var SPAWN_WATER_PERCENT = 0.50;
var MAX_WATER = 4;
var SUPER_WATER_PERCENT = 0.05;

// Lava:
var MAX_LAVA = 6;
var SUPER_LAVA_PERCENT = 0.05;

// Teleport Trap:
var TELEPORT_TRAP_MIN_LEVEL = 2;
var SPAWN_TELEPORT_TRAP_PERCENT = 0.20;
var MAX_TELEPORT_TRAPS = 2;

// Pit Traps:
var PIT_TRAP_MIN_LEVEL = 3;
var SPAWN_PIT_TRAP_PERCENT = 0.1;
var MAX_PIT_TRAPS = 2;

// Bear Traps:
var SPAWN_BEAR_TRAPS_PERCENT = 0.25;
var MAX_BEAR_TRAPS = 10;

// Fire Traps:
var SPAWN_FIRE_VENTS_PERCENT = 0.25;
var MAX_FIRE_VENTS = 10;

// Spike Traps:
var SPAWN_SPIKE_TRAPS_PERCENT = 0.25;
var MAX_SPIKE_TRAPS = 10;

// Fire Pots:
var SPAWN_FIRE_POTS_PERCENT = 0.25;
var MAX_FIRE_POTS = 10;

// Gas Barrels:
var SPAWN_GAS_POTS_PERCENT = 0.25;
var MAX_GAS_POTS = 10;

// Gas Vents:
var SPAWN_GAS_VENTS_PERCENT = 0.5;
var MAX_GAS_VENTS = 5;

// Camp fires:
var NUM_CAMP_FIRES = 2;

// Elites:
var MIN_ELITE_LEVEL = 4;
var NPC_ELITE_CHANCE = 0.05;

// MECHANICS:
// ************************************************************************************************
var CHARACTER_SIZE = {
	SMALL: 0,
	MEDIUM: 1,
	LARGE: 2
};

var DAMAGE_TYPES = [
	'Fire',
	'Cold',
	'Shock',
	'Toxic',
	'Physical'
];

var RESISTANCE_MULTIPLIER = [0, 0.8, 1.0, 1.2];


var MAX_PLAYER_SLEEP_TIME = 10;
var MP_REGEN_TIME = 100; // How many turns to regenerate 0->max hp or ep?
var HP_REGEN_TIME = 200;
var MIN_HP_REGEN_TIME = 5;
var CRIT_MULTIPLIER = 1.5; // How much are critical hits multiplied by
var INVENTORY_SIZE = 15; // Number of slots in character inventories
var SPREAD_DAMAGE_MOD = 0.9;
var TIMED_GATE_TIME = 200; 
var CORRODE_PERCENT = 0.5;
var EXTENDED_WAIT_TURNS = 200;
var MIN_MOVE_TIME = 50;
var CRITICAL_PERCENT = 0.05;
var TELEPORT_PER_TURN_PERCENT = 0.3;
var MOVE_TIME = [100, 100, 50]; // SLOW, NORMAL, FAST
var SKELETON_REVIVE_TIME = 80;
var COLD_TIME = 10;
var MAX_COLD_LEVEL = 10; // 0=NORMAL, 1=COLD, 2=FREEZING
var FREEZING_DAMAGE = 10;
var SPIDER_EGG_HATCH_TURNS = 5;
var HELL_FIRE_DAMAGE = 30;
var INFERNO_RING_DAMAGE = 2;
var FOOD_TIME = 50;
var SHROOM_HP = 10;
var SHROOM_EP = 4;
var ZONE_FADE_TIME = 250; // 250
var CONFUSION_RANDOM_MOVE_PERCENT = 0.75;

// TRAPS:
// ************************************************************************************************
var FIRE_SHROOM_MIN_DAMAGE = 8;
var FIRE_SHROOM_MAX_DAMAGE = 24;

// (will be x1.5 due to immobile crit)
var BEAR_TRAP_MIN_DAMAGE = 6; 
var BEAR_TRAP_MAX_DAMAGE = 18;

var FIRE_GLYPH_MIN_DAMAGE = 10;
var FIRE_GLYPH_MAX_DAMAGE = 30;

var SPIKE_TRAP_MIN_DAMAGE = 10;
var SPIKE_TRAP_MAX_DAMAGE = 30;

var FIRE_VENT_MIN_DAMAGE = 8;
var FIRE_VENT_MAX_DAMAGE = 24;

var FIRE_POT_MIN_DAMAGE = 15;
var FIRE_POT_MAX_DAMAGE = 45;

var GAS_VENT_MIN_DAMAGE = 4;
var GAS_VENT_MAX_DAMAGE = 12;

var GAS_POT_MIN_DAMAGE = 6;
var GAS_POT_MAX_DAMAGE = 18;





	


// DESIGN_FLAGS:
// ************************************************************************************************
var NICE_STAT_NAMES = {
	blockChance: 'Block Projectile',
	parryChance: 'Parry Melee',
	bonusMaxHp: 'Hit Points',
	bonusMaxMp: 'Mana Points',
	bonusMaxFood: 'Max Food',
	bonusExpMod: 'EXP',
	protection: 'Protection',
	fireResistance: 'Fire Resistance',
	coldResistance: 'Cold Resistance',
	toxicResistance: 'Toxic Resistance',
	shockResistance: 'Shock Resistance',
	bonusEvasion: 'Evasion',
	stealth: 'Stealth',
	stealthModifier: 'Stealth',
	meleePower: 'Melee Power',
	rangePower: 'Range Power',
	firePower: 'Fire Magic Power',
	coldPower: 'Cold Magic Power',
	toxicPower: 'Toxic Magic Power',
	stormPower: 'Storm Magic Power',
	spellPower: 'Spell Power',
	spellPowerModifier: 'Spell Power',
	bonusReflection: 'Reflection',
	isTelepathic: 'Telepathy',
	maxHpModifier: 'Hit Points',
	bonusMpRegenTime: 'Mana Regen',
	bonusHpRegenTime: 'Health Regen',
	meleeLifeTap: 'Melee Life Tap',
	strength: 'Strength',
	dexterity: 'Dexterity',
	intelligence: 'Intelligence',
};

var STAT_AS_PERCENT = {
	bonusExpMod: true,
	spellPowerModifier: true,
	maxHpModifier: true,
	stealthModifier: true,
	blockChance: true,
	parryChance: true,
};

var STAT_AS_FLAG = {
	bonusMovementSpeed: true,
	isFlying: true,
	isTelepathic: true,
	hasLifeSaving: true,
};

// FRAMES:
// ************************************************************************************************
var EQUIPMENT_SLOT_FRAMES = {
	body: 1280,
	hands: 1282,
	feet: 1283,
	head: 1284,
	ring: 1285,
	shield: 1286,
	charm: 1287,
	
};

// Targeting:
var GREEN_TARGET_BOX_FRAME = 1152;
var RED_TARGET_BOX_FRAME = 1153; // For targeting standard attacks
var PURPLE_TARGET_BOX_FRAME = 1154;
	
var GREEN_SELECT_BOX_FRAME = 1157;
var RED_SELECT_BOX_FRAME = 1158;
var PURPLE_SELECT_BOX_FRAME = 1159;

var GREEN_BOX_FRAME = 1162;
var RED_BOX_FRAME = 1163;
var PURPLE_BOX_FRAME = 1164;

var X_FRAME = 1167;

// Bars:
var HEALTH_BAR_FRAME = 1184;
var MANA_BAR_FRAME = 1185;
var FOOD_BAR_FRAME = 1186;
var EXP_BAR_FRAME = 1187;
var COLD_BAR_FRAME = 1188;
var POISON_BAR_FRAME = 1189;

// Rings:
var ELITE_RING_FRAME = 1200;
var SUMMONED_RING_FRAME = 1201;
var ALLY_RING_FRAME = 1202;

// Slots:
var ITEM_SLOT_FRAME = 1216;
var ABILITY_SLOT_FRAME = 1218;
var ABILITY_SLOT_RED_FRAME = 1220;
var ABILITY_SLOT_GREEN_FRAME = 1222;
var SLOT_SELECT_BOX_FRAME = 1232;
var RIGHT_RING_SELECT_BOX_FRAME = 1233;
var LEFT_RING_SELECT_BOX_FRAME = 1234;

// UI_BUTTONS:
var CHARACTER_BUTTON_FRAME = 1248;
var CLOSE_BUTTON_FRAME = 1250;
var OPTIONS_BUTTON_FRAME = 1252;
var SOUND_ON_BUTTON_FRAME = 1254;
var MUSIC_ON_BUTTON_FRAME = 1256;
var QUIT_BUTTON_FRAME = 1258;
var EXPLORE_BUTTON_FRAME = 1260;
var SOUND_OFF_BUTTON_FRAME = 1262;
var MUSIC_OFF_BUTTON_FRAME = 1264;



var PARTICLE_FRAMES = {
	RED:	1666,
	BLUE:	1667,
	GREEN:	1668,
	PURPLE:	1669,
	WHITE:	1670,
	YELLOW:	1671,
	SMOKE:	1672,
	MEZ:	1673,
};

var PLAYER_FRAMES = {
	Barbarian:		864,
	Necromancer:	865,
	Rogue:			866,
	Ranger:			867,
	FireMage:		868,
	StormMage:		869,
	IceMage:		870,
	Warrior:		871,
	Enchanter:		872,
};/*global gs, menuState, console, Phaser, window, trailerState, document, navigator*/
/*global SCREEN_WIDTH, SCREEN_HEIGHT, TILE_SIZE, SCALE_FACTOR, WIDE_SCREEN, SHADOW_COLOR, HUGE_WHITE_FONT, LARGE_WHITE_FONT*/
/*jshint esversion: 6*/
'use strict';

var game;
var loader = {};
var kongregate = null;
var kongregateAPI = kongregateAPI || null;

// WINDOW_ON_LOAD:
// Called when the page is finished loading
// ************************************************************************************************
window.onload = function () {
	/*
	var gui = require('nw.gui');
	var win = gui.Window.get();
	var zoomPercent = 150;
	win.zoomLevel = Math.log(zoomPercent/100) / Math.log(1.2);
	*/
	
	//SCREEN_WIDTH = window.screen.width;
	//SCREEN_HEIGHT = window.screen.height;
	
	
	game = new Phaser.Game(SCREEN_WIDTH, SCREEN_HEIGHT, Phaser.CANVAS, 'gameDiv');
	game.state.add('game', gs);
	game.state.add('menu', menuState);
	game.state.add('loader', loader);
	game.state.add('trailer', trailerState);
	
	
	
	game.state.start('loader');
	
	
};

loader.checkCookies = function () {
	var cookieEnabled = navigator.cookieEnabled;
    if (!cookieEnabled){ 
        document.cookie = "testcookie";
        cookieEnabled = document.cookie.indexOf("testcookie")!=-1;
    }
    return cookieEnabled || false;
};


// CREATE:
// ************************************************************************************************
loader.create = function () {
	// Load Kong API:
	if (document.URL.includes("kongregate") ) {
  		if (!kongregate && kongregateAPI) {
			let onComplete = function () {
				// Set the global kongregate API object
				kongregate = kongregateAPI.getAPI();
				console.log('Kong API Loaded');
			};
		
			kongregateAPI.loadAPI(onComplete);
		}
	}
	
	if (!loader.checkCookies()) {
		let text = game.add.text(0, 0, '', LARGE_WHITE_FONT);
		text.setText('You must enable your cookies / site Data\nIn Fire Fox: open menu (top right corner of browser)\nContent Blocking => Cookies and Site Data Tab => Accept Cookies and Site Data');
		
		
		return;
	}

	game.stage.backgroundColor = SHADOW_COLOR;
	
	game.scale.scaleMode = Phaser.ScaleManager.USER_SCALE;
	//game.scale.setUserScale(3, 3);
	game.renderer.renderSession.roundPixels = true;
	Phaser.Canvas.setImageRenderingCrisp(game.canvas);
	
	// Capturing right click:
	game.canvas.oncontextmenu = function (e) {
		e.preventDefault();
	};
	
	

	//game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
	//game.scale.setMinMax(100,100,2000,2000);
	
    //	You can listen for each of these events from Phaser.Loader
    game.load.onLoadStart.add(this.loadStart, this);
    game.load.onFileComplete.add(this.fileComplete, this);
    game.load.onLoadComplete.add(this.loadComplete, this);

    //	Progress report
    //this.text = game.add.text(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, '', { fill: '#ffffff' });
	this.text = game.add.text(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, '', HUGE_WHITE_FONT);

	// Font:
	//game.load.bitmapFont('Silkscreen', 'assets/fonts/silkscreen.png', 'assets/fonts/silkscreen.fnt');
	
	// Load stuff here:
	game.load.image('Title', 'assets/images/Title.png');
    game.load.spritesheet('Tileset', 'assets/images/Tileset.png', TILE_SIZE / SCALE_FACTOR, TILE_SIZE / SCALE_FACTOR);
	game.load.spritesheet('MapTileset', 'assets/images/MapTileset.png', TILE_SIZE / SCALE_FACTOR, 2 * TILE_SIZE / SCALE_FACTOR);
	game.load.spritesheet('EffectsTileset', 'assets/images/EffectsTileset.png', 2 * TILE_SIZE / SCALE_FACTOR, 2 * TILE_SIZE / SCALE_FACTOR);
	
	// HUD:
	game.load.image('Menu', 'assets/images/Menu.png');
	
	if (WIDE_SCREEN) {
		game.load.spritesheet('HUD', 'assets/images/HUD-Wide.png', 640, 360);
	}
	else {
		game.load.spritesheet('HUD', 'assets/images/HUD.png', 512, 350);
	}
	
	game.load.image('Bar', 'assets/images/Bar.png');
	game.load.spritesheet('Button', 'assets/images/Button.png', 100, 12);
	game.load.spritesheet('TextBox', 'assets/images/TextBox.png', 240, 8);
	game.load.image('MiniMap', 'assets/images/MiniMap.png');
	game.load.image('SmallMenu', 'assets/images/SmallMenu.png');
	game.load.spritesheet('BigSlot', 'assets/images/BigSlot.png', 24, 24);
	
	// STATIC_LEVELS_JSON:
	game.load.json('TestLevel', 'assets/maps/StaticLevels/TestLevel.json');
	
	// THE_UPPER_DUNGEON:
	game.load.json('TheUpperDungeon-01', 'assets/maps/StaticLevels/TheUpperDungeon-01.json');
	game.load.json('TheUpperDungeon-02', 'assets/maps/StaticLevels/TheUpperDungeon-02.json');
	game.load.json('TheUpperDungeon-03', 'assets/maps/StaticLevels/TheUpperDungeon-03.json');
	game.load.json('TheUpperDungeon-04', 'assets/maps/StaticLevels/TheUpperDungeon-04.json');
	game.load.json('TheUpperDungeon-OrcEntrance01', 'assets/maps/StaticLevels/TheUpperDungeon-OrcEntrance01.json');
	
	// THE_ORC_FORTRESS:
	game.load.json('TheOrcFortress-01', 'assets/maps/StaticLevels/TheOrcFortress-01.json');
	game.load.json('TheOrcFortress-02', 'assets/maps/StaticLevels/TheOrcFortress-02.json');
	game.load.json('TheOrcFortress-03', 'assets/maps/StaticLevels/TheOrcFortress-03.json');
	
	// THE_IRON_FORTRESS:
	game.load.json('TheIronFortress-01', 	'assets/maps/StaticLevels/TheIronFortress-01.json');
	game.load.json('TheIronFortress-02', 	'assets/maps/StaticLevels/TheIronFortress-02.json');
	
	// THE_UNDER_GROVE:
	game.load.json('TheUnderGrove-01', 		'assets/maps/StaticLevels/TheUnderGrove-01.json');
	game.load.json('TheUnderGrove-02', 		'assets/maps/StaticLevels/TheUnderGrove-02.json');

	// THE_DARK_TEMPLE:
	game.load.json('TheDarkTemple-01', 'assets/maps/StaticLevels/TheDarkTemple-01.json');
	game.load.json('TheDarkTemple-02', 'assets/maps/StaticLevels/TheDarkTemple-02.json');
	
	// THE_CORE::
	game.load.json('TheCore-01', 			'assets/maps/StaticLevels/TheCore-01.json');
	game.load.json('TheCore-EndLevel01', 	'assets/maps/StaticLevels/TheCore-EndLevel01.json');
	game.load.json('TheCore-EndLevel02',	'assets/maps/StaticLevels/TheCore-EndLevel02.json');
	
	// THE_ICE_CAVES:
	game.load.json('TheIceCaves-01', 			'assets/maps/StaticLevels/TheIceCaves-01.json');
	game.load.json('TheIceCaves-EndLevel01',	'assets/maps/StaticLevels/TheIceCaves-EndLevel01.json');
	game.load.json('TheIceCaves-EndLevel02',	'assets/maps/StaticLevels/TheIceCaves-EndLevel02.json');
	
	// THE_SEWERS:
	game.load.json('TheSewers-01', 			'assets/maps/StaticLevels/TheSewers-01.json');
	game.load.json('TheSewers-EndLevel01',	'assets/maps/StaticLevels/TheSewers-EndLevel01.json');
	game.load.json('TheSewers-EndLevel02',	'assets/maps/StaticLevels/TheSewers-EndLevel02.json');
	
	// THE_ARCANE_TOWER:
	game.load.json('TheArcaneTower-EndLevel01',	'assets/maps/StaticLevels/TheArcaneTower-EndLevel01.json');
	game.load.json('TheArcaneTower-EndLevel02',	'assets/maps/StaticLevels/TheArcaneTower-EndLevel02.json');
	
	// THE_CRYPT:
	game.load.json('TheCrypt-01', 			'assets/maps/StaticLevels/TheCrypt-01.json');
	game.load.json('TheCrypt-02', 			'assets/maps/StaticLevels/TheCrypt-02.json');
	
	// VAULT_OF_YENDOR:
	game.load.json('VaultOfYendor-EndLevel01', 			'assets/maps/StaticLevels/VaultOfYendor-EndLevel01.json');
	game.load.json('VaultOfYendor-EndLevel02', 			'assets/maps/StaticLevels/VaultOfYendor-EndLevel02.json');
   
	// VAULT_JSON:
	gs.loadVaults();

	
	// SOUNDS:
	game.load.audio('Armor', 'assets/audio/Armor.ogg');
	game.load.audio('Weapon', 'assets/audio/Weapon.ogg');
	game.load.audio('Potion', 'assets/audio/Potion.ogg');
	game.load.audio('Scroll', 'assets/audio/Scroll.ogg');
	game.load.audio('Coin', 'assets/audio/Coin.ogg');
	game.load.audio('Door', 'assets/audio/Door.ogg');
	game.load.audio('Fire', 'assets/audio/Fire.ogg');
	game.load.audio('Ice', 'assets/audio/Ice.ogg');
	game.load.audio('Melee', 'assets/audio/Melee.ogg');
	game.load.audio('Throw', 'assets/audio/Throw.ogg');
	game.load.audio('Point', 'assets/audio/Point.ogg');
	game.load.audio('PlayerHit', 'assets/audio/PlayerHit.ogg');
	game.load.audio('Book', 'assets/audio/Book.ogg');
	game.load.audio('Food', 'assets/audio/Food.ogg');
	game.load.audio('LevelUp', 'assets/audio/LevelUp.ogg');
	game.load.audio('Shock', 'assets/audio/Shock.ogg');
	game.load.audio('Spell', 'assets/audio/Spell.ogg');
	game.load.audio('Cure', 'assets/audio/Cure.ogg');
	game.load.audio('UIClick', 'assets/audio/UIClick.ogg');
	game.load.audio('Death', 'assets/audio/Death.ogg');
	game.load.audio('Explosion', 'assets/audio/Explosion.ogg');
	game.load.audio('Bolt', 'assets/audio/Bolt.ogg');
	game.load.audio('Jewlery', 'assets/audio/Jewlery.ogg');
	game.load.audio('Teleport', 'assets/audio/Teleport.ogg');
	game.load.audio('PitTrap', 'assets/audio/PitTrap.ogg');
	
	// Music:
	game.load.audio('MainMenu', 'assets/music/MainMenu.mp3');
	game.load.audio('MainDungeon', 'assets/music/MainDungeon.mp3');
	game.load.audio('TheUnderGrove', 'assets/music/UnderGrove.mp3');
	game.load.audio('TheIronFortress', 'assets/music/TheIronFortress.mp3');
	game.load.audio('TheCrypt', 'assets/music/TheCrypt.mp3');
	game.load.audio('TheCore', 'assets/music/TheCore.mp3');
	game.load.audio('TheIceCaves', 'assets/music/TheIceCaves.mp3');
	
    game.load.start();
};

// LOAD_START
// ************************************************************************************************
loader.loadStart = function () {
	this.text.setText("Loading ...");
};

// FILE_COMPLETE:
// Called each time a file is completed loading
// ************************************************************************************************
loader.fileComplete = function (progress, cacheKey, success, totalLoaded, totalFiles) {
	this.text.setText('Loading: ' + progress + "%");
	gs.centerText(this.text);
};

// LOAD_COMPLETE:
// Called when all files are done loading
// ************************************************************************************************
loader.loadComplete = function () {
	var darkTileset, darkMapTileset;
	this.text.setText("Load Complete");
	
	// Dark Tileset:
	gs.darkTileset = game.add.bitmapData(game.cache.getImage('Tileset').width, game.cache.getImage('Tileset').height);
	gs.darkTileset.draw(game.cache.getImage('Tileset'));
	gs.darkTileset.update();
	gs.darkTileset.processPixelRGB(function (pixel) {
		if (pixel.a > 0 || pixel.g > 0 || pixel.b > 0 || pixel.r > 0) {
			pixel.r = Math.round(pixel.r * 0.5);
			pixel.g = Math.round(pixel.g * 0.5);
			pixel.b = Math.round(pixel.b * 0.5);
			return pixel;
		}
		
		return false;
	}, this);
	game.cache.addSpriteSheet('DarkTileset', null, gs.darkTileset.canvas, 20, 20);
	
	// Dark MapTileset:
	gs.darkMapTileset = game.add.bitmapData(game.cache.getImage('MapTileset').width, game.cache.getImage('MapTileset').height);
	gs.darkMapTileset.draw(game.cache.getImage('MapTileset'));
	gs.darkMapTileset.update();
	gs.darkMapTileset.processPixelRGB(function (pixel) {
		if (pixel.a > 0 || pixel.g > 0 || pixel.b > 0 || pixel.r > 0) {
			pixel.r = Math.round(pixel.r * 0.5);
			pixel.g = Math.round(pixel.g * 0.5);
			pixel.b = Math.round(pixel.b * 0.5);
			return pixel;
		}
		
		return false;
	}, this);
	game.cache.addSpriteSheet('DarkMapTileset', null, gs.darkMapTileset.canvas, 20, 40);
	
	
	gs.music = {};
	gs.music.MainMenu = game.add.audio('MainMenu');
	gs.music.MainDungeon = game.add.audio('MainDungeon');
	gs.music.TheUnderGrove = game.add.audio('TheUnderGrove');
	gs.music.TheIronFortress = game.add.audio('TheIronFortress');
	gs.music.TheCrypt = game.add.audio('TheCrypt');
	gs.music.TheCore = game.add.audio('TheCore');
	gs.music.TheIceCaves = game.add.audio('TheIceCaves');
	
	gs.musicList = [
		gs.music.MainMenu,
		gs.music.MainDungeon,
		gs.music.TheUnderGrove,
		gs.music.TheIronFortress,
		gs.music.TheCrypt,
		gs.music.TheCore,
		gs.music.TheIceCaves
	];
	
	gs.sounds = {};
	
	// Sound:
	gs.sounds.armor = game.add.audio('Armor');
	gs.sounds.weapon = game.add.audio('Weapon');
	gs.sounds.potion = game.add.audio('Potion');
	gs.sounds.scroll = game.add.audio('Scroll');
	gs.sounds.coin = game.add.audio('Coin');
	gs.sounds.door = game.add.audio('Door');
	gs.sounds.fire = game.add.audio('Fire');
	gs.sounds.ice = game.add.audio('Ice');
	gs.sounds.melee = game.add.audio('Melee');
	gs.sounds.throw = game.add.audio('Throw');
	gs.sounds.point = game.add.audio('Point');
	gs.sounds.playerHit = game.add.audio('PlayerHit');
	gs.sounds.food = game.add.audio('Food');
	gs.sounds.levelUp = game.add.audio('LevelUp');
	gs.sounds.shock = game.add.audio('Shock');
	gs.sounds.spell = game.add.audio('Spell');
	gs.sounds.cure = game.add.audio('Cure');
	gs.sounds.death = game.add.audio('Death');
	gs.sounds.explosion = game.add.audio('Explosion');
	gs.sounds.bolt = game.add.audio('Bolt');
	gs.sounds.jewlery = game.add.audio('Jewlery');
	gs.sounds.teleport = game.add.audio('Teleport');
	gs.sounds.pitTrap = game.add.audio('PitTrap');
	
	// Currently unused:
	gs.sounds.book = game.add.audio('Book');
	gs.sounds.uiClick = game.add.audio('UIClick');
	
	
	
	game.state.start('menu');
};


/*global game, Phaser, localStorage, menuState, loseState, console, winState, XMLHttpRequest, util*/
/*global PlayerCharacter, NPC, Container, Shop, gameMetric, ItemSlotList, frameSelector, levelController*/
/*global UIStatMenu, UICharacterMenu, UIShopMenu, UIDialogMenu, UIEnchantmentMenu, UIAcquirementMenu, UITransferanceMenu, HUD*/
/*global UIHelpMenu*/
/*global featureGenerator, roomGenerator*/
/*global SPAWN_ENEMY_TURNS*/
/*global NUM_SCREEN_TILES_X, PLAYER_FRAMES, TILE_SIZE, LOS_DISTANCE, HUGE_WHITE_FONT*/
/*global TIER_II_ZONES, TIER_III_ZONES, BRANCH_I_ZONES, BRANCH_II_ZONES*/
/*global MERCHANT_INVENTORY_WIDTH, MERCHANT_INVENTORY_HEIGHT*/
/*jshint white: true, laxbreak: true, esversion: 6*/
'use strict';


var gs = {};

// PRELOAD:
// ************************************************************************************************
gs.preload = function () {};

// CREATE:
// ************************************************************************************************
gs.create = function () {
	this.initialize();
	
	// Player:
	this.createKeys();
	this.createPlayerCharacter();
	this.createPlayerCharacterInput();
	this.createLoSRays();
	
	// Merchent Inventory (shared between all merchants):
	this.merchantInventory = new ItemSlotList(MERCHANT_INVENTORY_WIDTH * MERCHANT_INVENTORY_HEIGHT);

	// Interface:
	this.createHUDSprites();
	this.HUD = new HUD();
	
	// Fixes issue w/ firefox cropping text:
	this.HUD.stateText.updateFont(HUGE_WHITE_FONT);
	
	this.shopMenu = new UIShopMenu();
	this.characterMenu = new UICharacterMenu();
	this.enchantmentMenu = new UIEnchantmentMenu();
	this.acquirementMenu = new UIAcquirementMenu();
	this.transferanceMenu = new UITransferanceMenu();
	this.helpMenu = new UIHelpMenu();
	
	// Timing:
	this.pauseTime = 0;
	
	// New Game or Load Game:
	if (this.playerDataExists()) {
		this.loadGame();
	} 
	else {
		this.newGame();
	}
	this.activeCharacter = this.characterList[0];
	
	this.pc.updateStats();
	this.HUD.refresh();
	this.HUD.miniMap.refresh(true);
	this.startTime = Date.now();
};

// INIT:
// Moving most creation stuff here so that the entire gs can be inited in menu state in order to display backgrounds
// This should only ever be called once
// ************************************************************************************************
gs.initialize = function () {
	//console.log("gs.initialize called");
	this.setDebugProperties();
	
	// Game proporties:
	this.setState('GAME_STATE');
	this.turn = 0;
	this.globalTurnTimer = 0;
	this.activeCharacterIndex = 0;
	
	// Lists:
	this.floorItemList = [];
	this.characterList = [];
	this.projectileList = [];
	this.particleList = [];
	this.cloudList = [];
	this.damageText = [];
	this.objectList = [];
	this.particleGeneratorList = [];

	// Sprite Groups (for layering):
	this.tileMapSpritesGroup = game.add.spriteBatch();
	this.floorObjectSpritesGroup = game.add.spriteBatch();
	this.objectSpritesGroup = game.add.group();
	this.shadowSpritesGroup = game.add.group();
	this.projectileSpritesGroup = game.add.group();
	this.hudTileSpritesGroup = game.add.spriteBatch();
	this.characterHUDGroup = game.add.group();
	
	this.popUpTextSpritesGroup = game.add.group();
	
	// Create Abilties:
	this.createAbilityTypes();
	
	
	// Create Types:
	this.createPlayerType();
	this.createNPCTypes();
	this.createAnimEffectTypes();
	this.createStatusEffectTypes();
	this.createTileTypes();
	this.createProjectileTypes();
	this.createLevelTypes();
	this.createVaultTypes();
	this.createObjectTypes();
	this.createUniqueNPCTypes();
	this.createTalents();
	this.setAbilityTypeDefaults();
	this.createItemTypes();
	this.createItemDropTables();
	this.createReligionTypes();
	this.createCloudTypes();
	this.createPlayerClasses();
	this.createPlayerRaces();
	this.createNPCClassTypes();
	featureGenerator.createTypes();
	roomGenerator.createRoomTypes();
	
	frameSelector.init();
	
	// Create Pools:
	this.createParticlePool();
	this.createObjectPool();
	this.createNPCPool();
	this.createProjectilePool();
	
	// Initiate Zone:
	this.createTileMapSprites();
	
	this.dialogMenu = new UIDialogMenu();
	
	// Sound:
	this.soundOn = this.help.soundOn;
	this.musicOn = this.help.musicOn;
	
	// Light:
    //this.initLighting();
};

// LOAD_GAME:
// ************************************************************************************************
gs.loadGame = function () {
	this.pc.load();
};

// NEW_GAME:
// ************************************************************************************************
gs.newGame = function () {
	
	
	// Force a seed from debugProperties:
	if (this.debugProperties.seed) {
		this.seed = this.debugProperties.seed;
		this.isDailyChallenge = false;
	}
	// Daily challenge seed:
	else if (this.startDailyChallenge) {
		let date = new Date();
		this.playerRace = this.playerRaces.Human;
		
		this.seed = "" + date.getFullYear() + date.getMonth() + date.getDate();
		this.achievements.lastChallenge = this.seed;
		this.isDailyChallenge = true;
		localStorage.setItem('Achievements', JSON.stringify(gs.achievements));
		
		game.rnd.sow(this.seed);
		this.playerClass = util.randElem(['Warrior', 'Barbarian', 'Ranger', 'Rogue', 'FireMage', 'IceMage', 'StormMage', 'Necromancer', 'Enchanter']);
	}
	// Random seed:
	else {	
		this.seed = '' + Date.now();
		this.isDailyChallenge = false;
	}
	
	// Logging:
	this.eventLog = [];
	
	this.nextCrystalChestGroupId = 0;
	this.crystalChestGroupIsOpen = [];
	
	
	// Branches:
	this.branches = [];
	this.branches.push('TheUpperDungeon');
	this.branches.push(util.randElem(TIER_II_ZONES));
	//this.branches.push('TheIronFortress');
	this.branches.push(util.randElem(TIER_III_ZONES));
	this.branches.push(util.randElem(BRANCH_I_ZONES));
	this.branches.push(util.randElem(BRANCH_II_ZONES));
	this.branches.push('VaultOfYendor');
	
	// Altars:
	this.remainingAltars = [];
	this.forEachType(this.religionTypes, function (religionType) {
		gs.remainingAltars.push(religionType.name);
	});
	
	// Level features:
	this.levelFeatures = {
		// The Ice Caves:
		BearCave: true,
		
		// The Iron Fortress:
		PitTurret: true,
		
		// The Arcane Tower:
		GolemWorkshop: true,
	};
	
	// Keeping track of generated stuff to never double gen:
	this.previouslySpawnedFeatures = [];
	this.previouslySpawnedUniques = [];
	this.previouslySpawnedStaticLevels = [];
	
	

	// Setup Level:
	this.zoneName = null;
	if (gs.debugProperties.startZoneName) {
		this.changeLevel(gs.debugProperties.startZoneName, gs.debugProperties.startZoneLevel);
	}
	else {
		this.changeLevel('TheUpperDungeon', 1);
	}
	this.savedTime = 0;
	
	// Setup Player:
	if (gs.zoneName === 'TestLevel') {
		this.pc.body.snapToTileIndex({x: 2, y: 20});
		
	}
	else {
		this.pc.body.snapToTileIndex(gs.getSafestIndex() || gs.getOpenIndexInLevel());
	}
	
	// Set default class:
	this.pc.race = this.playerRace;
	this.pc.setClass(this.playerClass);
	
	// Save in case the player dies right away:
	this.saveLevel();
	this.pc.save();

	if (gs.debugProperties.onNewGame) {
		this.onNewGame();
	}

	
	//gameMetric.run();
	
	//gameMetric.testLevel();
	
	//gameMetric.analyseAllSpawnTables();
	
	//gameMetric.testLevels();
	
};

// UPDATE:
// ************************************************************************************************
gs.update = function () {
	this.updateProjectiles();
	this.updateParticles();
	this.updateParticleGenerators();
	
	if (this.pauseTime > 0) {
		this.pauseTime -= 1;
	}
	
	// NPCs will pause before using abilities until the player finishes moving:
	if (this.activeCharacter.state === 'PAUSE' && gs.pc.body.state === 'WAITING') {
		this.activeCharacter.state = 'WAITING';
	}
	
	if (this.state === 'END_TURN') {
		if (this.allCharactersReady()) {
			this.startTurn();
			this.setState('GAME_STATE');
		}
	}
	else if (gs.pc.currentHp > 0 && gs.pauseTime === 0) {
		
		// Player chooseAction:
		if (this.activeCharacter === this.pc && this.canCharacterAct(this.pc)) {
			this.pc.chooseAction();
		}

		// NPC chooseAction:
		// As long as a character does not perform a blocking action, many characters can chooseAction in the same frame
		// This makes turns much faster
		while (this.canCharacterAct(this.activeCharacter) && (this.activeCharacter !== this.pc || this.pc.actionQueue.length > 0 && this.pc.actionQueue[0].type === 'WAIT')) {
			this.activeCharacter.chooseAction();
		}
	}
	
	

	// Update sprites:
	this.updateCharacterFrames();
	this.HUD.refresh();
	this.updateDamageText();
	this.updateHUDTileSprites();
	
	
	// Update Shop Menu:
	if (this.state === 'SHOP_MENU_STATE') {
		this.shopMenu.update();
	}
	
	if (this.state === 'CHARACTER_MENU_STATE') {
		this.characterMenu.update();
	}
	
	if (this.state === 'TRANSFERANCE_MENU_STATE') {
		this.transferanceMenu.update();
	}

	// Update camera:s
	game.camera.focusOnXY(this.pc.body.position.x + 128 + 20, this.pc.body.position.y); // 128
	//game.camera.focusOnXY(this.pc.body.position.x + 148 + 20, this.pc.body.position.y); // 128
	
	this.shadowMaskSprite.x = this.pc.body.position.x;//game.camera.x;
	this.shadowMaskSprite.y = this.pc.body.position.y;//game.camera.y;
	
	
	this.updateTileMapSprites();
	
	gs.objectSpritesGroup.sort('y', Phaser.Group.SORT_ASCENDING);
	
	
};

// CAN_CHARACTER_ACT:
// ************************************************************************************************
gs.canCharacterAct = function (character) {
	return this.projectileList.length === 0
		&& this.state === 'GAME_STATE'
		&& character.state === 'WAITING'
		&& character.body.state === 'WAITING';
};



// ALL_CHARACTERS_READY:
// Use this to determine if all characters have completed movement
// ************************************************************************************************
gs.allCharactersReady = function () {
	for (let i = 0; i < this.characterList.length; i += 1) {
		if (this.characterList[i].isAlive && (this.characterList[i].body.state !== 'WAITING' || this.characterList[i].eventQueue.length > 0)) {
			return false;
		}
	}
	
	if (this.projectileList.length > 0) {
		return false;
	}

	
	return true;
};

// END_TURN:
// ************************************************************************************************
gs.endTurn = function () {
	if (this.state !== 'DIALOG_MENU_STATE' && (this.projectileList.length > 0 || this.activeCharacter.eventQueue.length > 0)) {
		this.setState('END_TURN');
	}
	else {
		this.startTurn();
	}
};

gs.removeDeadCharacters = function () {
	// Remove dead Characters:
    for (let i = this.characterList.length - 1; i >= 0; i -= 1) {
        if (!this.characterList[i].isAlive && this.characterList[i] !== gs.pc) {
            this.characterList.splice(i, 1);
        }
    }
};

// START_TURN:
// ************************************************************************************************
gs.startTurn = function () {
	var lastActiveCharacter = this.activeCharacter;
	
	this.removeDeadCharacters();
	
	if (this.activeCharacterIndex >= this.characterList.length) {
		this.activeCharacterIndex = 0;
	}

	// Ticking the global clock:
	if (lastActiveCharacter === this.pc) {
		this.globalTurnTimer += gs.pc.waitTime;
	}

	// Dead player:
	if (!gs.pc.isAlive) {
		this.activeCharacterIndex = 0;
		this.activeCharacter = gs.pc;
		return;
	}
	
	// Find the next active character:
	while (this.characterList[this.activeCharacterIndex].waitTime > 0) {
		this.characterList[this.activeCharacterIndex].waitTime -= 50;
		this.activeCharacterIndex += 1;
		if (this.activeCharacterIndex >= this.characterList.length) {
			this.activeCharacterIndex = 0;
		}
	}

	this.activeCharacter = this.characterList[this.activeCharacterIndex];
	
	// Global Turns:
	if (this.activeCharacter === this.pc) {
		while (this.globalTurnTimer >= 100) {
			this.globalTurnTimer -= 100;
			this.updateGlobalTurn();
		}
	}
	
	// The player has just started his turn so we set hasNPCActed to false
	// If an npc acts in between then we stop the player from moving
	if (this.activeCharacter === this.pc) {
		gs.HUD.miniMap.refresh();
		gs.pc.previousTileIndex = {x: gs.pc.tileIndex.x, y: gs.pc.tileIndex.y};
		gs.pc.inventory.quickWeaponEquipped = false;
		
		if (this.hasNPCActed || this.numVisibleNPCs() > 0) {
			gs.pc.stopExploring();
		}
		this.hasNPCActed = false;
	}
};

// UPDATE_GLOBAL_TURN:
// ************************************************************************************************
gs.updateGlobalTurn = function () {
	
	gs.turn += 1;

	// Update effect:
	// Reverse order so that adding new effects won't immediately update
	for (let i = this.cloudList.length - 1; i >= 0 ; i -= 1) {
		if (this.cloudList[i].isAlive) {
			this.cloudList[i].updateTurn();
		}
	}

	// Update objects:
	this.objectList.forEach(function (object) {
		if (object.updateTurn) {
			object.updateTurn();
		}
	}, this);

	// Update Characters:
	for (let i = 0; i < this.characterList.length; i += 1) {
		if (this.characterList[i].isAlive) {
			this.characterList[i].updateTurn();
		}
	}
	
	// Level Controller:
	levelController.updateTurn();
	
	this.calculateLoS();
};

// CLEAR_GAME_DATA:
// Clear all game data from localStorage (use this instead of localStorage.clear()
// This DOES NOT clear the score table
// ************************************************************************************************
gs.clearGameData = function () {
	for (let key in localStorage) {
		if (localStorage.hasOwnProperty(key)) {
			if (key !== 'Achievements' && key !== 'Help' && key !== 'GameRecords' && key !== 'hasCompressed' && key !== 'hasUTF16Compressed') {
				localStorage.removeItem(key);
			}
		}
	}
	
	// Just in case theres some fiddle fuckery here:
	game.camera.onFadeComplete.removeAll();
};

// START_MUSIC:
// Starts the appropriate music for the zone:
// ************************************************************************************************
gs.startMusic = function () {
	if (this.zoneType().musicTrack) {
		this.getZoneMusic(this.zoneName).fadeIn(1000, true);
	}
};

// STOP_ALL_MUSIC:
// ************************************************************************************************
gs.stopAllMusic = function () {
	this.musicList.forEach(function (track) {
		track.stop();
	}, this);
};

// CREATE_KEYS:
// ************************************************************************************************
gs.createKeys = function () {
	this.keys = {
		a: game.input.keyboard.addKey(Phaser.Keyboard.A),
		w: game.input.keyboard.addKey(Phaser.Keyboard.W),
		s: game.input.keyboard.addKey(Phaser.Keyboard.S),
		d: game.input.keyboard.addKey(Phaser.Keyboard.D),
		e: game.input.keyboard.addKey(Phaser.Keyboard.E),
		r: game.input.keyboard.addKey(Phaser.Keyboard.R),
		t: game.input.keyboard.addKey(Phaser.Keyboard.T),
		i: game.input.keyboard.addKey(Phaser.Keyboard.I),
		c: game.input.keyboard.addKey(Phaser.Keyboard.C),
		o: game.input.keyboard.addKey(Phaser.Keyboard.O),
		q: game.input.keyboard.addKey(Phaser.Keyboard.Q),
		
		num1: game.input.keyboard.addKey(Phaser.Keyboard.ONE),
		num2: game.input.keyboard.addKey(Phaser.Keyboard.TWO),
		num3: game.input.keyboard.addKey(Phaser.Keyboard.THREE),
		num4: game.input.keyboard.addKey(Phaser.Keyboard.FOUR),
		num5: game.input.keyboard.addKey(Phaser.Keyboard.FIVE),
		num6: game.input.keyboard.addKey(Phaser.Keyboard.SIX),
		num7: game.input.keyboard.addKey(Phaser.Keyboard.SEVEN),
		num8: game.input.keyboard.addKey(Phaser.Keyboard.EIGHT),
		esc: game.input.keyboard.addKey(Phaser.Keyboard.ESC),
		space: game.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR),
		enter: game.input.keyboard.addKey(Phaser.Keyboard.ENTER),
		p: game.input.keyboard.addKey(Phaser.Keyboard.P),
		shift: game.input.keyboard.addKey(Phaser.Keyboard.SHIFT),
		period: game.input.keyboard.addKey(Phaser.Keyboard.PERIOD),
		comma: game.input.keyboard.addKey(Phaser.Keyboard.COMMA),
		tab: game.input.keyboard.addKey(Phaser.Keyboard.TAB),
		
		// NUMPAD:
		up: game.input.keyboard.addKey(Phaser.Keyboard.UP),
		down: game.input.keyboard.addKey(Phaser.Keyboard.DOWN),
		left: game.input.keyboard.addKey(Phaser.Keyboard.LEFT),
		right: game.input.keyboard.addKey(Phaser.Keyboard.RIGHT),
		home: game.input.keyboard.addKey(Phaser.Keyboard.HOME),
		pageUp: game.input.keyboard.addKey(Phaser.Keyboard.PAGE_UP),
		pageDown: game.input.keyboard.addKey(Phaser.Keyboard.PAGE_DOWN),
		end: game.input.keyboard.addKey(Phaser.Keyboard.END),
		
		numPad1: game.input.keyboard.addKey(Phaser.Keyboard.NUMPAD_1),
		numPad2: game.input.keyboard.addKey(Phaser.Keyboard.NUMPAD_2),
		numPad3: game.input.keyboard.addKey(Phaser.Keyboard.NUMPAD_3),
		numPad4: game.input.keyboard.addKey(Phaser.Keyboard.NUMPAD_4),
		numPad5: game.input.keyboard.addKey(12),
		numPad6: game.input.keyboard.addKey(Phaser.Keyboard.NUMPAD_6),
		numPad7: game.input.keyboard.addKey(Phaser.Keyboard.NUMPAD_7),
		numPad8: game.input.keyboard.addKey(Phaser.Keyboard.NUMPAD_8),
		numPad9: game.input.keyboard.addKey(Phaser.Keyboard.NUMPAD_9),
	};
};

// DESCRIPTION_OF_TILE_INDEX:
// Return a textual description of the tile located at tileIndex
// ************************************************************************************************
gs.descriptionOfTileIndex = function (tileIndex) {
	// Offscreen:
    if (!gs.isInBounds(tileIndex)) {
        return null;
    }
	// Unexplored:
	else if (!gs.getTile(tileIndex).explored) {
        return 'Unexplored';
    }
	// Character:
	else if (gs.getChar(tileIndex) && gs.pc.canSeeCharacter(gs.getChar(tileIndex))) {
		return gs.characterDesc(gs.getChar(tileIndex));
    }
	// Merchant:
	else if (gs.getChar(tileIndex) && gs.inArray(gs.getChar(tileIndex).type.name, ['Merchant', 'SkillTrainer', 'TalentTrainer', 'Priest'])) {
		return gs.characterDesc(gs.getChar(tileIndex));
    }
	// Effect:
	else if (gs.getCloud(tileIndex) && gs.getTile(tileIndex).visible) {
		return gs.capitalSplit(gs.getCloud(tileIndex).name) || 'Effect';
    }
	// Item:
	else if (gs.getItem(tileIndex)) {
        return gs.getItem(tileIndex).item.toLongDesc();
	}
	// Object:
	else if (gs.getTile(tileIndex).object && !gs.getTile(tileIndex).object.type.isHidden) {
		return gs.objectDesc(gs.getTile(tileIndex).object);
	}	
	// Tile:
	else {
		return gs.tileDesc(gs.getTile(tileIndex));
	}
};

// PLAY_SOUND:
// ************************************************************************************************
gs.playSound = function (sound, tileIndex) {
	if (!tileIndex || gs.getTile(tileIndex).visible || gs.distance(gs.pc.tileIndex, tileIndex) < 10) {
		if (this.soundOn) {
			sound.play();
		}
	}
};

// GAME_TIME:
// Returns the time since starting new game.
// Takes loading and continuing into account
// ************************************************************************************************
gs.gameTime = function () {
	return (Date.now() - gs.startTime) + gs.savedTime;
};

// LOAD_RANDOM_MAP_AS_BACKGROUND:
// ************************************************************************************************
gs.loadRandomMapAsBackground = function () {	
	var camTileIndex = {};
	
	// Load Map:
	gs.debugProperties.mapExplored = true;
	gs.debugProperties.mapVisible = true;
	gs.debugProperties.dressRooms = true;
	gs.debugProperties.spawnMobs = true;
	gs.debugProperties.spawnZoos = true;
	gs.debugProperties.generateGlobalStuff = true;
	gs.debugProperties.useLighting = false;
	
	gs.previouslySpawnedFeatures = [];
	gs.crystalChestGroupIsOpen = [];
	gs.remainingAltars = [];
	gs.levelFeatures = {};
	gs.previouslySpawnedUniques = [];
	gs.previouslySpawnedStaticLevels = [];
	gs.branches = [
		'TheUpperDungeon', 
		'TheOrcFortress', 'TheIronFortress', 'TheUnderGrove', 'TheSunlessDesert', 'TheSwamp',
		'TheDarkTemple', 'TheCrypt',
		'TheArcaneTower', 'TheSewers', 'TheIceCaves', 'TheCore',
		'VaultOfYendor'
	];
	
	gs.zoneName = util.randElem(gs.branches);
	gs.zoneLevel = util.randInt(1, 4);
	gs.generateLevel();
	
	// Set map visible:
	gs.exploreMap();
	gs.getAllIndex().forEach(function (tileIndex) {
		gs.getTile(tileIndex).visible = true;
	}, this);
	
	// Focus Camera:
	game.world.bounds.setTo(-1000, -1000, (this.numTilesX - 1) * TILE_SIZE + 2000, (this.numTilesY - 1) * TILE_SIZE + 3000);
	game.camera.setBoundsToWorld();

	
	// Make sure NPCs are visible and not displaying their hud info
	gs.updateTileMapSprites();
	gs.characterList.forEach(function (npc) {
		npc.updateFrame();
		npc.statusText.visible = false;
		npc.hpText.visible = false;
		npc.ringSprite.visible = false;
	}, this);
};



gs.localStorageSpace = function() {
	var allStrings = '';
	for(var key in localStorage){
		if (localStorage.hasOwnProperty(key)){
			allStrings += localStorage[key];
		}
	}
	return allStrings ? 3 + ((allStrings.length*16)/(8*1024)) + ' KB' : 'Empty (0 KB)';
};

gs.postStats = function (text) {
	if (!gs.help.userName || gs.help.userName.length <= 3 || gs.help.userName.length > 30 || !gs.debugProperties.logStats) {
		return;
	}
	console.log('attempting to send stats to server...');
	var xhttp = new XMLHttpRequest();
	var data = {
		playerName: gs.help.userName,
		zoneName: gs.capitalSplit(this.zoneName),
		zoneLevel: this.niceZoneLevel(this.zoneName, this.zoneLevel),
		text: text,
		playerClass: gs.pc.characterClass,
		playerLevel: gs.pc.level,
		time: gs.timeToString(gs.gameTime()),
	};
	xhttp.open('POST','https://justinwang123.pythonanywhere.com/stats/submit',true);
	xhttp.send(JSON.stringify(data));
};

gs.setState = function (newState) {
	this.state = newState;
};/*global gs, localStorage*/
'use strict';

var help = {};

// LEVEL_UP_DIALOG:
// ************************************************************************************************
help.levelUpDialog = function () {
	var dialog;
	
	if (!gs.help.skills && gs.state !== 'DIALOG_MENU_STATE') {
		// Setup Dialog:
		dialog = [{}];
		dialog[0].text = 'You have gained a level! You now have skill and talent points to spend. Your hit points and mana have also been restored to full.';
		dialog[0].responses = [{text: 'Ok', nextLine: 'exit'}
							  ];

		gs.help.skills = true;
		localStorage.setItem('Help', JSON.stringify(gs.help));
		gs.dialogMenu.open(dialog);
	}	
};

// TALENT_DIALOG:
// ************************************************************************************************
help.talentDialog = function () {
	var dialog;
	
	if (!gs.help.talents && gs.state !== 'DIALOG_MENU_STATE') {
		// Setup Dialog:
		dialog = [{}];
		dialog[0].text = 'You have gained a talent point!. You will gain a talent point every 4 levels. You began the game with a book specific to your class from which you can learn new talents. If you have found other books you can also learn talents from them. All talents have a minimum skill requirement.';
		dialog[0].responses = [{text: 'Ok', nextLine: 'exit'}
							  ];

		gs.help.talents = true;
		localStorage.setItem('Help', JSON.stringify(gs.help));
		gs.dialogMenu.open(dialog);
	}	
};

// ITEM_DIALOG:
// ************************************************************************************************
help.itemDialog = function () {
	var dialog;
	
	if (!gs.help.items && gs.state !== 'DIALOG_MENU_STATE') {
		// Setup Dialog:
		dialog = [{}];
		dialog[0].text = 'You have just picked up a piece of equipment, press C to open your character menu and equip it!';
		dialog[0].responses = [{text: 'Ok', nextLine: 'exit'}
							  ];

		gs.help.items = true;
		localStorage.setItem('Help', JSON.stringify(gs.help));
		gs.dialogMenu.open(dialog);
	}	
};

// BOOK_DIALOG:
// ************************************************************************************************
help.bookDialog = function () {
	var dialog;
	
	if (!gs.help.books && gs.state !== 'DIALOG_MENU_STATE') {
		
		// Setup Dialog:
		dialog = [{}];
		dialog[0].text = 'You have just picked up a talent book. Press C to open your character menu and view your available talents. When you have talent points available you can choose to learn new talents from it.';
		dialog[0].responses = [{text: 'Ok', nextLine: 'exit'}
							  ];

		gs.help.books = true;
		localStorage.setItem('Help', JSON.stringify(gs.help));
		gs.dialogMenu.open(dialog);
	}	
};

// STAIRS_DIALOG:
// ************************************************************************************************
help.stairsDialog = function () {
	var dialog;
	
	if (!gs.help.stairs && gs.state !== 'DIALOG_MENU_STATE') {
		
		// Setup Dialog:
		dialog = [{}];
		dialog[0].text = 'You have discovered a flight of stairs leading deeper into the dungeon. Use the < or > keys to descend or click the button on the HUD.';
		dialog[0].responses = [{text: 'Ok', nextLine: 'exit'}];

		gs.help.stairs = true;
		localStorage.setItem('Help', JSON.stringify(gs.help));
		gs.dialogMenu.open(dialog);
	}	
};

// REST_DIALOG:
// ************************************************************************************************
help.restDialog = function () {
	var dialog;
	
	if (!gs.help.rest && gs.state !== 'DIALOG_MENU_STATE') {
		
		// Setup Dialog:
		dialog = [{}];
		dialog[0].text = 'Your health is low, shift + click yourself to rest until healed.';
		dialog[0].responses = [{text: 'Ok', nextLine: 'exit'}];

		gs.help.rest = true;
		localStorage.setItem('Help', JSON.stringify(gs.help));
		gs.dialogMenu.open(dialog);
	}	
};

// UNSAFE_MOVE_DIALOG:
// ************************************************************************************************
help.unsafeMoveDialog = function () {
	var dialog;
	
	if (!gs.help.unsafeMove && gs.state !== 'DIALOG_MENU_STATE') {
		
		// Setup Dialog:
		dialog = [{}];
		dialog[0].text = 'There is a dangerous hazard in this tile, use shift + click to move onto hazardous terrain.';
		dialog[0].responses = [{text: 'Ok', nextLine: 'exit'}];

		gs.help.unsafeMove = true;
		localStorage.setItem('Help', JSON.stringify(gs.help));
		gs.dialogMenu.open(dialog);
	}	
};

/*global gs, console*/
/*global Item*/
/*global FACTION*/
/*jshint esversion: 6*/
'use strict';

var debug = {};

// SPAWN_NEXT_NPC:
// Use for testing each NPC in the game, one by one
// ************************************************************************************************
debug.spawnNextNPC = function () {
	if (!this.nextNPCIndex) {
		this.nextNPCIndex = 0;
	}
	
	if (this.nextNPCIndex < gs.npcTypeList.length) {
		console.log(gs.debugNextNPCIndex);
		gs.spawnNPCOrGroup({x: gs.pc.tileIndex.x + 1, y: gs.pc.tileIndex.y}, gs.npcTypeList[gs.debugNextNPCIndex].name);
		gs.updateCharacterFrames();
		gs.updateTileMapSprites();
		gs.debugNextNPCIndex += 1;
	}
	else {
		console.log('No more NPCs');
	}
	
};

// CREATE_OBJECT:
// ************************************************************************************************
debug.createObject = function (typeName, tileIndex = {x: gs.pc.tileIndex.x + 1, y: gs.pc.tileIndex.y}) {
	var obj;
	obj = gs.createObject(tileIndex, typeName);
	
	gs.updateTileMapSprites();
	
	return obj;
};

// FLOOD_OBJECT:
// ************************************************************************************************
debug.floodObject = function () {
	var tileIndex = gs.getNearestPassableIndex(gs.pc.tileIndex);
	
	console.log(tileIndex.depth);
	
	gs.debugCreateObject('Table', tileIndex);
	
	gs.updateTileMapSprites();
};

// CREATE_PARTICLE_POOF
// ************************************************************************************************
debug.createParticlePoof = function() {
	gs.createParticlePoof({x: gs.pc.tileIndex.x + 1, y: gs.pc.tileIndex.y});
};

// CREATE_NPC:
// Quick debug function for creating NPCs adjacent to the player
// Generally called from the console during testing and debugging
// ************************************************************************************************
debug.createNPC = function (typeName, flags) {
	console.log('Creating NPC: ' + typeName);
    gs.createNPC({x: gs.pc.tileIndex.x + 1, y: gs.pc.tileIndex.y}, typeName, flags);
	gs.updateCharacterFrames();
	gs.updateTileMapSprites();
	
};

// AGRO_ALL_NPCS:
// ************************************************************************************************
debug.agroAllNPCs = function () {
	gs.characterList.forEach(function (npc) {
		if (npc.isAlive && npc.faction === FACTION.HOSTILE) {
			npc.agroPlayer();
		}
	}, this);
};

// ADD_ITEM:
// ************************************************************************************************
debug.addItem = function (typeName, flags) {
	gs.pc.inventory.addItem(Item.createItem(typeName, flags));
};

// CREATE_FLOOR_ITEM:
// ************************************************************************************************
debug.createFloorItem = function (typeName, flags) {
	var tileIndex = {x: gs.pc.tileIndex.x + 1, y: gs.pc.tileIndex.y};
	gs.createFloorItem(tileIndex, Item.createItem(typeName, flags)); 
};

// CREATE_RANDOM_FLOOR_ITEM:
// ************************************************************************************************
debug.createRandomFloorItem = function (dropTableName) {
	var tileIndex = {x: gs.pc.tileIndex.x + 1, y: gs.pc.tileIndex.y};
	gs.createRandomFloorItem(tileIndex, dropTableName);
};

// SET_LEVEL:
// Use this to hack the players level
// ************************************************************************************************
debug.setPlayerLevel = function (level) {
	gs.pc.level = level;
	gs.pc.exp = gs.expPerLevel[gs.pc.level];
};/*global game, gs, console, Phaser, util*/
/*global PLAYER_INITIAL_HP, HP_PER_SKILL, DROP_GOLD_PERCENT, FACTION*/
/*jshint laxbreak: true, esversion: 6, loopfunc: true*/
'use strict';

var gameMetric = {};



// ANALYSE_ALL_SPAWN_TABLES:
// ************************************************************************************************
gameMetric.analyseAllSpawnTables = function () {
	// Setup:
	gs.clearGameData();
	gs.debugProperties.spawnMobs = true;
	gs.debugProperties.saveLevels = false;
	gs.debugProperties.dressRooms = false; // stops zoos, treasure rooms from spawning
	gs.debugProperties.testLevel = true;
	gs.debugProperties.generateGlobalStuff = false;
	gs.debugProperties.spawnUniques = false;
	
	this.showPerLevel = true;
	this.showLevelUps = false;
	
	console.log('Analysing Spawn Tables...');
	this.levelMetric('TheUpperDungeon', 1);
	this.levelMetric('TheUpperDungeon', 2);
	this.levelMetric('TheUpperDungeon', 3);
	this.levelMetric('TheUpperDungeon', 4);
	
	this.levelMetric('TheUnderGrove', 1);
	this.levelMetric('TheUnderGrove', 2);
	this.levelMetric('TheUnderGrove', 3);
	this.levelMetric('TheUnderGrove', 4);
	
	this.levelMetric('TheSwamp', 1);
	this.levelMetric('TheSwamp', 2);
	this.levelMetric('TheSwamp', 3);
	this.levelMetric('TheSwamp', 4);
	
	this.levelMetric('TheSunlessDesert', 1);
	this.levelMetric('TheSunlessDesert', 2);
	this.levelMetric('TheSunlessDesert', 3);
	this.levelMetric('TheSunlessDesert', 4);
	
	this.levelMetric('TheOrcFortress', 1);
	this.levelMetric('TheOrcFortress', 2);
	this.levelMetric('TheOrcFortress', 3);
	this.levelMetric('TheOrcFortress', 4);

	this.levelMetric('TheDarkTemple', 1);
	this.levelMetric('TheDarkTemple', 2);
	this.levelMetric('TheDarkTemple', 3);
	this.levelMetric('TheDarkTemple', 4);
	
	this.levelMetric('VaultOfYendor', 1);
	this.levelMetric('VaultOfYendor', 2);
	this.levelMetric('VaultOfYendor', 3);
	this.levelMetric('VaultOfYendor', 4);
	
	throw 'Complete';
};



// ZONE_METRICS:
// ************************************************************************************************
gameMetric.run = function () {
	var zones,
		bonusExp,
		level,
		i,
		success = true;


	// Setup:
	gs.clearGameData();
	gs.debugProperties.spawnMobs = true;
	gs.debugProperties.saveLevels = false;
	gs.debugProperties.dressRooms = false; // stops zoos, treasure rooms from spawning
	this.showPerLevel = true;
	this.showLevelUps = true;

	this.pcLevel = 1;
	this.gameTotalExp = 0;
	this.gameTotalGold = 0;
	this.gameTotalItems = 0;

	this.trials = 3;
	zones = gs.branches;
	//zones = ['TheUpperDungeon'];
	
	//zones = ['TheOrcFortress'];
	
	/*
	zones = ['TheUpperDungeon', 
			 'TheUnderGrove', 'TheIronFortress', // TIER I BRANCHES
			 'TheOrcFortress',
			 'TheSewers', 'TheIceCaves', 'TheCore', // TIER II BRANCHES
			 'TheArcaneTower', 'TheCrypt',
			 'TheDarkTemple',
			 'VaultOfYendor']; // TIER III BRANCHES
			 */
	
	
	console.log(zones);
	// Pass over every zone:
	for (i = 0; i < zones.length; i += 1) {
		console.log(zones[i] + ': -------------------------------------------------------------------- \n');
		
		// Per Level Metric:
		this.zoneTotalNPCs = 0;
		this.zoneTotalGold = 0;
		this.zoneTotalExp = 0;
		this.zoneTotalItems = 0;
		this.zoneTotalShrooms = 0;
		
		for (level = 1; level <= gs.zoneTypes[zones[i]].numLevels; level += 1) {
			console.log('Level: ' + level);
			if (!this.levelMetric(zones[i], level)) {
				success = false;
				break;
			}
			this.levelUp();
		}

		if (!success) {
			break;
		}
		this.levelUp();
	}

	console.log('GAME TOTAL: -------------------------------------------------------------------- \n');
	console.log('Gold: ' + this.gameTotalGold);
	console.log('Level: ' + this.pcLevel);
	console.log('Items: ' + this.gameTotalItems);

};

// LEVEL_METRIC:
// ************************************************************************************************
gameMetric.levelMetric = function (zoneName, zoneLevel) {
	var trial,
		TRIALS = this.trials,
		npcSum = 0,
		goldSum = 0,
		itemSum = 0,
		expSum = 0,
		shroomSum = 0,
		npcLevelSum = 0,
		npcHpSum = 0,
		avgNumNPCs,
		avgGold,
		avgExp,
		avgItems,
		avgShrooms,
		success,
		str = '';

	for (trial = 0; trial < TRIALS; trial += 1) {
		// Create Level:
		if (!gs.changeLevel(zoneName, zoneLevel, true)) {
			return false;
		}
		
		if (gs.getAllIndex().find(index => !gs.getTile(index).type)) {
			throw 'Tile has no type';
		}

		// Count NPCs:
		npcSum += this.countLiveNPCs();

		// Count Gold:
		goldSum += this.countGoldInZone();

		// Count EXP:
		expSum += this.countExpInZone();
		
		// Count Items:
		itemSum += this.countContainers();
		
		// Count Shrooms:
		shroomSum += this.countShroomsInZone();
		
		// Counting npc level:
		npcLevelSum += this.averageNPCLevel();
		npcHpSum += this.averageNPCHP();
		
		/*
		if (!(gs.zoneName === 'VaultOfYendor' && gs.zoneLevel === 4) && !gs.findObj(obj => obj.type.name === 'DownStairs')) {
			throw 'Could not find down stairs.';
		}

		if (!(gs.zoneName === 'TheUpperDungeon' && gs.zoneLevel === 1) && !gs.findObj(obj => obj.type.name === 'UpStairs')) {
			throw 'Could not find up stairs.';
		}
		*/
	}

	avgNumNPCs = Math.round(npcSum / TRIALS);
	avgGold = Math.round(goldSum / TRIALS);
	avgExp = Math.round(expSum / TRIALS);
	avgItems = Math.round(itemSum / TRIALS);
	avgShrooms = Math.round(shroomSum / TRIALS);
	
	if (this.showPerLevel) {
		//console.log(zoneName + '[' + zoneLevel + ']: NPCs: ' + avgNumNPCs + ', Gold: ' + avgGold + ', Exp: ' + avgExp);
		/*
		str = zoneName + '[' + zoneLevel + ']:\t';
		str += 'AvgNPCLevel: ' + gs.roundStr(npcLevelSum / TRIALS) + ', ';
		str += 'DangerLevel: ' + gs.dangerLevel(gs.zoneName, gs.zoneLevel) + ', ';
		str += 'AvgNPCHP: ' + gs.roundStr(npcHpSum / TRIALS) + ', ';
		console.log(str);
		*/
	}

	this.zoneTotalNPCs += avgNumNPCs;
	this.zoneTotalGold += avgGold;
	this.zoneTotalExp += avgExp;
	this.zoneTotalItems += avgItems;
	this.zoneTotalShrooms += avgShrooms;

	this.gameTotalExp += avgExp;
	this.gameTotalGold += avgGold;
	this.gameTotalItems += avgItems;
	
	
	
	
	return true;
};

// AVERAGE_NPC_LEVEL:
// Returns the average level of npcs in zone
// ************************************************************************************************
gameMetric.averageNPCLevel = function () {
	var sum = 0, count = 0;
	gs.getAllNPCs().forEach(function (npc) {
		if (npc.faction === FACTION.HOSTILE) {
			sum += npc.level;
			count += 1;
		}
	}, this);
	
	return sum / count;
};

// AVERAGE_NPC_HP:
// Returns the average hp of npcs in zone
// ************************************************************************************************
gameMetric.averageNPCHP = function () {
	var sum = 0, count = 0;
	gs.getAllNPCs().forEach(function (npc) {
		if (npc.faction === FACTION.HOSTILE) {
			sum += npc.maxHp;
			count += 1;
		}
	}, this);
	
	return sum / count;
};

// COUNT_SHROOMS_IN_ZONE:
// ************************************************************************************************
gameMetric.countShroomsInZone = function () {
	var x, y, count = 0;
	for (x = 0; x < gs.numTilesX; x += 1) {
		for (y = 0; y < gs.numTilesY; y += 1) {
			if (gs.getObj(x, y, 'HealingShroom')) {
				count += 1;
			}
		}
	}
	return count;
};

// COUNT_GOLD_IN_ZONE:
// ************************************************************************************************
gameMetric.countGoldInZone = function () {
	var i, count = 0;
	for (i = 0; i < gs.floorItemList.length; i += 1) {
		if (gs.floorItemList[i].item.type === gs.itemTypes.GoldCoin) {
			count += gs.floorItemList[i].item.amount;
		}
	}
	return count;
};

// COUNT_EXP_IN_ZONE:
// ************************************************************************************************
gameMetric.countExpInZone = function () {
	var i, count = 0;
	
	gs.getAllNPCs().forEach(function (npc) {
		if (npc.faction === FACTION.HOSTILE) {
			count += npc.exp;
			count += npc.type.dropPercent * gs.dangerLevel();
		}
	}, this);
	
	gs.getAllIndex().forEach(function (tileIndex) {
		// Count Containers:
		if (gs.getObj(tileIndex, obj => obj.isContainer())) {
			count += gs.dangerLevel();
		}
		
		// Count Items:
		if (gs.getItem(tileIndex)) {
			count += gs.dangerLevel();
		}
	}, this);
		
	return count;
};

// COUNT_CONTAINERS:
// ************************************************************************************************
gameMetric.countContainers = function () {
	var count = 0;
	
	
	gs.getAllIndex().forEach(function (tileIndex) {
		// Count Containers:
		if (gs.getObj(tileIndex, obj => obj.isContainer() && !obj.isOpen)) {
			count += 1;
		}
		
		// Count Items:
		if (gs.getItem(tileIndex) && gs.getItem(tileIndex).item.type.name !== 'GoldCoin') {
			count += 1;
		}
		
		// Count NPCs:
		if (gs.getChar(tileIndex) &&
			gs.getChar(tileIndex).type.dropPercent > 0) {
			count += gs.getChar(tileIndex).type.dropPercent * (1 - DROP_GOLD_PERCENT);
		}
	}, this);
	
	
	
	return Math.round(count);
};

// LEVEL_UP:
// ************************************************************************************************
gameMetric.levelUp = function () {
	while (this.gameTotalExp >= gs.expPerLevel[this.pcLevel + 1]) {
		this.pcLevel += 1;
		if (this.showLevelUps) {
			console.log('------- GAIN_LEVEL: ' + this.pcLevel + '-------');
		}
	}
};


// NPC_METRIC:
// ************************************************************************************************
gameMetric.npcMetric = function () {
	var i, key, str;
	
	for (i = 1; i < 30; i += 1) {
		str = '[' + i + '] ';
		str += 'PC:' + (PLAYER_INITIAL_HP + (HP_PER_SKILL / 2) * i);
		
		// NPCS:
		for (key in gs.npcTypes) {
			if (gs.npcTypes.hasOwnProperty(key) && gs.npcTypes[key].faction === FACTION.HOSTILE && gs.npcTypes[key].level === i) {
				str += ', ' + key + ':' + gs.npcTypes[key].maxHp;
			}
		}
		
		console.log(str);
	}
	
	throw 'DONE';
};
// COUNT_LIVE_NPCS
// ************************************************************************************************
gameMetric.countLiveNPCs = function () {
	return gs.getAllNPCs().filter(npc => npc.faction === FACTION.HOSTILE).length;
};

// TEST_LEVEL:
// ************************************************************************************************
gameMetric.testLevel = function () {
	var TRIALS = 1,
		zoneName = 'TheSwamp',
		zoneLevel = 4;
	
	console.log('Staring gameMetric.testLevel()');
	for (let trial = 0; trial < TRIALS; trial += 1) {
		if (trial % 5 === 0) {
			console.log('Trial: ' + trial);
		}
		
		// Create Level:
		gs.changeLevel(zoneName, zoneLevel, true);
		
		let success = this.verifyStairPath();
		
		if (!success) {
			console.log('FAILED');
			break;
		}
	}
	
	console.log('Finished');
};

// VERIFY_STAIR_PATH:
// ************************************************************************************************
gameMetric.verifyStairPath = function () {
	var upStairs = gs.findObj(obj => obj.type.name === 'UpStairs'),
		downStairs = gs.findObj(obj => obj.type.name === 'DownStairs'),
		path;
	
	/*
	gs.getIndexInBox(downStairs.tileIndex.x -1, downStairs.tileIndex.y - 1, downStairs.tileIndex.x + 2, downStairs.tileIndex.y + 2).forEach(function (index) {
		gs.setTileType(index, gs.tileTypes.Wall);
	}, this);
	*/
	
	if (!upStairs || !downStairs) {
		console.log('One of the stairs was not placed');
		return false;
	}
	
	path = gs.findPath(upStairs.tileIndex, downStairs.tileIndex, {allowDiagonal: true, canWalkFunc: gs.pc.canWalk.bind(gs.pc),});
	
	if (!path || path.length === 0) {
		console.log('No valid path between stairs');
		return false;
	}
	
	return true;
	
};

gameMetric.testLevels = function () {
	var branches;
	
	console.log('starting tests');
	
	branches = [
		'TheUpperDungeon', 
		'TheOrcFortress', 'TheIronFortress', 'TheUnderGrove', 'TheSunlessDesert', 'TheSwamp',
		'TheDarkTemple', 'TheCrypt',
		'TheArcaneTower', 'TheSewers', 'TheIceCaves', 'TheCore',
		'VaultOfYendor'
	];
	
	gs.zoneName = util.randElem(gs.branches);
	gs.zoneLevel = util.randInt(1, 4);
	
	for (let i = 0; i < 100; i += 1) {
		if (i % 10 === 0) {
			console.log('test: ' + i);
		}
		
		gs.seed = '' + Date.now();
		
		gs.previouslySpawnedFeatures = [];
		gs.crystalChestGroupIsOpen = [];
		gs.remainingAltars = [];
		gs.levelFeatures = {};
		gs.previouslySpawnedUniques = [];	
		
		gs.zoneName = util.randElem(branches);
		gs.zoneLevel = util.randInt(1, 4);
		gs.generateLevel();
		
		gs.destroyLevel();
		
	}
};/*global game, gs, console, Phaser, localStorage*/
/*global LARGE_WHITE_FONT, SCALE_FACTOR, FACTION, NUM_TILES_X, NUM_TILES_Y, LARGE_BOLD_WHITE_FONT, SMALL_WHITE_FONT*/
/*global TILE_SIZE*/
/*jshint esversion: 6, laxbreak: true*/
'use strict';

var util = {};

// GET_NAME_FROM_FRAME:
// ************************************************************************************************
gs.getNameFromFrame = function (frame, typeList) {
	for (let key in typeList) {
		if (typeList.hasOwnProperty(key)) {
			if (typeList[key].frame === frame || (typeList[key].frames && this.inArray(frame, typeList[key].frames))) {
				return typeList[key].name;
			}
		}
	}

	return null;
};

// TO_POSITION:
// ************************************************************************************************
util.toPosition = function (tileIndex) {
    return {x: (tileIndex.x * TILE_SIZE) + (TILE_SIZE / 2),
            y: (tileIndex.y * TILE_SIZE) + (TILE_SIZE / 2)};
};

// TO_TILE_INDEX:
// ************************************************************************************************
gs.toTileIndex = function (position) {
    return {x: Math.floor(position.x / TILE_SIZE), y: Math.floor(position.y / TILE_SIZE)};
};

// TO_PERCENT_STRING:
// ************************************************************************************************
gs.toPercentStr = function (frac) {
	return Math.round(gs.roundValue(frac) * 100) + '%';
};

// IS_STRAIGHT:
// Are the two tileIndices on either an orthogonal or diagonal straight line
// ************************************************************************************************
gs.isStraight = function (t1, t2) {
	return t1.x === t2.x || t1.y === t2.y || Math.abs(t1.x - t2.x) === Math.abs(t1.y - t2.y);
};

// GET_8_WAY_VECTOR:
gs.get8WayVector = function (fromTileIndex, toTileIndex) {
	return {x: (toTileIndex.x - fromTileIndex.x) / (Math.abs(toTileIndex.x - fromTileIndex.x) || 1),
			y: (toTileIndex.y - fromTileIndex.y) / (Math.abs(toTileIndex.y - fromTileIndex.y) || 1)};	
};

// ARRAY_INTERSECT:
// Returns a new array that is the intersection of a1 and a2
// ************************************************************************************************
gs.arrayIntersect = function (a1, a2) {
	return a1.filter(e => a2.indexOf(e) !== -1);
};


// RAND_INT:
// ************************************************************************************************
util.randInt = function (min, max) {
	return game.rnd.integerInRange(Math.floor(min), Math.ceil(max));
};

// FRAC:
// ************************************************************************************************
util.frac = function () {
	return game.rnd.frac();
};

gs.forEachType = function (types, func, context) {
	var key;
	
	for (key in types) {
		if (types.hasOwnProperty(key)) {
			func.call(context, types[key]);
		}
	}
};


// CREATE_BOX:
// ************************************************************************************************
gs.createBox = function (startX, startY, endX, endY) {
	var box = {};
	box.startX = startX;
	box.startY = startY;
	box.endX = endX;
	box.endY = endY;
	box.width = endX - startX;
	box.height = endY - startY;
	box.centerX = box.startX + Math.floor(box.width / 2);
	box.centerY = box.startY + Math.floor(box.height / 2);
	
	box.startTileIndex = {x: startX, y: startY};
	box.endTileIndex = {x: endX, y: endY};
	box.centerTileIndex = {x: box.centerX, y: box.centerY};
	
	return box;
};

util.boxType = function (box) {
	if (Math.min(box.width, box.height) / Math.max(box.width, box.height) > 0.8) {
		return 'SQUARE';
	}
	else if (box.width > box.height) {
		return 'WIDE';
	}
	else {
		return 'TALL';
	}
};

// INTERSECT_BOX:
// Returns the box that is the intersection of both boxes:
// ************************************************************************************************
util.intersectBox = function (box1, box2) {
	var minX = 1000, minY = 10000, maxX = -1, maxY = -1;
	
	gs.getIndexInBox(box1).forEach(function (tileIndex) {
		if (util.isInBox(tileIndex, box2)) {
			minX = Math.min(minX, tileIndex.x);
			minY = Math.min(minY, tileIndex.y);
			maxX = Math.max(maxX, tileIndex.x);
			maxY = Math.max(maxY, tileIndex.y);
		}
	}, this);
	
	if (minX < maxX && minY < maxY) {
		return gs.createBox(minX, minY, maxX + 1, maxY + 1);
	}
	else {
		return null;
	}
};

// IS_IN_BOX:
// Returns true if the tileIndex is inside the box:
// Remember that boxes are lower bounds inclusive and upper bounds exclusive
// ************************************************************************************************
util.isInBox = function (tileIndex, box) {
	return tileIndex.x >= box.startX
		&& tileIndex.y >= box.startY
		&& tileIndex.x < box.endX
		&& tileIndex.y < box.endY;
};

util.isDiagonallyAdjacent = function (tileIndex1, tileIndex2) {
	return tileIndex1.x === tileIndex2.x - 1 && tileIndex1.y === tileIndex2.y - 1
		|| tileIndex1.x === tileIndex2.x - 1 && tileIndex1.y === tileIndex2.y + 1
		|| tileIndex1.x === tileIndex2.x + 1 && tileIndex1.y === tileIndex2.y - 1
		|| tileIndex1.x === tileIndex2.x + 1 && tileIndex1.y === tileIndex2.y + 1;
};

// GET_BOUNDING_BOX:
// ************************************************************************************************
util.getBoundingBox = function (indexList) {
	var minX = NUM_TILES_X,
		minY = NUM_TILES_Y,
		maxX = 0,
		maxY = 0;
	
	indexList.forEach(function (index) {
		minX = Math.min(minX, index.x);
		minY = Math.min(minY, index.y);
		maxX = Math.max(maxX, index.x);
		maxY = Math.max(maxY, index.y);
	}, this);
	
	return gs.createBox(minX, minY, maxX + 1, maxY + 1);
};

// EDGE_BOX_INDEX_LIST:
// Returns a list of tileIndices that are on the edges of the box:
// ************************************************************************************************
util.edgeBoxIndexList = function (box) {
	var indexList = [];
	
	gs.getIndexInBox(box).forEach(function (tileIndex) {
		if (tileIndex.x === box.startX || tileIndex.y === box.startY || tileIndex.x === box.endX - 1 || tileIndex.y === box.endY - 1) {
			indexList.push({x: tileIndex.x, y: tileIndex.y});
		}
	}, this);
	
	return indexList;
};

// INNER_AREA_INDEX_LIST:
// Returns a list of tileIndices that belong to the area and are at least 1 tile away from walls
// This is useful for dressing the interior of a room while guaranteeing traversability
// ************************************************************************************************
util.innerAreaIndexList = function (area) {
	var indexList;
	
	indexList = gs.getIndexInBox(area);
	indexList = indexList.filter(index => gs.getTile(index).area === area);
	
	indexList = indexList.filter(function (index) {
		return !gs.getIndexListCardinalAdjacent(index).some(idx => !gs.getTile(idx).type.passable)
			&& !gs.getIndexListCardinalAdjacent(index).some(idx => gs.getArea(idx) !== area);
	}, this);
	
	return indexList;
};


// CREATE_SPRITE:
// ************************************************************************************************
gs.createSprite = function (x, y, image, group) {
    var sprite;
	
    //sprite = game.add.sprite(x, y, image);
	sprite = game.add.image(x, y, image);
    sprite.smoothed = false;
 
    if (group) {
        group.add(sprite);
    }
    
	if (!this.countSprites) {
		this.countSprites = 1;
	} 
	else {
		this.countSprites += 1;
	}
	
    return sprite;
};

// CREATE TEXT:
// ************************************************************************************************
gs.createText = function (x, y, textStr, font, group) {
    var text, ref, ref2;
	
	
	text = game.add.text(x, y, textStr, font);
	//text = game.add.bitmapText(x, y, 'Silkscreen', textStr, 14);
	
	text.smoothed = false;
	
	// Overwrite setText:
	ref = text.setText;
	
	text.setText = function (str) {
		if (this.text != str) {
			ref.call(this, str);
		}
	};
	
	// Overwrite setStyle:
	ref2 = text.setStyle;
	
	text.setStyle = function (style) {
		if (this.style != style) {
			ref2.call(this, style);
		}
	};
	
	
    if (group) {
        group.add(text);
    }
    
    return text;
};

// CREATE_SMALL_BUTTON:
// ************************************************************************************************
gs.createSmallButton = function (x, y, frame, callBack, context, group) {
	var button;
	button = game.add.button(x, y, 'Tileset', callBack, context, frame + 1, frame);
	button.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	button.hitArea = new Phaser.Rectangle(4, 4, 12, 12);
	
	if (group) {
		group.add(button);
	}
	
	return button;
};


// CREATE_BUTTON:
// ************************************************************************************************
gs.createButton = function (x, y, image, callBack, context, group) {
    var button = game.add.button(x, y, image, callBack, context);
    button.smoothed = false;

	if (group) {
		group.add(button);
	}
    return button;
};

// CREATE_TEXT_BUTTON:
// ************************************************************************************************
gs.createTextButton = function (x, y, text, callBack, context, group) {
    var button = {};
    
    // Create button group:
    button.group = game.add.group();
    
    // Create button:
    button.button = game.add.button(x, y, 'Button', callBack, context, 1, 0, 0, 0);
	button.button.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
    button.button.smoothed = false;
    button.button.anchor.setTo(0.5, 0.5);
    button.group.add(button.button);
    
    // Create text:
    button.text = game.add.text(x - 1, y + 3, text, SMALL_WHITE_FONT);
	this.centerText(button.text);
    button.group.add(button.text);
	
	if (group) {
		group.add(button.group);
	}
    
    return button;
};

// CREATE_BAR:
// ************************************************************************************************
gs.createBar = function (x, y, frame, group) {
	var bar = {};
	
	bar.group = game.add.group();
	
	bar.frame = this.createSprite(x, y, 'Bar', bar.group);
	bar.frame.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	
	bar.bar = this.createSprite(x + SCALE_FACTOR, y + SCALE_FACTOR, 'Tileset', bar.group);
	bar.bar.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	bar.bar.frame = frame;
	
	bar.text = this.createText(x + 58, y + 12, '', LARGE_BOLD_WHITE_FONT, bar.group);
	this.centerText(bar.text);
	
	if(group) {
		group.add(bar.group);
	}
	return bar;
};

// CREATE_ICON_BUTTON:
gs.createIconButton = function (x, y, frame, callBack, context, group) {
	var button;
	
	this.createSprite(x, y, 'Slot', group);
	button = this.createButton(x + 2, y + 2, 'InterfaceTileset', callBack, context, group);
	button.frame = frame;
	
	return button;
};

// IN_ARRAY:
// ************************************************************************************************
gs.inArray =  function (element, array) {
    for (let i = 0; i < array.length; i += 1) {
        if (array[i] === element) {
            return true;
        }
    }

    return false;
};

// REMOVE_FROM_ARRAY:
// ************************************************************************************************
gs.removeFromArray = function (element, array) {
    for (let i = 0; i < array.length; i += 1) {
        if (array[i] === element) {
            array.splice(i, 1);
            return;
        }
    }
};

// RAND_ELEM:
// ************************************************************************************************
util.randElem = function (list) {
	if (list.length === 0) {
		throw 'list.length === 0';
	}
	if (list.length === 1) {
		return list[0];
	} else {
		return list[util.randInt(0, list.length - 1)];
	}
};

// CHOOSE_RANDOM:
// ************************************************************************************************
gs.chooseRandom = function (table) {
    var sum = table.reduce(function (pV, nV) {return pV + nV.percent; }, 0),
		percentSum = 0,
        rand = util.randInt(0, sum - 1),
        i;
	
    for (i = 0; i < table.length; i += 1) {
        percentSum += table[i].percent;
        if (rand < percentSum) {
            return table[i].name;
        }
    }
    
    return table[table.length - 1].name;
};

// RAND_SUBSET:
// ************************************************************************************************
gs.randSubset = function (list, size) {
	var copyList = list.slice(0),
		subset = [],
		i;
	
	if (size > list.length) {
		throw 'size > list.length';
	}
	
	for (i = 0; i < size; i += 1) {
		subset.push(copyList.splice(Math.floor(util.randInt(0, copyList.length - 1)), 1)[0]);
	}
	return subset;
};

// RANDOM_COLOR:
// ************************************************************************************************
gs.randomColor = function () {
	return 'rgb(' + util.randInt(0, 255) + ',' + util.randInt(0, 255) + ',' + util.randInt(0, 255) + ')';
};

// CAPITAL_SPLIT:
// ************************************************************************************************
gs.capitalSplit = function (string) {
	var array;
	
	// Make sure to capitalize first letter:
	string = string.charAt(0).toUpperCase() + string.slice(1);
	
	array = string.match(/[A-Z][a-z]+/g);
	return array.join(' ');
};

// WRAP_TEXT:
// ************************************************************************************************
gs.wrapText = function (text, maxWidth) {
    var i, j, lineStart = 0, lineEnd = 0, breaklines = [], lines = [];

    if (typeof (String.prototype.trim) === "undefined") {
        String.prototype.trim = function () {
            return String(this).replace(/^\s+|\s+$/g, '');
        };
    }

    breaklines = text.split('\n');

    for (j = 0; j < breaklines.length; j += 1) {
        lineStart = 0;
        lineEnd = 0;
        for (i = 0; i < breaklines[j].length; i += 1) {
            if (breaklines[j][i] === ' ') {
                lineEnd = i;
            }

            if (i - lineStart === maxWidth) {
                lines.push(breaklines[j].substring(lineStart, lineEnd));
                lineStart = lineEnd;
            }
        }

        // add remaining text:
        lines.push(breaklines[j].substring(lineStart, breaklines[j].length));
    }


    for (i = 0; i < lines.length; i += 1) {
        lines[i] = lines[i].trim();
    }

    return lines;
};

// COUNT_CHILDREN:
// ************************************************************************************************
gs.countChildren = function (group) {
	var i, sum = 0;
	// Base Case:
	if (!group.children || group.children.length === 0) {
		return 1;
	}
	
	// Recursive Case:
	for (i = 0; i < group.children.length; i += 1) {
		sum += gs.countChildren(group.children[i]);
	}
	return sum;
};

// NAME_TYPES:
// ************************************************************************************************
gs.nameTypes = function (types) {
	var key;
	
	for (key in types) {
		if (types.hasOwnProperty(key)) {
			types[key].name = key;
			types[key].niceName = this.capitalSplit(key);
		}
	}
};

// RANGE:
// ************************************************************************************************
gs.range = function (startNum, endNum, step) {
	var i, arr = [];
	
	step = step || 1;
	
	for (i = startNum; i <= endNum; i += step) {
		arr.push(i);
	}
	return arr;
};

// CREATE_2D_ARRAY:
// ************************************************************************************************
gs.create2DArray = function (numX, numY, createFunc) {
    var x, y, array;
    
    array = [];
    for (x = 0; x < numX; x += 1) {
        array[x] = [];
        for (y = 0; y < numY; y += 1) {
            array[x][y] = createFunc(x, y);
        }
    }
    return array;
};



gs.roundValue = function (value, numDec) {
	numDec = numDec || 2;
	return Math.round(value * Math.pow(10, numDec)) / Math.pow(10, numDec);
};

gs.roundStr = function (value, numDec) {
	numDec = numDec || 2;
	
	value = this.roundValue(value, numDec);
	value = String(value);
	
	while (value.length < 5) {
		value += ' ';
	}
	
	return value;
};

gs.countTypes = function (types) {
	var key, count = 0;
	
	for (key in types) {
		if (types.hasOwnProperty(key) && !types[key].hasOwnProperty('faction') || types[key].faction === FACTION.HOSTILE) {
			if (types[key].slot === undefined || types[key].slot !== 'none') {
				count += 1;
			}
			
		}
	}
	return count;
};

// CENTER_TEXT:
// ************************************************************************************************
gs.centerText = function (text) {
	text.anchor.x = Math.round(text.width * 0.5) / text.width;
	text.anchor.y = Math.round(text.height * 0.5) / text.height;
	
	if (text.anchor.x % 2 === 1) {
		text.anchor.x += 1;
	}
};

// CENTER_TEXT_X:
// ************************************************************************************************
gs.centerTextX = function (text) {
	text.anchor.x = Math.round(text.width * 0.5) / text.width;
	
	if (text.anchor.x % 2 === 1) {
		text.anchor.x += 1;
	}
};

// VECTOR_EQUAL:
// ************************************************************************************************
gs.vectorEqual = function (v1, v2) {
	return v1.x === v2.x && v1.y === v2.y;
};

// GET_TILE_DISTANCE:
// ************************************************************************************************
gs.distance = function (tileIndex1, tileIndex2) {
    return game.math.distance(tileIndex1.x, tileIndex1.y, tileIndex2.x, tileIndex2.y);
};

// SQ_DISTANCE:
// ************************************************************************************************
gs.sqDistance = function (v1, v2) {
	return Math.max(Math.abs(v1.x - v2.x), Math.abs(v1.y - v2.y));
};

// GET_CARDINAL_VECTOR:
// This function returns a vector representing a cardinal direction
// [1, 0], [-1, 0], [0, 1], [0, -1]
// This represents the nearest cardinal direction between fromTileIndex and toTileIndex
// ************************************************************************************************
gs.getCardinalVector = function (fromTileIndex, toTileIndex) {
	if (this.vectorEqual(fromTileIndex, toTileIndex)) {
		return null;
	}
	
	// X-axis is longest:
	if (Math.abs(fromTileIndex.x - toTileIndex.x) > Math.abs(fromTileIndex.y - toTileIndex.y)) {
		return {x: fromTileIndex.x < toTileIndex.x ? 1 : -1, y: 0};
	} 
	// Y-axis is longest:
	else {
		return {x: 0, y: fromTileIndex.y < toTileIndex.y ? 1 : -1};
	}
};

// GET_NORMAL_FROM_ANGLE:
// ************************************************************************************************
gs.getNormalFromAngle = function (angle) {
	angle = angle * Math.PI / 180;
	return {x: Math.sin(angle), y: Math.cos(angle)};
};

// GET_NORMAL:
// ************************************************************************************************
gs.getNormal = function (startPosition, endPosition) {
    var length = game.math.distance(startPosition.x, startPosition.y, endPosition.x, endPosition.y);
    
    return {x: (endPosition.x - startPosition.x) / length,
            y: (endPosition.y - startPosition.y) / length};
};

// GET_ORTHO_VECTOR:
// ************************************************************************************************
gs.getOrthoVector = function (vector) {
	return {x: -vector.y, y: vector.x};
};

// PLAYER_DATA_EXISTS:
// ************************************************************************************************
gs.playerDataExists = function () {
	return localStorage.getItem('PlayerData') !== null;
};

// LAST_LINES:
// Return the last [num] lines:
// ************************************************************************************************
gs.lastLines = function (lines, num) {
	if (lines.length <= num) {
		return lines;
	} else {
		return lines.slice(lines.length - num);
	}
};

// ASSERT:
// ************************************************************************************************
gs.ASSERT = function (predicate, text) {
	if (this.debugProperties.throwExceps && !predicate) {
		throw text;
	}
};

// TIME_TO_STRING:
// ************************************************************************************************
gs.timeToString = function (time) {
	var seconds = Math.round(time / 1000) % 60,
		mins = Math.floor(Math.round(time / 1000) / 60);
		
	if (seconds < 10) {
		return '' + mins + ':0' + seconds;
	}
	else {
		return '' + mins + ':' + seconds;
	}
	
};

// ANGLE_TO_FACE:
// ************************************************************************************************
util.angleToFace = function (fromPos, toPos) {
    return (game.math.angleBetween(fromPos.x, -fromPos.y, toPos.x, -toPos.y)) * 180 / Math.PI + 135;
};/*global gs, console, debug*/
/*global ItemSlotList, ItemSlot, CharacterInventory*/
/*global STATIC_LEVEL_CHANCE, VAULT_ROOM_PERCENT, FLOATING_FEATURE_PERCENT*/
/*jshint esversion: 6*/
'use strict';

// SET_DEBUG_PROPERTIES:
// ************************************************************************************************
gs.setDebugProperties = function () {
	this.versionStr = '0.50';
	
	this.debugProperties = {
		throwExceps: true,
		showAreas: false,
		mapVisible: false,
		showCharactersOnMap: true,
		npcCanAgro: true, // true
		dressRooms: true,
		generateGlobalStuff: true,
		allowRespawn: false,
		useLighting: true,
		saveLevels: true,
		testLevel: false, // false (generates a flat level)
		allowFastTravel: false, // false
		spawnUniques: true,
		logAStarTunnels: false,
		
		// Commonly used:
		startClass: 'FireMage',//,//'Rogue', //'FireMage',
		startRace: 'Human',
		startZoneName: 'TheUpperDungeon', //TestLevel',
		startZoneLevel: 1, // 1
		mapExplored: true, // false
		spawnMobs: false, // true
		disableMana: true, // false
		noDamage: true, // false
		logStats: false,
		warpStairs: true,
		showDebugText: true,
		
		onNewGame: true,
		
		seed: null,
		
		forceSideFeature: 'ChoiceTreasureRoom'
	};
	
	
	
	this.clearDebugProperties();
	//this.debugProperties.showDebugText = true;
	
	// 1542943238824, TheCrypt, 1
	// 1542940152196, TheOrcFortress, 4 (streamer)
	/*
	this.debugProperties.seed = "1542943238824";
	this.debugProperties.startZoneName = 'TheCrypt';
	this.debugProperties.startZoneLevel = 1;
	this.debugProperties.startClass = 'FireMage';
	this.debugProperties.startRace = 'Human';
	this.debugProperties.mapExplored = true;
	*/

	//STATIC_LEVEL_CHANCE = 1.0;
	
	if (STATIC_LEVEL_CHANCE !== 0.1) {
		console.log('REMEMBER TO CHANGE STATIC_LEVEL_CHANCE!');
	}
	
	if (VAULT_ROOM_PERCENT !== 0.5) {
		console.log('REMEMBER TO CHANGE VAULT_ROOM_PERCENT!');
	}
	
	if (FLOATING_FEATURE_PERCENT !== 0.25) {
		console.log('REMEMBER TO CHANGE FLOATING_FEATURE_PERCENT!');
	}
};

gs.onNewGame = function () {
	
	console.log('Num Items: ' + this.countTypes(this.itemTypes) + '/160');
	console.log('Num Abilities: ' + this.countPlayerAbilities() + '/40');
	console.log('Num Talents: ' + this.countTypes(this.talents) + '/60');
	console.log('Num Mobs: ' + this.countTypes(this.npcTypes) + '/110');
	
	gs.pc.learnTalent('FlashFreeze');
	gs.pc.learnTalent('ToxicAttunement');
	
	gs.pc.talentPoints = 10;
	
	// UNIT_TESTS:
	ItemSlot.UnitTests();
	ItemSlotList.UnitTests();
	CharacterInventory.UnitTests();
};

// CLEAR_DEBUG_PROPERTIES:
// ************************************************************************************************
gs.clearDebugProperties = function () {
	this.debugProperties = {
		throwExceps: true,
		showAreas: false,
		mapVisible: false,
		showCharactersOnMap: false,
		npcCanAgro: true, // true
		dressRooms: true,
		generateGlobalStuff: true,
		allowRespawn: false,
		useLighting: true,
		saveLevels: true,
		testLevel: false, // false (generates a flat level)
		allowFastTravel: false, // false
		spawnUniques: true,
		menuMap: true,
		
		// Commonly used:
		startClass: null ,//'FireMage', //'Ranger', //'FireMage',
		startZoneName: 'TheUpperDungeon',
		startZoneLevel: 1, // 1
		mapExplored: false, // false
		spawnMobs: true, // true
		disableMana: false, // false
		noDamage: false, // false
		logStats: true,
	};
};

// ASSERT_EQUAL:
// ************************************************************************************************
var ASSERT_EQUAL = function (value, expected, message = "") {
	if (value !== expected) {
		throw 'ASSERT_EQUAL: ' + message;
	}
};

// ASSERT_THROW:
// Make sure the function throws an exception
// ************************************************************************************************
var ASSERT_THROW = function (func, message) {
	try {
		func.apply(this);
	}
	catch (msg) {
		return;
	}
	
	throw 'ASSERT_THROW: ' + message;
};


/*global gs, console*/
'use strict';

gs.logDungeonLevel = function () {
	var str = '';
	
	if (gs.zoneName === 'TheUpperDungeon' && gs.zoneLevel === 1) {
		return;
	}
	
	str += 'Entered: ' + gs.zoneName + '[' + gs.zoneLevel + '] ';
	str += 'Time: ' + gs.timeToString(gs.gameTime()) + ', ';
	str += 'Turn: ' + gs.turn;
	this.eventLog.push(str);
};

gs.logExperienceLevel = function () {
	var str = '';
	
	str += 'Gained XL: ' + gs.pc.level + ' ';
	str += 'Time: ' + gs.timeToString(gs.gameTime()) + ', ';
	str += 'Turn: ' + gs.turn;
	this.eventLog.push(str);
};

gs.logCriticalMoment = function () {
	var str = '';
	
	str += 'Critical Moment: ';
	str += 'Time: ' + gs.timeToString(gs.gameTime()) + ', ';
	str += 'Turn: ' + gs.turn;
	this.eventLog.push(str);
};

gs.printEventLog = function () {
	var str = '';
	
	this.eventLog.forEach(function (event) {
		str += event + '\n';
	}, this);
	
	console.log(str);
};/*global gs, localStorage, console, LZString*/
/*jshint esversion: 6*/
'use strict';

// GAME_RECORD:
// ************************************************************************************************
function GameRecord () {}

// LOAD_GAME_RECORDS:
// ************************************************************************************************
gs.loadGameRecords = function () {
	var data;
		
	// Load records:
	if (localStorage.getItem('GameRecords')) {
		let rawData;
		
		// User is using latest compression:
		if (localStorage.getItem('hasUTF16Compressed')) {
			console.log('Loading from UTF16 Compressed');
			rawData = LZString.decompressFromUTF16(localStorage.getItem('GameRecords'));
			
		}
		// User is using old compression:
		else if (localStorage.getItem('hasCompressed')) {
			console.log('Loading from old Compressed');
			rawData = LZString.decompress(localStorage.getItem('GameRecords'));
		}
		// The user has never performed compression:
		else {
			console.log('Loading from never compressed');
			rawData = localStorage.getItem('GameRecords');
		}
		
		try {
			data = JSON.parse(rawData);
		}
		catch (err) {
			console.log('ERROR: Corrupted GameRecords please contact Justin Wang');
		}
	}
	
	gs.gameRecords = [];
	
	if (data) {
		data.forEach(function (e) {
			gs.gameRecords.push(gs.loadGameRecord(e));
		}, this);
	}
};

// LOG_GAME_RECORD:
// Call this to create a new game record:
// ************************************************************************************************
gs.logGameRecord = function (text, isWin) {
	var gameRecord = new GameRecord();
	
	gameRecord.date = Date.now();
	gameRecord.isChallenge = gs.isDailyChallenge;
	gameRecord.gameTime = gs.gameTime();
	gameRecord.zoneName = gs.capitalSplit(gs.zoneName);
	gameRecord.zoneLevel = gs.niceZoneLevel(gs.zoneName, gs.zoneLevel);
	gameRecord.playerClass = gs.pc.characterClass;
	gameRecord.playerRace = gs.pc.race.name;
	gameRecord.playerLevel = gs.pc.level;
	gameRecord.isWin = isWin;
	gameRecord.text = text;
	
	this.gameRecords.push(gameRecord);
	
	console.log('creating game record...');
	
	localStorage.setItem('GameRecords', LZString.compressToUTF16(JSON.stringify(this.gameRecords)));
	localStorage.setItem('hasCompressed', 1);
	localStorage.setItem('hasUTF16Compressed', 1);
};

// LOAD_GAME_RECORD:
// ************************************************************************************************
gs.loadGameRecord = function (data) {
	var gameRecord = new GameRecord();
	
	gameRecord.date = data.date;
	gameRecord.isChallenge = data.isChallenge;
	gameRecord.gameTime = data.gameTime;
	gameRecord.zoneName = data.zoneName;
	gameRecord.zoneLevel = data.zoneLevel;
	gameRecord.playerClass = data.playerClass;
	gameRecord.playerRace = data.playerRace;
	gameRecord.playerLevel = data.playerLevel;
	gameRecord.isWin = data.isWin;
	gameRecord.text = data.text || "";
	
	return gameRecord;
};



// TO_STRING:
// ************************************************************************************************
GameRecord.prototype.toString = function () {
	var str = '', date;
	
	// Date Title:
	date = new Date(this.date);
	str += date.toDateString();
	if (this.isChallenge) {
		str += ' - daily challenge';
	}
	str += ':\n';
	
	
	str += 'lvl ' + this.playerLevel + ' ';
	str += gs.capitalSplit(this.playerClass) + ' ';
	
	
	if (this.isWin) {
		str += 'Successfully retrieved the goblet.';
	}
	else if (this.text && this.text.length > 0) {
		str += this.text + ' in ' + gs.capitalSplit(this.zoneName) + ' ' + this.zoneLevel + '.';
	}
	else {
		str += 'Was killed in ' + gs.capitalSplit(this.zoneName) + ' ' + this.zoneLevel + '.';
	}

	str += ' Time: ' + gs.timeToString(this.gameTime) + '.';
	
	return str;
};
/*global gs, kongregate, console*/
/*global CLASS_LIST*/
/*jshint esversion: 6*/
'use strict';


// SUBMIT_KONG_STATS:
// Called from the menu-state to update the kongregate stats
// ************************************************************************************************
gs.submitKongStats = function () {
	// Fastest Win Time:
	if (this.fastestWinTime()) {
		this.kongSubmit('FastestWinTime', Math.ceil(this.fastestWinTime().time / (1000 * 60)));
	}
	
	// Total Wins:
	if (this.totalWins() > 0) {
		this.kongSubmit('TotalWins', this.totalWins());
	}
	
	// Highest Win Streak:
	if (this.highestWinStreak() > 1) {
		this.kongSubmit('HighestWinStreak', this.highestWinStreak());
	}
};



// FASTEST_WIN_TIME:

// ************************************************************************************************
gs.fastestWinTime = function () {
	var minTime = 10 * 60 * 60 * 1000, // 10 hours
		minClassName;
	
	CLASS_LIST.forEach(function (className) {
		if (this.achievements[className]) {
			if (this.achievements[className] < minTime) {
				minTime = this.achievements[className];
				minClassName = className;
			}
		}
	}, this);
	
	if (minTime === 10 * 60 * 60 * 1000) {
		return false;
	}
	else {
		return {time: minTime, className: minClassName};
	}
};



// TOTAL_WINS:
// ************************************************************************************************
gs.totalWins = function () {
	return this.gameRecords.filter(record => record.isWin).length;
};

// TOTAL_DEATHS:
// ************************************************************************************************
gs.totalDeaths = function () {
	return this.gameRecords.filter(record => !record.isWin).length;
};

// TOTAL_GAMES:
// ************************************************************************************************
gs.totalGames = function () {
	return this.totalWins() + this.totalDeaths();
};

// NUM_WINS_WITH_CLASS:
// ************************************************************************************************
gs.numWinsWithClass = function (className) {
	return this.gameRecords.filter(record => record.isWin && record.playerClass === className).length;
};

// NUM_DEATHS_WITH_CLASS:
// ************************************************************************************************
gs.numDeathsWithClass = function (className) {
	return this.gameRecords.filter(record => !record.isWin && record.playerClass === className).length;
};

// NUM_CHALLENGE_WINS:
// ************************************************************************************************
gs.numChallengeWins = function () {
	return this.gameRecords.filter(record => record.isWin && record.isChallenge).length;
};

// NUM_CHALLENGE_DEATHS:
// ************************************************************************************************
gs.numChallengeDeaths = function () {
	return this.gameRecords.filter(record => !record.isWin && record.isChallenge).length;
};

// HIGHEST_WIN_STREAK:
// ************************************************************************************************
gs.highestWinStreak = function () {
	var max = 0;
	
	CLASS_LIST.forEach(function (className) {
		if (this.bestWinStreakWithClass(className) > max) {
			max = this.bestWinStreakWithClass(className);
		}
	}, this);
	
	return max;
};

// HIGHEST_WIN_STREAK_CLASS:
// ************************************************************************************************
gs.highestWinStreakClass = function () {
	var max = 0, bestClass = null;
	
	CLASS_LIST.forEach(function (className) {
		if (this.bestWinStreakWithClass(className) > max) {
			max = this.bestWinStreakWithClass(className);
			bestClass = className;
		}
	}, this);
	
	return bestClass;
};




// BEST_WIN_STREAK_WITH_CLASS:
// ************************************************************************************************
gs.bestWinStreakWithClass = function (className) {
	var count = 0, maxCount = 0, list;
	
	list = this.gameRecords.filter(record => record.playerClass === className);
	
	list.forEach(function (record) {
		if (record.isWin) {
			count += 1;
			
			maxCount = Math.max(count, maxCount);
		}
		else {
			count = 0;
		}
	}, this);
	
	return maxCount;
};

// CURRENT_WIN_STREAK_WITH_CLASS:
// ************************************************************************************************
gs.currentWinStreakWithClass = function (className) {
	var list = this.gameRecords.filter(record => record.playerClass === className),
		count = 0;
	
	if (list.length === 0) {
		return 0;
	}
	
	for (let i = list.length - 1; i >= 0; i -= 1) {
		if (list[i].isWin) {
			count += 1;
		}
		else {
			break;
		}
	}
	
	return count;
};

// BEST_CHALLENGE_WIN_STREAK:
// ************************************************************************************************
gs.bestChallengeWinStreak = function () {
	var count = 0, maxCount = 0, list;
	
	list = this.gameRecords.filter(record => record.isChallenge);
	
	list.forEach(function (record) {
		if (record.isWin) {
			count += 1;
			
			maxCount = Math.max(count, maxCount);
		}
		else {
			count = 0;
		}
	}, this);
	
	return maxCount;
};

// CURRENT_CHALLENGE_WIN_STREAK:
// ************************************************************************************************
gs.currentChallengeWinStreak = function () {
	var list = this.gameRecords.filter(record => record.isChallenge),
		count = 0;
	
	if (list.length === 0) {
		return 0;
	}
	
	for (let i = list.length - 1; i >= 0; i -= 1) {
		if (list[i].isWin) {
			count += 1;
		}
		else {
			break;
		}
	}
	
	return count;
};

// KONG_SUBMIT:
// ************************************************************************************************
gs.kongSubmit = function (statName, statValue) {
	if (kongregate) {
		kongregate.stats.submit(statName, statValue);	
	}
	else {
		console.log('Submitting ' + statName + ': ' + statValue);
	}
		
};/*global game, Phaser, localStorage, gs, console, util, document, navigator*/
/*global ClassSelectMenu, RaceSelectMenu, UIRecordMenu*/
/*global LARGE_WHITE_FONT, TILE_SIZE, SCREEN_WIDTH, SCREEN_HEIGHT, SCALE_FACTOR*/
/*global PLAYER_FRAMES, HUGE_WHITE_FONT, ITEM_SLOT_FRAME, NUM_SCREEN_TILES_X, SMALL_WHITE_FONT, ZONE_FADE_TIME, LARGE_RED_FONT*/
/*global MUSIC_ON_BUTTON_FRAME, MUSIC_OFF_BUTTON_FRAME, CHARACTER_BUTTON_FRAME*/
/*jshint esversion: 6*/

'use strict';

var menuState = {};


// PRELOAD:
// ************************************************************************************************
menuState.preload = function () {
	game.time.advancedTiming = true;
	
};

// CREATE:
// ************************************************************************************************
menuState.create = function () {
	var startY = 0,
		startX = 720,
		width = SCREEN_WIDTH - startX,
		menuGroup,
		sprite,
		textBox,
		i = 0,
		tileIndex,
		onComplete,
		iconSpaceY,
		str;
	
	// Data (Achievements and Help):
	this.loadData();
	
	// Setting an initial seed:
	gs.seed = '' + Date.now();
	gs.setDebugProperties();
	gs.initialize();
	
	// Random Map Background:
	if (gs.debugProperties.menuMap) {
		gs.loadRandomMapAsBackground();
		gs.shadowMaskSprite.visible = false;
	}
	
	// Creating the menu HUD:
	menuGroup = game.add.group();
	menuGroup.fixedToCamera = true;
	
	this.classSelectMenu = new ClassSelectMenu();
	this.raceSelectMenu = new RaceSelectMenu();
	this.recordMenu = new UIRecordMenu();
	
	// Game Title:
	gs.createSprite(0, 20, 'Title', menuGroup);
	
	// Version Text:
	this.versionText = gs.createText(4, 0, 'Version: ' + gs.versionStr, SMALL_WHITE_FONT, menuGroup);
	
	// Credits Text:
	this.creditsText = gs.createText(4, SCREEN_HEIGHT - 44, 'Now available on steam early access\nFor Windows and Mac OS', LARGE_WHITE_FONT, menuGroup);
	
	//\nProgramming by: Justin Wang\nArt by: Justin Wang and TheBlackHand\nSound: www.kenney.nl and ArtisticDude\nMusic: Nooskewl Games
	
	// Music Button:
	this.musicButton = gs.createSmallButton(SCREEN_WIDTH - 36, -4, MUSIC_ON_BUTTON_FRAME, this.toggleMusicClicked, this);
	this.musicButton.fixedToCamera = true;
	
	// Credits Button:
	this.creditsButton = gs.createSmallButton(SCREEN_WIDTH - 64, -4, CHARACTER_BUTTON_FRAME, this.creditsClicked, this);
	this.creditsButton.fixedToCamera = true;
	
	
	// Music:
	gs.stopAllMusic();
	
	// Music On:
	if (gs.musicOn) {
		this.musicButton.setFrames(MUSIC_ON_BUTTON_FRAME + 1, MUSIC_ON_BUTTON_FRAME);
		gs.music.MainMenu.loopFull();
	}
	// Music Off:
	else {
		this.musicButton.setFrames(MUSIC_OFF_BUTTON_FRAME + 1, MUSIC_OFF_BUTTON_FRAME);
		gs.stopAllMusic();
	}
	
	this.classSelectMenu.open();
	
	
	if (gs.debugProperties.menuMap) {
		tileIndex = gs.getOpenIndexInLevel();
		this.camPos = {x: tileIndex.x * TILE_SIZE - TILE_SIZE / 2, y: tileIndex.y * TILE_SIZE - TILE_SIZE / 2};

		// Get dest (not same as pos):
		this.camDestIndex = gs.getOpenIndexInLevel();
		while (gs.vectorEqual(this.camDestIndex, gs.toTileIndex(this.camPos))) {
			this.camDestIndex = gs.getOpenIndexInLevel();
		}

		this.camVelocity = gs.getNormal(gs.toTileIndex(this.camPos), this.camDestIndex);
		this.count = 0;
	}
	
	
	// Forcing quick start:
	if (gs.debugProperties.startClass) {
		gs.clearGameData();
		gs.playerClass = gs.debugProperties.startClass;
		gs.playerRace = gs.playerRaces[gs.debugProperties.startRace];
		game.state.start('game');
	}

	gs.submitKongStats();
};


// UPDATE:
// ************************************************************************************************
menuState.update = function () {
	
	/*
	if (gs.help.userName && gs.help.userName.length >= 1) {
		this.userNameText.setText('User Name: ' + gs.help.userName);
		this.userNameText.setStyle(LARGE_WHITE_FONT);
	}
	else {
		this.userNameText.setText('Not logged in (see discord FAQ)');
		this.userNameText.setStyle(LARGE_RED_FONT);
	}
	*/
	
	this.classSelectMenu.update();
	this.raceSelectMenu.update();
	
	if (gs.debugProperties.menuMap) {
		// Changing background levels:
		this.count += 1;
		if (gs.vectorEqual(gs.toTileIndex(this.camPos), this.camDestIndex)) {
			// Only change level if enough time has passed:
			if (this.count >= 300) {
				this.count = 0;
				gs.destroyLevel();
				gs.loadRandomMapAsBackground();
			}

			// Get new destIndex:
			this.camDestIndex = gs.getOpenIndexInLevel();
			while( gs.vectorEqual(this.camDestIndex, gs.toTileIndex(this.camPos))) {
				this.camDestIndex = gs.getOpenIndexInLevel();
			}
			this.camVelocity = gs.getNormal(gs.toTileIndex(this.camPos), this.camDestIndex);

		}

		// Panning Camera:
		this.camPos.x += this.camVelocity.x * 2;
		this.camPos.y += this.camVelocity.y * 2;
		game.camera.focusOnXY(this.camPos.x + 124, this.camPos.y);
		gs.updateTileMapSprites();

		gs.objectSpritesGroup.sort('y', Phaser.Group.SORT_ASCENDING);
	}
	
	
};

// LOAD_DATA:
// ************************************************************************************************
menuState.loadData = function () {
	// Achievements:
	gs.achievements = JSON.parse(localStorage.getItem('Achievements'));
	
	if (!gs.achievements) {
		// Achivements stores the fastest time the player has completed the game.
		// If an achievement is equal to 0 it means the player never won the game with that class.
		gs.achievements = {
			Warrior: 0,
			Barbarian: 0,
			Ranger: 0,
			Rogue: 0,
			FireMage: 0,
			StormMage: 0,
			IceMage: 0,
			Necromancer: 0,
			Enchanter: 0,
		};
	}
	
	if (!gs.achievements.lastChallenge) {
		gs.achievements.lastChallenge = null;
	}
	
	gs.help = JSON.parse(localStorage.getItem('Help'));
	
	// Default help:
	if (!gs.help) {
		gs.help = {
			items: false,
			skills: false,
			books: false,
			stairs: false,
			rest: false,
			unsafeMove: false,
			musicOn: true,
			soundOn: true,
			userName: "",
		};
	}
	
	if (!gs.help.userName) {
		gs.help.userName = "";
	}
	
	// Game Records:
	gs.loadGameRecords();
	
	
};


// TOGGLE_MUSIC_CLICKED:
// ************************************************************************************************
menuState.toggleMusicClicked = function () {
	// Toggle music off:
	if (gs.musicOn) {
		gs.musicOn = false;
		gs.help.musicOn = false;
		this.musicButton.setFrames(MUSIC_OFF_BUTTON_FRAME + 1, MUSIC_OFF_BUTTON_FRAME);
		gs.stopAllMusic();
	}
	// Toggle music on:
	else {
		gs.musicOn = true;
		gs.help.musicOn = true;
		this.musicButton.setFrames(MUSIC_ON_BUTTON_FRAME + 1, MUSIC_ON_BUTTON_FRAME);
		gs.music.MainMenu.loopFull();
	}
	
	localStorage.setItem('Help', JSON.stringify(gs.help));
};

// START_GAME:
// ************************************************************************************************
menuState.startGame = function () {
	game.state.start('game');
	game.camera.flash('#ffffff', ZONE_FADE_TIME * 4);
	game.camera.onFadeComplete.removeAll();
};


/*global game, gs, console, Phaser, localStorage*/
/*global menuState*/
/*global SMALL_WHITE_FONT, LARGE_WHITE_FONT, CLASS_LIST*/
/*global SCALE_FACTOR, ITEM_SLOT_FRAME, PLAYER_FRAMES, SCREEN_WIDTH, SCREEN_HEIGHT, ZONE_FADE_TIME*/
/*jshint esversion: 6*/

'use strict';

// CONSTRUCTOR:
// ************************************************************************************************
function ClassSelectMenu () {
	var sprite, 
		iconSpaceY, 
		i = 0, 
		startX = 720, 
		startY = 0,
		width = SCREEN_WIDTH - startX,
		str;
	
	// Group:
	this.group = game.add.group();
	this.group.fixedToCamera = true;

	// Menu Sprite:
	sprite = gs.createSprite(0, 0, 'HUD', this.group);
	sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	
	this.totalAchievements = 0;
	iconSpaceY = 50;
	
	// Create class panels:
	this.classPanelList = [];
	CLASS_LIST.forEach(function (className, i) {
		this.classPanelList.push(this.createClassPanel(startX + 6, startY + 4 + i * iconSpaceY, className));
	}, this);
	
	
	// Daily Challenge:
	this.createChallengePanel(startX + 6, 454);
	
	// Submit total achievements:
	/*
	if (this.totalAchievements > 0) {
		gs.kongSubmit('TotalAchievements', this.totalAchievements);
	}
	*/
	
	// Achievement Text:
	this.achievementText = gs.createText(startX + 4, SCREEN_HEIGHT, '', SMALL_WHITE_FONT, this.group);
	this.achievementText.lineSpacing = -5;
	this.achievementText.anchor.setTo(0, 1);
	
	// Records Button:
	this.recordsButton = gs.createTextButton(startX + width / 2, 520, 'Game Records', this.recordsClicked, this, this.group);
	
	
	// Continue Button:
	if (gs.playerDataExists()) {
		this.continueButton = gs.createTextButton(startX + width / 2, 550, 'Continue Save', this.continueClicked, this, this.group);
		this.saveData = JSON.parse(localStorage.getItem('PlayerData'));
	}
	
	
	this.group.visible = false;
}

// RECORDS_CLICKED:
// ************************************************************************************************
ClassSelectMenu.prototype.recordsClicked = function () {
	if (menuState.recordMenu.group.visible) {
		menuState.recordMenu.close();
	}
	else {
		menuState.recordMenu.open();
	}
};

// CREATE_CHALLENGE_PANEL:
// ************************************************************************************************
ClassSelectMenu.prototype.createChallengePanel = function (x, y) {
	this.challengeButton = gs.createButton(x, y, 'BigSlot', this.challengeClicked, this, this.group);
	this.challengeButton.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	this.challengeButton.setFrames(1, 0);
	
	this.challengeSprite = gs.createSprite(x + 4, y + 4, 'Tileset', this.group);
	this.challengeSprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	this.challengeSprite.frame = 1226;
	
	this.challengeText = gs.createText(x + 60, y - 2, 'Daily Challenge', LARGE_WHITE_FONT, this.group);
	
	this.challengeAchivements = [];
	for (let i = 0; i < 3; i += 1) {
		this.challengeAchivements[i] = gs.createSprite(x + 54 + i * 32, y + 14, 'Tileset', this.group);
		this.challengeAchivements[i].frame = 1269 + i;
		this.challengeAchivements[i].scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
		this.challengeAchivements[i].inputEnabled = true;
	}
	
	if (gs.bestChallengeWinStreak() < 2) {
		this.challengeAchivements[0].tint = 0x555555;
	}
	
	if (gs.bestChallengeWinStreak() < 3) {
		this.challengeAchivements[1].tint = 0x555555;
	}
	
	if (gs.bestChallengeWinStreak() < 5) {
		this.challengeAchivements[2].tint = 0x555555;
	}
};

// CREATE_CLASS_PANEL:
// ************************************************************************************************
ClassSelectMenu.prototype.createClassPanel = function (x, y, className) {
	var classPanel = {}, str;
	
	classPanel.button = gs.createButton(x, y, 'BigSlot', this.classClicked, this, this.group);
	classPanel.button.className = className;
	classPanel.button.scale.setTo(2, 2);
	classPanel.button.setFrames(1, 0);

	// Class Image: 
	classPanel.image =  gs.createSprite(x + 4, y + 4, 'Tileset', this.group);
	classPanel.image.scale.setTo(2, 2);
	classPanel.image.frame = PLAYER_FRAMES[className];

	// Class Name Text:
	str = gs.capitalSplit(className);
	if (gs.achievements[className] > 0) {
		str += ' [' + gs.timeToString(gs.achievements[className]) + ']';
	}
	classPanel.text = gs.createText(x + 60, y - 2, str, LARGE_WHITE_FONT, this.group);

	
	// Achievements:
	classPanel.achievementIcons = [];
	classPanel.achievementIcons[0] = gs.createSprite(x + 54, y + 14, 'Tileset', this.group);
	classPanel.achievementIcons[0].frame = 1266;
	classPanel.achievementIcons[0].scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	classPanel.achievementIcons[0].inputEnabled = true;
	// Locked:
	if (gs.achievements[className] === 0) {
		classPanel.achievementIcons[0].tint = 0x555555;
	}
	// Unlocked:
	else {
		this.totalAchievements += 1;
	}

	classPanel.achievementIcons[1] = gs.createSprite(x + 54 + 32, y + 14, 'Tileset', this.group);
	classPanel.achievementIcons[1].frame = 1267;
	classPanel.achievementIcons[1].scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	classPanel.achievementIcons[1].inputEnabled = true;
	// Locked:
	if (gs.achievements[className] === 0 || gs.achievements[className] > 60 * 60 * 1000) {
		classPanel.achievementIcons[1].tint = 0x555555;
	}
	// Unlocked:
	else {
		this.totalAchievements += 1;
	}

	classPanel.achievementIcons[2] = gs.createSprite(x + 54 + 64, y + 14, 'Tileset', this.group);
	classPanel.achievementIcons[2].frame = 1268;
	classPanel.achievementIcons[2].scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	classPanel.achievementIcons[2].inputEnabled = true;
	// Locked:
	if (gs.achievements[className] === 0 || gs.achievements[className] > 45 * 60 * 1000) {
		classPanel.achievementIcons[2].tint = 0x555555;
	}
	// Unlocked:
	else {
		this.totalAchievements += 1;
	}
	
	return classPanel;
};

// UPDATE:
// ************************************************************************************************
ClassSelectMenu.prototype.update = function () {
	var str = '';
	this.achievementText.setText('');
	
	
	this.classPanelList.forEach(function (panel) {
		// Set Achievement Text:
		if (panel.achievementIcons[0].input.checkPointerOver(game.input.activePointer)) {
			str = 'Win for the first time.';
		}
		if (panel.achievementIcons[1].input.checkPointerOver(game.input.activePointer)) {
			str = 'Win in under 60 minutes.';
		}
		if (panel.achievementIcons[2].input.checkPointerOver(game.input.activePointer)) {
			str = 'Win in under 45 minutes.';
		}
		
		// Set Class Text:
		if (panel.button.input.checkPointerOver(game.input.activePointer)) {
			str = gs.capitalSplit(panel.button.className);
			
			if (panel.button.className === 'Barbarian') {
				str += '\nAbility cooldowns only recharge when killing enemies.';
			}
			
			str += this.getStatsFor(panel.button.className);
		}
	}, this);
	
	// Set Continue Text:
	if (this.continueButton && this.continueButton.button.input.checkPointerOver(game.input.activePointer)) {
		str = 'level ' + this.saveData.level + ' ' + gs.capitalSplit(this.saveData.characterClass) + '\n';
		str += gs.capitalSplit(this.saveData.zoneName) + ' ';
		str += gs.niceZoneLevel(this.saveData.zoneName, this.saveData.zoneLevel);
	}
	
	// Set Daily Challenge Text:
	if (this.challengeButton.input.checkPointerOver(game.input.activePointer)) {
		let date = new Date();
		
		// Already completed challenge:
		if (this.isChallengeComplete()) {
			str = "Daily Challenge Complete for : " + date.toDateString();
		}
		// Challenge not started:
		else {
			str = "Start Daily challenge for: " + date.toDateString();
		}
		
		str += '\nBest Win Streak: ' + gs.bestChallengeWinStreak();
		str += '\nCurrent Win Streak: ' + gs.currentChallengeWinStreak();
	}
	
	// Set Achievement Text:
	if (this.challengeAchivements[0].input.checkPointerOver(game.input.activePointer)) {
		str = 'Win 2 daily challenges in a row.';
	}
	if (this.challengeAchivements[1].input.checkPointerOver(game.input.activePointer)) {
		str = 'Win 3 daily challenges in a row.';
	}
	if (this.challengeAchivements[2].input.checkPointerOver(game.input.activePointer)) {
		str = 'Win 5 daily challenges in a row.';
	}
	
	// Credits:
	if (menuState.creditsButton.input.checkPointerOver(game.input.activePointer)) {
		str = 'Programming by: Justin Wang\n';
		str += 'Art by: Justin Wang and TheBlackHand\n';
		str += 'Sound: www.kenney.nl and ArtisticDude\n';
		str += 'Music: Nooskewl Games';
	
	}
	
	this.achievementText.setText(gs.wrapText(str, 32).join('\n'));
	
	
};

// GET_STATS_FOR:
// ************************************************************************************************
ClassSelectMenu.prototype.getStatsFor = function (className) {
	var str = '\n';
	if (gs.achievements[className] > 0) {
		str += 'Best Win Time: ' + gs.timeToString(gs.achievements[className]) + '\n';
	}
	
	str += 'Num Wins: ' + gs.numWinsWithClass(className) + '\n';
	str += 'Num Deaths: ' + gs.numDeathsWithClass(className) + '\n';
	str += 'Best Win Streak: ' + gs.bestWinStreakWithClass(className) + '\n';
	str += 'Current Win Streak: ' + gs.currentWinStreakWithClass(className);
	return str;
};

// IS_CHALLENGE_COMPLETE:
// ************************************************************************************************
ClassSelectMenu.prototype.isChallengeComplete = function () {
	let date = new Date();
	return gs.achievements.lastChallenge === "" + date.getFullYear() + date.getMonth() + date.getDate();
};

// CLASS_CLICKED:
// ************************************************************************************************
ClassSelectMenu.prototype.classClicked = function (button) {
	var dialog = [{}], onYes;
	
	menuState.recordMenu.close();
	
	onYes = function () {
		/*
		gs.playerClass = button.className;
		this.close();
		menuState.raceSelectMenu.open();
		*/
		
		gs.playerClass = button.className;
		gs.playerRace = gs.playerRaces.Human;
		gs.clearGameData();
		gs.startDailyChallenge = false;
	
		game.camera.fade('#000000', ZONE_FADE_TIME * 2);
		game.camera.onFadeComplete.add(menuState.startGame, menuState);
	}.bind(this);
	
	dialog[0].text = 'You currently have a saved game stored. Are you sure you want to start a new game?';
	dialog[0].responses = [
		{text: 'Yes', nextLine: 'exit', func: onYes},
		{text: 'No', nextLine: 'exit'},
	];
	
	if (gs.playerDataExists() && !gs.debugProperties.startClass) {
		gs.dialogMenu.open(dialog);
	}
	else {
		onYes();
	}
};

// CONTINUE_CLICKED:
// ************************************************************************************************
ClassSelectMenu.prototype.continueClicked = function () {
	gs.startDailyChallenge = false;
	
	game.camera.fade('#000000', ZONE_FADE_TIME * 2);
    game.camera.onFadeComplete.add(menuState.startGame, menuState);
};

// OPEN:
// ************************************************************************************************
ClassSelectMenu.prototype.open = function () {
	this.group.visible = true;
};

// CLOSE:
// ************************************************************************************************
ClassSelectMenu.prototype.close = function () {
	this.group.visible = false;
};

// CHALLENGE_CLICKED:
// ************************************************************************************************
ClassSelectMenu.prototype.challengeClicked = function () {
	var dialog = [{}], onYes;
	
	if (!this.isChallengeComplete()) {
		onYes = function () {
			// Clearing game data to start the new game:
			gs.clearGameData();

			gs.startDailyChallenge = true;
			game.camera.fade('#000000', ZONE_FADE_TIME * 2);
			game.camera.onFadeComplete.add(menuState.startGame, menuState);
		}.bind(this);

		dialog[0].text = 'You currently have a saved game stored. Are you sure you want to start a new game?';
		dialog[0].responses = [
			{text: 'Yes', nextLine: 'exit', func: onYes},
			{text: 'No', nextLine: 'exit'},
		];

		if (gs.playerDataExists()) {
			gs.dialogMenu.open(dialog);
		}
		else {
			onYes();
		}
	}
};

/*global game, gs, console, Phaser, menuState*/
/*global SCALE_FACTOR, SCREEN_WIDTH, ZONE_FADE_TIME, SMALL_WHITE_FONT*/

'use strict';

// CONSTRUCTOR:
// ************************************************************************************************
function RaceSelectMenu () {
	var sprite,
		startX = 720,
		width = SCREEN_WIDTH - startX,
		iconSpaceY = 30;
	
	// Group:
	this.group = game.add.group();
	this.group.fixedToCamera = true;

	// Menu Sprite:
	sprite = gs.createSprite(0, 0, 'HUD', this.group);
	sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	
	// Text:
	this.text = gs.createText(startX + 4, 400, '', SMALL_WHITE_FONT, this.group); 
	
	// Create Race Buttons:
	this.raceButtons = [];
	gs.playerRaceList.forEach(function (playerRace, i) {
		var button;
		button = gs.createTextButton(startX + width / 2, 20 + i * iconSpaceY, playerRace.name, this.raceClicked, this, this.group);
		button.button.playerRace = playerRace;
		this.raceButtons.push(button);
	}, this);
	
	
	this.group.visible = false;
}

// UPDATE:
RaceSelectMenu.prototype.update = function () {
	this.raceButtons.forEach(function (textButton) {
		if (textButton.button.input.checkPointerOver(game.input.activePointer)) {
			this.text.setText(textButton.button.playerRace.desc());
		}
	}, this);
};

// RACE_CLICKED:
// ************************************************************************************************
RaceSelectMenu.prototype.raceClicked = function (button) {
	// Clearing game data to start the new game
	gs.clearGameData();
	
	gs.startDailyChallenge = false;
	
	// Set Race:
	gs.playerRace = button.playerRace;
	
	// Starting a fade:
	game.camera.fade('#000000', ZONE_FADE_TIME * 2);
    game.camera.onFadeComplete.add(menuState.startGame, menuState);
};


// OPEN:
// ************************************************************************************************
RaceSelectMenu.prototype.open = function () {
	this.group.visible = true;
};

// CLOSE:
// ************************************************************************************************
RaceSelectMenu.prototype.close = function () {
	this.group.visible = false;
};/*global game, Phaser, localStorage, gs, console, util*/
/*global ClassSelectMenu, RaceSelectMenu*/
/*global LARGE_WHITE_FONT, TILE_SIZE, SCREEN_WIDTH, SCREEN_HEIGHT, SCALE_FACTOR*/
/*global PLAYER_FRAMES, HUGE_WHITE_FONT, ITEM_SLOT_FRAME, NUM_SCREEN_TILES_X, SMALL_WHITE_FONT, ZONE_FADE_TIME*/
/*global MUSIC_ON_BUTTON_FRAME, MUSIC_OFF_BUTTON_FRAME*/
'use strict';

var trailerState = {};

// PRELOAD:
// ************************************************************************************************
trailerState.preload = function () {
	game.time.advancedTiming = true;
	
};

// CREATE:
// ************************************************************************************************
trailerState.create = function () {
	var tileIndex;
	
	NUM_SCREEN_TILES_X = 27;
	
	
	
	gs.help = {
		soundsOn: false,
		musicOn: false
	};
	gs.initialize();
	gs.loadRandomMapAsBackground();
	gs.shadowMaskSprite.visible = true;
	
	this.group = game.add.group();
	//this.group.fixedToCamera = true;
	this.sprite = gs.createSprite(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, 'Tileset', this.group);
	this.sprite.anchor.setTo(0.5, 0.5);
	this.sprite.visible = false;

	// Music:
	gs.stopAllMusic();
	
	this.camVelocity = gs.getNormalFromAngle(util.randInt(0, 360));
	tileIndex = gs.getOpenIndexInLevel();
	this.camPos = {x: tileIndex.x * TILE_SIZE - TILE_SIZE / 2, y: tileIndex.y * TILE_SIZE - TILE_SIZE / 2};
	this.camDestIndex = gs.getOpenIndexInLevel();
	this.camVelocity = gs.getNormal(gs.toTileIndex(this.camPos), this.camDestIndex);
	this.count = 0;
};


// UPDATE:
// ************************************************************************************************
trailerState.update = function () {	
	// Changing background levels:
	this.count += 1;
	if (this.count >= 300) {
		this.count = 0;
		gs.destroyLevel();
		gs.loadRandomMapAsBackground();
		
		this.camDestIndex = gs.getOpenIndexInLevel();
		this.camVelocity = gs.getNormal(gs.toTileIndex(this.camPos), this.camDestIndex);
	}
	
	if (gs.vectorEqual(gs.toTileIndex(this.camPos), this.camDestIndex)) {
		this.camDestIndex = gs.getOpenIndexInLevel();
		this.camVelocity = gs.getNormal(gs.toTileIndex(this.camPos), this.camDestIndex);
	}

	// Panning Camera:
	this.camPos.x += this.camVelocity.x * 1.5;
	this.camPos.y += this.camVelocity.y * 1.5;
	game.camera.focusOnXY(this.camPos.x, this.camPos.y);
	gs.shadowMaskSprite.x = game.camera.x;
	gs.shadowMaskSprite.y = game.camera.y;
	
	gs.updateTileMapSprites();
	
	this.sprite.x = this.camPos.x;
	this.sprite.y = this.camPos.y;

	gs.objectSpritesGroup.sort('y', Phaser.Group.SORT_ASCENDING);

};/*global gs*/
/*jshint esversion: 6*/
'use strict';

// AREA_CONSTRUCTOR:
// ************************************************************************************************
function Area() {
	// A list of tileIndices belonging to this area
	// This includes floor and wall tiles
	this.indexList = [];
	
	// A list of tileIndices belonging to this area that are also walls
	// Area walls must be cardinally adjacent to an areas floors
	// The wallIndexList can be generated by the Area class once its floors have been added
	// Corner walls will not be added to wallIndexList but will be added to indexList
	// This allows wallIndexList to be used as a starting point for hallways.
	this.wallIndexList = [];
	
	// The bounds of the area:
	// This will be updated every time that addTile is called
	// Note how the the values are initiated in such away that the first addTile call will successfully set the bounds
	this.startX = gs.numTilesX + 1;
	this.startY = gs.numTilesY + 1;
	this.endX = -1;
	this.endY = -1;
	
}

// ADD_TILE:
// Call to add a tile to the area
// Will mark the tile as belonging to the area by setting tile.area = this
// Will automatically update the bounds of the area
// ************************************************************************************************
Area.prototype.addTile = function (tileIndex) {
	// Testing for errors:
	if (!gs.isInBounds(tileIndex))	throw 'tileIndex is out of bounds';
	if (gs.getTile(tileIndex).area)	throw 'tile already belongs to an area';
	
	// Adding tileIndex to lists
	this.indexList.push(tileIndex);
	
	// Setting the tiles area:
	gs.getTile(tileIndex).area = this;
	
	// Adjusting bounds:
	this.startX = Math.min(this.startX, tileIndex.x);
	this.startY = Math.min(this.startY, tileIndex.y);
	this.endX = Math.max(this.endX, tileIndex.x + 1);
	this.endY = Math.max(this.endY, tileIndex.y + 1);
};

// ADD_ALL_ADJACENT_WALLS:
// Call this function once all floor tiles have been added in order to add the adjacent walls
// ************************************************************************************************
Area.prototype.addAdjacentWalls = function () {
	// First finding tiles to add to wallIndexList:
	this.indexList.forEach(function (tileIndex) {
		// Only expand on floor tiles:
		if (!gs.getTile(tileIndex).type.passable) {
			return;
		}
		
		gs.getIndexListCardinalAdjacent(tileIndex).forEach(function (index) {
			if (!gs.getTile(index).type.passable && !gs.getTile(index).area) {
				this.addTile(index);
				this.wallIndexList.push(index);
				gs.getTile(index).areaFlag = 'AREA_WALL';
			}
		}, this);
		
	}, this);
	
	// Catching the remaining tiles:
	this.indexList.forEach(function (tileIndex) {
		// Only expand on floor tiles:
		if (!gs.getTile(tileIndex).type.passable) {
			return;
		}
		
		gs.getIndexListAdjacent(tileIndex).forEach(function (index) {
			if (!gs.getTile(index).type.passable && !gs.getTile(index).area) {
				this.addTile(index);
			}
		}, this);
		
	}, this);
	
};
// UPDATE_BOUNDS:
// ************************************************************************************************
Area.prototype.updateBounds = function () {
	this.width = this.endX - this.startX;
	this.height = this.endY - this.endY;
	this.startTileIndex = {x: this.startX, y: this.startY};
	this.endTileIndex = {x: this.endX, y: this.endY};
};/*global Phaser, game, console, gs, util*/
/*global frameSelector*/
/*global NUM_TILES_X, NUM_TILES_Y, FACTION*/
/*jshint white: true, laxbreak: true, esversion: 6*/
'use strict';

// CREATE_TILE_TYPES:
// ************************************************************************************************
gs.createTileTypes = function () {
	// Tile Types:
    this.tileTypes = {
		Floor:		{frame: 0, 		passable: 1, transparent: 1, isPit: 0, frames: this.range(0, 255)},
		Bridge:		{frame: 384,	passable: 1, transparent: 1, isPit: 0},
		CaveFloor:	{frame: 256, 	passable: 1, transparent: 1, isPit: 0, frames: this.range(256, 511)},
		Wall:		{frame: 512, 	passable: 0, transparent: 0, isPit: 0, frames: this.range(512, 767)},
		CaveWall:	{frame: 768, 	passable: 0, transparent: 0, isPit: 0, frames: this.range(768, 1023)},
		Pit:		{frame: 1024, 	passable: 1, transparent: 1, isPit: 1, frames: this.range(1024, 1151)},
		CavePit:	{frame: 1152,	passable: 1, transparent: 1, isPit: 1, frames: this.range(1152, 1215)},
		HalfWall:	{frame: 1216,	passable: 0, transparent: 1, isPit: 0, frames: this.range(1216, 1279)},
		Water:		{frame: 1280, 	passable: 1, transparent: 1, isPit: 0, frames: this.range(1280, 1343)},
		Lava:		{frame: 1344, 	passable: 1, transparent: 1, isPit: 0, frames: this.range(1344, 1407)},
	};
	
	// Tile Colors (minimap):
	this.tileTypes.Lava.color = 'rgb(200, 24, 24)';
	
	// Tile Desc:
	this.tileTypes.Water.desc = 'Creates unstable footing, making you vulnerable to melee attacks. Also makes you wet and vulnerable to shock';
	
	
	this.nameTypes(this.tileTypes);
};

// TILE_DESC:
// ************************************************************************************************
gs.tileDesc = function (tile) {
	var str = tile.type.niceName;
	
	if (tile.type.desc) {
		str += '\n' + tile.type.desc;
	}
	
	return str;
};

// INITIATE_TILE_MAP:
// ************************************************************************************************
gs.initiateTileMap = function () {
	this.numTilesX = NUM_TILES_X;
	this.numTilesY = NUM_TILES_Y;
	
	// Create empty map:
    this.tileMap = [];
    for (let x = 0; x < this.numTilesX; x += 1) {
        this.tileMap[x] = [];
        for (let y = 0; y < this.numTilesY; y += 1) {
            this.tileMap[x][y] = {
				explored: false,   
				visible: false,  
				character: null,	  
				frame: null,       
				item: null,     
				effect: null,	  
				object: null,				  
				isClosed: false,
				cloud: null,
				tileIndex: {x: x, y: y},
				triggerGroup: 0, // Note that 0 implies no group
			};
		}
	}
	
	this.dropWallList = [];
};

// IS_RAY:
// ************************************************************************************************
gs.isRay = function (startTileIndex, endTileIndex, pred) {
	var startPosition = util.toPosition(startTileIndex),
        endPosition = util.toPosition(endTileIndex),
        length = game.math.distance(startPosition.x, startPosition.y, endPosition.x, endPosition.y),
        normal = this.getNormal(startPosition, endPosition),
        currentPosition = startPosition,
        currentTileIndex,
        step = 4,
        currentDistance = 0;
	
	for (currentDistance = 0; currentDistance < length; currentDistance += step) {
        currentPosition = {x: startPosition.x + normal.x * currentDistance,
                           y: startPosition.y + normal.y * currentDistance};
        currentTileIndex = this.toTileIndex(currentPosition);
		
		if (!this.vectorEqual(currentTileIndex, startTileIndex) && !this.vectorEqual(currentTileIndex, endTileIndex)) {
			if (!pred(currentTileIndex)) {
				return false;
			}
		}
	}
		
	return true;
};

// IS_RAY_CLEAR:
// ************************************************************************************************
gs.isRayClear = function (startTileIndex, endTileIndex) {
	return this.isRay(startTileIndex, endTileIndex, function (tileIndex) {
		return gs.isTileIndexTransparent(tileIndex);
	}, this);
};

// IS_RAY_SHOOTABLE:
// Used by NPCs so they shoot each other while still moving around terrain:
// ************************************************************************************************
gs.isRayShootable = function (startTileIndex, endTileIndex) {
    return this.isRay(startTileIndex, endTileIndex, function (tileIndex) {
		return gs.isTileIndexTransparent(tileIndex) && gs.isStaticPassable(tileIndex);
	}, this);
};

// IS_RAY_PASSABLE:
// ************************************************************************************************
gs.isRayPassable = function (startTileIndex, endTileIndex) {
	return this.isRay(startTileIndex, endTileIndex, function (tileIndex) {
		return gs.isPassable(tileIndex);
	}, this);
};

// IS_RAY_STATIC_PASSABLE:
// ************************************************************************************************
gs.isRayStaticPassable = function (startTileIndex, endTileIndex) {
	return this.isRay(startTileIndex, endTileIndex, function (tileIndex) {
		return gs.isStaticPassable(tileIndex);
	}, this);
};

// IS_B_RAY:
// Returns true if every tileIndex in the BRay satisfies the predicate
// ************************************************************************************************
gs.isBRay = function (startTileIndex, endTileIndex, pred) {
	var indexList = this.getIndexInBRay(startTileIndex, endTileIndex);
	
	for (let i = 0; i < indexList.length; i += 1) {
		if (!pred.call(this, indexList[i])) {
			return false;
		}
	}
	
	return true;
};

// GET_INDEX_IN_B_RAY:
// Returns a list of all tile indices in a line using Bresenham’s algorithm
// ************************************************************************************************
gs.getIndexInBRay = function (startTileIndex, endTileIndex) {
	var deltaX = endTileIndex.x - startTileIndex.x,
		deltaY = endTileIndex.y - startTileIndex.y,
		deltaErr,
		endPred,
		error = 0, // No error at start
		y,
		x,
		indexList = [],
		pushToList;
	
	pushToList = function (x, y) {
		if (!gs.vectorEqual({x: x, y: y}, startTileIndex)) {
			indexList.push({x: x, y: y});
		}
	};
	
	// Same start and end will simply return the startTileIndex:
	if (gs.vectorEqual(startTileIndex, endTileIndex)) {
		return [{x: startTileIndex.x, y: startTileIndex.y}];
	}
	

	// Vertical line is special case:
	if (startTileIndex.x === endTileIndex.x) {
		if (deltaY > 0) {
			for (y = startTileIndex.y; y <= endTileIndex.y; y += 1) {
				pushToList(startTileIndex.x, y);
			}
		}
		else {
			for (y = startTileIndex.y; y >= endTileIndex.y; y -= 1) {
				pushToList(startTileIndex.x, y);
			}
		}
	
		return indexList;
	}
	// Low (mostly horizontal):
	else if (Math.abs(deltaX) >= Math.abs(deltaY)) {
		deltaErr = Math.abs(deltaY / deltaX);
		y = startTileIndex.y;
	
		if (deltaX > 0) {
			endPred = function (x) {return x <= endTileIndex.x;};
		}
		else {
			endPred = function (x) {return x >= endTileIndex.x;};
		}

		for (x = startTileIndex.x; endPred(x); x += Math.sign(deltaX)) {
			pushToList(x, y);
			error += deltaErr;

			while (error > 0.5) {
				y += Math.sign(deltaY);
				error -= 1;
			}
		}

		return indexList;
	}
	// High (mostly vertical):
	else  {
		deltaErr = Math.abs(deltaX / deltaY);
		x = startTileIndex.x;
	
		if (deltaY > 0) {
			endPred = function (y) {return y <= endTileIndex.y;};
		}
		else {
			endPred = function (y) {return y >= endTileIndex.y;};
		}

		for (y = startTileIndex.y; endPred(y); y += Math.sign(deltaY)) {
			pushToList(x, y);
			error += deltaErr;

			while (error > 0.5) {
				x += Math.sign(deltaX);
				error -= 1;
			}
		}

		return indexList;
	}
};

// GET_STAIR_INDEX:
// Stairs can be spawned in any open tile index in the level as long as it is not a side room
// Returns null if no possible tile is found
// ************************************************************************************************
gs.getStairIndex = function () {
	var indexList = gs.getAllIndex();
	
	indexList = indexList.filter(index => this.isIndexOpen(index));
	indexList = indexList.filter(index => gs.getIndexListCardinalAdjacent(index).filter(idx => this.isIndexOpen(idx)).length >= 4);
	indexList = indexList.filter(index => !gs.getArea(index) || gs.getArea(index).type !== 'SideRoom');
	
	return indexList.length > 0 ? util.randElem(indexList) : null;
};

// GET_OPEN_INDEX_IN_AREA:
// ************************************************************************************************
gs.getOpenIndexInArea = function (area) {
	var indexList = this.getAllIndex();
	
	indexList = indexList.filter(index => gs.isIndexOpen(index) && gs.getTile(index).area === area);
	
	return indexList.length > 0 ? util.randElem(indexList) : null;
};

// GET_OPEN_BOX_IN_AREA:
// ************************************************************************************************
gs.getOpenBoxInArea = function (area, width, height) {
	var indexList = gs.getIndexInBox(area),
		list = [];
	
	indexList.forEach(function (tileIndex) {
		var boxList = gs.getIndexInBox(tileIndex.x, tileIndex.y, tileIndex.x + width, tileIndex.y + height);
		boxList = boxList.filter(index => gs.isIndexOpen(index));
		boxList = boxList.filter(index => gs.getTile(index).area = area);
		
		if (boxList.length === width * height) {
			list.push(gs.createBox(tileIndex.x, tileIndex.y, tileIndex.x + width, tileIndex.y + height));
		}
	}, this);
	
	return list.length > 0 ? util.randElem(list) : null;
};

// GET_WIDE_OPEN_INDEX_IN_AREA:
// ************************************************************************************************
gs.getWideOpenIndexInArea = function (area) {
	var indexList = this.getAllIndex();
	indexList = indexList.filter(index => gs.isWideOpen(index) && gs.getTile(index).area === area);
	return indexList.length > 0 ? util.randElem(indexList) : null;
};

// GET_OPEN_INDEX_IN_BOX
// ************************************************************************************************
gs.getOpenIndexInBox = function (box, startY, endX, endY) {
	var indexList;

	// Handle argument conversion:
	if (typeof box === 'number') {
		box = {startX: box, startY: startY, endX: endX, endY: endY};
	}
	
	indexList = this.getIndexInBox(box);
	indexList = indexList.filter(index => gs.isIndexOpen(index));
	return indexList.length > 0 ? util.randElem(indexList) : null;
};

// GET_WIDE_OPEN_INDEX_IN_BOX:
// ************************************************************************************************
gs.getWideOpenIndexInBox = function (box, startY, endX, endY) {
	var indexList;
	
	// Handle argument conversion:
	if (typeof box === 'number') {
		box = {startX: box, startY: startY, endX: endX, endY: endY};
	}
	
	indexList = this.getIndexInBox(box);
	indexList = indexList.filter(index => gs.isWideOpen(index));
	return indexList.length > 0 ? util.randElem(indexList) : null;
};

// GET_HALL_INDEX:
// ************************************************************************************************
gs.getHallIndex = function (box, startY, endX, endY) {
	var indexList;
	
	// Handle argument conversion:
	if (typeof box === 'number') {
		box = {startX: box, startY: startY, endX: endX, endY: endY};
	}
	
	indexList = this.getIndexInBox(box);
	indexList = indexList.filter(index => gs.isHallIndex(index));
	
	return indexList.length > 0 ? util.randElem(indexList) : null;
};

// GET_OPEN_INDEX_IN_LEVEL:
// ************************************************************************************************
gs.getOpenIndexInLevel = function () {
	return this.getOpenIndexInBox(0, 0, this.numTilesX, this.numTilesY);
};

// GET_WIDE_OPEN_INDEX_IN_LEVEL:
// ************************************************************************************************
gs.getWideOpenIndexInLevel = function () {
	return this.getWideOpenIndexInBox(0, 0, this.numTilesX, this.numTilesY);
};

// GET_PASSABLE_INDEX_IN_BOX:
// ************************************************************************************************
gs.getPassableIndexInBox = function (box, startY, endX, endY) {
	var indexList;
	
	// Handle argument conversion:
	if (typeof box === 'number') {
		box = {startX: box, startY: startY, endX: endX, endY: endY};
	}
	
	indexList = this.getIndexInBox(box);
	indexList = indexList.filter(index => gs.isPassable(index));
	return indexList.length > 0 ? util.randElem(indexList) : null;
};


// IS_VALID_SPAWN_INDEX:
// ************************************************************************************************
gs.isValidSpawnIndex = function (tileIndex, y) {
	if (typeof tileIndex === 'number') {
		tileIndex = {x: tileIndex, y: y};
	}
	
	return this.isPassable(tileIndex)
		&& !this.getTile(tileIndex).isClosed
		&& this.getTile(tileIndex).type.name !== 'Water'
		&& !this.getTile(tileIndex).type.isPit
		&& this.isIndexSafe(tileIndex)
		&& !this.getObj(tileIndex, obj => obj.isZoneLine())
		&& !this.getObj(tileIndex, obj => obj.type.activate);
};

// IS_VALID_WATER_SPAWN_INDEX:
// ************************************************************************************************
gs.isValidWaterSpawnIndex = function (tileIndex, y) {
	if (typeof tileIndex === 'number') {
		tileIndex = {x: tileIndex, y: y};
	}
	
	return gs.isPassable(tileIndex)
		&& !this.getTile(tileIndex).isClosed
		&& gs.getTile(tileIndex).type.name === 'Water'
		&& this.isIndexSafe(tileIndex)
		&& !this.getObj(tileIndex, obj => obj.isZoneLine())
		&& !this.getObj(tileIndex, obj => obj.type.activate);
};

// IS_VALID_LAVA_SPAWN_INDEX:
// ************************************************************************************************
gs.isValidLavaSpawnIndex = function (tileIndex, y) {
	if (typeof tileIndex === 'number') {
		tileIndex = {x: tileIndex, y: y};
	}
	
	return gs.isPassable(tileIndex)
		&& !this.getTile(tileIndex).isClosed
		&& gs.getTile(tileIndex).type.name === 'Lava'
		&& !this.getObj(tileIndex, obj => obj.isZoneLine())
		&& !this.getObj(tileIndex, obj => obj.type.activate);
};

// GET_WATER_SPAWN_INDEX:
// ************************************************************************************************
gs.getWaterSpawnIndex = function () {
    var indexList = this.getAllIndex();
	indexList = indexList.filter(index => this.isValidWaterSpawnIndex(index));
	return indexList.length > 0 ? util.randElem(indexList) : null;
};

// GET_SPAWN_INDEX:
// ************************************************************************************************
gs.getSpawnIndex = function () {
	var indexList = this.getAllIndex();
	indexList = indexList.filter(index => this.isValidSpawnIndex(index));
	return indexList.length > 0 ? util.randElem(indexList) : null;
};

// GET_LAVA_SPAWN_INDEX:
// ************************************************************************************************
gs.getLavaSpawnIndex = function () {
    var indexList = this.getAllIndex();
	indexList = indexList.filter(index => this.isValidLavaSpawnIndex(index));
	return indexList.length > 0 ? util.randElem(indexList) : null;
};

// GET_MERCHANT_SPAWN_INDEX:
// ************************************************************************************************
gs.getMerchantSpawnIndex = function () {
	var indexList = gs.getAllIndex();
	
	indexList = indexList.filter(index => this.isValidSpawnIndex(index));
	indexList = indexList.filter(index => !this.getItem(index));
	indexList = indexList.filter(index => this.isWidePassable(index));
	
	return indexList.length > 0 ? util.randElem(indexList) : null;
};

// GET_PASSABLE_ADJACENT_INDEX:
// ************************************************************************************************
gs.getPassableAdjacentIndex = function (tileIndex) {
	var indexList = this.getIndexListAdjacent(tileIndex);
	indexList = indexList.filter(index => gs.isPassable(index));
	return indexList.length > 0 ? util.randElem(indexList) : null;
};

// IS_ADJACENT_TO_TRANSPARENT:
// Returns a tileIndex that is adjacent that is also staticPassable
// ************************************************************************************************
gs.isAdjacentToTransparent = function (tileIndex) {
	var indexList = this.getIndexListAdjacent(tileIndex);
	indexList = indexList.filter(index => gs.isTileIndexTransparent(index));
	return indexList.length > 0 ? true : false;
};


// GET_INDEX_LIST_ADJACENT:
// ************************************************************************************************
gs.getIndexListAdjacent = function (tileIndex) {
	var indexList = this.getIndexInBox(tileIndex.x - 1, tileIndex.y - 1, tileIndex.x + 2, tileIndex.y + 2);
	indexList = indexList.filter(index => !gs.vectorEqual(tileIndex, index));
	return indexList;
};

// GET_INDEX_LIST_CARDINAL_ADJACENT:
// ************************************************************************************************
gs.getIndexListCardinalAdjacent = function (tileIndex) {
	var indexList = this.getIndexListAdjacent(tileIndex);
	indexList = indexList.filter(index => gs.distance(index, tileIndex) === 1);
	return indexList;
};

// GET_INDEX_IN_RADIUS:
// Will return the centerTileIndex if tileRadius = 0
// ************************************************************************************************
gs.getIndexInRadius = function (centerTileIndex, tileRadius) {
	var x, y, indexList = [];
	
	if (tileRadius === 0) {
		return [{x: centerTileIndex.x, y: centerTileIndex.y}];
	}
	
	for (x = centerTileIndex.x - Math.ceil(tileRadius); x <= centerTileIndex.x + Math.ceil(tileRadius); x += 1) {
		for (y = centerTileIndex.y - Math.ceil(tileRadius); y <= centerTileIndex.y + Math.ceil(tileRadius); y += 1) {
			if (gs.isInBounds(x, y) && gs.distance(centerTileIndex, {x: x, y: y}) <= tileRadius) {
				indexList.push({x: x, y: y});
			}
		}
	}
	return indexList;
};

// GET_INDEX_IN_RAY:
// Returns a list of all tile indices in a line
// If haltCondition is passed then the function will terminate when that condition evaluates to true
// ************************************************************************************************
gs.getIndexInRay = function (startTileIndex, endTileIndex, haltCondition) {
	var startPos = util.toPosition(startTileIndex),
		endPos = util.toPosition(endTileIndex),
		tiles = [],
		indexList = [],
		distance = 0,
		finalDistance = game.math.distance(startPos.x, startPos.y, endPos.x, endPos.y),
		normal = gs.getNormal(startPos, endPos),
		stepSize = 4,
		tile,
		i,
		x = startPos.x,
		y = startPos.y;

	while (distance < finalDistance) {
        x += normal.x * stepSize;
        y += normal.y * stepSize;
        distance += stepSize;
		
		tile = this.getTile(this.toTileIndex({x: x, y: y}));
        
		if (haltCondition && haltCondition(this.toTileIndex({x: x, y: y}))) {
			break;
		}
		
		if (tile && !gs.inArray(tile, tiles)) {
            tiles.push(tile);
        }
    }
  
	for (i = 1; i < tiles.length; i += 1) {
		indexList.push(tiles[i].tileIndex);
	}
	return indexList;
};

// GET_ALL_INDEX:
// ************************************************************************************************
gs.getAllIndex = function () {
	return this.getIndexInBox(0, 0, this.numTilesX, this.numTilesY);
};

// GET_INDEX_IN_BOX:
// ************************************************************************************************
gs.getIndexInBox = function (box, startY, endX, endY) {
	var x, y, indexList = [];
	
	if (typeof box === 'number') {
		box = {startX: box, startY: startY, endX: endX, endY: endY};
	}
	
	for (x = box.startX; x < box.endX; x += 1) {
		for (y = box.startY; y < box.endY; y += 1) {
			if (gs.isInBounds(x, y)) {
				indexList.push({x: x, y: y});
			}
		}
	}
	
	return indexList;
};

// GET_INDEX_IN_FAN:
// Returns all tiles in a 90deg are originating at tileIndex and pointing in dirVector
// dirVector must be one of the major cardinal directions
// ************************************************************************************************
gs.getIndexInFan = function (tileIndex, range, dirVector) {
	var angle,
		indexList,
		arc = 30;
	
	angle = util.angleToFace({x: 0, y: 0}, dirVector);
	
	indexList = this.getIndexInRadius(tileIndex, range + 1);
	indexList = indexList.filter(index => !this.vectorEqual(index, tileIndex));
	indexList = indexList.filter(index => gs.distance(tileIndex, index) < range + 1);
	
	if (angle >= 315 || angle <= 45) {
		indexList = indexList.filter(index => Math.abs(util.angleToFace(tileIndex, index) - angle) <= arc || Math.abs(util.angleToFace(tileIndex, index) - angle) >= 360 - arc);
	}
	else {
		indexList = indexList.filter(index => Math.abs(util.angleToFace(tileIndex, index) - angle) <= arc);
	}
	
	return indexList;
};

// GET_NEAREST_PASSABLE_INDEX:
// Used when dragging NPCs up stairs or when using a teleport pad
// Will conduct a large flood fill, sorted by depth and return the nearest passable tileIndex
// ************************************************************************************************
gs.getNearestPassableIndex = function (tileIndex) {
	var indexList;
	// Base Case:
	if (gs.isPassable(tileIndex)) {
		return tileIndex;
	}
	
	indexList = gs.getIndexInFlood(tileIndex, index => gs.getTile(index).type.passable, 5, true);
	indexList = indexList.filter(index => gs.isPassable(index));
	indexList.sort((a, b) => a.depth - b.depth);
	
	if (indexList.length === 0) {
		return null;
	}
	
	return indexList[0];
};

// GET_INDEX_IN_FLOOD:
// ************************************************************************************************
gs.getIndexInFlood = function (startTileIndex, func, maxDepth, allowDiagonal = false) {
	var openList = [],
		closedList = [],
		currentNode,
		tryToAddChild,
		isInOpenList,
		isInClosedList,
		loopCount = 0;
	
	maxDepth = maxDepth || 10000;

	// TRY_TO_ADD_CHILD:
	tryToAddChild = function (tileIndex, depth) {
		if (gs.isInBounds(tileIndex)
				&& depth <= maxDepth
				&& func(tileIndex)
				&& !isInOpenList(tileIndex)
				&& !isInClosedList(tileIndex)) {
			
			openList.push({x: tileIndex.x, y: tileIndex.y, depth: depth});
        }
	};
	
	// IS_IN_OPEN_LIST:
	isInOpenList = function (tileIndex) {
		return openList.find(node => gs.vectorEqual(node, tileIndex));
	};
	
	// IS_IN_CLOSED_LIST:
	isInClosedList = function (tileIndex) {
		return closedList.find(node => gs.vectorEqual(node, tileIndex));
	};
	
	openList.push({x: startTileIndex.x, y: startTileIndex.y, depth: 0});
	
	while (openList.length > 0) {
		currentNode = openList.shift();
		closedList.push(currentNode);
		
		// Add adjacent:
		tryToAddChild({x: currentNode.x + 1, y: currentNode.y}, currentNode.depth + 1);
		tryToAddChild({x: currentNode.x - 1, y: currentNode.y}, currentNode.depth + 1);
		tryToAddChild({x: currentNode.x, y: currentNode.y + 1}, currentNode.depth + 1);
		tryToAddChild({x: currentNode.x, y: currentNode.y - 1}, currentNode.depth + 1);
		
		if (allowDiagonal) {
			tryToAddChild({x: currentNode.x - 1, y: currentNode.y - 1}, currentNode.depth + 1);
			tryToAddChild({x: currentNode.x - 1, y: currentNode.y + 1}, currentNode.depth + 1);
			tryToAddChild({x: currentNode.x + 1, y: currentNode.y - 1}, currentNode.depth + 1);
			tryToAddChild({x: currentNode.x + 1, y: currentNode.y + 1}, currentNode.depth + 1);
		}
		
		loopCount += 1;
		if (loopCount > 10000) {
			throw 'getIndexInFlood: loopCount exceeded';
		}
	}
	
	return closedList;
};


// GET_TILE:
// ************************************************************************************************
gs.getTile = function (tileIndex, y) {
	if (typeof tileIndex === 'number') {
		tileIndex = {x: tileIndex, y: y};
	}
	
    if (this.isInBounds(tileIndex)) {
        return this.tileMap[tileIndex.x][tileIndex.y];
    } 
	else {
        return null;
    }
};

// GET_ITEM:
// ************************************************************************************************
gs.getItem = function (tileIndex, y) {
	if (typeof tileIndex === 'number') {
		tileIndex = {x: tileIndex, y: y};
	}
	
    if (this.isInBounds(tileIndex)) {
        return this.tileMap[tileIndex.x][tileIndex.y].item || null;
    } 
	else {
        return null;
    }
};

// GET_OBJ:
// ************************************************************************************************
gs.getObj = function (tileIndex, y, typeName) {
	var obj; 
	
	// x, y, typeName
	if (typeof tileIndex === 'number') {
		tileIndex = {x: tileIndex, y: y};
	}
	// index, typeName
	else {
		typeName = y;
	}
	
	// Not in bounds:
	if (!this.isInBounds(tileIndex)) {
		return null;
	}
	
	obj = this.tileMap[tileIndex.x][tileIndex.y].object;
	
	// No Object:
	if (!obj) {
		return null;
	}
	
	// No Pred:
	if (!typeName) {
		return obj;
	}
    
	// With predicate:
	if (typeof typeName === 'function') {
		return typeName.call(this, obj) ? obj : null;
	}
	// With specified typeName list:
	else if (typeof typeName === 'object') {
		return this.inArray(obj.type.name, typeName) ? obj : null;
	}
	// With specified typeName:
	else if (typeName) {
		return obj.type.name === typeName ? obj : null;
	}
};

// GET_CHARACTER:
// ************************************************************************************************
gs.getChar = function (tileIndex, y) {
	if (typeof tileIndex === 'number') {
		tileIndex = {x: tileIndex, y: y};
	}
	
    if (this.isInBounds(tileIndex)) {
        return this.tileMap[tileIndex.x][tileIndex.y].character || null;
    } 
	else {
        return null;
    }
};

// GET_EFFECT:
// ************************************************************************************************
gs.getEffect = function (tileIndex, y) {
	if (typeof tileIndex === 'number') {
		tileIndex = {x: tileIndex, y: y};
	}
	
    if (this.isInBounds(tileIndex)) {
        return this.tileMap[tileIndex.x][tileIndex.y].effect || null;
    } 
	else {
        return null;
    }
};

// GET_CLOUD:
// ************************************************************************************************
gs.getCloud = function (tileIndex, y) {
	if (typeof tileIndex === 'number') {
		tileIndex = {x: tileIndex, y: y};
	}
	
    if (this.isInBounds(tileIndex)) {
        return this.tileMap[tileIndex.x][tileIndex.y].cloud || null;
    } 
	else {
        return null;
    }
}; 

// GET_AREA:
// ************************************************************************************************
gs.getArea = function (tileIndex, y) {
	if (typeof tileIndex === 'number') {
		tileIndex = {x: tileIndex, y: y};
	}
	
    if (this.isInBounds(tileIndex)) {
        return this.tileMap[tileIndex.x][tileIndex.y].area || null;
    } 
	else {
        return null;
    }
};

// SET_TILE_TYPE:
// ************************************************************************************************
gs.setTileType = function (tileIndex, tileType, frame) {	
    if (this.isInBounds(tileIndex)) {
        this.tileMap[tileIndex.x][tileIndex.y].type = tileType;
		this.tileMap[tileIndex.x][tileIndex.y].frame = frame || frameSelector.selectFrame(tileType);
		
		if (!tileType.passable) {
			this.getTile(tileIndex).area = null;
		}
    }
};
    
// IS_PASSABLE:
// ************************************************************************************************
gs.isPassable = function (tileIndex, y) {
	if (typeof tileIndex === 'number') {
		tileIndex = {x: tileIndex, y: y};
	}
	
    return this.isInBounds(tileIndex)
            && this.getTile(tileIndex).type.passable
			&& !this.getObj(tileIndex, obj => !obj.isPassable())
            && this.getChar(tileIndex) === null
            && (!this.getCloud(tileIndex) || this.getCloud(tileIndex).isPassable);
};

// IS_DROP_WALL:
// ************************************************************************************************
gs.isDropWall = function (tileIndex, y) {
	if (typeof tileIndex === 'number') {
		tileIndex = {x: tileIndex, y: y};
	}
	
	return this.dropWallList.find(list => list.find(index => gs.vectorEqual(tileIndex, index)));
};

// IS_HALL_INDEX:
// ************************************************************************************************
gs.isHallIndex = function (tileIndex, y) {
	if (typeof tileIndex === 'number') {
		tileIndex = {x: tileIndex, y: y};
	}
	
	return this.isIndexOpen(tileIndex) && !this.getTile(tileIndex).isSolidWall;
};

// IS_STATIC_PASSABLE:
// Returns true if the tileType and object are passable
// Ignores characters
// Useful for lots of ability targeting
// ************************************************************************************************
gs.isStaticPassable = function (tileIndex, y) {
	if (typeof tileIndex === 'number') {
		tileIndex = {x: tileIndex, y: y};
	}
	
    return gs.isInBounds(tileIndex)
		&& gs.getTile(tileIndex).type.passable
		&& !gs.getObj(tileIndex, obj => !obj.isPassable());
};

// IS_INDEX_OPEN:
// ************************************************************************************************
gs.isIndexOpen = function (tileIndex, y) {
	if (typeof tileIndex === 'number') {
		tileIndex = {x: tileIndex, y: y};
	}
	
	return this.isInBounds(tileIndex)
		&& this.isPassable(tileIndex)
		&& this.getTile(tileIndex).type !== this.tileTypes.Water
		&& this.getTile(tileIndex).type !== this.tileTypes.Lava
		&& !this.getTile(tileIndex).type.isPit
		&& !this.getObj(tileIndex)
		&& !this.getChar(tileIndex)
		&& !this.getItem(tileIndex)
		&& !this.getTile(tileIndex).isClosed;
};

// IS_WIDE_OPEN:
// Returns true if the 3x3 box centered on tileIndex is all open
// ************************************************************************************************
gs.isWideOpen = function (tileIndex, y) {
	var indexList;
	
	if (typeof tileIndex === 'number') {
		tileIndex = {x: tileIndex, y: y};
	}
	
	if (!gs.isIndexOpen(tileIndex)) {
		return false;
	}
	
	indexList = gs.getIndexListCardinalAdjacent(tileIndex);
	indexList = indexList.filter(index => this.isIndexOpen(index));
	return indexList.length === 4;
};
	
// IS_WIDE_PASSABLE:
// ************************************************************************************************
gs.isWidePassable = function (tileIndex, y) {
	var indexList;
	
	if (typeof tileIndex === 'number') {
		tileIndex = {x: tileIndex, y: y};
	}
	
	if (!gs.isPassable(tileIndex)) {
		return false;
	}
	
	indexList = gs.getIndexListCardinalAdjacent(tileIndex);
	indexList = indexList.filter(index => this.isPassable(index));
	return indexList.length === 4;
};
	

// IS_INDEX_SAFE:
// ************************************************************************************************
gs.isIndexSafe = function (tileIndex, character) {
	character = character || {};
	
	return (this.getTile(tileIndex).type.name !== 'Lava' || character.isFlying)
		&& !this.getObj(tileIndex, obj => obj.type.isDangerous)
		&& (!this.getCloud(tileIndex) || this.getCloud(tileIndex).isSafe);
};

// IS_TILE_INDEX_TRANSPARENT:
// ************************************************************************************************
gs.isTileIndexTransparent = function (tileIndex) {
    return tileIndex.x >= 0 
		&& tileIndex.x < this.numTilesX 
		&& tileIndex.y >= 0 
		&& tileIndex.y < this.numTilesY
		&& this.tileMap[tileIndex.x][tileIndex.y].type.transparent
		&& (!this.tileMap[tileIndex.x][tileIndex.y].cloud || this.tileMap[tileIndex.x][tileIndex.y].cloud.isTransparent)
		&& (!this.tileMap[tileIndex.x][tileIndex.y].object || this.tileMap[tileIndex.x][tileIndex.y].object.isTransparent());
};

// IS_TILE_INDEX_IN_BOUNDS:
// ************************************************************************************************
gs.isInBounds = function (tileIndex, y) {
	if (typeof tileIndex === 'number') {
		tileIndex = {x: tileIndex, y: y};
	}
	
    return tileIndex.x >= 0  && tileIndex.y >= 0 && tileIndex.x < this.numTilesX && tileIndex.y < this.numTilesY;
};

// IS_VISIBLE_WALL:
// Returns true if the tile at tileIndex is both a wall and has a frame in which the graphic shows the wall itself 
// ************************************************************************************************
gs.isVisibleWall = function (tileIndex) {
	var typeName = this.getTile(tileIndex).type.name;

	if (typeName !== 'Wall' && typeName !== 'CaveWall') {
		return false;
	}
	
	if (!gs.isPassable(tileIndex.x, tileIndex.y + 1)) {
		return false;
	}
	
	return true;
};

// EXPLORE_MAP:
// ************************************************************************************************
gs.exploreMap = function () {
    for (let x = 0; x < this.numTilesX; x += 1) {
        for (let y = 0; y < this.numTilesY; y += 1) {
            if (this.getChar(x, y) ||
				this.getObj(x, y) ||
				this.isPassable(x, y) ||
				this.isAdjacentToTransparent({x: x, y: y})) {
                this.getTile(x, y).explored = true;
            }
        }
    }
};

// REVEAL_DUNGEON_SENSE:
// Explore any tile with an item, chest, or down stair
// ************************************************************************************************
gs.revealDungeonSenese = function () {
	var x, y;
	
	for (x = 0; x < this.numTilesX; x += 1) {
        for (y = 0; y < this.numTilesY; y += 1) {
			if (gs.getItem(x, y) || gs.getObj(x, y, 'Chest') || gs.getObj(x, y, obj => obj.isZoneLine()))  {
				gs.getTile(x, y).explored = true;
			}
		}
	}
	this.HUD.miniMap.refresh(true);
};

// GET_SAFEST_INDEX:
// Return the tileIndex that is furthest away from any enemy
// ************************************************************************************************
gs.getSafestIndex = function () {
	var distanceToMonster,
		list = [],
		indexList;
	
	distanceToMonster = function (tileIndex) {
		let npcList = gs.getAllNPCs();
		npcList = npcList.filter(npc => npc.faction === FACTION.HOSTILE);
		npcList.sort((a, b) => gs.distance(a.tileIndex, tileIndex) - gs.distance(b.tileIndex, tileIndex));
		
		return npcList.length > 0 ? gs.distance(npcList[0].tileIndex, tileIndex) : 1000;
	};
	
	indexList = this.getAllIndex();
	indexList = indexList.filter(index => gs.isIndexOpen(index));
	
	indexList.forEach(function (tileIndex) {
		list.push({tileIndex: tileIndex, distance: distanceToMonster(tileIndex)}); 
	}, this);
	
	list.sort((a, b) => b.distance - a.distance);
	
	return list.length > 0 ? list[0].tileIndex : null;
};/*global gs, util, console*/
/*global LARGE_WHITE_FONT*/
/*global TILE_SIZE*/
/*global FACTION*/
/*jshint esversion: 6, laxbreak: true*/
'use strict';

// FIND_UNEXPLORED_TILE_INDEX:
// Flood the entire level testing tileType passability until the nearest unexplored tile is found
// ************************************************************************************************
gs.findUnexploredTileIndex = function (fromTileIndex, unsafeMove = false) {
	var openList = [],
		closedList = [],
		currentTileIndex,
		tryToAddChild,
		addChild,
		isInOpenList,
		isInClosedList,
		isGoodTile,
		indexList,
		i,
		canPassDoor,
		isAllyAtIndex,
		nearestUnexploredTileIndex = null,
		allowDiagonal = gs.pc.movementSpeed > 0;
	
	// IS_GOOD_TILE:
	isGoodTile = function (tileIndex) {
		return (!gs.getTile(tileIndex).explored && gs.isPassable(tileIndex))
			|| (gs.getItem(tileIndex) && !gs.getItem(tileIndex).wasDropped)
			|| gs.getObj(tileIndex, ['HealingShroom', 'EnergyShroom'])
			|| gs.getObj(tileIndex, obj => obj.type.name === 'BookShelf' && obj.isFull)
			|| gs.getChar(tileIndex) && gs.getChar(tileIndex).type.name === 'Crate' && gs.distance(tileIndex, gs.pc.tileIndex) >= gs.pc.inventory.getWeapon().type.minRange
			|| gs.getObj(tileIndex, obj => obj.isContainer() && !obj.isOpen && !obj.isGuarded);
	};
	
	isAllyAtIndex = function (tileIndex) {
		return gs.getChar(tileIndex) && gs.getChar(tileIndex).faction === FACTION.PLAYER;
	};
	
	canPassDoor = function (tileIndex) {
		return gs.getObj(tileIndex, obj => obj.isDoor())
			&& (gs.getObj(tileIndex).isOpen || !gs.getObj(tileIndex, obj => obj.isGuarded || obj.isLocked || obj.isSealed));
	};
	
	// TRY_TO_ADD_CHILD:
	tryToAddChild = function (tileIndex) {
		if (gs.isInBounds(tileIndex)
				&& (gs.isPassable(tileIndex) || isAllyAtIndex(tileIndex) || canPassDoor(tileIndex) || isGoodTile(tileIndex))
				&& (gs.isIndexSafe(tileIndex, gs.pc) || unsafeMove)
				&& gs.pc.canWalk(tileIndex)
				&& !isInOpenList(tileIndex)
				&& !isInClosedList(tileIndex)) {
			
			openList.push(tileIndex);
			
			if (isGoodTile(tileIndex)) {
				nearestUnexploredTileIndex = tileIndex;
			}
        }
	};
	
	// IS_IN_OPEN_LIST:
	isInOpenList = function (tileIndex) {
		return openList.find(function (index) {return index.x === tileIndex.x && index.y === tileIndex.y; });
	};
	
	// IS_IN_CLOSED_LIST:
	isInClosedList = function (tileIndex) {
		return closedList.find(function (index) {return index.x === tileIndex.x && index.y === tileIndex.y; });
	};
	
	
	// Return any items, shrooms or containers that have already been discovered before searching further:
	indexList = this.getAllIndex();
	indexList = indexList.filter(index => gs.getTile(index).explored);
	indexList = indexList.filter(index => isGoodTile(index));
	indexList = indexList.filter(index => gs.isIndexSafe(index, gs.pc));
	indexList = indexList.filter(index => gs.distance(index, gs.pc.tileIndex) < 10);
	indexList = indexList.sort((indexA,indexB) => gs.distance(indexA, gs.pc.tileIndex) - gs.distance(indexB, gs.pc.tileIndex));
	for (i = 0; i < indexList.length; i += 1) {
		// Player must have a valid path to it:
		if (this.pc.getPathTo(indexList[i])) {
			return indexList[i];
		}
	}
	
	
	openList.push(fromTileIndex);
	
	while (openList.length > 0) {
		currentTileIndex = openList.shift();
		closedList.push(currentTileIndex);
		
		// Add adjacent:
		tryToAddChild({x: currentTileIndex.x + 1, y: currentTileIndex.y});
		tryToAddChild({x: currentTileIndex.x - 1, y: currentTileIndex.y});
		tryToAddChild({x: currentTileIndex.x, y: currentTileIndex.y + 1});
		tryToAddChild({x: currentTileIndex.x, y: currentTileIndex.y - 1});
		
		// Add adjacent diagonals:
		if (allowDiagonal) {
			tryToAddChild({x: currentTileIndex.x + 1, y: currentTileIndex.y - 1});
			tryToAddChild({x: currentTileIndex.x - 1, y: currentTileIndex.y - 1});
			tryToAddChild({x: currentTileIndex.x + 1, y: currentTileIndex.y + 1});
			tryToAddChild({x: currentTileIndex.x - 1, y: currentTileIndex.y + 1});
		}
		
		if (nearestUnexploredTileIndex) {
			break;
		}
	}
	
	// unsafe move (trim to first 
	if (unsafeMove && nearestUnexploredTileIndex) {
		
		let path = gs.findPath(fromTileIndex, nearestUnexploredTileIndex, {allowDiagonal: allowDiagonal});
		if (path && path.length > 0) {
			let index = path.indexOf(path.find(index => !gs.isIndexSafe(index, gs.pc)));
			
			if (index > -1 && index + 1 < path.length && gs.isIndexSafe(path[index + 1], gs.pc)) {
				nearestUnexploredTileIndex = path[index + 1];	
			}
			else {
				nearestUnexploredTileIndex = null;
			}
		}
		else {
			nearestUnexploredTileIndex = null;
		}
	}
	
	return nearestUnexploredTileIndex;
};


// FIND_PATH:
// ************************************************************************************************
gs.findPath = function (fromIndex, toIndex, flags) {
	var calculateH,
		tryToAddChild,
		addChild,
		isInOpenList,
		isInClosedList,
		getNodeFromOpenList,
		popOpenListF,
		createPath,
		openList = [],
		closedList = {},
		loopCount = 0,
		exitState = 0,
		currentNode,
		indexPath = [],
		canWalkFunc,
		passDoors,
		exploredOnly,
		avoidTraps,
		character,
		maxDepth,
		allowDiagonal,
		isValidTileIndex,
		accuracy,
		isAllyAtIndex;
	
	// Flags:
	flags = flags || {};
	passDoors = flags.passDoors || false;
	canWalkFunc = flags.canWalkFunc || null;
	exploredOnly = flags.exploredOnly || false;
	avoidTraps = flags.avoidTraps || false;
	character = flags.character || null;
	maxDepth = flags.maxDepth || 1000;
	allowDiagonal = flags.allowDiagonal || false;
	isValidTileIndex = flags.isValidTileIndex;
	calculateH = flags.calculateH;
	accuracy = flags.drunk ? 0.25 : 1.0;
	
	if (!canWalkFunc) {
		canWalkFunc = function () {
			return true;
		};
	}
	
	isAllyAtIndex = function (tileIndex) {
		return character === gs.pc && gs.getChar(tileIndex) && gs.getChar(tileIndex).faction === FACTION.PLAYER;
	};
	
	if (!isValidTileIndex) {
		isValidTileIndex = function (tileIndex) {
			return (gs.isPassable(tileIndex) || isAllyAtIndex(tileIndex) || (gs.getObj(tileIndex, obj => obj.isDoor() && !obj.isLocked && !obj.isGuarded && !obj.isSealed) && passDoors))
				&& (!exploredOnly || gs.getTile(tileIndex).explored)
				&& (!avoidTraps || gs.isIndexSafe(tileIndex, character))
				&& canWalkFunc(tileIndex);
		};
	}
	
	if (!calculateH) {
		calculateH = function (tileIndex) {
			return gs.distance(tileIndex, toIndex); 
		};
	}
	
	addChild = function (parentNode, tileIndex, hCost, gCost) {
		var tempNode;
		
		// Node is not on the open list so create it:
		if (!isInOpenList(tileIndex)) {
			openList.push({tileIndex: tileIndex, 
						   parentNode: parentNode, 
						   g: parentNode.g + gCost, 
						   h: hCost, 
						   f: parentNode.g + gCost + hCost});
		} 
		// Node is on the open list, check if this is a shorter path:
		else {
			tempNode = getNodeFromOpenList(tileIndex);
			if (parentNode.g + gCost + hCost < tempNode.f) {
				tempNode.parentNode = parentNode;
				tempNode.g = parentNode.g + gCost;
				tempNode.f = tempNode.h + tempNode.g;
			}
		}
	};
	
	isInOpenList = function (tileIndex) {
		return openList.find(node => gs.vectorEqual(node.tileIndex, tileIndex));
	};
	
	isInClosedList = function (tileIndex) {
		//return closedList.find(node => gs.vectorEqual(node.tileIndex, tileIndex));
		return closedList.hasOwnProperty(tileIndex.x + ',' + tileIndex.y);
	};
	
	getNodeFromOpenList = function (tileIndex) {
		return openList.find(node => gs.vectorEqual(node.tileIndex, tileIndex));
	};
	
	popOpenListF = function () {
		var lowestNode = openList[0],
			lowestIndex = 0,
			i;
		
		
		for (i = 0; i < openList.length; i += 1) {
			if ((openList[i].f < lowestNode.f || openList[i].f === lowestNode.f && openList[i].h < lowestNode.h) && (accuracy === 1 || util.frac() <= accuracy)) {
				lowestNode = openList[i];
				lowestIndex = i;
			}
		}
		
		openList.splice(lowestIndex, 1);
		return lowestNode;
	};
	
	tryToAddChild = function (tileIndex) {
		if (gs.isInBounds(tileIndex) && isValidTileIndex(tileIndex) && !isInClosedList(tileIndex)) {
			addChild(currentNode, {x: tileIndex.x, y: tileIndex.y}, calculateH({x: tileIndex.x, y: tileIndex.y}), 1);
        } 
		// Always add the goal
		else if (gs.vectorEqual(tileIndex, toIndex)) {
            addChild(currentNode, {x: tileIndex.x, y: tileIndex.y}, calculateH({x: tileIndex.x, y: tileIndex.y}), 1);
        }
	};
	
	// Quick return if destination is invalid:
	let indexList = gs.getIndexInRadius(toIndex, 1.5);
	indexList = indexList.filter(index => isValidTileIndex(index));
	if (indexList.length === 0) {
		return null;
	}
	
	// Push first node:
	openList.push({tileIndex: fromIndex, parentNode: null, g: 0, h: calculateH(fromIndex), f: calculateH(fromIndex)});
	
	while (true) {
		// No path exists:
		if (openList.length === 0) {
			exitState = -1;
			break;
		}
		
		// Loop count exceeded:
		if (loopCount > maxDepth) {
			exitState = -2;
			break;
		}
		
		currentNode = popOpenListF();
		
		if (gs.debugProperties.logPathFinding) {
			gs.createText(currentNode.tileIndex.x * TILE_SIZE, currentNode.tileIndex.y * TILE_SIZE, '' + loopCount, LARGE_WHITE_FONT);
		}

		// Found goal:
		if (gs.vectorEqual(currentNode.tileIndex, toIndex)) { 
			exitState = 1;
			break;
		}
		
		// Add adjacent:
		tryToAddChild({x: currentNode.tileIndex.x + 1, y: currentNode.tileIndex.y});
		tryToAddChild({x: currentNode.tileIndex.x - 1, y: currentNode.tileIndex.y});
		tryToAddChild({x: currentNode.tileIndex.x, y: currentNode.tileIndex.y + 1});
		tryToAddChild({x: currentNode.tileIndex.x, y: currentNode.tileIndex.y - 1});
		
		if (allowDiagonal) {
			tryToAddChild({x: currentNode.tileIndex.x + 1, y: currentNode.tileIndex.y - 1});
			tryToAddChild({x: currentNode.tileIndex.x - 1, y: currentNode.tileIndex.y - 1});
			tryToAddChild({x: currentNode.tileIndex.x + 1, y: currentNode.tileIndex.y + 1});
			tryToAddChild({x: currentNode.tileIndex.x - 1, y: currentNode.tileIndex.y + 1});
		}
		
		//closedList.push(currentNode);
		closedList[currentNode.tileIndex.x + ',' + currentNode.tileIndex.y] = 1;
		loopCount += 1;
	}
	
	//console.log('loopCount: ' + loopCount);
	//console.log('closedList: ' + closedList.length);
	
	if (exitState === -1 || exitState === -2) {
		return null;
	} 
	else if (exitState === 1) {
		// Start at goal node and work backwords:
		while (currentNode.parentNode) {
			indexPath.push(currentNode.tileIndex);
			currentNode = currentNode.parentNode;
		}
		
		//console.log('pathLength: ' + indexPath.length);
		return indexPath;
	}
};/*global gs, game, console, Phaser*/
/*global NUM_TILES_X, NUM_TILES_Y*/
/*global TILE_SIZE, SCALE_FACTOR, SHADOW_COLOR*/
/*global NUM_SCREEN_TILES_X, NUM_SCREEN_TILES_Y*/
/*global LOS_DISTANCE*/
/*jshint esversion: 6, laxbreak: true, loopfunc: true*/
'use strict';
// CREATE_TILE_MAP_SPRITES:
// ************************************************************************************************
gs.createTileMapSprites = function () {
    
    
    this.tileMapSprites = [];
    for (let x = 0; x < NUM_SCREEN_TILES_X; x += 1) {
        this.tileMapSprites[x] = [];
        for (let y = 0; y < NUM_SCREEN_TILES_Y; y += 1) {
			this.tileMapSprites[x][y] = gs.createSprite(x * TILE_SIZE, y * TILE_SIZE, 'MapTileset', this.tileMapSpritesGroup);
			this.tileMapSprites[x][y].scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
			this.tileMapSprites[x][y].anchor.setTo(0.5, 0.75);
			this.tileMapSprites[x][y].visible = false;
			//this.tileMapSprites[x][y].enableBody = false;
        }
    }
	
	
	this.createShadowMask();
};




// CREATE_SHADOW_MASK
// ************************************************************************************************
gs.createShadowMask = function () {
	var width = NUM_SCREEN_TILES_X * TILE_SIZE,
		height = NUM_SCREEN_TILES_Y * TILE_SIZE,
		radius = width / 2,
		gradient,
		color = SHADOW_COLOR,
		startAlpha = 'ff';
	
	// Creating Shadow Mask:
	this.shadowMaskBMP = game.add.bitmapData(width, width);
	
	gradient = this.shadowMaskBMP.context.createRadialGradient(radius, radius, radius * 2 * 0.05, radius, radius, radius * 2 * 0.5);
	gradient.addColorStop(0, color + '00');
	gradient.addColorStop(1, color + 'aa');
	this.shadowMaskBMP.context.fillStyle = gradient;
	this.shadowMaskBMP.context.fillRect(0, 0, radius * 2, radius * 2);
	
	this.shadowMaskSprite = this.createSprite(0, 0, this.shadowMaskBMP, this.shadowSpritesGroup);
	this.shadowMaskSprite.anchor.setTo(0.5, 0.5);
	
	this.shadowMaskBMP.dirty = true;
};

// UPDATE_TILE_MAP_SPRITES:
// ************************************************************************************************
gs.updateTileMapSprites = function () {
    var cameraTileIndex = this.toTileIndex(game.camera.position),
		tileIndex = {x: 0, y: 0},
		objectGroupArray = ['Wall', 'CaveWall', 'HalfWall'],
		tileSprite;
	
	
	
    for (let x = 0; x < NUM_SCREEN_TILES_X; x += 1) {
        for (let y = 0; y < NUM_SCREEN_TILES_Y; y += 1) {
			
			tileIndex.x = cameraTileIndex.x + x;
			tileIndex.y = cameraTileIndex.y + y;
			
			tileSprite = this.tileMapSprites[x][y];
			tileSprite.x = ((tileIndex.x + 0.5) * TILE_SIZE);
            tileSprite.y = ((tileIndex.y + 0.5) * TILE_SIZE);
			
			
            // If in bounds:
            if (this.isInBounds(tileIndex)) {
                // If explored:
                if (this.getTile(tileIndex).explored) {
					tileSprite.visible = true;
				
					// Tile Unique Frame:
					if (this.getTile(tileIndex).frame) {
						tileSprite.frame = this.getTile(tileIndex).frame;
					}
					// Tile Generic Frame:
					else {
						tileSprite.frame = this.getTile(tileIndex).type.frame;
					}
					
					// Moving tile to correct layer:
					if (gs.inArray(this.getTile(tileIndex).type.name, objectGroupArray)) {
						this.objectSpritesGroup.add(tileSprite);
					}
					else {
						this.tileMapSpritesGroup.add(tileSprite);
					}

					// Debug show areas (highlights areas in red):
					if (this.debugProperties.showAreas) {
						if (this.getTile(tileIndex).area && this.getTile(tileIndex).areaFlag === 'AREA_WALL' || this.getTile(tileIndex).isSolidWall) {
							tileSprite.tint = 0Xff0000;
						}
						else if (this.getTile(tileIndex).area) {
							tileSprite.tint = 0X00ff00;
						}
						else {
							tileSprite.tint = 0Xffffff;
						}
					}
					
					// Make item visible:
					if (this.getItem(tileIndex)) {
						this.getItem(tileIndex).sprite.visible = true;
					}
					
					// Make objects visible:
					if (this.getObj(tileIndex, obj => !obj.type.isHidden)) {
						this.getObj(tileIndex).sprite.visible = true;
					}

					// Make effects visible:
					if (this.getCloud(tileIndex)) {
						this.getCloud(tileIndex).sprite.visible = true;
					}
					
                    // If explored and visible:
                    if (this.getTile(tileIndex).visible) {
						this.setSpriteKey(tileSprite, 'MapTileset');
						
						// Make item ligth:
						if (this.getItem(tileIndex)) {
							this.setSpriteKey(this.getItem(tileIndex).sprite, 'Tileset');
						}
						
						// Make objects light:
						if (this.getObj(tileIndex)) {
							this.setSpriteKey(this.getObj(tileIndex).sprite, 'MapTileset');
						}
						
						// Make effect light:
						if (this.getCloud(tileIndex)) {
							this.setSpriteKey(this.getCloud(tileIndex).sprite, 'Tileset');
						}
                    }
					// If explored and not visible:
					else {
						this.setSpriteKey(tileSprite, 'DarkMapTileset');
						
						// Make item dark:
						if (this.getItem(tileIndex)) {
							this.setSpriteKey(this.getItem(tileIndex).sprite, 'DarkTileset');
						}
						
						// Make objects dark:
						if (this.getObj(tileIndex)) {
							this.setSpriteKey(this.getObj(tileIndex).sprite, 'DarkMapTileset');
						}
						
						// Make effect dark:
						if (this.getCloud(tileIndex)) {
							this.setSpriteKey(this.getCloud(tileIndex).sprite, 'DarkTileset');
						}
                    }
					
					
                } 
				// If not explored:
				else {
                    tileSprite.visible = false;
                    
                    // Hide item:
                    if (this.getItem(tileIndex)) {
                        this.getItem(tileIndex).sprite.visible = false;
                    }
					
					// Hide Object:
					if (this.getObj(tileIndex)) {
						this.getObj(tileIndex).sprite.visible = false;
					}
					
					// Hide Effect:
					if (this.getCloud(tileIndex)) {
						this.getCloud(tileIndex).sprite.visible = false;
					}
                }
            }
			// If not in bounds:
			else {
                tileSprite.visible = false;
            }
        }
    }
};

// SET_SPRITE_KEY:
// ************************************************************************************************
gs.setSpriteKey = function (sprite, key) {
	var frame;
	
	if (sprite.key !== key) {
		frame = sprite.frame;
		sprite.loadTexture(key, frame, true);
		sprite.frame = frame;

		if (sprite.animations && sprite.animations.getAnimation("anim")) {
			sprite.play('anim', 5, true);
		}
	}
};

// CREATE_LOS_RAYS:
// ************************************************************************************************
gs.createLoSRays = function () {
	var angle = 0,
        angleDelta = Math.PI / 20,
        distance = 0,
        stepDelta = 4,
        sightDistance = TILE_SIZE * LOS_DISTANCE,
        point,
        tileIndex;
	
	this.losRays = [];

    point = new Phaser.Point(1, 0);
	
    for (angle = 0; angle < Math.PI * 2; angle += angleDelta) {
        point = Phaser.Point.rotate(point, 0, 0, angleDelta);
		let indexList = [];
		
        for (distance = 0; distance <= sightDistance; distance += stepDelta) {
			tileIndex = this.toTileIndex({x: 20 + point.x * distance, y: 20 + point.y * distance});
            
			if (!indexList.find(index => gs.vectorEqual(tileIndex, index))) {
				indexList.push({x: tileIndex.x, y: tileIndex.y});
			}
		}
		
		this.losRays.push(indexList);
    }
};

// CALCULATE_LOS:
// ************************************************************************************************
gs.calculateLoS = function (forceRefresh = false) {
    // Make all tiles not visible:
	if (forceRefresh) {
		for (let x = 0; x < this.numTilesX; x += 1) {
			for (let y = 0; y < this.numTilesY; y += 1) {
				this.tileMap[x][y].visible = this.debugProperties.mapVisible;
			}
    	}
	}
	else {
		for (let x = Math.max(0, gs.pc.tileIndex.x - LOS_DISTANCE - 1); x < Math.min(this.numTilesX, gs.pc.tileIndex.x + LOS_DISTANCE + 2); x += 1) {
			for (let y = Math.max(0, gs.pc.tileIndex.y - LOS_DISTANCE - 1); y < Math.min(this.numTilesY, gs.pc.tileIndex.y + LOS_DISTANCE + 2); y += 1) {
				this.tileMap[x][y].visible = this.debugProperties.mapVisible;
			}
    	}
	}
    
	
	// Tiles adjacent to player are always visible:
	this.getIndexInBox(this.pc.tileIndex.x - 1, this.pc.tileIndex.y - 1, this.pc.tileIndex.x + 2, this.pc.tileIndex.y + 2).forEach(function (tileIndex) {
		// Visible:
        this.tileMap[tileIndex.x][tileIndex.y].visible = true;
		
		// Explored:
		this.setTileIndexExplored(tileIndex);
	}, this);
	
	this.losRays.forEach(function (ray) {
		for (let i = 0; i < ray.length; i += 1) {
			let tileIndex = {x: ray[i].x + gs.pc.tileIndex.x, y: ray[i].y + gs.pc.tileIndex.y};
			
			if (this.isTileIndexTransparent(tileIndex)) {
				gs.setTileIndexVisible(tileIndex);
            } 
			else {
                break;
            }
		}
		
	}, this);
};



// SET_TILE_INDEX_VISIBLE:
// ************************************************************************************************
gs.setTileIndexVisible = function (tileIndex) {
	var indexList = this.getIndexInBox(tileIndex.x - 1, tileIndex.y -1, tileIndex.x + 2, tileIndex.y + 2);
	
	// Handling the tile itself:
    if (this.isInBounds(tileIndex)) {
		// Visible:
        this.tileMap[tileIndex.x][tileIndex.y].visible = true;
		
		// Explored:
		this.setTileIndexExplored(tileIndex);
    }
	
	// Handling adjacent wall tiles:
	indexList.forEach(function (index) {
		if (!this.isTileIndexTransparent(index)) {
			// Visible:
			this.tileMap[index.x][index.y].visible = true;

			// Explored:
			this.setTileIndexExplored(index);
		}
	}, this);
};

// SET_TILE_INDEX_EXPLORED:
// ************************************************************************************************
gs.setTileIndexExplored = function (tileIndex) {
	var objList, charList;
	
	// Explored:
	if (!this.tileMap[tileIndex.x][tileIndex.y].explored) {
		this.tileMap[tileIndex.x][tileIndex.y].explored = true;
		
		objList = [
			'UpStairs',  'DownStairs', 
			'HealthFountain', 'ManaFountain', 'ExperienceFountain', 'WellOfWishing', 'AttributeFountain',
			'EnchantmentTable', 'TransferanceTable',
			'StoneDoor', 'Gate',
		    'CrystalChest',
			'AltarOfTrog', 'AltarOfWealth', 'AltarOfTheArcher', 'AltarOfTheWizard', 'AltarOfHealth', 'AltarOfExploration',
		];
		
		charList = [
			'Merchant', 'TalentTrainer', 'SkillTrainer', 'Priest'
		];
		
		// Need to be very careful here so as not to fuck up charge and sprint w/ popup messages:
		if (gs.pc.isExploring && !gs.pc.isMultiMoving) {
			// Halting exploration if something interesting is discovered:
			if (this.getObj(tileIndex, objList)) {
				gs.pc.stopExploring();
				gs.pc.popUpText('Spotted ' + gs.capitalSplit(this.getObj(tileIndex).type.name), '#ffffff');
			} 
			else if (this.getChar(tileIndex) && this.inArray(this.getChar(tileIndex).name, charList)) {
				gs.pc.stopExploring();
				gs.pc.popUpText('Spotted ' + gs.capitalSplit(this.getChar(tileIndex).type.name), '#ffffff');
			}	
		}
		
	}
};

/*
gs.createTileMapSprites = function () {
	this.mapBMP = game.add.bitmapData(800, 800);
	
	//this.mapBMP.copy('MapTileset', 0, 0);
	
	this.mapSprite = game.add.sprite(0, 0, this.mapBMP, this.tileMapSpritesGroup);
	this.mapSprite.scale.setTo(2, 2);
	this.mapSprite.smoothed = false;
	this.mapSprite.fixedToCamera = true;
	

	this.frameMap = [];
	for (let x = 0; x < NUM_SCREEN_TILES_X; x += 1) {
		this.frameMap[x] = [];
		for (let y = 0; y < NUM_SCREEN_TILES_Y; y += 1) {
			this.frameMap[x][y] = -1;
		}
	}
	
	this.createShadowMask();
	
	
};

gs.updateTileMapSprites = function () {
	 var cameraTileIndex = this.toTileIndex(game.camera.position),
		 tileIndex = {x: 0, y: 0},
		 tile,
		 frame;
	
	this.mapSprite.x = ((cameraTileIndex.x + 0.5) * TILE_SIZE);
    this.mapSprite.y = ((cameraTileIndex.y + 0.5) * TILE_SIZE);
	
    for (let x = 0; x < NUM_SCREEN_TILES_X; x += 1) {
        for (let y = 0; y < NUM_SCREEN_TILES_Y; y += 1) {
			tileIndex.x = cameraTileIndex.x + x;
			tileIndex.y = cameraTileIndex.y + y;
			
			
			if (this.isInBounds(tileIndex)) {
				tile = this.tileMap[tileIndex.x][tileIndex.y];
				frame = tile.frame || tile.type.frame;
				
				if (this.frameMap[x][y] !== frame) {
					this.mapBMP.copy('MapTileset', (frame % 32) * 20, Math.floor(frame / 32) * 40, 20, 40, x * 20, y * 20);
					this.frameMap[x][y] = frame;
				}
				
				
			}
		}
	}
	this.mapBMP.dirty = true;
};
*/
/*global game, gs, localStorage, console, util*/
/*global TILE_SIZE, SCALE_FACTOR*/
/*global TIER_II_ZONES, TIER_III_ZONES, BRANCH_I_ZONES, BRANCH_II_ZONES*/
/*global DANGER_LEVEL*/
/*global NPC, Container, Shop, featureGenerator, Inventory, bspGenerator, SPAWN_ENEMY_TURNS, FACTION*/
/*jshint laxbreak: true, esversion: 6*/

'use strict';

// ZONE_TYPE:
// Returns the type of zone
// ************************************************************************************************
gs.zoneType = function () {
	return gs.zoneTypes[gs.zoneName];
};

// NEXT_LEVEL:
// Returns {zoneName, zoneLevel} of the next level (upon falling down a pit)
// Returns null if there is no next valid next level (in this case the player character will be killed by the fall)
// ************************************************************************************************
gs.nextLevel = function () {
	var nextZoneName, nextLevel;
	
	if (this.zoneLevel === 4) {
		nextLevel = 1;
		
		// TIER_I => TIER_II:
		if (this.zoneName === 'TheUpperDungeon') {
			nextZoneName = gs.arrayIntersect(this.branches, TIER_II_ZONES)[0];
		}
		// TIER_II => TIER_III:
		else if (gs.inArray(this.zoneName, TIER_II_ZONES)) {
			nextZoneName = gs.arrayIntersect(this.branches, TIER_III_ZONES)[0];
		}
		// TIER_III => TIER_IV:
		else if (gs.inArray(this.zoneName, TIER_III_ZONES)) {
			nextZoneName = 'VaultOfYendor';
		}
		else {
			return null;
		}
	}
	else {
		nextLevel = this.zoneLevel + 1;
		nextZoneName = this.zoneName;
	}
	
	return {zoneName: nextZoneName, zoneLevel: nextLevel};
};

// DESCEND_LEVEL:
// Called when falling down pits and pit traps.
// Will handle transitions between zones.
// ************************************************************************************************
gs.descendLevel = function () {
	var nextLevel = gs.nextLevel();
	
	if (!nextLevel) {
		throw 'Error: cannot descent on this level';
	}
	
	this.changeLevel(nextLevel.zoneName, nextLevel.zoneLevel);
};

// CHANGE_LEVEL:
// Called from: zoneTo, pitTrap, player.load and when starting a new game.
// ************************************************************************************************
gs.changeLevel = function (toDungeonName, toDungeonLevel, forceGenerate) {
	var prevZoneName = this.zoneName, success = false;
	
	forceGenerate = forceGenerate || false;
	
	// Save the previous level:
	if (prevZoneName && gs.debugProperties.saveLevels) {
		this.saveLevel();
		this.pc.save();
	}
	
	this.zoneName = toDungeonName;
	this.zoneLevel = toDungeonLevel;
	
	// Destroy stuff:
	this.destroyLevel();
	
	// Reset character list and push player:
    this.characterList = [];
    this.characterList.push(gs.pc);
    
	// Make sure player starts first:
	this.activeCharacterIndex = 0;
	this.activeCharacter = this.characterList[0];
	this.pc.waitTime = 0;
	
	// Load a previously visited level:
	if (this.canReloadLevel(toDungeonName, toDungeonLevel) && !forceGenerate) {
		this.reloadLevel(toDungeonName, toDungeonLevel);
		success = true;
	}
	// Generating level:
	else {
		success = this.generateLevel();
		
		// Exploration god heal:
		if (gs.pc.religion === 'Exploration' && gs.pc.currentHp < gs.pc.maxHp) {
			gs.pc.healHp(gs.pc.maxHp);
		}
		
		// Dungeon Sense:
		if (gs.pc.hasTalent('DungeonSense')) {
			gs.revealDungeonSenese();
		}
		
		// Timed treasure room dialog:
		if (featureGenerator.featureTypeCounts.TimedTreasureRoom > 0) {
			gs.dialogMenu.open(gs.dialog.TimedTreasureRoom);
		}
		
		// Notify the player he is in a branch:
		if (gs.state !== 'DIALOG_MENU_STATE' && this.atBranchEntrance()) {
			gs.dialogMenu.open(gs.dialog.BranchHelp);
		}
		
		// Log Event:
		this.logDungeonLevel();
	}
	
	// Camera:
	game.world.bounds.setTo(-1000, -1000, (this.numTilesX - 1) * TILE_SIZE + 2000, (this.numTilesY - 1) * TILE_SIZE + 3000);
	game.camera.setBoundsToWorld();
	
	// Stop music if the toZone has no music or if it is different then the current track: 
	if (!this.getZoneMusic(toDungeonName) || this.getZoneMusic(toDungeonName) !== this.getZoneMusic(prevZoneName)) {
		this.stopAllMusic();
	}
	
	// Start music if it exists:
	if (this.musicOn && this.getZoneMusic(toDungeonName) && this.getZoneMusic(toDungeonName) !== this.getZoneMusic(prevZoneName)) {
		this.getZoneMusic(toDungeonName).fadeIn(1000, true);
	}
	
	// Explore Level:
	if (this.debugProperties.mapExplored) {
		this.exploreMap();
	}
	
	gs.pc.statusEffects.onChangeLevel();
	
	return success;
};

// AT_BRANCH_ENTRANCE:
// ************************************************************************************************
gs.atBranchEntrance = function () {
	return gs.inArray(this.zoneName, BRANCH_I_ZONES.concat(BRANCH_II_ZONES))
		&& gs.zoneLevel === 1;
};

// GET_PULL_NPC_LIST:
// ************************************************************************************************
gs.getPullNPCList = function (zoneLine) {
	var list = [];
	
	// Pull Hostile NPCs
	this.getIndexInRadius(zoneLine.tileIndex, 1.5).forEach(function (index) {
		let char = this.getChar(index);
		if (char && char !== this.pc && char.isAgroed && char.faction === FACTION.HOSTILE && !char.isStunned && !char.isImmobile) {
			list.push(char.toData());
			char.destroy();
		}
	}, this);
	
	// Pull Friendly Allies from everywhere:
	this.getAllAllies().forEach(function (char) {
		list.push(char.toData());
		char.destroy();
	}, this);
	
	return list;
};

// ZONE_TO:
// Called when interacting with a zoneline.
// ************************************************************************************************
gs.zoneTo = function (zoneLine) {
	var i, tileIndex, prevZoneName, prevZoneLevel, char, pullNPCList;
	
	prevZoneName = this.zoneName;
	prevZoneLevel = this.zoneLevel;
	
	pullNPCList = this.getPullNPCList(zoneLine);
	
	// Change level:
	this.changeLevel(zoneLine.toZoneName, zoneLine.toZoneLevel);
	
	// Search for a connecting zoneLine in the new zone:
	if (this.getZoneLineTileIndex(prevZoneName, prevZoneLevel)) {
		let zoneLineTileIndex = this.getZoneLineTileIndex(prevZoneName, prevZoneLevel);
		this.pc.body.snapToTileIndex(gs.getNearestPassableIndex(zoneLineTileIndex));
	}
	else {
		throw 'Zoning from ' + prevZoneName + ' to ' + zoneLine.toZoneName + ', no valid zoneline';
	}
	
	
	// Now in new zone:
	this.pc.stopExploring();
	
	this.calculateLoS(true);
	gs.HUD.miniMap.refresh(true);
	
	this.placePulledNPCs(pullNPCList);
	
	// Force it to be players turn:
	this.activeCharacterIndex = 0;
	this.activeCharacter = this.characterList[0];
	
	
	
	
	gs.pc.updateStats();
};

// PLACE_PULLED_NPCS:
// ************************************************************************************************
gs.placePulledNPCs = function (pullNPCList) {
	var tileIndex, char;
	
	// Pulled NPCS:
	for (let i = 0; i < pullNPCList.length; i += 1) {
		tileIndex = gs.getNearestPassableIndex(this.pc.tileIndex);
		
		if (!tileIndex) {
			throw 'Could not place pulled NPC';
		}
		
		pullNPCList[i].tileIndex = {x: tileIndex.x, y: tileIndex.y};
		char = this.loadNPC(pullNPCList[i]);
		
		char.isAgroed = true;
	}
};

// DESTROY_LEVEL:
// ************************************************************************************************
gs.destroyLevel = function () {
	this.destroyAllNPCs();
    this.destroyAllFloorItems();
	this.destroyAllObjects();
	this.destroyAllProjectiles();
	this.destroyAllClouds();
};

// GET_ZONE_LINE_TILE_INDEX:
// With no arguments this function will return the first zone line it finds
// ************************************************************************************************
gs.getZoneLineTileIndex = function (toZoneName, toZoneLevel) {	
	for (let x = 0; x < this.numTilesX; x += 1) {
		for (let y = 0; y < this.numTilesY; y += 1) {
			let obj = this.getObj(x, y, obj => obj.isZoneLine());
			
			if (obj && obj.toZoneName === toZoneName && obj.toZoneLevel === toZoneLevel) {
				return {x: x, y: y};
			}
		}
	}
	return null;
};

gs.niceZoneLevel = function (zoneName, zoneLevel) {
	zoneName = zoneName || this.zoneName;
	zoneLevel = zoneLevel || this.zoneLevel;
	
	if (zoneName === 'TheUpperDungeon') {
		return zoneLevel;
	}
	else if (gs.inArray(zoneName, TIER_II_ZONES)) {
		return zoneLevel + 4;
	}
	else if (gs.inArray(zoneName, TIER_III_ZONES)) {
		return zoneLevel + 8;
	}
	else if (zoneName === 'VaultOfYendor') {
		return zoneLevel + 12;
	}
	else {
		return zoneLevel;
	}
};

// DANGER_LEVEL:
// Because of branches we need to have an easy way to determine the dungeon level.
// This could be thought of as depth from the surface.
// This can be used to determine what objects, traps, features, and items to spawn.
// Can also be used for enchantment level and gold amount.
// ************************************************************************************************
gs.dangerLevel = function (zoneName, zoneLevel) {
	zoneName = zoneName || this.zoneName;
	zoneLevel = zoneLevel || this.zoneLevel;
	
	if (zoneName === 'TestLevel') {
		return 1;
	}
	else if (zoneName === 'TheUpperDungeon') {
		return DANGER_LEVEL.TIER_I[zoneLevel];
	}
	else if (gs.inArray(zoneName, TIER_II_ZONES)) {
		return DANGER_LEVEL.TIER_II[zoneLevel];
	}
	else if (gs.inArray(zoneName, TIER_III_ZONES)) {
		return DANGER_LEVEL.TIER_III[zoneLevel];
	}
	else if (gs.inArray(zoneName, BRANCH_I_ZONES)) {
		return DANGER_LEVEL.BRANCH_I[zoneLevel];
	}
	else if (gs.inArray(zoneName, BRANCH_II_ZONES)) {
		return DANGER_LEVEL.BRANCH_II[zoneLevel];
	}
	else if (zoneName === 'VaultOfYendor') {
		return DANGER_LEVEL.TIER_IV[zoneLevel];
	}
	else {
		throw 'dangerLevel() - not valid dangerLevel for zone: ' + zoneName;
	}
};

// DROP_GOLD_AMOUNT:
// How much gold should spawn on floor and be dropped by enemies.
// This will be based on the dangerLevel()
// ************************************************************************************************
gs.dropGoldAmount = function () {
	return Math.ceil(this.dangerLevel() / 2);

};


// GET_ZONE_MUSIC:
// ************************************************************************************************
gs.getZoneMusic = function (zoneName) {
	// No zone data:
	if (this.zoneTypes[zoneName]) {
		return this.zoneTypes[zoneName].musicTrack;
	} else {
		return null;
	}
};

// UNEXPLORED_TILES_REMAINING:
// ************************************************************************************************
gs.unexploredTilesRemaining = function () {
	var indexList = gs.getAllIndex();
	indexList = indexList.filter(index => !gs.getTile(index).explored && gs.getTile(index).type.passable && !gs.getTile(index).type.isPit);
	return indexList.length > 0;
};

// EXPLODE_WALL:
// Used by drop walls or triggered drop walls
// Requires a list of tileIndices
// ************************************************************************************************
gs.explodeWall = function (indexList) {
	indexList.forEach(function (index) {
		gs.setTileType(index, gs.tileTypes.Floor);
		if (gs.getObj(index)) {
			gs.destroyObject(gs.getObj(index));
		}
		gs.createParticlePoof(index, 'WHITE');
		
		gs.shout(index, FACTION.HOSTILE, true);
	}, this);
			
	game.camera.shake(0.020, 200);
	gs.playSound(gs.sounds.explosion, gs.pc.tileIndex);
	gs.calculateLoS();
	gs.hasNPCActed = true;
};/*global gs, game, console, localStorage*/
/*global levelController, Item, frameSelector*/
/*global TILE_SIZE, SCALE_FACTOR, PLAYER_FRAMES*/
/*jshint esversion: 6, loopfunc: true*/
'use strict';

// LOAD_JSON_LEVEL:
// Load a level from a .json file
// ************************************************************************************************
gs.loadJSONLevel = function (levelName) {
	var tileTypeMap, data, object, frame, x, y, frameOffset;
	
	data = game.cache.getJSON(levelName);
	
	if (data.tilesets[1]) {
		frameOffset = data.tilesets[1].firstgid - 1;
	}
	
	
	tileTypeMap = this.parseJSONMap(levelName);
	this.numTilesX = tileTypeMap.length;
	this.numTilesY = tileTypeMap[0].length;
	this.initiateTileMap();
	this.createTileMap({x: 0, y: 0}, tileTypeMap);
	
	// Load NPCs and Items:
	for (let i = 0; i < data.layers[1].objects.length; i += 1) {
		object = data.layers[1].objects[i];
		frame = object.gid - 1;
		x = Math.round(object.x / (TILE_SIZE / SCALE_FACTOR));
		y = Math.round(object.y / (TILE_SIZE / SCALE_FACTOR)) - 1;
		
		
		if (data.tilesets[1]) {
			// Loading Characters:
			if ((gs.debugProperties.spawnMobs || gs.zoneName === 'TestLevel') && this.getNameFromFrame(frame - frameOffset, this.npcTypes)) {
				gs.createNPC({x: x, y: y}, this.getNameFromFrame(frame - frameOffset, this.npcTypes));
			}
			
			// Load Items:
			if (this.getNameFromFrame(frame - frameOffset, this.itemTypes)) {
				gs.createFloorItem({x: x, y: y}, Item.createItem(this.getNameFromFrame(frame - frameOffset, this.itemTypes)));
			}
		}
	}
	
	
	
	// Spawn NPCS:
	if (gs.debugProperties.spawnMobs) {
		
		for (let x = 0; x < this.numTilesX; x += 1) {
			for (let y = 0; y < this.numTilesY; y += 1) {
				let tileIndex = {x: x, y: y};
				
				// Zoo Mob:
				if (tileTypeMap[x][y].zooMob) {	
					gs.spawnMonsterZooNPC(tileIndex);
					gs.getChar(tileIndex).isAsleep = false;
				}

				// Spawn Mob:
				if (tileTypeMap[x][y].spawnMob) {
					gs.spawnRandomNPC(tileIndex);
					gs.getChar(tileIndex).isAsleep = false;
				}

			}			
		}
	}
};


// PARSE_JSON_MAP:
// Parses the data in a .JSON file, converting it to a tileTypeMap in the internal format
// This tileTypeMap is the same internal format as the game saves to and can then be passed to createTileMap to be created
// So the purpose of this function is simply to convert the static .JSON files produced by Tiled into our internal format
// It does not actually do any loading itself.
// ************************************************************************************************
gs.parseJSONMap = function (fileName, rotate) {
	var tileTypeMap,
		data,
		object,
		frame,
		numTilesX,
		numTilesY,
		frameOffset,
		objData,
		dataHeight,
		dataWidth,
		getTileTypeMap,
		typeName;

	data = game.cache.getJSON(fileName);
	if (rotate) {
		dataWidth = data.width;
		dataHeight = data.height;
		numTilesX = data.height;
		numTilesY = data.width;
	}
	else {
		dataWidth = data.width;
		dataHeight = data.height;
		numTilesX = data.width;
		numTilesY = data.height;
	}
	
	if (data.tilesets[1]) {
		frameOffset = data.tilesets[1].firstgid - 1;
	}
	
	getTileTypeMap = function (x, y) {
		if (rotate) {
			return tileTypeMap[y][x];
		}
		else {
			return tileTypeMap[x][y];
		}
	};
	
	// INIT_TILE_TYPE_MAP:
	// ********************************************************************************************
	tileTypeMap = [];
	for (let x = 0; x < numTilesX; x += 1) {
		tileTypeMap[x] = [];
		for (let y = 0; y < numTilesY; y += 1) {
			tileTypeMap[x][y] = {};
		}
	}
	
	// LOADING_TILE_LAYER:
	// ********************************************************************************************
	for (let y = 0; y < dataHeight; y += 1) {
		for (let x = 0; x < dataWidth; x += 1) {
			frame = data.layers[0].data[y * data.width + x] - 1;
			typeName = this.getNameFromFrame(frame, this.tileTypes);
			
			getTileTypeMap(x, y).f = frame;
			
			if (frame === 480) {
				getTileTypeMap(x, y).f = frameSelector.selectFrame(gs.tileTypes.Wall);
			}
			
			if (frame === 481) {
				getTileTypeMap(x, y).f = frameSelector.selectFrame(gs.tileTypes.CaveWall);
			}
			
			if (frame === 482) {
				getTileTypeMap(x, y).f = frameSelector.selectFrame(gs.tileTypes.Floor);
			}
			
			if (frame === 483) {
				getTileTypeMap(x, y).f = frameSelector.selectFrame(gs.tileTypes.CaveFloor);
			}
			
			// Error Checking:
			if (!typeName) {
				throw 'parseJSONMap() failed, ' + frame + ' is not a valid frame. Index: ' + x + ',' + y;
			}
		}
	}
	
	// LOADING_FLAG_LAYER:
	// ********************************************************************************************
	if (data.layers[2]) {
		for (let y = 0; y < dataHeight; y += 1) {
			for (let x = 0; x < dataWidth; x += 1) {
				frame = data.layers[2].data[y * data.width + x] - 1;
				
				// isSolidWall flag:
				if (frame === 2016) {
					getTileTypeMap(x, y).s = true;
				}
				
				// Zoo flag:
				if (frame === 2017) {
					getTileTypeMap(x, y).zooMob = true;
				}
				
				// Mob Flag:
				if (frame === 2020) {
					getTileTypeMap(x, y).spawnMob = true;
				}
				
				// Closed:
				if (frame === 2019) {
					getTileTypeMap(x, y).c = true;
				}
				
				// Trigger Tiles:
				if (frame >= 2023 && frame <= 2033) {
					getTileTypeMap(x, y).t = frame - 2022;
				}
			}
		}
	}
	
	// LOADING_OBJECT_LAYER:
	// ********************************************************************************************
	if (data.layers[1]) {
		for (let i = 0; i < data.layers[1].objects.length; i += 1) {
			object = data.layers[1].objects[i];
			frame = object.gid - 1;
			let x = Math.round(object.x / (TILE_SIZE / SCALE_FACTOR));
			let y = Math.round(object.y / (TILE_SIZE / SCALE_FACTOR)) - 1;

			// Loading Objects
			if (this.getNameFromFrame(frame, this.objectTypes)) {
				// Creating objData:
				objData = {
					frame: frame,
					typeFrame: this.objectTypes[this.getNameFromFrame(frame, this.objectTypes)].frame
				};
				
				// Adding additional properties:
				if (object.properties) {
					for (let key in object.properties) {
						if (object.properties.hasOwnProperty(key)) {
							objData[key] = object.properties[key];
						}
					}
				}
				
				// Parse trigger:
				if (objData.hasOwnProperty('triggerTileIndex')) {
					objData.triggerTileIndex = JSON.parse(objData.triggerTileIndex);
				}
				
				// Parse toTileIndex:
				if (objData.hasOwnProperty('toTileIndex')) {
					objData.toTileIndex = JSON.parse(objData.toTileIndex);
				}
				
				getTileTypeMap(x, y).obj = objData;
			}
			// Loading Characters:
			else if (data.tilesets[1] && this.getNameFromFrame(frame - frameOffset, this.npcTypes)) {
				// Pass, handled elsewhere
			}
			// Loading Items:
			else if (data.tilesets[1] && this.getNameFromFrame(frame - frameOffset, this.itemTypes)) {
				// Pass, handled elsewhere
			}
			// Unknown Frame:
			else {
				throw fileName + ' Unknown frame: ' + frame + ', at tileIndex: ' + x + ', ' + y;
			}
		}
	}
	
	return tileTypeMap;
};


// SAVE_LEVEL:
// ************************************************************************************************
gs.saveLevel = function () {
    var x, y, i, j, data;
	
    data = {};
    data.numTilesX = this.numTilesX;
	data.numTilesY = this.numTilesY;
	data.levelController = levelController.toData();
	data.staticLevelName = gs.staticLevelName;
	data.levelTriggers = gs.levelTriggers;
	
	// Save tile map:
    data.tileMap = [];
    for (x = 0; x < this.numTilesX; x += 1) {
        data.tileMap[x] = [];
        for (y = 0; y < this.numTilesY; y += 1) {
            // Save Tile:
			data.tileMap[x][y] = {
				f: this.tileMap[x][y].frame,
			};
			
			// Optional Data (defaults to false on load):
			if (this.tileMap[x][y].explored)		data.tileMap[x][y].e = 1;
			if (this.tileMap[x][y].isClosed)		data.tileMap[x][y].c = 1;
			if (this.tileMap[x][y].triggerGroup) 	data.tileMap[x][y].t = this.tileMap[x][y].triggerGroup;
			
			// Save Objects:
			if (this.getObj(x, y)) {
				data.tileMap[x][y].obj = this.getObj(x, y).toData();
			}
        }
    }
	
	// Save npcs
    data.npcs = [];
	this.getAllNPCs().forEach(function (npc) {
		data.npcs.push(npc.toData());
	}, this);
    
    // Save items:
    data.items = [];
    for (i = 0; i < this.floorItemList.length; i += 1) {
        if (this.floorItemList[i].isAlive) {
            data.items.push(this.floorItemList[i].toData());
        }
    }
	
	// Save drop walls:
	data.dropWalls = [];
	for (i = 0; i < this.dropWallList.length; i += 1) {
		data.dropWalls.push(this.dropWallList[i]);
	}
	
	data.lastTurn = this.turn;
    localStorage.setItem(this.zoneName + this.zoneLevel, JSON.stringify(data));
};


// CAN_RELOAD_LEVEL:
// Can load previously saved level:
// ************************************************************************************************
gs.canReloadLevel = function (zoneName, zoneLevel) {
	return localStorage.getItem(zoneName + zoneLevel) !== null;
};

// RELOAD_LEVEL:
// Load previously saved level:
// ************************************************************************************************
gs.reloadLevel = function (zoneName, zoneLevel) {
    var i, data;
    
    data = JSON.parse(localStorage.getItem(zoneName + zoneLevel));
	this.numTilesX = data.numTilesX;
	this.numTilesY = data.numTilesY;
	levelController.loadData(data.levelController);
	gs.staticLevelName = data.staticLevelName;
	gs.levelTriggers = data.levelTriggers;
	
	// Create tile map:
	this.initiateTileMap();
	this.createTileMap({x: 0, y: 0}, data.tileMap);
	
    // load NPCs:
    for (i = 0; i < data.npcs.length; i += 1) {
		this.loadNPC(data.npcs[i]);		
    }
    
    // Load Items:
    for (i = 0; i < data.items.length; i += 1) {
		this.loadFloorItem(data.items[i]);
    }
	
	// Load Drop Walls:
	this.dropWallList = [];
	for (i = 0; i < data.dropWalls.length; i += 1) {
		this.dropWallList.push(data.dropWalls[i]);
	}
    
	this.lastTurn = data.lastTurn;
};


// CREATE_TILE_MAP:
// Given a tileTypeMap object, fill the tilemap with tiles and objects
// This function DOES NOT create NPCs
// This function DOES NOT create items
// ************************************************************************************************
gs.createTileMap = function (startTileIndex, tileTypeMap) {
    var tileIndex,
		numTilesX = tileTypeMap.length,
		numTilesY = tileTypeMap[0].length,
		obj,
		tileData;
	
    for (let x = 0; x < numTilesX; x += 1) {
        for (let y = 0; y < numTilesY; y += 1) {
			tileIndex = {x: startTileIndex.x + x, y: startTileIndex.y + y};
			tileData = tileTypeMap[x][y];
			
			// Tile Properties:
			this.getTile(tileIndex).explored = 		tileData.e || false;
			this.getTile(tileIndex).isClosed = 		tileData.c || false;
			this.getTile(tileIndex).isSolidWall = 	tileData.s || false;
			this.getTile(tileIndex).triggerGroup =	tileData.t || 0;
			
			
			
			// Tile Type:
			this.setTileType(tileIndex, this.tileTypes[this.getNameFromFrame(tileData.f, this.tileTypes)]);
			this.getTile(tileIndex).frame = tileData.f;
			
			// Objects:
			if (tileData.obj) {
				
				// Offset toTileIndex:
				if (tileData.obj.triggerTileIndex) {
					tileData.obj.triggerTileIndex.forEach(function (index) {
						index.x = index.x + startTileIndex.x;
						index.y = index.y + startTileIndex.y;
					}, this);
				}
				
				
				
				gs.loadObj(tileIndex, tileData.obj);
			}
        }
    }
};


/*global game, gs, console, Phaser*/
/*global bspGenerator, rogueGenerator, cycleGenerator, caveRoomGenerator, caveGenerator, cave2Generator, swampGenerator*/
/*global arcaneGenerator, ringGenerator, cryptGenerator, sewerTunnelsGenerator, sewerRoadsGenerator*/
/*jshint esversion: 6, laxbreak: true*/
'use strict';

// CREATE_LEVEL_TYPES:
// ************************************************************************************************
gs.createLevelTypes = function () {
	var key;

	this.zoneTypes = {};
	this.createNPCGroupTypes();
	this.createSpawnTables();
	this.createRoomDressingTables();
	this.createZoneDressingTables();
	this.createZoneSpecialFeaturesTables();
	this.createZoneTileFrames();

	this.zoneTypes.TestLevel = {
		// Level Generation:
		numLevels: 4,
		tileFrames: this.zoneTileFrames.MainDungeon
	};
	
	// THE_UPPER_DUNGEON:
	// ********************************************************************************************
	this.zoneTypes.TheUpperDungeon = {
		// Level Generation:
		numLevels: 4,
		dressingTable: this.zoneDressingTables.TheUpperDungeon,
		tileFrames: this.zoneTileFrames.MainDungeon,
		musicTrack: this.music.MainDungeon,
		specialFeatures: this.zoneSpecialFeaturesTables.EarlyGame,
		vaultTags: ['Dungeon', 'Generic'],
		roomTags: ['Square', 'Cross', 'Vault'],
		generators: [
			{name: bspGenerator, percent: 25},
			{name: rogueGenerator, percent: 25},
			{name: cycleGenerator, percent: 25},
			{name: caveRoomGenerator, percent: 25}
		],
		
		
		// NPCs:
		spawnTable: this.spawnTables.TheUpperDungeon,
								 
		// Environment:
		spawnMushrooms: true,
		spawnWater: true,
		spawnVines: true,
		spawnFireShrooms: true,
		spawnWallFlags: true

	};
	
	// THE_UNDER_GROVE: (TIER I)
	// ********************************************************************************************
	this.zoneTypes.TheUnderGrove = {
		// Level Generation:
		numLevels: 4,
		dressingTable: this.zoneDressingTables.TheUnderGrove,
		tileFrames: this.zoneTileFrames.TheUnderGrove,
		musicTrack: this.music.TheUnderGrove,
		distanceScalar: 0.035,
		specialFeatures: this.zoneSpecialFeaturesTables.MidGame,
		roomTags: ['Square', 'Cross', 'Vault'],
		generators: [
			{name: caveGenerator, percent: 50},
			{name: cave2Generator, percent: 50}
		],
		
		// NPCs:
		spawnTable: this.spawnTables.TheUnderGrove,
		
								 
		// Environment:
		spawnMushrooms: true,
		spawnWater: true,
		spawnVines: true,
		spawnStreamers: true,
		spawnBearTraps: true,
		spawnFirePots: true,
		spawnFireShrooms: true
	};
	
	// THE_SUNLESS_DESERT: (TIER I)
	// ********************************************************************************************
	this.zoneTypes.TheSunlessDesert = {
		// Level Generation:
		numLevels: 4,
		dressingTable: this.zoneDressingTables.TheSunlessDesert,
		tileFrames: this.zoneTileFrames.TheSunlessDesert,
		musicTrack: this.music.TheUnderGrove,
		distanceScalar: 0.035,
		specialFeatures: this.zoneSpecialFeaturesTables.MidGame,
		roomTags: ['Square', 'Cross', 'Vault'],
		generators: [
			{name: caveGenerator, percent: 50},
			{name: cave2Generator, percent: 50}
		],
		
		// NPCs:
		spawnTable: this.spawnTables.TheSunlessDesert,
		
								 
		// Environment:
		spawnMushrooms: true,
		spawnBones: true,
		spawnStreamers: true,
		spawnFirePots: true,
		spawnFireShrooms: true
	};
	
	// THE_SWAMP: (TIER I)
	// ********************************************************************************************
	this.zoneTypes.TheSwamp = {
		// Level Generation:
		numLevels: 4,
		dressingTable: this.zoneDressingTables.TheUnderGrove,
		tileFrames: this.zoneTileFrames.TheSwamp,
		musicTrack: this.music.TheUnderGrove,
		specialFeatures: this.zoneSpecialFeaturesTables.MidGame,
        roomTags: ['Square', 'Cross', 'Vault'],
		generators: [
			{name: swampGenerator, percent: 100}
		],
		
		// NPCs:
		spawnTable: this.spawnTables.TheSwamp,
		
								 
		// Environment:
		spawnMushrooms: true,
		spawnWater: true,
		spawnVines: true,
		spawnStreamers: true,
		spawnBearTraps: true,
		spawnFirePots: true,
		spawnFireShrooms: true
	};
	
	// THE_ORC_FORTRESS:
	// ********************************************************************************************
	this.zoneTypes.TheOrcFortress = {
		// Level Generation:
		numLevels: 4,
		dressingTable: this.zoneDressingTables.TheOrcFortress,
		tileFrames: this.zoneTileFrames.TheOrcFortress,
		musicTrack: this.music.MainDungeon,
		specialFeatures: this.zoneSpecialFeaturesTables.MidGame,
		vaultTags: ['Generic', 'Dungeon'],
		roomTags: ['Square', 'Cross', 'Vault'],
		generators: [
			{name: bspGenerator, percent: 25},
			{name: rogueGenerator, percent: 25},
			{name: cycleGenerator, percent: 25},
			{name: caveRoomGenerator, percent: 25}
		],
		
		// NPCs:
		spawnTable: this.spawnTables.TheOrcFortress,
		
								 
		// Environment:
		spawnMushrooms: true,
		spawnWater: true,
		spawnVines: true,
		spawnStreamers: true,
		spawnFireShrooms: true,
		spawnFirePots: true,
		spawnWallFlags: true
	};
	
	
	// THE_IRON_FORTRESS: (TIER I)
	// ********************************************************************************************
	this.zoneTypes.TheIronFortress = {
		// Level Generation:
		numLevels: 4,
		dressingTable: this.zoneDressingTables.TheIronFortress,
		tileFrames: this.zoneTileFrames.TheIronFortress,
		musicTrack: this.music.TheIronFortress,
		specialFeatures: this.zoneSpecialFeaturesTables.MidGame,
		vaultTags: ['Generic', 'TheIronFortress'],
		roomTags: ['Square', 'Cross', 'Vault'],
		generators: [
			{name: bspGenerator, percent: 33},
			{name: rogueGenerator, percent: 33},
			{name: cycleGenerator, percent: 33}
		],
		
		// NPCs:
		spawnTable: this.spawnTables.TheIronFortress,
						 
		// Environment:
		spawnMushrooms: true,
		spawnWater: true,
		spawnOil: true,
		spawnStreamers: true,
		spawnFirePots: true,
		spawnFireVents: true,
		spawnFireShrooms: true
	};
	
	// THE_ARCANE_TOWER: (TIER II)
	// ********************************************************************************************
	this.zoneTypes.TheArcaneTower = {
		// Level Generation:
		numLevels: 4,
		dressingTable: this.zoneDressingTables.TheArcaneTower,
		tileFrames: this.zoneTileFrames.TheArcaneTower,
		musicTrack: this.music.TheIronFortress,
		specialFeatures: this.zoneSpecialFeaturesTables.LateGame,
		vaultTags: ['TheArcaneTower'],
		roomTags: ['Square', 'Circle', 'Vault'],
		generators: [
			{name: arcaneGenerator, percent: 75},
			{name: ringGenerator, percent: 25}
		],
		
		// NPCs:
		spawnTable: this.spawnTables.TheArcaneTower,
		
								 
		// Environment:
		spawnMushrooms: true,
		spawnWater: true,
		spawnFirePots: true,
		spawnFireGlyphs: true
	};
	
	// THE_CRYPT: (TIER II)
	// ********************************************************************************************
	this.zoneTypes.TheCrypt = {
		// Level Generation:
		numLevels: 4,
		dressingTable: this.zoneDressingTables.TheCrypt,
		tileFrames: this.zoneTileFrames.TheCrypt,
		musicTrack: this.music.TheCrypt,
		specialFeatures: this.zoneSpecialFeaturesTables.LateGame,
		vaultTags: ['Generic', 'TheCrypt'],
		roomTags: ['Square', 'Cross', 'Vault'],
		generators: [
			{name: bspGenerator, percent: 25},
			{name: rogueGenerator, percent: 25},
			{name: cryptGenerator, percent: 50}
		],
		
		// NPCs:
		spawnTable: this.spawnTables.TheCrypt,
		
		
		// Environment:
		spawnBlood: true,
		spawnMushrooms: true,
		spawnWater: true,
		spawnVines: true,
		spawnStreamers: true,
		spawnSpikeTraps: true,
		spawnGasPots: true,
		spawnFireShrooms: true
	};
	
	// THE_DARK_TEMPLE:
	// ********************************************************************************************
	this.zoneTypes.TheDarkTemple = {
		// Level Generation:
		numLevels: 4,
		dressingTable: this.zoneDressingTables.TheOrcFortress,
		tileFrames: this.zoneTileFrames.TheDarkTemple,
		musicTrack: this.music.MainDungeon,
		specialFeatures: this.zoneSpecialFeaturesTables.LateGame,
        roomTags: ['Square', 'Cross', 'Circle', 'Vault'],
		generators: [
			{name: bspGenerator,		percent: 25},
			{name: rogueGenerator,		percent: 25},
			{name: cycleGenerator,		percent: 25},
			{name: caveRoomGenerator,	percent: 15},
			{name: ringGenerator,		percent: 10}
		],
		
		// NPCs:
		spawnTable: this.spawnTables.TheDarkTemple,
		
								 
		// Environment:
		spawnMushrooms: true,
		spawnWater: true,
		spawnVines: true,
		spawnFireShrooms: true,
		spawnStreamers: true,
		spawnPits: true,
		spawnFirePots: true
	};
	
	// THE_VAULT_OF_YENDOR:
	// ********************************************************************************************
	this.zoneTypes.VaultOfYendor = {
		// Level Generation:
		numLevels: 4,
		dressingTable: this.zoneDressingTables.TheOrcFortress,
		tileFrames: this.zoneTileFrames.VaultOfYendor,
		musicTrack: this.music.MainDungeon,
		specialFeatures: this.zoneSpecialFeaturesTables.LateGame,
		roomTags: ['Square', 'Cross', 'Circle', 'Vault'],
		generators: [
			{name: bspGenerator,		percent: 25},
			{name: rogueGenerator,		percent: 25},
			{name: cycleGenerator,		percent: 25},
			{name: caveRoomGenerator,	percent: 15},
			{name: ringGenerator,		percent: 10}
		],
		
		// NPCs:
		spawnTable: this.spawnTables.VaultOfYendor,
		
								 
		// Environment:
		spawnMushrooms: true,
		spawnWater: true,
		spawnVines: true,
		spawnFireShrooms: true,
		spawnStreamers: true,
		spawnPits: true,
		spawnFirePots: true
	};
	
	// THE_SEWERS: (TIER III)
	// ********************************************************************************************
	this.zoneTypes.TheSewers = {
		// Level Generation:
		numLevels: 4,
		dressingTable: this.zoneDressingTables.TheSewers,
		tileFrames: this.zoneTileFrames.TheSewers,
		musicTrack: this.music.TheIronFortress,
		specialFeatures: this.zoneSpecialFeaturesTables.LateGame,
		roomTags: ['Square', 'Cross', 'Vault'],
		generators: [
			{name: sewerTunnelsGenerator, percent: 50},
			{name: sewerRoadsGenerator, percent: 50}
		],
		
		// NPCs:
		spawnTable: this.spawnTables.TheSewers,
		
		
		// Environment:
		spawnMushrooms: true,
		spawnVines: true,
		spawnStreamers: false,
		spawnGasVents: true,
		spawnGasPots: true,
		spawnFireShrooms: true
	};

	
	// THE_CORE: (TIER III)
	// ********************************************************************************************
	this.zoneTypes.TheCore = {
		// Level Generation:
		numLevels: 4,
		dressingTable: this.zoneDressingTables.TheCore,
		tileFrames: this.zoneTileFrames.TheCore,
		musicTrack: this.music.TheCore,
		specialFeatures: this.zoneSpecialFeaturesTables.LateGame,
		roomTags: ['Square', 'Cross', 'Vault'],
		generators: [
			{name: bspGenerator, percent: 20},
			{name: rogueGenerator, percent: 20},
			{name: caveGenerator, percent: 20},
			{name: cave2Generator, percent: 20},
			{name: caveRoomGenerator, percent: 20}
		],
		
		// NPCs:
		spawnTable: this.spawnTables.TheCore,
		
		
		// Environment:
		spawnVines: true,
		spawnLava: true,
		spawnFireVents: true,
		spawnPits: true
	};

	// THE_ICE_CAVES: (TIER III)
	// ********************************************************************************************
	this.zoneTypes.TheIceCaves = {
		// Level Generation:
		numLevels: 4,
		dressingTable: this.zoneDressingTables.TheIceCaves,
		tileFrames: this.zoneTileFrames.TheIceCaves,
		musicTrack: this.music.TheIceCaves,
		specialFeatures: this.zoneSpecialFeaturesTables.LateGame,
		
		roomTags: ['Square', 'Cross', 'Vault'],
		generators: [
			{name: caveGenerator, percent: 33},
			{name: cave2Generator, percent: 33},
			{name: caveRoomGenerator, percent: 33}
		],
		
		// NPCs:
		spawnTable: this.spawnTables.TheIceCaves,
		
		
		// Environment:
		spawnWater: true,
		spawnIce: true,
		isCold: true,
		spawnPits: true,
		spawnBearTraps: true
	};
	
	
	// Zone name list:
	this.nameTypes(this.zoneTypes);
	this.zoneNamesList = [];
	this.forEachType(this.zoneTypes, function (zoneType) {
		this.zoneNamesList.push(zoneType.name);
		
		zoneType.floatingFeatures = zoneType.floatingFeatures || [];
		
		zoneType.vaultTags = zoneType.vaultTags || ['Generic'];
	}, this);
	

	
	this.createStaticLevelTypes();
	this.createZoneConnections();
	this.setZoneFloatingFeatures();
};

// SET_ZONE_FLOATING_FEATURES:
// ************************************************************************************************
gs.setZoneFloatingFeatures = function () {
	// TIER_I:
	// ************************************************************************************************
	this.zoneTypes.TheUpperDungeon.floatingFeatures = [
		'RatCave'
	];
	
	// TIER_II:
	// ************************************************************************************************
	this.zoneTypes.TheUnderGrove.floatingFeatures = [
		'OgreCave', 'AntCave', 'BeeHive'
	];
	
	this.zoneTypes.TheSunlessDesert.floatingFeatures = [
		'OgreCave'
	];
	
	this.zoneTypes.TheSwamp.floatingFeatures = [
		'AntCave'
	];
	
	this.zoneTypes.TheOrcFortress.floatingFeatures = [
		'TreasureTrap', 'FireTrap', 'OgreCave', 'OrcPriestTemple', 'OrcFortress', 'MerchantShop'
	];
	
	// TIER_III:
	// ************************************************************************************************
	this.zoneTypes.TheIronFortress.floatingFeatures = [
		'BallistaRoom', 'TreasureTrap', 'MerchantShop'
	];
	
	this.zoneTypes.TheDarkTemple.floatingFeatures = [
		'TreasureTrap', 'FireTrap', 'MerchantShop'
	];
	
	// BRANCH_I:
	// ************************************************************************************************

	// BRANCH_II:
	// ************************************************************************************************
	this.zoneTypes.TheCore.floatingFeatures = [
		'OrcFortress', 'OrcPriestTemple'
	];
	
	this.zoneTypes.TheIceCaves.floatingFeatures = [
		'BearCave', 'OrcPriestTemple'
	];
	
	// TIER_IV:
	// ************************************************************************************************
	this.zoneTypes.VaultOfYendor.floatingFeatures = [
		'TreasureTrap', 'FireTrap', 'MerchantShop'
	];
};



// CREATE_STATIC_LEVEL_TYPES:
// ************************************************************************************************
gs.createStaticLevelTypes = function () {
	
	gs.staticLevelTypes = [
		// TIER_I_ZONES:
		// ****************************************************************************************
		// THE_UPPER_DUNGEON:
		{zoneName: 'TheUpperDungeon', fileName: 'TheUpperDungeon-01'},
		{zoneName: 'TheUpperDungeon', fileName: 'TheUpperDungeon-02'},
		{zoneName: 'TheUpperDungeon', fileName: 'TheUpperDungeon-03'},
		{zoneName: 'TheUpperDungeon', fileName: 'TheUpperDungeon-04'},
		{zoneName: 'TheUpperDungeon', fileName: 'TheUpperDungeon-OrcEntrance01', pred: function () {return gs.zoneLevel === 4 && gs.inArray('TheOrcFortress', gs.branches); }},
		
		// TIER_II_ZONES:
		// ****************************************************************************************
		// THE_ORC_FORTRESS:
		{zoneName: 'TheOrcFortress', fileName: 'TheOrcFortress-01'},
		{zoneName: 'TheOrcFortress', fileName: 'TheOrcFortress-02'},
		{zoneName: 'TheOrcFortress', fileName: 'TheOrcFortress-03'},
        
		// THE_IRON_FORTRESS:
		{zoneName: 'TheIronFortress', fileName: 'TheIronFortress-01'},
		{zoneName: 'TheIronFortress', fileName: 'TheIronFortress-02'},
		
		// THE_UNDER_GROVE:
		{zoneName: 'TheUnderGrove',	fileName: 'TheUnderGrove-01'},
		{zoneName: 'TheUnderGrove',	fileName: 'TheUnderGrove-02'},
		
		// THE_SWAMP:
		
		// TIER_III_ZONES:
		// ****************************************************************************************
		// THE_DARK_TEMPLE:
		{zoneName: 'TheDarkTemple', fileName: 'TheDarkTemple-01'},
        {zoneName: 'TheDarkTemple', fileName: 'TheDarkTemple-02'},
        
		// THE_CRYPT:
		{zoneName: 'TheCrypt', fileName: 'TheCrypt-01'},
		{zoneName: 'TheCrypt', fileName: 'TheCrypt-02'},
		
		// BRANCH_I_ZONES:
		// ****************************************************************************************
		// THE_SEWERS:
		{zoneName: 'TheSewers', fileName: 'TheSewers-01'},
		
		// THE_ARCANE_TOWER:
		
		// BRANCH_II_ZONES:
		// ****************************************************************************************
		// THE_CORE:
		{zoneName: 'TheCore', fileName: 'TheCore-01'},
		
		// THE_ICE_CAVES:
		{zoneName: 'TheIceCaves', fileName: 'TheIceCaves-01', maxLevel: 3}
		
		
		
		// TIER_IV_ZONES:
		// ****************************************************************************************
		// THE_VAULT_OF_YENDOR:

	];
	
	// SET_DEFAULTS_AND_ERROR_CHECK:
	this.staticLevelTypes.forEach(function (type) {
		if (!game.cache.getJSON(type.fileName)) {
			throw 'Invalid static level file: ' + type.fileName;
		}
		
		// Default min and max level:
		type.minLevel = type.minLevel || 1;
		type.maxLevel = type.maxLevel || 4;
		
		if (!type.hasOwnProperty('pred')) {
			type.pred = function () {
				return true;
			};
		}
	}, this);
};

// GET_STATIC_LEVEL_LIST:
// Returns a list of valid static levels
// ************************************************************************************************
gs.getStaticLevelList = function () {
	var list = [];
	
	// Hacky fix:
	// For some reason some players lose this
	if (!this.previouslySpawnedStaticLevels) {
		this.previouslySpawnedStaticLevels = [];
	}
	
	this.staticLevelTypes.forEach(function (type) {
		if (type.zoneName === this.zoneName
				&& !this.inArray(type.fileName, this.previouslySpawnedStaticLevels)
				&& this.zoneLevel >= type.minLevel
				&& this.zoneLevel <= type.maxLevel
				&& type.pred()) {
			
			list.push(type);
		}
	}, this);
	
	return list;
};

// CREATE_ZONE_CONNECTIONS:
// ************************************************************************************************
gs.createZoneConnections = function () {
	// Branches:
	
	this.zoneConnections = [
		// TIER_I => TIER_II:
		{fromZoneName: 'TheUpperDungeon',	fromZoneLevel: 4, toZoneName: 'TheOrcFortress',		toZoneLevel: 1},
		{fromZoneName: 'TheUpperDungeon',	fromZoneLevel: 4, toZoneName: 'TheIronFortress',	toZoneLevel: 1},
		{fromZoneName: 'TheUpperDungeon',	fromZoneLevel: 4, toZoneName: 'TheSwamp',			toZoneLevel: 1},
		{fromZoneName: 'TheUpperDungeon',	fromZoneLevel: 4, toZoneName: 'TheSunlessDesert',	toZoneLevel: 1},
		{fromZoneName: 'TheUpperDungeon',	fromZoneLevel: 4, toZoneName: 'TheUnderGrove',		toZoneLevel: 1},
		
		// TIER_II => TIER_III:
		{fromZoneName: 'TheOrcFortress',	fromZoneLevel: 4, toZoneName: 'TheDarkTemple',		toZoneLevel: 1},
		{fromZoneName: 'TheOrcFortress',	fromZoneLevel: 4, toZoneName: 'TheCrypt',			toZoneLevel: 1},
		{fromZoneName: 'TheIronFortress',	fromZoneLevel: 4, toZoneName: 'TheDarkTemple',		toZoneLevel: 1},
		{fromZoneName: 'TheIronFortress',	fromZoneLevel: 4, toZoneName: 'TheCrypt',			toZoneLevel: 1},
		{fromZoneName: 'TheSwamp',			fromZoneLevel: 4, toZoneName: 'TheDarkTemple',		toZoneLevel: 1},
		{fromZoneName: 'TheSwamp',			fromZoneLevel: 4, toZoneName: 'TheCrypt',			toZoneLevel: 1},
		{fromZoneName: 'TheUnderGrove',		fromZoneLevel: 4, toZoneName: 'TheDarkTemple',		toZoneLevel: 1},
		{fromZoneName: 'TheUnderGrove',		fromZoneLevel: 4, toZoneName: 'TheCrypt',			toZoneLevel: 1},
		{fromZoneName: 'TheSunlessDesert',	fromZoneLevel: 4, toZoneName: 'TheDarkTemple',		toZoneLevel: 1},
		{fromZoneName: 'TheSunlessDesert',	fromZoneLevel: 4, toZoneName: 'TheCrypt',			toZoneLevel: 1},
		
		// TIER_III => BRANCH_I:
		{fromZoneName: 'TheDarkTemple',		fromZoneLevel: 1, toZoneName: 'TheArcaneTower',		toZoneLevel: 1},
		{fromZoneName: 'TheDarkTemple',		fromZoneLevel: 1, toZoneName: 'TheSewers',			toZoneLevel: 1},
		{fromZoneName: 'TheCrypt',			fromZoneLevel: 1, toZoneName: 'TheArcaneTower',		toZoneLevel: 1},
		{fromZoneName: 'TheCrypt',			fromZoneLevel: 1, toZoneName: 'TheSewers',			toZoneLevel: 1},
		
		// TIER_III => BRANCH_II:
		{fromZoneName: 'TheDarkTemple',		fromZoneLevel: 3, toZoneName: 'TheCore',			toZoneLevel: 1},
		{fromZoneName: 'TheDarkTemple',		fromZoneLevel: 3, toZoneName: 'TheIceCaves',		toZoneLevel: 1},
		{fromZoneName: 'TheCrypt',			fromZoneLevel: 3, toZoneName: 'TheCore',			toZoneLevel: 1},
		{fromZoneName: 'TheCrypt',			fromZoneLevel: 3, toZoneName: 'TheIceCaves',		toZoneLevel: 1},
		
		// TIER_III => TIER_IV:
		{fromZoneName: 'TheDarkTemple',		fromZoneLevel: 4, toZoneName: 'VaultOfYendor',		toZoneLevel: 1},
		{fromZoneName: 'TheCrypt',			fromZoneLevel: 4, toZoneName: 'VaultOfYendor',		toZoneLevel: 1}
	];
	
	// Verify:
	this.zoneConnections.forEach(function (branch) {
		if (!this.zoneTypes[branch.fromZoneName] || !this.zoneTypes[branch.toZoneName]) {
			throw 'Invalid branch: ' + branch.fromZoneName + ' - ' + branch.toZoneName;
		}
	}, this);
};

// CREATE_ZONE_SPECIAL_FEATURE_TABLES:
// ************************************************************************************************
gs.createZoneSpecialFeaturesTables = function () {
	this.zoneSpecialFeaturesTables = {};
	
	// EARLY_GAME (MDI and tier I branches):
	this.zoneSpecialFeaturesTables.EarlyGame = [
		{name: 'DropWallRoom',		percent: 20},
		{name: 'MonsterZoo',		percent: 25},
		{name: 'StorageRoom',		percent: 30},
		{name: 'Library',			percent: 21},
		{name: 'GoldRoom',			percent: 1},
		{name: 'PotionRoom',		percent: 1},
		{name: 'FoodRoom',			percent: 1},
		{name: 'ScrollRoom',		percent: 1}
	];
	
	// MID_GAME (MDII and Tier II branches):
	// Adds: treasure room and timed treasure room
	this.zoneSpecialFeaturesTables.MidGame = [
		{name: 'DropWallRoom',			percent: 30},
		{name: 'MonsterZoo',			percent: 20},
		{name: 'StorageRoom',			percent: 10},
		{name: 'Library',				percent: 20},
		{name: 'TreasureRoom',			percent: 10},
		
		{name: 'GoldRoom',				percent: 1},
		{name: 'PotionRoom',			percent: 1},
		{name: 'FoodRoom',				percent: 1},
		{name: 'ScrollRoom',			percent: 1},
		{name: 'TimedTreasureRoom',		percent: 5},
		{name: 'ChoiceTreasureRoom',	percent: 1}
		
	];
	
	// LATE_GAME (MDIII, MDIV, and tier III branches):
	this.zoneSpecialFeaturesTables.LateGame = [
		{name: 'DropWallRoom',			percent: 30},
		{name: 'MonsterZoo',			percent: 20},
		{name: 'StorageRoom',			percent: 10},
		{name: 'Library',				percent: 20},
		{name: 'TreasureRoom',			percent: 10},
		
		{name: 'GoldRoom',				percent: 1},
		{name: 'PotionRoom',			percent: 1},
		{name: 'FoodRoom',				percent: 1},
		{name: 'ScrollRoom',			percent: 1},
		{name: 'TimedTreasureRoom',		percent: 5},
		{name: 'ChoiceTreasureRoom',	percent: 1}
	];
};

// CREATE_ZONE_DRESSING_TABLES:
// Zone dressing tables are used to select which dressing functions can potentially be applied to areas in the zone.
// See level-dressing.js for implementation of dressing functions.
// ************************************************************************************************
gs.createZoneDressingTables = function () {
	this.zoneDressingTables = {};
	
	
	// THE_UPPER_DUNGEON_DRESSING_TABLE:
	this.zoneDressingTables.TheUpperDungeon = {
		// CAVE_AREA_TYPE:
		Cave: [
			{name: 'WaterCave', percent: 50},
			{name: 'GrassCave', percent: 50}
		],
		
		// LARGE_ROOM_AREA_TYPE:
		LargeRoom: [
			{name: 'PoolRoom', percent: 25},
			{name: 'PillarRoom', percent: 25},
			{name: 'DiningRoom', percent: 5},
			{name: 'PracticeRoom', percent: 5},
			{name: 'NONE', percent: 40}
		],
		
		// SIDE_ROOM_AREA_TYPE:
		SideRoom: [
			{name: 'DropWallRoom', percent: 10},
			{name: 'MonsterZoo', percent: 10},
			//{name: 'Library', percent: 10},
			{name: 'BoneRoom', percent: 10},
			{name: 'GoldRoom', percent: 1},
			{name: 'NONE', percent: 49}
		]
	};
	
	
	// THE_ORC_FORTRESS_DRESSING_TABLE:
	this.zoneDressingTables.TheOrcFortress = {
		// CAVE_AREA_TYPE:
		Cave: [
			{name: 'WaterCave', percent: 50},
			{name: 'GrassCave', percent: 50}
		],
		
		// LARGE_ROOM_AREA_TYPE:
		LargeRoom: [
			{name: 'PoolRoom', percent: 25},
			{name: 'PillarRoom', percent: 25},
			{name: 'DiningRoom', percent: 5},
			{name: 'BedRoom', percent: 5},
			{name: 'PracticeRoom', percent: 5},
			{name: 'NONE', percent: 35}
		]
	};
	
	// THE_UNDER_GROVE_DRESSING_TABLE:
	this.zoneDressingTables.TheUnderGrove = {
		// CAVE_AREA_TYPE:
		Cave: [
			{name: 'GroveWaterCave', percent: 50},
			{name: 'GroveCave', percent: 50}
		],
		
		
		// SIDE_ROOM_AREA_TYPE:
		SideRoom: [
			{name: 'TreasureRoom', percent: 10},
			{name: 'DropWallRoom', percent: 10},
			{name: 'MonsterZoo', percent: 10},
			//{name: 'Library', percent: 10},
			{name: 'BoneRoom', percent: 10},
			{name: 'GoldRoom', percent: 1},
			{name: 'NONE', percent: 39}
		]
	};
	
	// THE_SUNLESS_DESERT:
	this.zoneDressingTables.TheSunlessDesert = {
		// CAVE_AREA_TYPE:
		Cave: [
			{name: 'DesertCave', percent: 100}
		]
	};
	
	// THE_IRON_FORTRESS:
	this.zoneDressingTables.TheIronFortress = {
		// CAVE_AREA_TYPE:
		Cave: [
			{name: 'WaterCave', percent: 50},
			{name: 'GrassCave', percent: 50}
		],
		
		// LARGE_ROOM_AREA_TYPE:
		LargeRoom: [
			{name: 'PoolRoom', percent: 25},
			{name: 'PillarRoom', percent: 25},
			{name: 'DiningRoom', percent: 5},
			{name: 'PracticeRoom', percent: 5},
			{name: 'NONE', percent: 40}
		]
	};
	
	// THE_ARCANE_TOWER:
	this.zoneDressingTables.TheArcaneTower = {
		// CAVE_AREA_TYPE:
		Cave: [
			{name: 'WaterCave', percent: 50},
			{name: 'GrassCave', percent: 50}
		],
		
		// LARGE_ROOM_AREA_TYPE:
		LargeRoom: [
			{name: 'PoolRoom', percent: 25},
			{name: 'PillarRoom', percent: 25},
			{name: 'DiningRoom', percent: 10},
			{name: 'NONE', percent: 40}
		]
	};
	
	// THE_CRYPT_DRESSING_TABLE:
	this.zoneDressingTables.TheCrypt = {
		// CAVE_AREA_TYPE:
		Cave: [
			{name: 'WaterCave', percent: 50},
			{name: 'GrassCave', percent: 50}
		],
		
		// CRYPT_AREA_TYPE:
		Crypt: [
			{name: 'Tomb', percent: 100}
		],
		
		// LARGE_ROOM_AREA_TYPE:
		LargeRoom: [
			{name: 'Tomb', percent: 50},
			{name: 'PoolRoom', percent: 25},
			{name: 'NONE', percent: 25}
		]
	};
	
	// THE_CORE_DRESSING_TABLE:
	this.zoneDressingTables.TheCore = {
		// CAVE_AREA_TYPE:
		Cave: [
			{name: 'LavaCave', percent: 100}
			//{name: 'NONE', percent: 50},
		],
		
		// LARGE_ROOM_AREA_TYPE:
		LargeRoom: [
			{name: 'PoolRoom', percent: 25},
			{name: 'PillarRoom', percent: 25},
			{name: 'DiningRoom', percent: 5},
			{name: 'PracticeRoom', percent: 5},
			{name: 'NONE', percent: 40}
		]
	};
	
	// THE_ICE_CAVES_DRESSING_TABLE:
	this.zoneDressingTables.TheIceCaves = {

	};
	
	// THE_SEWERS_DRESSING_TABLE:
	this.zoneDressingTables.TheSewers = {
	};
};

gs.isBaseTileFrame = function (frame) {
	for (let i = 0; i < this.tilesetList.length; i += 1) {
		if (frame === this.tilesetList[i].base) {
			return true;
		}
	}
	
	return false;
};

// ZONE_TILE_FRAMES:
// zoneTileFrames are used so that each zone can have different frames for each tile.
// For example we may want slimy walls in the sewer and normal walls in the main dungeon.
// base: the basic frame used most of the time for the tile.
// alternate: a list of alternative tiles to use some small percentage of the time.
// ********************************************************************************************
gs.createZoneTileFrames = function () {
	this.tilesets = {};
	this.zoneTileFrames = {};
	
	// Duneon Floor Tilesets:
	this.tilesets.TheUpperDungeonFloor = 	{base: 0, alternate: [13, 14, 15, 16, 17]};
	this.tilesets.TheOrcFortressFloor =	{base: 128, alternate: [141, 142, 143, 144, 145]};
	this.tilesets.TheDarkTempleFloor =	{base: 160, alternate: [173, 174, 175, 176]};
	this.tilesets.IronFortressFloor =	{base: 32, alternate: [45, 46, 47, 48, 49, 50, 51, 52]};
	this.tilesets.ArcaneTowerFloor =	{base: 96};
	this.tilesets.TheCoreFloor =		{base: 64, alternate: [77, 78, 79, 80]};
	this.tilesets.IceCavesFloor =		{base: 64, alternate: [77, 78, 79, 80]};
	this.tilesets.SewersFloor =			{base: 0, alternate: [13, 14, 15, 16, 17]};
	this.tilesets.YendorFloor =			{base: 192, alternate: [205, 206, 207, 208]};
	
	// Dungeon Walls:
	this.tilesets.TheUpperDungeonWall = 	{base: 512, alternate: [530, 531]};
	this.tilesets.TheOrcFortressWall =	{base: 672, alternate: [690, 691]};
	this.tilesets.TheDarkTempleWall =	{base: 704, alternate: [722, 723, 724, 725]};
	this.tilesets.IronFortressWall =	{base: 608, alternate: [626, 627]};
	this.tilesets.ArcaneTowerWall =		{base: 640, alternate: [658, 659]};
	this.tilesets.TheCoreWall =			{base: 544, alternate: [562]};
	this.tilesets.IceCavesWall =		{base: 544, alternate: [562]};
	this.tilesets.SewersWall =			{base: 576, alternate: [594, 595, 596]};
	this.tilesets.YendorWall =			{base: 736, };//alternate: [754, 755, 756, 757]};
	
	// Cave Floor Tilesets:
	this.tilesets.TheUpperDungeonCaveFloor = 	{base: 256};
	this.tilesets.UnderGroveCaveFloor =		{base: 360};
	this.tilesets.SunlessDesertCaveFloor =	{base: 320};
	this.tilesets.SwampCaveFloor =			{base: 272, alternate: [273, 274]};
	this.tilesets.TheCoreCaveFloor =		{base: 352};
	this.tilesets.IceCavesCaveFloor =		{base: 288};
	this.tilesets.SewersCaveFloor =			{base: 256};
	this.tilesets.YendorCaveFloor =			{base: 258, alternate: [259, 260]};
		
	// Cave Walls:
	this.tilesets.TheUpperDungeonCaveWall = 	{base: 768};
	this.tilesets.UnderGroveCaveWall =		{base: 768};
	this.tilesets.SunlessDesertCaveWall =	{base: 928};
	this.tilesets.SwampCaveWall =			{base: 896};
	this.tilesets.TheCoreCaveWall =			{base: 800};
	this.tilesets.IceCavesCaveWall =		{base: 832};
	this.tilesets.SewersCaveWall =			{base: 768};
	
	// Dungeon Pit:
	this.tilesets.IceCavesPit =				{base: 1056};
	
	// Cave Pits:
	this.tilesets.TheCoreCavePit =			{base: 1072};
	this.tilesets.IceCavesCavePit =			{base: 1056};
	
	this.tilesetList = [];
	this.forEachType(this.tilesets, function (type) {
		this.tilesetList.push(type);
	}, this);
	
	
	// ZONE_TILESETS:
	// ********************************************************************************************
	// MAIN_DUNGEON:
	this.zoneTileFrames.MainDungeon = {
		Floor: 		this.tilesets.TheUpperDungeonFloor,
		Wall: 		this.tilesets.TheUpperDungeonWall,
		CaveFloor:	this.tilesets.TheUpperDungeonCaveFloor,
		CaveWall: 	this.tilesets.TheUpperDungeonCaveWall,
		Door: 		{base: 1584},
	};
	
	// VAULT_OF_YENDOR:
	this.zoneTileFrames.VaultOfYendor = {
		Floor: 		this.tilesets.YendorFloor,
		Wall: 		this.tilesets.YendorWall,
		CaveFloor: 	this.tilesets.YendorCaveFloor,
		CaveWall: 	this.tilesets.SwampCaveWall,
		Pillar:		{base: 1614},
		Door: 		{base: 1584},
	};
	
	// THE_ORC_FORTRESS:
	this.zoneTileFrames.TheOrcFortress = {
		Floor: 		this.tilesets.TheOrcFortressFloor,
		Wall: 		this.tilesets.TheOrcFortressWall,
		CaveFloor: 	this.tilesets.TheUpperDungeonCaveFloor,
		CaveWall: 	this.tilesets.TheUpperDungeonCaveWall,
		Pillar:		{base: 1610},
		Door: 		{base: 1584},
	};
	
	// THE_DARK_TEMPLE:
	this.zoneTileFrames.TheDarkTemple = {
		Floor: 		this.tilesets.TheDarkTempleFloor,
		Wall: 		this.tilesets.TheDarkTempleWall,
		CaveFloor: 	this.tilesets.TheUpperDungeonCaveFloor,
		CaveWall: 	this.tilesets.TheUpperDungeonCaveWall,
		Pillar:		{base: 1610},
		Door: 		{base: 1584},
	};
	
	// THE_IRON_FORTRESS:
	this.zoneTileFrames.TheIronFortress = {
		Floor: 		this.tilesets.IronFortressFloor,
		Wall: 		this.tilesets.IronFortressWall,
		CaveFloor: 	this.tilesets.TheUpperDungeonCaveFloor,
		CaveWall: 	this.tilesets.TheUpperDungeonCaveWall,
		Door: 		{base: 1584},
		Pillar: 	{base: 1609},
	};
	
	// THE_ARCANCE_TOWER:
	this.zoneTileFrames.TheArcaneTower = {
		Floor: 		this.tilesets.ArcaneTowerFloor,
		Wall: 		this.tilesets.ArcaneTowerWall,
		CaveFloor: 	this.tilesets.TheUpperDungeonCaveFloor,
		CaveWall: 	this.tilesets.TheUpperDungeonCaveWall,
		Door: 		{base: 1584},
		Pillar:		{base: 1613},
	};
	
	// THE_UNDER_GROVE:
	this.zoneTileFrames.TheUnderGrove = {
		Floor: 		this.tilesets.TheUpperDungeonFloor,
		Wall: 		this.tilesets.TheUpperDungeonWall,
		CaveFloor: 	this.tilesets.UnderGroveCaveFloor,
		CaveWall: 	this.tilesets.UnderGroveCaveWall,
		Door: 		{base: 1584},
	};
	
	// THE_SUNLESS_DESERT:
	this.zoneTileFrames.TheSunlessDesert = {
		Floor: 		this.tilesets.TheUpperDungeonFloor,
		Wall: 		this.tilesets.TheUpperDungeonWall,
		CaveFloor: 	this.tilesets.SunlessDesertCaveFloor,
		CaveWall: 	this.tilesets.SunlessDesertCaveWall,
		Door: 		{base: 1584},
	};
	
	// THE_SWAMP:
	this.zoneTileFrames.TheSwamp = {
		Floor: 		this.tilesets.TheUpperDungeonFloor,
		Wall: 		this.tilesets.TheUpperDungeonWall,
		CaveFloor: 	this.tilesets.SwampCaveFloor,
		CaveWall: 	this.tilesets.SwampCaveWall,
		Water:		{base: 1296},
		Door: 		{base: 1584},
	};
	
	// THE_CRYPT:
	this.zoneTileFrames.TheCrypt = {
		// Tiles:
		Floor: 		{base: 64, alternate: [77, 78, 79, 80]},
		CaveFloor: 	{base: 256},
		Wall: 		{base: 544, alternate: [562, 563, 564, 565]},
		CaveWall: 	{base: 768},
		
		// Objects:
		Door: 		{base: 1584},
		Pillar:		{base: 1611}
	};
	
	// THE_SEWERS:
	this.zoneTileFrames.TheSewers = {
		Floor: 		this.tilesets.SewersFloor,
		Wall: 		this.tilesets.SewersWall,
		CaveWall: 	this.tilesets.SewersCaveWall,
		CaveFloor: 	this.tilesets.SewersFloor,
		Door: 		{base: 1584},
	};
	
	// THE_ICE_CAVES:
	this.zoneTileFrames.TheIceCaves = {
		Floor: 		this.tilesets.IceCavesFloor,
		Wall: 		this.tilesets.IceCavesWall,
		Pit:		this.tilesets.IceCavesPit,
		CaveWall: 	this.tilesets.IceCavesCaveWall,
		CaveFloor: 	this.tilesets.IceCavesCaveFloor,
		CavePit:	this.tilesets.IceCavesCavePit,
		Door: 		{base: 1584},
		Stalagmite:	{base: 1601},
	};
	
	// THE_CORE:
	this.zoneTileFrames.TheCore = {
		Floor: 		this.tilesets.TheCoreFloor,
		Wall: 		this.tilesets.TheCoreWall,
		CaveFloor: 	this.tilesets.TheCoreCaveFloor,
		CaveWall: 	this.tilesets.TheCoreCaveWall,
		CavePit:	this.tilesets.TheCoreCavePit,
		Door: 		{base: 1584},
		Stalagmite:	{base: 1602},
	};
};
	
/*global gs, game, util, console*/
/*global NPC_COMMON_PERCENT, NPC_UNCOMMON_PERCENT, NPC_RARE_PERCENT*/
/*global NPC_ELITE_CHANCE, MIN_ELITE_LEVEL, SLEEPING_PERCENT, MOB_WANDER_PERCENT*/
/*global FACTION, NUM_NPCS, TIER_II_ZONES, TIER_III_ZONES, BRANCH_I_ZONES, BRANCH_II_ZONES*/
/*jshint esversion: 6*/
'use strict';

// CREATE_SPAWN_TABLES:
// ************************************************************************************************
gs.createSpawnTables = function () {
	this.spawnTables = {};
	this.uniqueSpawnTable = {};
	
	// MAIN_DUNGEON (TIER I):
	// ********************************************************************************************
	this.spawnTables.TheUpperDungeon = [
		// MAIN_DUNGEON_LEVEL_1:
		[{name: 'RatPack',				freq: 'COMMON'},
		 {name: 'RatNest',				freq: 'UNCOMMON'},
		 {name: 'Bat',					freq: 'COMMON'},
		 {name: 'BatPack',				freq: 'UNCOMMON'},
		 {name: 'GoblinArcher',			freq: 'UNCOMMON'},
		],
		
		// MAIN_DUNGEON_LEVEL_2:
		[{name: 'RatPack',				freq: 'COMMON'},
		 {name: 'RatNest',				freq: 'UNCOMMON'},
		 {name: 'Bat',					freq: 'COMMON'},
		 {name: 'BatPack',				freq: 'UNCOMMON'},
		 
		 {name: 'GoblinWarrior',		freq: 'COMMON'},
		 {name: 'GoblinArcher',			freq: 'UNCOMMON'},
		 {name: 'GoblinBrute',			freq: 'UNCOMMON'},
		 {name: 'GoblinFireMage',		freq: 'RARE'},
		 {name: 'GoblinStormMage',		freq: 'RARE'},
		],
		
		// MAIN_DUNGEON_LEVEL_3:
		[{name: 'RatPack',				freq: 'COMMON'},
		 {name: 'RatNest',				freq: 'UNCOMMON'},
		 {name: 'Bat',					freq: 'COMMON'},
		 {name: 'BatPack',				freq: 'COMMON'},
		 
		 {name: 'GoblinWarrior',		freq: 'COMMON'},
		 {name: 'GoblinArcher',			freq: 'COMMON'},
		 {name: 'GoblinBrute',			freq: 'COMMON'},
		 {name: 'GoblinFireMage',		freq: 'UNCOMMON'},
		 {name: 'GoblinStormMage',		freq: 'UNCOMMON'},
		 {name: 'GoblinShamanGroup',	freq: 'RARE'},
		 {name: 'Centipede',			freq: 'RARE'},
		],
		
		// MAIN_DUNGEON_LEVEL_4:
		[{name: 'RatPack',				freq: 'COMMON'},
		 {name: 'RatNest',				freq: 'UNCOMMON'},
		 {name: 'BatPack',				freq: 'COMMON'},
		 
		 {name: 'GoblinWarrior',		freq: 'COMMON'},
		 {name: 'GoblinArcher',			freq: 'COMMON'},
		 {name: 'GoblinBrute',			freq: 'COMMON'},
		 {name: 'GoblinFireMage',		freq: 'UNCOMMON'},
		 {name: 'GoblinStormMage',		freq: 'UNCOMMON'},
		 {name: 'GoblinShamanGroup',	freq: 'UNCOMMON'},
		 {name: 'Centipede',			freq: 'RARE'},
		],
	];
	
	this.uniqueSpawnTable.TheUpperDungeon = [
		{name: 'TheRatPiper',			minLevel: 3, maxLevel: 4, percent: 0.1},
		{name: 'TheVampireBat',			minLevel: 3, maxLevel: 4, percent: 0.1},
	];
	
	// THE_ORC_FORTRESS:
	// ********************************************************************************************
	this.spawnTables.TheOrcFortress = [
		// THE_ORC_FORTRESS_LEVEL_1:
		[{name: 'BatPack',				freq: 'RARE'},
		 {name: 'GoblinHoard',			freq: 'COMMON'},
		 
		 {name: 'WolfPack',				freq: 'COMMON'},
		 {name: 'OrcWarrior',			freq: 'COMMON'},
		 {name: 'OrcArcher',			freq: 'UNCOMMON'},
		 {name: 'WolfKennel',			freq: 'UNCOMMON'},
		 {name: 'Ogre',					freq: 'UNCOMMON'},
		 {name: 'OrcFireMage',			freq: 'RARE'},
		 {name: 'OrcStormMage',			freq: 'RARE'},
		],
		
		// THE_ORC_FORTRESS_LEVEL_2:
		[{name: 'GoblinHoard',			freq: 'UNCOMMON'},
		 
		 {name: 'WolfPack',				freq: 'COMMON'},
		 {name: 'OrcWarrior',			freq: 'COMMON'},
		 {name: 'OrcArcher',			freq: 'UNCOMMON'},
		 {name: 'WolfKennel',			freq: 'UNCOMMON'},
		 {name: 'Ogre',					freq: 'COMMON'},
		 {name: 'OrcFireMage',			freq: 'UNCOMMON'},
		 {name: 'OrcStormMage',			freq: 'UNCOMMON'},
		 {name: 'OrcPriestGroup',		freq: 'RARE'},
		],
		
		// THE_ORC_FORTRESS_LEVEL_3:
		[{name: 'GoblinHoard',			freq: 'RARE'},
		 
		 {name: 'WolfPack',				freq: 'COMMON'},
		 {name: 'OrcWarrior',			freq: 'COMMON'},
		 {name: 'OrcArcher',			freq: 'UNCOMMON'},
		 {name: 'WolfKennel',			freq: 'UNCOMMON'},
		 {name: 'Ogre',					freq: 'COMMON'},
		 {name: 'OrcFireMage',			freq: 'UNCOMMON'},
		 {name: 'OrcStormMage',			freq: 'UNCOMMON'},
		 {name: 'OrcPriestGroup',		freq: 'UNCOMMON'},
		 {name: 'OrcSummoner',			freq: 'RARE'},
		 
		 {name: 'ElectricEel',			freq: 'RARE'},
		],
		
		// THE_ORC_FORTRESS_LEVEL_4:
		[{name: 'WolfPack',				freq: 'COMMON'},	
		 {name: 'OrcWarrior',			freq: 'COMMON'},
		 {name: 'OrcArcher',			freq: 'COMMON'},
		 {name: 'WolfKennel',			freq: 'UNCOMMON'},
		 {name: 'Ogre',					freq: 'COMMON'},
		 {name: 'OrcFireMage',			freq: 'UNCOMMON'},
		 {name: 'OrcStormMage',			freq: 'UNCOMMON'},
		 {name: 'OrcPriestGroup',		freq: 'UNCOMMON'},
		 {name: 'OrcSummoner',			freq: 'UNCOMMON'},
		 
		 {name: 'OrcPack',				freq: 'RARE'},
		],
	];
	
	this.uniqueSpawnTable.TheOrcFortress = [
		{name: 'OrcKingPack', minLevel: 2, maxLevel: 4, percent: 0.1},
	];
	
	// THE_IRON_FORTRESS:
	// ********************************************************************************************
	this.spawnTables.TheIronFortress = [
		// THE_IRON_FORTRESS_LEVEL_1:
		[{name: 'BatPack',				freq: 'RARE'},
		 {name: 'GoblinHoard',			freq: 'COMMON'},
		 
		 {name: 'ClockworkRatPack',		freq: 'COMMON'},
		 {name: 'ClockworkWarrior',		freq: 'COMMON'},
		 {name: 'ClockworkArcher',		freq: 'COMMON'},
		 {name: 'ClockworkFactory',		freq: 'RARE'},
		 {name: 'GoblinBomber',			freq: 'UNCOMMON'},
		],
		
		// THE_IRON_FORTRESS_LEVEL_2:
		[{name: 'GoblinHoard',			freq: 'UNCOMMON'},
		 
		 {name: 'ClockworkRatPack',		freq: 'COMMON'},
		 {name: 'ClockworkWarrior',		freq: 'COMMON'},
		 {name: 'ClockworkArcher',		freq: 'COMMON'},
		 {name: 'ClockworkFactory',		freq: 'RARE'},
		 {name: 'GoblinBomber',			freq: 'UNCOMMON'},
		 {name: 'ClockworkPyro',		freq: 'UNCOMMON'},
		 {name: 'Ballista',				freq: 'UNCOMMON'},
		 
		 {name: 'CorrosiveSlime',		freq: 'RARE'},
		],
		
		// THE_IRON_FORTRESS_LEVEL_3:
		[{name: 'GoblinHoard',			freq: 'RARE'},
		 
		 {name: 'ClockworkRatPack',		freq: 'COMMON'},
		 {name: 'ClockworkWarrior',		freq: 'COMMON'},
		 {name: 'ClockworkArcher',		freq: 'COMMON'},
		 {name: 'ClockworkFactory',		freq: 'RARE'},
		 {name: 'GoblinBomber',			freq: 'UNCOMMON'},
		 {name: 'ClockworkPyro',		freq: 'UNCOMMON'},
		 {name: 'Ballista',				freq: 'UNCOMMON'},
		 {name: 'ClockworkRhino',		freq: 'UNCOMMON'},
		 {name: 'BombomberPack',		freq: 'RARE'},
		 
		 {name: 'CorrosiveSlime',		freq: 'RARE'},
		],
		
		// THE_IRON_FORTRESS_LEVEL_4:
		[{name: 'ClockworkRatPack',		freq: 'COMMON'},
		 {name: 'ClockworkWarrior',		freq: 'COMMON'},
		 {name: 'ClockworkArcher',		freq: 'COMMON'},
		 {name: 'ClockworkFactory',		freq: 'RARE'},
		 {name: 'GoblinBomber',			freq: 'UNCOMMON'},
		 {name: 'ClockworkPyro',		freq: 'UNCOMMON'},
		 {name: 'Ballista',				freq: 'UNCOMMON'},
		 {name: 'ClockworkRhino',		freq: 'UNCOMMON'},
		 {name: 'BombomberPack',		freq: 'RARE'},
		 
		 {name: 'CorrosiveSlime',		freq: 'RARE'},
		],
	];
	
	
	// THE_SUNLESS_DESERT:
	// ********************************************************************************************
	this.spawnTables.TheSunlessDesert = [	
		// THE_SUNLESS_DESERT_LEVEL_1:
		[{name: 'RatNest',				freq: 'UNCOMMON'},
		 {name: 'BatPack',				freq: 'UNCOMMON'},
		 {name: 'GoblinHoard',			freq: 'COMMON'},
		 
		 {name: 'ScarabSwarm',			freq: 'COMMON'},
		 {name: 'SpittingViper',		freq: 'COMMON'},
		 {name: 'TrapDoorSpider',		freq: 'UNCOMMON'},
		],
		
		// THE_SUNLESS_DESERT_LEVEL_2:
		[{name: 'RatNest',				freq: 'UNCOMMON'},
		 {name: 'BatPack',				freq: 'UNCOMMON'},
		 {name: 'GoblinHoard',			freq: 'UNCOMMON'},
		 
		 {name: 'ScarabSwarm',			freq: 'COMMON'},
		 {name: 'SpittingViper',		freq: 'COMMON'},
		 {name: 'TrapDoorSpider',		freq: 'UNCOMMON'},
		 {name: 'Scorpion',				freq: 'UNCOMMON'},
		 {name: 'SunFlower',			freq: 'UNCOMMON'},
		],
		
		// THE_SUNLESS_DESERT_LEVEL_3:
		[{name: 'GoblinHoard',				freq: 'RARE'},
		 
		 {name: 'ScarabSwarm',				freq: 'COMMON'},
		 {name: 'SpittingViper',			freq: 'COMMON'},
		 {name: 'TrapDoorSpider',			freq: 'UNCOMMON'},
		 {name: 'Scorpion',					freq: 'COMMON'},
		 {name: 'SunFlower',				freq: 'UNCOMMON'},
		 {name: 'Mummy',					freq: 'COMMON'},
		 {name: 'GoatHerd',					freq: 'UNCOMMON'},
		 {name: 'MummyPriestGroup',			freq: 'UNCOMMON'},
		],
		
		// THE_SUNLESS_DESERT_LEVEL_4:
		[{name: 'ScarabSwarm',				freq: 'COMMON'},
		 {name: 'SpittingViper',			freq: 'COMMON'},
		 {name: 'TrapDoorSpider',			freq: 'UNCOMMON'},
		 {name: 'Scorpion',					freq: 'COMMON'},
		 {name: 'SunFlower',				freq: 'UNCOMMON'},
		 {name: 'Mummy',					freq: 'COMMON'},
		 {name: 'GoatHerd',					freq: 'UNCOMMON'},
		 {name: 'MummyPriestGroup',			freq: 'COMMON'},
		],
	];
	
	this.uniqueSpawnTable.TheSunlessDesert = [
		{name: 'CylomarTheAncientPyromancer', minLevel: 2, maxLevel: 4, percent: 0.1},
	];
	
	// THE_UNDER_GROVE:
	// ********************************************************************************************
	this.spawnTables.TheUnderGrove = [	
		// THE_UNDER_GROVE_LEVEL_1:
		[{name: 'RatNest',				freq: 'UNCOMMON'},
		 {name: 'BatPack',				freq: 'UNCOMMON'},
		 {name: 'GoblinHoard',			freq: 'COMMON'},
		 
		 {name: 'Jaguar',				freq: 'COMMON'},
		 {name: 'Spider',				freq: 'COMMON'},
		 {name: 'SpiderNest',			freq: 'UNCOMMON'},
		 {name: 'PoisonSpider',			freq: 'COMMON'},
		],
		
		// THE_UNDER_GROVE_LEVEL_2:
		[{name: 'RatPack',				freq: 'UNCOMMON'},
		 {name: 'RatNest',				freq: 'UNCOMMON'},
		 {name: 'BatPack',				freq: 'UNCOMMON'},
		 {name: 'GoblinHoard',			freq: 'UNCOMMON'},
		 
		 {name: 'Jaguar',				freq: 'COMMON'},
		 {name: 'Spider',				freq: 'COMMON'},
		 {name: 'SpiderNest',			freq: 'UNCOMMON'},
		 {name: 'PoisonSpider',			freq: 'COMMON'},
		 {name: 'CentaurArcher',		freq: 'UNCOMMON'},
		 {name: 'CentaurWarrior',		freq: 'COMMON'},
		 {name: 'GiantBeePack',			freq: 'UNCOMMON'},
		 
		 {name: 'ElectricEel',			freq: 'RARE'},
		 
		],
		
		// THE_UNDER_GROVE_LEVEL_3:
		[{name: 'GoblinHoard',			freq: 'RARE'},
		 
		 {name: 'Jaguar',				freq: 'COMMON'},
		 {name: 'Spider',				freq: 'COMMON'},
		 {name: 'SpiderNest',			freq: 'UNCOMMON'},
		 {name: 'PoisonSpider',			freq: 'COMMON'},
		 {name: 'CentaurArcher',		freq: 'UNCOMMON'},
		 {name: 'CentaurWarrior',		freq: 'COMMON'},
		 {name: 'ElephantPack',			freq: 'RARE'},
		 {name: 'GiantBeePack',			freq: 'UNCOMMON'},
		 
		 {name: 'ElectricEel',			freq: 'RARE'},
		],
		
		// THE_UNDER_GROVE_LEVEL_4:
		[{name: 'Jaguar',				freq: 'COMMON'},
		 {name: 'Spider',				freq: 'COMMON'},
		 {name: 'SpiderNest',			freq: 'UNCOMMON'},
		 {name: 'PoisonSpider',			freq: 'COMMON'},
		 {name: 'CentaurArcher',		freq: 'UNCOMMON'},
		 {name: 'CentaurWarrior',		freq: 'COMMON'},
		 {name: 'ElephantPack',			freq: 'UNCOMMON'},
		 {name: 'GiantBeePack',			freq: 'UNCOMMON'},
		 
		 {name: 'ElectricEel',			freq: 'RARE'},
		],
	];
	
	this.uniqueSpawnTable.TheUnderGrove = [
		{name: 'TheQueenSpider',		minLevel: 3, maxLevel: 6, percent: 0.1},
	];
	
	// THE_SWAMP:
	// ********************************************************************************************
	this.spawnTables.TheSwamp = [	
		// THE_SWAMP_LEVEL_1:
		[{name: 'RatNest',				freq: 'UNCOMMON'},
		 {name: 'BatPack',				freq: 'UNCOMMON'},
		 {name: 'GoblinHoard',			freq: 'COMMON'},
		 
		 {name: 'PirahnaPack',			freq: 'UNCOMMON'},
		 {name: 'FrogPack',				freq: 'COMMON'},
		 {name: 'PoisonViper',			freq: 'UNCOMMON'},
		 {name: 'SpinyFrog',			freq: 'UNCOMMON'},
		],
		
		// THE_SWAMP_LEVEL_2:
		[{name: 'RatNest',				freq: 'UNCOMMON'},
		 {name: 'BatPack',				freq: 'UNCOMMON'},
		 {name: 'GoblinHoard',			freq: 'UNCOMMON'},
		 
		 {name: 'PirahnaPack',			freq: 'UNCOMMON'},
		 {name: 'FrogPack',				freq: 'COMMON'},
		 {name: 'PoisonViper',			freq: 'UNCOMMON'},
		 {name: 'SpinyFrog',			freq: 'COMMON'},
		 
		 {name: 'ElectricEel',			freq: 'RARE'},
		],
		
		// THE_SWAMP_LEVEL_3:
		[{name: 'GoblinHoard',			freq: 'RARE'},
		 
		 {name: 'PirahnaPack',			freq: 'UNCOMMON'},
		 {name: 'FrogPack',				freq: 'COMMON'},
		 {name: 'PoisonViper',			freq: 'COMMON'},
		 {name: 'SpinyFrog',			freq: 'COMMON'},
		 {name: 'Mosquito',				freq: 'UNCOMMON'},
		 {name: 'BullFrog',				freq: 'UNCOMMON'},
		 {name: 'SnappingTurtle',		freq: 'UNCOMMON'},
		 
		 {name: 'ElectricEel',			freq: 'UNCOMMON'},
		],
		
		// THE_SWAMP_LEVEL_4:
		[{name: 'PirahnaPack',			freq: 'UNCOMMON'},
		 {name: 'FrogPack',				freq: 'COMMON'},
		 {name: 'PoisonViper',			freq: 'COMMON'},
		 {name: 'SpinyFrog',			freq: 'COMMON'},
		 {name: 'Mosquito',				freq: 'UNCOMMON'},
		 {name: 'BullFrog',				freq: 'COMMON'},
		 {name: 'SnappingTurtle',		freq: 'COMMON'},
		 
		 {name: 'ElectricEel',			freq: 'COMMON'},
		],
	];
	
	this.uniqueSpawnTable.TheSwamp = [
		{name: 'KasicTheMosquitoPrince',			minLevel: 2, maxLevel: 4, percent: 0.1},
	];
	
	// THE_DARK_TEMPLE:
	// ********************************************************************************************
	this.spawnTables.TheDarkTemple = [
		// THE_DARK_TEMPLE (LEVEL 1):
		[{name: 'OrcPack',				freq: 'COMMON'},
		 
		 {name: 'DarkElfWarden',		freq: 'COMMON'},
		 {name: 'DarkElfSentinel',		freq: 'COMMON'},
		 {name: 'DarkElfPyromancer',	freq: 'UNCOMMON'},
		 {name: 'DarkElfStormologist',	freq: 'UNCOMMON'},
		 {name: 'DarkElfPriestGroup',	freq: 'UNCOMMON'},
		 
		 {name: 'CorrosiveSlime',		freq: 'RARE'},
		 {name: 'TentacleSpitter',		freq: 'RARE'},
		 {name: 'ManaViper',			freq: 'RARE'},
		 {name: 'StoneGolem',			freq: 'RARE'},
		 {name: 'NecromancerPack',		freq: 'RARE'},
		],
		
		// THE_DARK_TEMPLE (LEVEL 2):
		[{name: 'OrcPack',				freq: 'UNCOMMON'},
		 
		 {name: 'DarkElfWarden',		freq: 'COMMON'},
		 {name: 'DarkElfSentinel',		freq: 'COMMON'},
		 {name: 'DarkElfPyromancer',	freq: 'UNCOMMON'},
		 {name: 'DarkElfStormologist',	freq: 'UNCOMMON'},
		 {name: 'DarkElfPriestGroup',	freq: 'UNCOMMON'},
		 {name: 'DarkElfSummoner',		freq: 'UNCOMMON'},
		 
		 {name: 'CorrosiveSlime',		freq: 'RARE'},
		 {name: 'TentacleSpitter',		freq: 'RARE'},
		 {name: 'ManaViper',			freq: 'RARE'},
		 {name: 'StoneGolem',			freq: 'RARE'},
		 {name: 'NecromancerPack',		freq: 'RARE'},
		],

		// THE_DARK_TEMPLE (LEVEL 3):
		[{name: 'OrcPack',				freq: 'RARE'},
	
		 {name: 'DarkElfWarden',		freq: 'COMMON'},
		 {name: 'DarkElfSentinel',		freq: 'COMMON'},
		 {name: 'DarkElfPyromancer',	freq: 'UNCOMMON'},
		 {name: 'DarkElfStormologist',	freq: 'UNCOMMON'},
		 {name: 'DarkElfPriestGroup',	freq: 'UNCOMMON'},
		 {name: 'DarkElfSummoner',		freq: 'UNCOMMON'},
		 {name: 'EvilEye',				freq: 'RARE'},
		 
		 {name: 'CorrosiveSlime',		freq: 'RARE'},
		 {name: 'TentacleSpitter',		freq: 'RARE'},
		 {name: 'ManaViper',			freq: 'RARE'},
		 {name: 'StoneGolem',			freq: 'RARE'},
		 {name: 'NecromancerPack',		freq: 'RARE'},
		],
		
		// THE_DARK_TEMPLE (LEVEL 4):
		[{name: 'DarkElfWarden',		freq: 'COMMON'},
		 {name: 'DarkElfSentinel',		freq: 'COMMON'},
		 {name: 'DarkElfPyromancer',	freq: 'UNCOMMON'},
		 {name: 'DarkElfStormologist',	freq: 'UNCOMMON'},
		 {name: 'DarkElfPriestGroup',	freq: 'UNCOMMON'},
		 {name: 'DarkElfSummoner',		freq: 'UNCOMMON'},
		 {name: 'EvilEye',				freq: 'RARE'},
		 
		 {name: 'CorrosiveSlime',		freq: 'RARE'},
		 {name: 'TentacleSpitter',		freq: 'RARE'},
		 {name: 'ManaViper',			freq: 'RARE'},
		 {name: 'StoneGolem',			freq: 'RARE'},
		 {name: 'NecromancerPack',		freq: 'RARE'},
		],
	];
	
	
	// THE_CRYPT:
	// ********************************************************************************************
	this.spawnTables.TheCrypt = [
		// THE_CRYPT_LEVEL 1:
		[{name: 'MaggotPack',			freq: 'COMMON'},
		 {name: 'RottingCorpse',		freq: 'UNCOMMON'},
		 {name: 'SkeletonWarrior',		freq: 'COMMON'},
		 {name: 'SkeletonArcher',		freq: 'COMMON'},
		 {name: 'SkeletonPack',			freq: 'UNCOMMON'},
		],
		
		// THE_CRYPT_LEVEL 2:
		[{name: 'MaggotPack',			freq: 'COMMON'},
		 {name: 'RottingCorpse',		freq: 'UNCOMMON'},
		 {name: 'SkeletonWarrior',		freq: 'COMMON'},
		 {name: 'SkeletonArcher',		freq: 'COMMON'},
		 {name: 'SkeletonPack',			freq: 'UNCOMMON'},
		 {name: 'NecromancerPack',		freq: 'COMMON'},
		],
		
		// THE_CRYPT_LEVEL 3:
		[{name: 'MaggotPack',			freq: 'COMMON'},
		 {name: 'RottingCorpse',		freq: 'UNCOMMON'},
		 {name: 'SkeletonWarrior',		freq: 'COMMON'},
		 {name: 'SkeletonArcher',		freq: 'COMMON'},
		 {name: 'SkeletonPack',			freq: 'UNCOMMON'},
		 {name: 'NecromancerPack',		freq: 'COMMON'},
		 {name: 'ZombieBloat',			freq: 'COMMON'},
		 {name: 'Wraith',				freq: 'RARE'},
		 {name: 'MagicEye',				freq: 'RARE'}
		],
		
		// THE_CRYPT_LEVEL 4:
		[{name: 'MaggotPack',			freq: 'UNCOMMON'},
		 {name: 'RottingCorpse',		freq: 'UNCOMMON'},
		 {name: 'SkeletonWarrior',		freq: 'COMMON'},
		 {name: 'SkeletonArcher',		freq: 'COMMON'},
		 {name: 'SkeletonPack',			freq: 'UNCOMMON'},
		 {name: 'NecromancerPack',		freq: 'COMMON'},
		 {name: 'ZombieBloat',			freq: 'COMMON'},
		 {name: 'Wraith',				freq: 'UNCOMMON'},
		 {name: 'MagicEye',				freq: 'RARE'}
		],	
	];
	
	this.uniqueSpawnTable.TheCrypt = [
		{name: 'TheLichKing', minLevel: 7, maxLevel: 10, percent: 0.05},
	];
	
	// THE_VAULT_OF_YENDOR:
	// ********************************************************************************************
	this.spawnTables.VaultOfYendor = [
		// THE_VAULT_OF_YENDOR (LEVEL 1):
		[{name: 'DarkElfHoard',			freq: 'UNCOMMON'},
		 {name: 'DarkElfPriestGroup',	freq: 'UNCOMMON'},
		 
		 {name: 'HellHoundPack',		freq: 'COMMON'},
		 {name: 'DrachnidWarrior',		freq: 'COMMON'},
		 {name: 'DrachnidArcher',		freq: 'COMMON'},
		 {name: 'FleshGolem',			freq: 'UNCOMMON'},
		
		 {name: 'DarkElfBladeDancer',	freq: 'UNCOMMON'},
		 {name: 'CrystalGolem',			freq: 'UNCOMMON'},
		 
		 
		 {name: 'Troll',				freq: 'UNCOMMON'},
		 {name: 'IceElemental',			freq: 'UNCOMMON'},
		 {name: 'FireElemental',		freq: 'UNCOMMON'},
		 {name: 'Slime',				freq: 'UNCOMMON'},
		 
		 {name: 'ManaViper',			freq: 'RARE'},
		 {name: 'IceStatue',			freq: 'RARE'},
		 {name: 'FireStatue',			freq: 'RARE'},
		 {name: 'StormStatue',			freq: 'RARE'},
		 {name: 'TentacleSpitter',		freq: 'RARE'},
		],
		
		// THE_VAULT_OF_YENDOR (LEVEL 2):
		[{name: 'DarkElfHoard',			freq: 'UNCOMMON'},
		 {name: 'DarkElfPriestGroup',	freq: 'UNCOMMON'},
		 
		 {name: 'HellHoundPack',		freq: 'COMMON'},
		 {name: 'DrachnidWarrior',		freq: 'COMMON'},
		 {name: 'DrachnidArcher',		freq: 'COMMON'},
		 {name: 'FleshGolem',			freq: 'UNCOMMON'},
		
		 {name: 'DarkElfBladeDancer',	freq: 'UNCOMMON'},
		 {name: 'CrystalGolem',			freq: 'UNCOMMON'},
		 
		 {name: 'Succubus',				freq: 'RARE'},
		 
		 {name: 'Troll',				freq: 'UNCOMMON'},
		 {name: 'IceElemental',			freq: 'UNCOMMON'},
		 {name: 'FireElemental',		freq: 'UNCOMMON'},
		 {name: 'Slime',				freq: 'UNCOMMON'},
		 
		 {name: 'ManaViper',			freq: 'RARE'},
		 {name: 'IceStatue',			freq: 'RARE'},
		 {name: 'FireStatue',			freq: 'RARE'},
		 {name: 'StormStatue',			freq: 'RARE'},
		 {name: 'TentacleSpitter',		freq: 'RARE'},
		],

		// THE_VAULT_OF_YENDOR (LEVEL 3):
		[{name: 'DarkElfHoard',			freq: 'RARE'},
		 {name: 'DarkElfPriestGroup',	freq: 'RARE'},
		 
		 {name: 'HellHoundPack',		freq: 'COMMON'},
		 {name: 'DrachnidWarrior',		freq: 'COMMON'},
		 {name: 'DrachnidArcher',		freq: 'COMMON'},
		 {name: 'FleshGolem',			freq: 'UNCOMMON'},
		
		 {name: 'DarkElfBladeDancer',	freq: 'UNCOMMON'},
		 {name: 'CrystalGolem',			freq: 'UNCOMMON'},
		 
		 {name: 'Succubus',				freq: 'RARE'},
		 
		 {name: 'Troll',				freq: 'UNCOMMON'},
		 {name: 'IceElemental',			freq: 'UNCOMMON'},
		 {name: 'FireElemental',		freq: 'UNCOMMON'},
		 {name: 'Slime',				freq: 'UNCOMMON'},
		 
		 {name: 'ManaViper',			freq: 'RARE'},
		 {name: 'IceStatue',			freq: 'RARE'},
		 {name: 'FireStatue',			freq: 'RARE'},
		 {name: 'StormStatue',			freq: 'RARE'},
		 {name: 'TentacleSpitter',		freq: 'RARE'},
		],
		
		// THE_VAULT_OF_YENDOR (LEVEL 4):
		[{name: 'HellHoundPack',		freq: 'COMMON'},
		 {name: 'DrachnidWarrior',		freq: 'COMMON'},
		 {name: 'DrachnidArcher',		freq: 'COMMON'},
		 {name: 'FleshGolem',			freq: 'UNCOMMON'},
		
		 {name: 'DarkElfBladeDancer',	freq: 'UNCOMMON'},
		 {name: 'CrystalGolem',			freq: 'UNCOMMON'},
		 
		 {name: 'Succubus',				freq: 'RARE'},
		 
		 {name: 'Troll',				freq: 'UNCOMMON'},
		 {name: 'IceElemental',			freq: 'UNCOMMON'},
		 {name: 'FireElemental',		freq: 'UNCOMMON'},
		 {name: 'Slime',				freq: 'UNCOMMON'},
		 
		 {name: 'ManaViper',			freq: 'RARE'},
		 {name: 'IceStatue',			freq: 'RARE'},
		 {name: 'FireStatue',			freq: 'RARE'},
		 {name: 'StormStatue',			freq: 'RARE'},
		 {name: 'TentacleSpitter',		freq: 'RARE'},
		],
	];
	
	
	// THE_ARCANE_TOWER:
	// ********************************************************************************************
	this.spawnTables.TheArcaneTower = [	
		// LEVEL_1:
		[{name: 'ManaViper',			freq: 'UNCOMMON'},
		 {name: 'FireImp',				freq: 'COMMON'},
		 {name: 'StormImp',				freq: 'COMMON'},
		 {name: 'IceImp',				freq: 'COMMON'},
		 {name: 'StoneGolem',			freq: 'UNCOMMON'},
		 {name: 'FireStaffTurret',		freq: 'RARE'},
		],
		
		// LEVEL_2:
		[{name: 'ManaViper',			freq: 'UNCOMMON'},
		 {name: 'FireImp',				freq: 'COMMON'},
		 {name: 'StormImp',				freq: 'COMMON'},
		 {name: 'IceImp',				freq: 'COMMON'},
		 {name: 'StoneGolem',			freq: 'UNCOMMON'},
		 {name: 'FireStaffTurret',		freq: 'UNCOMMON'},
		 {name: 'StormStatue',			freq: 'RARE'},
		],
		
		// LEVEL_3:
		[{name: 'ManaViper',			freq: 'UNCOMMON'},
		 {name: 'FireImp',				freq: 'COMMON'},
		 {name: 'StormImp',				freq: 'COMMON'},
		 {name: 'IceImp',				freq: 'COMMON'},
		 {name: 'StoneGolem',			freq: 'COMMON'},
		 {name: 'FireStaffTurret',		freq: 'UNCOMMON'},
		 {name: 'StormStatue',			freq: 'RARE'},
		],
		
		// LEVEL_4:
		[{name: 'ManaViper',			freq: 'UNCOMMON'},
		 {name: 'FireImp',				freq: 'COMMON'},
		 {name: 'StormImp',				freq: 'COMMON'},
		 {name: 'IceImp',				freq: 'COMMON'},
		 {name: 'StoneGolem',			freq: 'COMMON'},
		 {name: 'FireStaffTurret',		freq: 'UNCOMMON'},
		 {name: 'StormStatue',			freq: 'UNCOMMON'},
		],
	];
	
	
	
	
	// THE_SEWERS:
	// ********************************************************************************************
	this.spawnTables.TheSewers = [
		// THE_SEWERS_LEVEL_1:
		[{name: 'MaggotPack',			freq: 'COMMON'},
		 {name: 'GiantLeach',			freq: 'COMMON'},
		 {name: 'RottingCorpse',		freq: 'UNCOMMON'},
		 {name: 'Troll',				freq: 'UNCOMMON'},
		 {name: 'TentacleSpitter',		freq: 'UNCOMMON'},
		 {name: 'Crocodile',			freq: 'UNCOMMON'},
		 {name: 'AcidicSlime',			freq: 'UNCOMMON'},
		 {name: 'BoaConstrictor',		freq: 'RARE'},
		 {name: 'Bloat',				freq: 'RARE'},
		 
		 {name: 'CorrosiveSlime',		freq: 'RARE'},
		],
		
		// THE_SEWERS_LEVEL_2:
		[{name: 'MaggotPack',			freq: 'COMMON'},
		 {name: 'GiantLeach',			freq: 'COMMON'},
		 
		 {name: 'RottingCorpse',		freq: 'UNCOMMON'},
		 {name: 'Troll',				freq: 'UNCOMMON'},
		 {name: 'TentacleSpitter',		freq: 'COMMON'},
		 {name: 'Crocodile',			freq: 'COMMON'},
		 {name: 'Bloat',				freq: 'UNCOMMON'},
		 {name: 'AcidicSlime',			freq: 'UNCOMMON'},
		 {name: 'BoaConstrictor',		freq: 'UNCOMMON'},
		 {name: 'Slime',				freq: 'RARE'},
		 {name: 'ToxicStatue',			freq: 'RARE'},
		 
		 {name: 'CorrosiveSlime',		freq: 'RARE'},
		],
		
		// THE_SEWERS_LEVEL_3:
		[{name: 'MaggotPack',			freq: 'COMMON'},
		 {name: 'GiantLeach',			freq: 'COMMON'},
		 {name: 'RottingCorpse',		freq: 'UNCOMMON'},
		 {name: 'Troll',				freq: 'UNCOMMON'},
		 {name: 'TentacleSpitter',		freq: 'COMMON'},
		 {name: 'Crocodile',			freq: 'COMMON'},
		 {name: 'Bloat',				freq: 'COMMON'},
		 {name: 'AcidicSlime',			freq: 'COMMON'},
		 {name: 'BoaConstrictor',		freq: 'COMMON'},
		 {name: 'Slime',				freq: 'UNCOMMON'},
		 {name: 'ToxicStatue',			freq: 'RARE'},
		 {name: 'MagicEye',				freq: 'RARE'},
		 
		 {name: 'CorrosiveSlime',		freq: 'RARE'},
		],
		 
		// THE_SEWERS_LEVEL_4:
		[{name: 'MaggotPack',			freq: 'UNCOMMON'},
		 {name: 'GiantLeach',			freq: 'COMMON'},
		 {name: 'RottingCorpse',		freq: 'UNCOMMON'},
		 {name: 'Troll',				freq: 'UNCOMMON'},
		 {name: 'TentacleSpitter',		freq: 'UNCOMMON'},
		 {name: 'Crocodile',			freq: 'COMMON'},
		 {name: 'Bloat',				freq: 'COMMON'},
		 {name: 'AcidicSlime',			freq: 'COMMON'},
		 {name: 'BoaConstrictor',		freq: 'COMMON'},
		 {name: 'Slime',				freq: 'COMMON'},
		 {name: 'ToxicStatue',			freq: 'UNCOMMON'},
		 {name: 'MagicEye',				freq: 'RARE'},
		 
		 {name: 'CorrosiveSlime',		freq: 'RARE'},
		],
	];
	
	
	
	
	
	// THE_CORE:
	// ********************************************************************************************
	this.spawnTables.TheCore = [
		// THE_CORE_LEVEL_1:
		[{name: 'FireBatPack',		freq: 'COMMON'},
		 {name: 'FireLizard',		freq: 'COMMON'},
		 {name: 'FireBatNest',		freq: 'UNCOMMON'},
		 {name: 'LavaEel',			freq: 'COMMON'},
		 {name: 'FireStatue',		freq: 'UNCOMMON'},
		 {name: 'FireElemental',	freq: 'RARE'},
		 {name: 'MagicEye',			freq: 'RARE'}
		],
		
		// THE_CORE_LEVEL_2:
		[{name: 'FireBatPack',		freq: 'COMMON'},
		 {name: 'FireLizard',		freq: 'COMMON'},
		 {name: 'FireBatNest',		freq: 'UNCOMMON'},
		 {name: 'LavaEel',			freq: 'COMMON'},
		 {name: 'FireStatue',		freq: 'UNCOMMON'},
		 {name: 'FireElemental',	freq: 'UNCOMMON'},
		 {name: 'ObsidianGolem',	freq: 'RARE'},
		 {name: 'MagicEye',			freq: 'RARE'}
		],
		
		// THE_CORE_LEVEL_3:
		[{name: 'FireBatPack',		freq: 'COMMON'},
		 {name: 'FireLizard',		freq: 'COMMON'},
		 {name: 'FireBatNest',		freq: 'UNCOMMON'},
		 {name: 'LavaEel',			freq: 'COMMON'},
		 {name: 'FireStatue',		freq: 'UNCOMMON'},
		 {name: 'FireElemental',	freq: 'COMMON'},
		 {name: 'ObsidianGolem',	freq: 'RARE'},
		 {name: 'MagicEye',			freq: 'RARE'}
		],
		
		// THE_CORE_LEVEL_4:
		[{name: 'FireBatPack',		freq: 'COMMON'},
		 {name: 'FireLizard',		freq: 'COMMON'},
		 {name: 'FireBatNest',		freq: 'UNCOMMON'},
		 {name: 'LavaEel',			freq: 'COMMON'},
		 {name: 'FireStatue',		freq: 'UNCOMMON'},
		 {name: 'FireElemental',	freq: 'COMMON'},
		 {name: 'ObsidianGolem',	freq: 'UNCOMMON'},
		 {name: 'MagicEye',			freq: 'RARE'}
		],
	];
	
	// THE_ICE_CAVES:
	// ********************************************************************************************
	this.spawnTables.TheIceCaves = [
		// THE_ICE_CAVES_LEVEL_1:
		[{name: 'DireWolfPack',			freq: 'COMMON'},
		 {name: 'Penguin',				freq: 'COMMON'},
		 {name: 'DireWolfKennel',		freq: 'UNCOMMON'},
		 {name: 'IceStatue',			freq: 'UNCOMMON'},
		 
		 {name: 'MagicEye',				freq: 'RARE'}
		],
		
		// THE_ICE_CAVES_LEVEL_2:
		[{name: 'DireWolfPack',			freq: 'COMMON'},
		 {name: 'Penguin',				freq: 'COMMON'},
		 {name: 'DireWolfKennel',		freq: 'UNCOMMON'},
		 {name: 'IceStatue',			freq: 'UNCOMMON'},
		 {name: 'PolarBear',			freq: 'COMMON'},
		 {name: 'YakPack',				freq: 'RARE'},
		 
		 {name: 'MagicEye',				freq: 'RARE'}
		],
		
		// THE_ICE_CAVES_LEVEL_3:
		[{name: 'DireWolfPack',			freq: 'COMMON'},
		 {name: 'Penguin',				freq: 'COMMON'},
		 {name: 'DireWolfKennel',		freq: 'UNCOMMON'},
		 {name: 'IceStatue',			freq: 'UNCOMMON'},
		 {name: 'PolarBear',			freq: 'COMMON'},
		 {name: 'YakPack',				freq: 'RARE'},
		 {name: 'IceElemental',			freq: 'UNCOMMON'},
		 
		 {name: 'MagicEye',				freq: 'RARE'}
		],
		
		// THE_ICE_CAVES_LEVEL_4:
		[{name: 'DireWolfPack',			freq: 'COMMON'},
		 {name: 'Penguin',				freq: 'COMMON'},
		 {name: 'DireWolfKennel',		freq: 'UNCOMMON'},
		 {name: 'IceStatue',			freq: 'UNCOMMON'},
		 {name: 'PolarBear',			freq: 'COMMON'},
		 {name: 'YakPack',				freq: 'UNCOMMON'},
		 {name: 'IceElemental',			freq: 'COMMON'},
		 
		 {name: 'MagicEye',				freq: 'RARE'}
		],
	];
	
	this.forEachType(this.spawnTables, function (spawnTable) {
		spawnTable.forEach(function (levelTable) {
			levelTable.forEach(function (e) {
				if (!this.npcTypes[e.name] && !this.npcGroupTypes[e.name]) {
					throw 'Invalid npcType or npcGroupType: ' + e.name;
				}
			}, this);
		}, this);
	}, this);
	
	this.forEachType(this.uniqueSpawnTable, function (spawnTable) {
		spawnTable.forEach(function (e) {
			if (!this.npcTypes[e.name] && !this.npcGroupTypes[e.name]) {
				throw 'Invalid uniqueNPC: ' + e.name;		
			}
		}, this);
	}, this);
};

// CREATE_NPC_GROUP_TYPES:
// ************************************************************************************************
gs.createNPCGroupTypes = function () {
	this.npcGroupTypes = {
		// THE_UPPER_DUNGEON_GROUPS:
		// ****************************************************************************************
		RatPack: {
			maxSize: 3,
			npcTypes: [{name: 'Rat', percent: 100}]
		},
		
		BatPack: {
			maxSize: 3,
			npcTypes: [{name: 'Bat', percent: 100}]
		},
		
		GoblinShamanGroup: {
			maxSize: 3,
			forceNPCTypes: ['GoblinShaman'],
			npcTypes: [
				{name: 'GoblinWarrior', percent: 50},
				{name: 'GoblinArcher', percent: 50},
			]
		},
		
		GoblinHoard: {
			maxSize: 6,
			npcTypes: [
				{name: 'GoblinWarrior', percent: 30},	   
				{name: 'GoblinBrute', percent: 20},   
				{name: 'GoblinArcher', percent: 20},   
				{name: 'GoblinFireMage', percent: 10},
				{name: 'GoblinStormMage', percent: 10},
				{name: 'GoblinShaman', percent: 10}
			]
		},
		
		// THE_ORC_FORTRESS_GROUPS:
		// ****************************************************************************************
		WolfPack: {
			maxSize: 3,
			npcTypes: [
				{name: 'Wolf', percent: 100}
			]
		},
		
		OrcPriestGroup: {
			maxSize: 3,
			forceNPCTypes: ['OrcPriest'],
			npcTypes: [
				{name: 'OrcWarrior', percent: 50},
				{name: 'OrcArcher', percent: 50},
			]
		},
		
		OrcPack: {
			maxSize: 6,
			npcTypes: [
				{name: 'OrcWarrior', percent: 30},
				{name: 'Ogre', percent: 10},
				{name: 'OrcArcher', percent: 20},
				{name: 'OrcFireMage', percent: 10},
				{name: 'OrcStormMage', percent: 10},
				{name: 'OrcPriest', percent: 10},
				{name: 'OrcSummoner', percent: 10},
			]
		},
		
		OrcKingPack: {
			maxSize: 6,
			forceNPCTypes: ['KingMonRacar'],
			npcTypes: [
				{name: 'OrcWarrior', percent: 30},
				{name: 'Ogre', percent: 10},
				{name: 'OrcArcher', percent: 20},
				{name: 'OrcFireMage', percent: 10},
				{name: 'OrcStormMage', percent: 10},
				{name: 'OrcPriest', percent: 10},
				{name: 'OrcSummoner', percent: 10},
			]
		},
		
		// THE_IRON_FORTRESS_GROUPS:
		// ****************************************************************************************
		ClockworkRatPack: {
			maxSize: 4,
			npcTypes: [{name: 'ClockworkRat', percent: 100}]
		},
		
		BombomberPack: {
			maxSize: 3,
			npcTypes: [{name: 'Bombomber', percent: 100}]
		},
		
		// THE_DARK_TEMPLE_GROUPS:
		// ****************************************************************************************
		DarkElfPriestGroup: {
			maxSize: 3,
			forceNPCTypes: ['DarkElfPriest'],
			npcTypes: [
				{name: 'DarkElfSentinel', percent: 50},
				{name: 'DarkElfWarden', percent: 50},
			]
		},
		
		DarkElfHoard: {
			maxSize: 6,
			npcTypes: [
				{name: 'DarkElfSentinel', 		percent: 30},
				{name: 'DarkElfWarden', 		percent: 40},
				{name: 'DarkElfPyromancer', 	percent: 5},
				{name: 'DarkElfStormologist', 	percent: 5},
				{name: 'DarkElfPriest', 		percent: 10},
				{name: 'DarkElfSummoner', 		percent: 10},
			]
		},
		
		// THE_VAULT_OF_YENDOR_GROUPS:
		// ****************************************************************************************
		HellHoundPack: {
			maxSize: 6,
			npcTypes: [
				{name: 'HellHound', percent: 100}
			]	
		},
		
		// THE_SUNLESS_DESERT:
		// ****************************************************************************************
		ScarabSwarm: {
			maxSize: 4,
			npcTypes: [{name: 'Scarab', percent: 100}],
		},
		
		GoatHerd: {
			maxSize: 4,
			npcTypes: [{name: 'Goat', percent: 100}],
		},
		
		MummyPriestGroup: {
			maxSize: 3,
			forceNPCTypes: ['MummyPriest'],
			npcTypes: [
				{name: 'Mummy', percent: 100},
			]
		},
		
		AncientWindCallerGroup: {
			maxSize: 3,
			forceNPCTypes: ['AncientWindCaller'],
			npcTypes: [
				{name: 'Mummy', percent: 100}
			]
		},
		
		// THE_SWAMP:
		// ****************************************************************************************
		PirahnaPack: {
			maxSize: 4,
			npcTypes: [{name: 'Pirahna', percent: 100}],
			spawnInWater: true,
		},
		
		FrogPack: {
			maxSize: 3,
			npcTypes: [{name: 'BlinkFrog', percent: 100}]
		},
		
		// THE_UNDERGROVE:
		// ****************************************************************************************
		ElephantPack: {
			maxSize: 3,
			npcTypes: [{name: 'Elephant', percent: 100}],
		},
		
		GiantBeePack: {
			maxSize: 3,
			npcTypes: [{name: 'GiantBee', percent: 100}],
		},
		
		// THE_CRYPT_GROUPS:
		// ****************************************************************************************
		MaggotPack: {
			maxSize: 6,
			npcTypes: [{name: 'Maggot', percent: 100}]
		},
		
		SkeletonPack: {
			maxSize: 3,
			npcTypes: [
				{name: 'SkeletonWarrior', percent: 75},
				{name: 'SkeletonArcher', percent: 25}
			]
		},
		
		NecromancerPack: {
			maxSize: 4,
			forceNPCTypes: ['Necromancer'],
			npcTypes: [
				{name: 'SkeletonWarrior', percent: 50},
				{name: 'SkeletonArcher', percent: 50}
			]
		},
		
		// THE CORE:
		// ****************************************************************************************
		FireBatPack: {
			maxSize: 6,
			npcTypes: [
				{name: 'FireBat', percent: 100}
			]
		},
		
		// THE_ICE_CAVES:
		// ****************************************************************************************
		DireWolfPack: {
			maxSize: 3,
			npcTypes: [
				{name: 'DireWolf', percent: 100}
			]
		},
		
		YakPack: {
			maxSize: 4,
			npcTypes: [{name: 'Yak', percent: 100}],
		},
	};
	
	this.nameTypes(this.npcGroupTypes);
};

// GET_PERCENT_SPAWN_TABLE:
// ************************************************************************************************
gs.getPercentSpawnTable = function (spawnTable) {
	var table = spawnTable.slice(0);
	for (let i = 0; i < table.length; i += 1) {
		if (table[i].freq === 'COMMON') {
			table[i].percent = NPC_COMMON_PERCENT;
		} 
		else if (table[i].freq === 'UNCOMMON') {
			table[i].percent = NPC_UNCOMMON_PERCENT;
		} 
		else if (table[i].freq === 'RARE') {
			table[i].percent = NPC_RARE_PERCENT;
		} 
		else {
			throw 'Unknown freq ' + table[i].freq;
		}
	}
	return table;
};

// GET_ZOO_SPAWN_TABLE:
// ************************************************************************************************
gs.getZooSpawnTable = function (spawnTable) {
	var table = [],
		percent = {COMMON: NPC_COMMON_PERCENT, UNCOMMON: NPC_UNCOMMON_PERCENT, RARE: NPC_RARE_PERCENT},
		group,
		addToTable;
	
	addToTable = function (name, percent) {
		var npcType = gs.npcTypes[name];
		
		if (!npcType.neverSpawnInZoo && !npcType.spawnInWater && !npcType.spawnInLava) {
			table.push({name: name, percent: percent});
		}
	};
	
	for (let i = 0; i < spawnTable.length; i += 1) {
		// NPC:
		if (gs.npcTypes[spawnTable[i].name]) {
			addToTable(spawnTable[i].name, percent[spawnTable[i].freq]);
		}
		// Group:
		else {
			group = gs.npcGroupTypes[spawnTable[i].name];
			
			// Force NPC Types:
			if (group.forceNPCTypes) {
				for (let j = 0; j < group.forceNPCTypes.length; j += 1) {
					addToTable(group.forceNPCTypes[j], percent[spawnTable[i].freq]);
				}
			}
			
			// Random:
			for (let j = 0; j < group.npcTypes.length; j += 1) {
				addToTable(group.npcTypes[j].name, percent[spawnTable[i].freq] * (group.npcTypes[j].percent / 100));
			}
		}
	}
	
	return table;
};


// NUM_SPAWNED_NPCS:
// ************************************************************************************************
gs.numSpawnedNPCs = function (zoneName, zoneLevel) {
	
	
	if (zoneName === 'TheUpperDungeon') {
		return NUM_NPCS.TIER_I[zoneLevel];
	}
	else if (gs.inArray(zoneName, TIER_II_ZONES)) {
		return NUM_NPCS.TIER_II[zoneLevel];
	}
	else if (gs.inArray(zoneName, TIER_III_ZONES)) {
		return NUM_NPCS.TIER_III[zoneLevel];
	}
	else if (gs.inArray(zoneName, BRANCH_I_ZONES)) {
		return NUM_NPCS.BRANCH_I[zoneLevel];
	}
	else if (gs.inArray(zoneName, BRANCH_II_ZONES)) {
		return NUM_NPCS.BRANCH_II[zoneLevel];
	}
	else if (zoneName === 'VaultOfYendor') {
		return NUM_NPCS.TIER_IV[zoneLevel];
	}
	else {
		throw 'invalid zoneName';
	}
};

// POPULATE_LEVEL:
// ************************************************************************************************
gs.populateLevel = function () {
	var totalNPCs;

	// Never spawn more than 1.5 x max NPCs (includes vaults, side rooms, etc)
	totalNPCs = Math.min(this.numSpawnedNPCs(this.zoneName, this.zoneLevel) * 1.5, 
						 this.numHostileNPCs() + this.numSpawnedNPCs(this.zoneName, this.zoneLevel));
	
	// Spawn Mobs:
	while (this.numHostileNPCs() < totalNPCs) {
		this.spawnRandomNPCOrGroup();
	}
};

// NUM_HOSTILE_NPCS:
// ************************************************************************************************
gs.numHostileNPCs = function () {
	return this.getAllNPCs().filter(npc => npc.faction === FACTION.HOSTILE).length;
};

// POPULATE_TEST_LEVEL:
// ************************************************************************************************
gs.populateTestLevel = function () {
	var start = 0,
		end = 70;
	
	end = Math.min(end, this.npcTypeList.length);
	
	for (let i = start; i < end; i += 1) {
		if (this.npcTypeList[i].faction === FACTION.HOSTILE) {
			this.spawnNPCOrGroup(null, this.npcTypeList[i].name);
		}
		
	}
};




// SPAWN_UNIQUES:
// This function is responsible for handling all the complexities of spawning uniques.
// Its important to keep track of which uniques have been spawned so we don't double spawn them.
// ************************************************************************************************
gs.spawnUniques = function () {
	var tileIndex, table = gs.uniqueSpawnTable[this.zoneName];
	
	if (!gs.debugProperties.spawnUniques) {
		return;
	}
	
	if (!table) {
		return;
	}
	
	//console.log(table);
	table = table.filter(e => gs.zoneLevel >= e.minLevel && gs.zoneLevel <= e.maxLevel);
	table = table.filter(e => !gs.inArray(e.name, gs.previouslySpawnedUniques));
	//console.log(table);
	
	table.forEach(function (e) {
		if (game.rnd.frac() < e.percent) {
			this.spawnNPCOrGroup(null, e.name);
			gs.previouslySpawnedUniques.push(e.name);
		}
	}, this);
};

// SPAWN_RANDOM_NPC_OR_GROUP
// Spawn a random NPC or npcGroup from the current zones spawn table.
// If passed a tileIndex will spawn at that location, otherwise a suitable tileIndex is randomly chosen.
// npcFlags can be passed, otherwise default (random) flags will be chosen.
// if isRespawn=true then npcTypes flagged as neverRespawn will not be spawned.
// ************************************************************************************************
gs.spawnRandomNPCOrGroup = function (tileIndex, npcFlags, isRespawn) {	
	var spawnTable,
		spawnTypeName;
		
	// Get random npcTypeName:
	spawnTable = this.getPercentSpawnTable(this.zoneType().spawnTable[this.zoneLevel - 1]);
	spawnTypeName = this.chooseRandom(spawnTable);
	
	// Handle the neverRespawn flag on npcTypes:
	// Note only individual npcTypes can be currently be set to never spawn (not npcGroups)
	while (isRespawn && this.npcTypes[spawnTypeName] && this.npcTypes[spawnTypeName].neverRespawn) {
		spawnTypeName = this.chooseRandom(spawnTable);
	}
	
	this.spawnNPCOrGroup(tileIndex, spawnTypeName, npcFlags);
};

// SPAWN_NPC_OR_GROUP:
// ************************************************************************************************
gs.spawnNPCOrGroup = function (tileIndex, spawnTypeName, flags) {
	var spawnType,
		isAsleep = game.rnd.frac() < SLEEPING_PERCENT,
		npcClassType = null,
		isWandering = game.rnd.frac() < MOB_WANDER_PERCENT;
	
	// Flags override default properties:
	if (flags) {
		isAsleep = flags.isAsleep;
		isWandering = flags.isWandering;
	}
	
	
	
	// Get the spawnType (either an npcType or a groupType)
	if (this.npcTypes[spawnTypeName]) {
		spawnType = this.npcTypes[spawnTypeName];
	}
	else if (this.npcGroupTypes[spawnTypeName]) {
		spawnType = this.npcGroupTypes[spawnTypeName];
	}
	else {
		throw 'Invalid spawnTypeName: ' + spawnTypeName;
	}
	
	// Get random spawn tileIndex:
	if (!tileIndex) {
		// Spawn In Water:
		if (spawnType.spawnInWater) {
			tileIndex = this.getWaterSpawnIndex();
		}
		// Spawn In Lava:
		else if (spawnType.spawnInLava) {
			tileIndex = this.getLavaSpawnIndex();
		}
		// Normal spawn:
		else {
        	tileIndex = this.getSpawnIndex();
		}
	}
	
	if (!tileIndex) {
		//console.log('Failed to find valid spawnIndex for: ' + npcTypeName);
		return;
	}
	
	// Spawn Group:
	if (this.npcGroupTypes.hasOwnProperty(spawnTypeName)) {
		this.spawnNPCGroup(tileIndex, spawnType);
	}
	// Spawn Single:
	else {
		// Elite:
		if (this.dangerLevel() >= MIN_ELITE_LEVEL && game.rnd.frac() < NPC_ELITE_CHANCE) {
			npcClassType = gs.getNPCClassType(spawnTypeName);
		}
		
		this.createNPC(tileIndex, spawnTypeName, {isAsleep: isAsleep, npcClassType: npcClassType, isWandering: isWandering});
		
		// Webs around spider nests:
		if (spawnTypeName === 'SpiderNest') {
			gs.createVinePatch({x: tileIndex.x - 1, y: tileIndex.y}, 2, 'SpiderWeb', 0.5);
		}

		// Bones around rat nests:
		if (spawnTypeName === 'RatNest') {
			gs.createVinePatch({x: tileIndex.x, y: tileIndex.y}, 2, 'Bones', 0.5);
		}

		// Blood around rotting corpses:
		if (spawnTypeName === 'RottingCorpse') {
			gs.createVinePatch(tileIndex, 2, 'Blood', 0.5);
		}
	}
};

// SPAWN_NPC_GROUP:
// ************************************************************************************************
gs.spawnNPCGroup = function (tileIndex, groupType) {
	var isAsleep, numNpcs, npcTileIndex, indexList, npcTypeName, npcClassType, forceNPCTypes;
	
	if (groupType.forceNPCTypes) {
		forceNPCTypes = groupType.forceNPCTypes.slice(0);
	}
	else {
		forceNPCTypes = [];
	}
	
	// Entire group will either sleep or not sleep:
	isAsleep = game.rnd.frac() < SLEEPING_PERCENT;

	// Random numNPCs in group:
	numNpcs = util.randInt(Math.ceil(groupType.maxSize / 2), groupType.maxSize);
	
	// Water Spawns:
	if (groupType.spawnInWater) {
		indexList = gs.getIndexInFlood(tileIndex, index => gs.isValidWaterSpawnIndex(index), 3);
	}
	// Lava Spawns:
	else if (groupType.spawnInLava) {
		indexList = gs.getIndexInFlood(tileIndex, index => gs.isValidLavaSpawnIndex(index), 3);
	}
	// Normal Spawns:
	else {
		indexList = gs.getIndexInFlood(tileIndex, index => gs.isValidSpawnIndex(index), 3);
	}
	
	for (let i = 0; i < numNpcs; i += 1) {
		if (indexList.length > 0) {
			npcTileIndex = indexList.shift();
			
			if (forceNPCTypes.length > 0) {
				npcTypeName = forceNPCTypes.pop();
			}
			else {
				npcTypeName =  this.chooseRandom(groupType.npcTypes);
			}
			
			if (this.dangerLevel() >= MIN_ELITE_LEVEL && game.rnd.frac() < NPC_ELITE_CHANCE) {
				npcClassType = gs.getNPCClassType(npcTypeName);
			}
			else {
				npcClassType = null;
			}
			
			this.createNPC(npcTileIndex, npcTypeName, {isAsleep: isAsleep, isWandering: false, npcClassType: npcClassType});
		}
	}
};

// SPAWN_RANDOM_NPC:
// Spawns a single NPC i.e. not group at the tileIndex
// ************************************************************************************************
gs.spawnRandomNPC = function (tileIndex) {
	var spawnTable, npcTypeName, flags = {};
	
	spawnTable = this.zoneType().spawnTable[this.zoneLevel - 1];
	
	// Filter only single:
	spawnTable = spawnTable.filter(e => gs.npcTypes[e.name]);
	
	// Only lava mobs:
	if (gs.getTile(tileIndex).type.name === 'Lava') {
		spawnTable = spawnTable.filter(e => gs.npcTypes[e.name].spawnInLava);
	}
	// Only water mobs:
	else if (gs.getTile(tileIndex).type.name === 'Water') {
		spawnTable = spawnTable.filter(e => gs.npcTypes[e.name].spawnInWater);
	}
	// Never lava or water mobs:
	else {
		spawnTable = spawnTable.filter(e => !gs.npcTypes[e.name].spawnInWater && !gs.npcTypes[e.name].spawnInLava);
	}
	
	// Get random npcTypeName:
	spawnTable = this.getPercentSpawnTable(spawnTable);
	npcTypeName = this.chooseRandom(spawnTable);
	
	// Elite:
	if (this.dangerLevel() >= MIN_ELITE_LEVEL && game.rnd.frac() < NPC_ELITE_CHANCE) {
		flags.npcClassType = gs.getNPCClassType(npcTypeName);
	}
	
	this.createNPC(tileIndex, npcTypeName, flags);
};


// SPAWN_MONSTER_ZOO_NPC:
// ************************************************************************************************
gs.spawnMonsterZooNPC = function (tileIndex) {
	var spawnTable = this.getZooSpawnTable(this.zoneType().spawnTable[this.zoneLevel - 1]),
		npcTypeName = this.chooseRandom(spawnTable),
		count = 0,
		flags = {};

	flags.isAsleep = true;
	
	// Elite:
	if (this.dangerLevel() >= MIN_ELITE_LEVEL && game.rnd.frac() < NPC_ELITE_CHANCE) {
		flags.npcClassType = gs.getNPCClassType(npcTypeName);
	}
	
	this.createNPC(tileIndex, npcTypeName, flags);
};/*global game, gs, Phaser, console, util*/
/*global Item*/
/*global NUM_TILES_X*/
/*global MIN_ELITE_LEVEL, NPC_ELITE_CHANCE, TIMED_GATE_TIME*/
/*jshint white: true, laxbreak: true, esversion: 6 */
'use strict';

// CREATE_ROOM_DRESSING_TABLES:
// ********************************************************************************************
gs.createRoomDressingTables = function () {
	
	
	this.roomDressingTypes = {
		// LargeRoom:
		Tomb:				{areaType: 'LargeRoom', func: this.dressTomb},
		
		// Cave:
	  	CrystalCave:		{areaType: 'Cave', func: this.dressCrystalCave},
	  	WaterCave:			{areaType: 'Cave', func: this.dressWaterCave},
	  	GrassCave:			{areaType: 'Cave', func: this.dressGrassCave},
		LavaCave:			{areaType: 'Cave', func: this.dressLavaCave},
		GroveCave:			{areaType: 'Cave', func: this.dressGroveCave},
		GroveWaterCave: 	{areaType: 'Cave', func: this.dressGroveWaterCave},
		DesertCave:			{areaType: 'Cave', func: this.dressDesertCave},
		
	};

	// Default Dressing Properties:
	this.forEachType(this.roomDressingTypes, function (element) {
		element.minSize = element.minSize || 0;
		element.maxSize = element.maxSize || NUM_TILES_X;
		element.maxCount = element.maxCount || 1000;
	}, this);
	
	this.nameTypes(this.roomDressingTypes);
};

// DRESS_ROOMS:
// ************************************************************************************************
gs.dressRooms = function () {
	
	if (this.debugProperties.dressRooms && this.areaList) {
		for (let i = 0; i < this.areaList.length; i += 1) {
			if (this.areaList[i].type === 'Cave' || this.areaList[i].type === 'Crypt') {
				this.dressRoom(this.areaList[i]);
			}
			
		}
	}
};

// DRESS_ROOM:
// ************************************************************************************************
gs.dressRoom = function (area) {	
	var roomDressingType = this.getRoomDressingType(area);
	
	if (roomDressingType) {
		roomDressingType.func.call(this, area);
		
		if (!this.dressingTypeCounts[roomDressingType.name]) {
			this.dressingTypeCounts[roomDressingType.name] = 0;
		}
		this.dressingTypeCounts[roomDressingType.name] += 1;
	}
};

// GET_ROOM_DRESSING_TYPE:
// Given an area, determine based on its areaType what random roomDressing to use.
// This function uses the dressingTable specified and defined in level-type.js.
// If no appropriate dressingType is available or NONE is randomly chosen then return null indicating no dressing for the area.
// ************************************************************************************************
gs.getRoomDressingType = function (area) {
	var roomDressingTypeName, dressingTable;

	// The zone has no dressing table:
	if (!this.zoneType().dressingTable) {
		throw this.zoneName + ' does not have a valid dressing table';
	}

	// A valid dressing table exists based on the area type:
	if (this.zoneType().dressingTable[area.type] && this.zoneType().dressingTable[area.type].length > 0) {
		dressingTable = this.zoneType().dressingTable[area.type].filter(function (element) {
			var dressingType = this.roomDressingTypes[element.name];
			
			return element.name === 'NONE'
				|| ((!element.minLevel || this.dangerLevel() >= element.minLevel)
					&& area.width >= dressingType.minSize
					&& area.height >= dressingType.minSize
				   	&& area.width <= dressingType.maxSize
				   	&& area.height <= dressingType.maxSize
					&& (!this.dressingTypeCounts[element.name] || this.dressingTypeCounts[element.name] < dressingType.maxCount)
				   	&& (!dressingType.validFunc || dressingType.validFunc(area)));	
		}, this);
		
		if (dressingTable.length === 0) {
			return null;
		}
		
		roomDressingTypeName = this.chooseRandom(dressingTable);

		if (roomDressingTypeName === 'NONE') {
			return null;
		}
		else {
			return this.roomDressingTypes[roomDressingTypeName];
		}
	}
	// No valid dressing table exists based on the area type:
	else {
		return null;
	}
};





// DRESS_TOMB:
// The Tomb is a large room with caskets placed down the center in one or more columns providing cover from projectiles.
// ************************************************************************************************
gs.dressTomb = function (area) {
	var indexList;
	// end - 1 so that caskets do not spawn against end walls
	indexList = this.getIndexInBox(area.startX, area.startY, area.endX - 1, area.endY - 1);
	
	// startX + 1 so that caskets do not spawn against start walls
	indexList = indexList.filter(index => index.x % 2 === (area.startX + 1) % 2 && index.y % 2 === (area.startY + 1) % 2);
	
	indexList = indexList.filter(index => game.rnd.frac() < 0.5);
	
	indexList.forEach(function (index) {
		gs.createObject(index, 'Casket');
	});
};





// DRESS_WATER_CAVE:
// ************************************************************************************************
gs.dressWaterCave = function (area) {
	var i, tileIndex, num;

	this.createLakes(area, util.randInt(3, 6));

	// Stalagmites:
	num = util.randInt(1, [16, 8, 4][area.depth]);
	for (i = 0; i < num; i += 1) {
		tileIndex = this.getWideOpenIndexInArea(area);
		if (tileIndex) {
			gs.createObject(tileIndex, 'Stalagmite');
		}
	}
	
	// Rubble:
	if (game.rnd.frac() < 0.25) {
		num = util.randInt(1, [4, 2, 1][area.depth]);
		for (i = 0; i < num; i += 1) {
			tileIndex = gs.getOpenIndexInArea(area);
			if (tileIndex) {
				this.createVinePatch(tileIndex, util.randInt(1, 4), 'Rubble', 0.75);
			}
		}
	}
};


// CREATE_LAKES:
// ************************************************************************************************
gs.createLakes = function (area, num) {
	var i, x, y, tileIndex, waterTileIndexes = [], path;

	// Water:
	for (i = 0; i < num; i += 1) {
		tileIndex = gs.getOpenIndexInArea(area);
		if (tileIndex) {
			this.floodTiletype(tileIndex, gs.tileTypes.Water, util.randInt(3, 7));
			waterTileIndexes.push(tileIndex);
		}
	}

	// First River:
	if (game.rnd.frac() < 0.75) {
		path = this.findPath(waterTileIndexes[0], waterTileIndexes[1], {allowDiagonal: false, maxDepth: 1000});
		if (path && path.length > 0) {
			for (i = 0; i < path.length; i += 1) {
				gs.setTileType(path[i], gs.tileTypes.Water);
			}
		}
	}

	// Second River:
	if (game.rnd.frac() < 0.50) {
		path = this.findPath(waterTileIndexes[1], waterTileIndexes[2], {allowDiagonal: false, maxDepth: 1000});
		if (path && path.length > 0) {
			for (i = 0; i < path.length; i += 1) {
				gs.setTileType(path[i], gs.tileTypes.Water);
			}
		}
	}

	// Grass around water:
	for (x = area.startX + 1; x < area.endX - 1; x += 1) {
		for (y = area.startY + 1; y < area.endY - 1; y += 1) {
			if (this.isIndexOpen(x, y)
				&& (this.tileMap[x + 1][y].type.name === 'Water'
					|| this.tileMap[x - 1][y].type.name === 'Water'
					|| this.tileMap[x][y + 1].type.name === 'Water'
					|| this.tileMap[x][y - 1].type.name === 'Water')) {
				this.createVinePatch({x: x, y: y}, util.randInt(1, 3), 'LongGrass');
			}
		}
	}
};

// DRESS_DESERT_CAVE:
// ************************************************************************************************
gs.dressDesertCave = function (area) {
	var num, tileIndex;
	
	// Stalagmites:
	num = util.randInt(1, [16, 8, 4][area.depth]);
	for (let i = 0; i < num; i += 1) {
		tileIndex = this.getWideOpenIndexInArea(area);
		if (tileIndex) {
			gs.createObject(tileIndex, 'Stalagmite');
		}
	}
	
	// Rubble:
	if (game.rnd.frac() < 0.5) {
		num = util.randInt(1, [4, 2, 1][area.depth]);
		for (let i = 0; i < num; i += 1) {
			tileIndex = gs.getOpenIndexInArea(area);
			if (tileIndex) {
				this.createVinePatch(tileIndex, util.randInt(1, 4), 'Rubble', 0.75);
			}
		}
	}
};

// DRESS_GRASS_CAVE:
// ************************************************************************************************
gs.dressGrassCave = function (area) {
	var tileIndex,
		num,
		indexList,
		i;

	// Stalagmites:
	num = util.randInt(1, [16, 8, 4][area.depth]);
	for (i = 0; i < num; i += 1) {
		tileIndex = this.getWideOpenIndexInArea(area);
		if (tileIndex) {
			gs.createObject(tileIndex, 'Stalagmite');
		}
	}
	
	// Grass:
	num = util.randInt(1, [4, 2, 1][area.depth]);
	for (i = 0; i < num; i += 1) {
		tileIndex = gs.getOpenIndexInArea(area);
		if (tileIndex) {
			gs.createVinePatch(tileIndex, util.randInt(2, 4), 'LongGrass', 0.5);
		}
	}
	
	// Rubble:
	if (game.rnd.frac() < 0.5) {
		num = util.randInt(1, [4, 2, 1][area.depth]);
		for (i = 0; i < num; i += 1) {
			tileIndex = gs.getOpenIndexInArea(area);
			if (tileIndex) {
				this.createVinePatch(tileIndex, util.randInt(1, 4), 'Rubble', 0.75);
			}
		}
	}
};


// DRESS_GROVE_CAVE:
// ************************************************************************************************
gs.dressGroveCave = function (area) {
	var num, i, tileIndex;
	
	// Ferns:
	num = util.randInt(1, [16, 8, 4][area.depth]);
	for (i = 0; i < num; i += 1) {
		tileIndex = this.getWideOpenIndexInArea(area);
		if (tileIndex) {
			gs.createObject(tileIndex, 'Fern');
		}
	}
	
	// Stalagmites:
	num = util.randInt(1, [16, 8, 4][area.depth]);
	for (i = 0; i < num; i += 1) {
		tileIndex = this.getWideOpenIndexInArea(area);
		if (tileIndex) {
			gs.createObject(tileIndex, 'Stalagmite');
		}
	}
	
	// Grass:
	num = util.randInt(1, [4, 2, 1][area.depth]);
	for (i = 0; i < num; i += 1) {
		tileIndex = gs.getOpenIndexInArea(area);
		if (tileIndex) {
			gs.createVinePatch(tileIndex, util.randInt(2, 6), 'LongGrass', 0.50);
		}
	}
};

// DRESS_GROVE_WATER_CAVE:
// ************************************************************************************************
gs.dressGroveWaterCave = function (area) {
	var num, i, tileIndex;
	
	this.createLakes(area, util.randInt(3, 6));
	
	// Ferns:
	num = util.randInt(1, [16, 8, 4][area.depth]);
	for (i = 0; i < num; i += 1) {
		tileIndex = this.getWideOpenIndexInArea(area);
		if (tileIndex) {
			gs.createObject(tileIndex, 'Fern');
		}
	}
	
	// Stalagmites:
	num = util.randInt(1, [16, 8, 4][area.depth]);
	for (i = 0; i < num; i += 1) {
		tileIndex = this.getWideOpenIndexInArea(area);
		if (tileIndex) {
			gs.createObject(tileIndex, 'Stalagmite');
		}
	}
	
	
	// Grass:
	num = util.randInt(1, [4, 2, 1][area.depth]);
	for (i = 0; i < num; i += 1) {
		tileIndex = gs.getOpenIndexInArea(area);
		if (tileIndex) {
			gs.createVinePatch(tileIndex, util.randInt(2, 6), 'LongGrass', 0.50);
		}
	}
};

// DRESS_LAVA_CAVE:
// ************************************************************************************************
gs.dressLavaCave = function (area) {
	var i, tileIndex, num;

	this.createLavaLakes(area, util.randInt(3, 6));

	// Stalagmites:
	num = util.randInt(1, [16, 8, 4][area.depth]);
	for (i = 0; i < num; i += 1) {
		tileIndex = this.getWideOpenIndexInArea(area);
		if (tileIndex) {
			gs.createObject(tileIndex, 'Stalagmite');
		}
	}
	
	// Rubble:
	if (game.rnd.frac() < 0.25) {
		num = util.randInt(1, [4, 2, 1][area.depth]);
		for (i = 0; i < num; i += 1) {
			tileIndex = gs.getOpenIndexInArea(area);
			if (tileIndex) {
				this.createVinePatch(tileIndex, util.randInt(1, 4), 'Rubble', 0.75);
			}
		}
	}
};


// CREATE_LAVA_LAKES:
// ************************************************************************************************
gs.createLavaLakes = function (area, num) {
	var i, x, y, tileIndex, lavaTileIndexes = [], path;

	// Lava Lake:
	for (i = 0; i < num; i += 1) {
		tileIndex = gs.getOpenIndexInArea(area);
		if (tileIndex) {
			this.floodTiletype(tileIndex, gs.tileTypes.Lava, util.randInt(3, 7));
			lavaTileIndexes.push(tileIndex);
		}
	}

	// First River:
	if (game.rnd.frac() < 0.75) {
		path = this.findPath(lavaTileIndexes[0], lavaTileIndexes[1], {allowDiagonal: false, maxDepth: 1000});
		if (path && path.length > 0) {
			for (i = 0; i < path.length; i += 1) {
				gs.setTileType(path[i], gs.tileTypes.Lava);
			}
		}
	}

	// Second River:
	if (game.rnd.frac() < 0.50) {
		path = this.findPath(lavaTileIndexes[1], lavaTileIndexes[2], {allowDiagonal: false, maxDepth: 1000});
		if (path && path.length > 0) {
			for (i = 0; i < path.length; i += 1) {
				gs.setTileType(path[i], gs.tileTypes.Lava);
			}
		}
	}
};


// IS_GOOD_WALL_INDEX:
// ************************************************************************************************
gs.isGoodWallIndex = function (tileIndex) {
	// No adjacent wall:
	if (!this.getIndexListCardinalAdjacent(tileIndex).some(function (tileIndex) {return gs.getTile(tileIndex).type.name === 'Wall'; })) {
		return false;	
	}
	
	// Has adjacent door:
	if (this.getIndexListCardinalAdjacent(tileIndex).some(function (tileIndex) {return gs.getObj(tileIndex, obj => obj.isDoor()); })) {
		return false;
	}
	
	return true;
};

// CREATE_VINE_PATCH:
// ************************************************************************************************
gs.createVinePatch = function (tileIndex, maxDepth, objectName, percent) {
	var iterFunc;

	percent = percent || 1;
	
	// ITER FUNC:
	// *********************************************************************
	iterFunc = function (x, y, depth) {
		if (depth > maxDepth) {
			return;
		}

		if (gs.isInBounds(x, y)
			&& gs.getTile(x, y).type.passable
			&& !gs.getObj(x, y)
			&& gs.getTile(x, y).type.name !== 'Water'
			&& game.rnd.frac() <= percent) {
			
			if (objectName === 'Water') {
				gs.setTileType({x: x, y: y}, gs.tileTypes.Water);
			} else {
				gs.createObject({x: x, y: y}, objectName);
			}
		}

		if (gs.isIndexOpen(x + 1, y) || gs.getChar(x + 1, y)) {
			iterFunc(x + 1, y, depth + 1);
		}
		if (gs.isIndexOpen(x - 1, y) || gs.getChar(x - 1, y)) {
			iterFunc(x - 1, y, depth + 1);
		}
		if (gs.isIndexOpen(x, y + 1) || gs.getChar(x, y + 1)) {
			iterFunc(x, y + 1, depth + 1);
		}
		if (gs.isIndexOpen(x, y - 1) || gs.getChar(x, y - 1)) {
			iterFunc(x, y - 1, depth + 1);
		}
	};


	iterFunc(tileIndex.x, tileIndex.y, 0);
};


// FLOOD_TILE_TYPE:
// *****************************************************************************
gs.floodTiletype = function (tileIndex, tileType, maxDepth) {
	var area = this.getTile(tileIndex).area,
		floodFunc,
		index,
		fillSpaces;


	// FLOOD FUNC:
	// *************************************************************************
	floodFunc = function (startX, startY) {
		var x, y, iterFunc;

		// ITER FUNC:
		// *********************************************************************
		iterFunc = function (x, y, depth) {
			if (depth > maxDepth) {
				return;
			}

			gs.setTileType({x: x, y: y}, tileType);

			if (gs.isIndexOpen(x + 1, y)) {
				iterFunc(x + 1, y, depth + 1);
			}
			if (gs.isIndexOpen(x - 1, y)) {
				iterFunc(x - 1, y, depth + 1);
			}
			if (gs.isIndexOpen(x, y + 1)) {
				iterFunc(x, y + 1, depth + 1);
			}
			if (gs.isIndexOpen(x, y - 1)) {
				iterFunc(x, y - 1, depth + 1);
			}
		};

		iterFunc(startX, startY, 0);
	};

	// FILL SPACES:
	// *************************************************************************
	fillSpaces = function () {
		var numWaterNeighbours, numWaterWallNeighbours, x, y;

		// NUM WATER WALL NEIGHBOURS:
		// *************************************************************************
		numWaterWallNeighbours = function (x, y) {
			var count = 0;
			count += gs.isInBounds(x + 1, y) && (gs.getTile(x + 1, y).type === tileType || !gs.isIndexOpen(x + 1, y)) ? 1 : 0;
			count += gs.isInBounds(x - 1, y) && (gs.getTile(x - 1, y).type === tileType || !gs.isIndexOpen(x - 1, y)) ? 1 : 0;
			count += gs.isInBounds(x, y + 1) && (gs.getTile(x, y + 1).type === tileType || !gs.isIndexOpen(x, y + 1)) ? 1 : 0;
			count += gs.isInBounds(x, y - 1) && (gs.getTile(x, y - 1).type === tileType || !gs.isIndexOpen(x, y - 1)) ? 1 : 0;
			return count;
		};

		// NUM WATER NEIGHBOURS:
		// *************************************************************************
		numWaterNeighbours = function (x, y) {
			var count = 0;
			count += gs.isInBounds(x + 1, y) && gs.getTile(x + 1, y).type === tileType ? 1 : 0;
			count += gs.isInBounds(x - 1, y) && gs.getTile(x - 1, y).type === tileType ? 1 : 0;
			count += gs.isInBounds(x, y + 1) && gs.getTile(x, y + 1).type === tileType ? 1 : 0;
			count += gs.isInBounds(x, y - 1) && gs.getTile(x, y - 1).type === tileType ? 1 : 0;
			return count;
		};

		
        for (x = 0; x < gs.numTilesX; x += 1) {
            for (y = 0; y < gs.numTilesY; y += 1) {
                if (gs.isIndexOpen(x, y) && numWaterNeighbours(x, y) >= 1 && numWaterWallNeighbours(x, y) >= 3) {
                    gs.setTileType({x: x, y: y}, tileType);
                }
            }
        }
		
	};

	floodFunc(tileIndex.x, tileIndex.y);
	fillSpaces();
};/*global gs, game, console*/
/*jshint esversion: 6*/
'use strict';
var levelFiller = {};


// SECOND_ROOM_DRESSING_PASS:
// This function can be used after most other generation has occured in order to add additional dressing to
// otherwise empty rooms. Note that this occurs after dressRooms, generateGlobalStuff and populateLevel
// ************************************************************************************************
levelFiller.secondRoomDressingPass = function () {
	var countObjects, indexList, tileIndex, fillTypes;
	
	
	
	if (!gs.inArray(gs.zoneName, ['TheOrcFortress', 'TheDarkTemple']) || !gs.areaList) {
		return;
	}
	
	fillTypes = [
		this.fillAreaGrass,
		this.fillAreaRubble,
		this.fillAreaFireShrooms,
	];
	
	countObjects = function (area) {
		var indexList = gs.getIndexInBox(area);
		indexList = indexList.filter(index => gs.getObj(index) || gs.getTile(index).type.name === 'Water');
		return indexList.length;
	};
	
	gs.areaList.forEach(function (area) {
		if (area.type === 'LargeRoom' && countObjects(area) < area.width * area.height * 0.10) {
			util.randElem(fillTypes).call(this, area);
		}
	}, this);
};

// FILL_AREA_FIRE_SHROOMS:
// ************************************************************************************************
levelFiller.fillAreaFireShrooms = function (area) {
	var tileIndex;
	tileIndex = gs.getOpenIndexInArea(area);
	if (tileIndex) {
		gs.spawnShroomTrap(tileIndex);
	}
};

// FILL_AREA_GRASS:
// ************************************************************************************************
levelFiller.fillAreaGrass = function (area) {
	this.fillAreaBrokenFloor(area, 'LongGrass');
};

// FILL_AREA_RUBBLE:
// ************************************************************************************************
levelFiller.fillAreaRubble = function (area) {
	this.fillAreaBrokenFloor(area, 'Rubble');
};

// FILL_AREA_BROKEN_FLOOR:
// ************************************************************************************************
levelFiller.fillAreaBrokenFloor = function (area, objTypeName) {
	var tileIndex, indexList;
	
	tileIndex = gs.getOpenIndexInArea(area);
	if (tileIndex) {
		indexList = gs.getIndexInFlood(tileIndex, gs.isPassable.bind(gs), 5);
		indexList.forEach(function (index) {
			if (gs.getTile(index).type.name === 'Floor' && game.rnd.frac() < 1.0 / gs.distance(index, tileIndex)) {
				gs.setTileType(index, gs.tileTypes.CaveFloor);

				if (!gs.getObj(index) && game.rnd.frac() < 0.75) {
					gs.createObject(index, objTypeName);
				}
			}

		}, this);
	}
};

/*global game, gs, console, util*/
/*global Item*/
/*jshint esversion: 6*/

'use strict';

// LOAD_VAULTS:
// Called from loader in order to load the json files for each vault
// ************************************************************************************************
gs.loadVaults = function () {
	this.createVaultGenerateFuncs();
	
	this.vaultTypes = {
		IronFortressBallista:		{},
		GolemWorkshop: 	{},
		Library: 		{initFunc: this.vaultGenerateFuncs.Library},
		
		// Generic Vaults:
		GenericRoom01:	{tags: ['Generic']},
		GenericRoom02:	{tags: ['Generic']},
		GenericRoom03:	{tags: ['Generic']},
		GenericRoom04:	{tags: ['Generic']},
		GenericRoom05:	{tags: ['Generic']},
		GenericRoom06:	{tags: ['Generic']},
		GenericRoom07:	{tags: ['Generic']},
		GenericRoom08:	{tags: ['Generic']},
        GenericRoom09:	{tags: ['Generic']},
        GenericRoom10:	{tags: ['Generic']},
        GenericRoom11:	{tags: ['Generic']},
        GenericRoom12:	{tags: ['Generic']},
        GenericRoom13:	{tags: ['Generic']},
        GenericRoom14:	{tags: ['Generic']},
        GenericRoom15:	{tags: ['Generic']},
        GenericRoom16:	{tags: ['Generic']},
        GenericRoom17:	{tags: ['Generic'], hasPits: true},
        GenericRoom18:	{tags: ['Generic']},
		GenericRoom19:	{tags: ['Generic']},
		
		// Dungeon (upper levels and orc fortress)
		Dungeon01: {tags: ['Dungeon']},
		Dungeon02: {tags: ['Dungeon']},
		Dungeon03: {tags: ['Dungeon'], dontRotate: true},
		Dungeon04: {tags: ['Dungeon']},
		Dungeon05: {tags: ['Dungeon']},
		Dungeon06: {tags: ['Dungeon']},
		Dungeon07: {tags: ['Dungeon'], dontRotate: true},
		Dungeon08: {tags: ['Dungeon'], dontRotate: true},
		Dungeon09: {tags: ['Dungeon']},
		Dungeon10: {tags: ['Dungeon'], dontRotate: true},
		
		// Iron Fortress:
		IronFortress01: {tags: ['TheIronFortress'], dontRotate: true},
		IronFortress02: {tags: ['TheIronFortress'], dontRotate: true},
		
		// The Crypt:
		TheCrypt01: {tags: ['TheCrypt'], dontRotate: true},
		TheCrypt02: {tags: ['TheCrypt'], dontRotate: true},
		TheCrypt03: {tags: ['TheCrypt'], dontRotate: true},
		TheCrypt04: {tags: ['TheCrypt']},
		TheCrypt05: {tags: ['TheCrypt']},
		TheCrypt06: {tags: ['TheCrypt']},
		TheCrypt07: {tags: ['TheCrypt']},
		TheCrypt08: {tags: ['TheCrypt'], dontRotate: true},
		TheCrypt09: {tags: ['TheCrypt']},
		TheCrypt10: {tags: ['TheCrypt']},
		TheCrypt11: {tags: ['TheCrypt']},
		TheCrypt12: {tags: ['TheCrypt']},
		TheCrypt13: {tags: ['TheCrypt'], dontRotate: true},
		TheCrypt14: {tags: ['TheCrypt']},
		TheCrypt15: {tags: ['TheCrypt']},
		
		// The Arcane Tower:
		TheArcaneTower01: {tags: ['TheArcaneTower']},
		TheArcaneTower02: {tags: ['TheArcaneTower']},
		
		
		// Floating Features:
		BallistaRoom: 		{isFloatingFeature: true},
		OrcPriestTemple:	{isFloatingFeature: true},
		OrcFortress:		{isFloatingFeature: true},
		GoblinFarm:			{isFloatingFeature: true},
		TreasureTrap:		{isFloatingFeature: true},
        FireTrap:           {isFloatingFeature: true},
        WishFountain:       {isFloatingFeature: true},
        MerchantShop:       {isFloatingFeature: true, initFunc: this.vaultGenerateFuncs.MerchantShop},
        PrisonRoom:         {isFloatingFeature: true},
        IceRoom:            {isFloatingFeature: true},
        BigPitTrap:         {isFloatingFeature: true},
        PitFallRoom:        {isFloatingFeature: true},
        IglooRoom:          {isFloatingFeature: true},
		
		// Feast Hall:
		FeastHallMain01:	{path: 'assets/maps/vaults/FeastHall/Hall01.json'},

	};
	
	this.nameTypes(this.vaultTypes);
	
	this.forEachType(this.vaultTypes, function (vaultType) {
		if (vaultType.path) {
			game.load.json(vaultType.name, vaultType.path);
		}
		else if (vaultType.isFloatingFeature) {
			game.load.json(vaultType.name, 'assets/maps/floating-features/' + vaultType.name + '.json');
		}
		else {
			game.load.json(vaultType.name, 'assets/maps/vaults/' + vaultType.name + '.json');
		}
		
		
		if (!vaultType.tags) {
			vaultType.tags = [];
		}
		
		/*
		if (this.vaultGenFuncs.hasOwnProperty(vaultType.name)) {
			vaultType.genFunc = gs.vaultGenFuncs[vaultType.name];
		}
		*/
	}, this);
};

// CREATE_VAULT_TYPES:
// Called in gameState create, after the json for each vault has been loaded.
// ************************************************************************************************
gs.createVaultTypes = function () {
	this.forEachType(this.vaultTypes, function (vaultType) {
		var data = game.cache.getJSON(vaultType.name);
		vaultType.width = data.width;
		vaultType.height = data.height;
		vaultType.allowRotate = Boolean(!vaultType.dontRotate);
		
		// Determine if contains a pit:
		/*
		for (let x = 0; x < vaultType.width; x += 1) {
			for (let y = 0; y < vaultType.height; y += 1) {
				let frame = data.layers[0].data[y * data.width + x] - 1;
				let typeName = this.getNameFromFrame(frame, this.tileTypes);
				
				if (typeName === 'Pit' || typeName === 'CavePit') {
					vaultType.hasPits = true;
					console.log(vaultType.name);
				}
			}
		}
		*/
	}, this);
};

// CREATE_VAULT_GENERATE_FUNCS:
// ************************************************************************************************
gs.createVaultGenerateFuncs = function () {
	this.vaultGenerateFuncs = {};
	
	// Library:
	this.vaultGenerateFuncs.Library = function (area) {
		let itemNameList;
		
		gs.createCrystalChestGroup();
		
		// Select 3 different tomes:
		itemNameList = gs.itemTypeDropRate.Books.map(e => e.name);
		itemNameList = gs.randSubset(itemNameList, 3);
		
		
		gs.getIndexInBox(area).forEach(function (index) {
			if (gs.getObj(index, obj => obj.type.name === 'CrystalChest')) {
				let crystalChest = gs.getObj(index);
				
				crystalChest.groupId = gs.nextCrystalChestGroupId;
				crystalChest.item = Item.createItem(itemNameList.pop());
			}
		}, this);
	};
	
	// Merchant shop:
	this.vaultGenerateFuncs.MerchantShop = function (area) {
		gs.stockMerchant();
	};
};

// RAND_VAULT_TYPE:
// ************************************************************************************************
gs.randVaultType = function (minWidth, minHeight, maxWidth, maxHeight, tags) {
	var list = [];
	

	this.forEachType(this.vaultTypes, function (vaultType) {
		/*
		if (gs.inArray(vaultType.fileName, gs.closeVaultList)) {
			return;
		}
		*/
		// Skip pits on last levels:
		if (gs.zoneLevel === gs.zoneType().numLevels && vaultType.hasPits) {
			return;
		}
		if (!vaultType.neverChoose && (!tags || gs.arrayIntersect(tags, vaultType.tags).length > 0)) {
		
			if (vaultType.width >= minWidth && vaultType.width <= maxWidth && vaultType.height >= minHeight && vaultType.height <= maxHeight) {
				list.push({vaultTypeName: vaultType.name});
			}

			if (vaultType.allowRotate && vaultType.height >= minWidth && vaultType.height <= maxWidth && vaultType.width >= minHeight && vaultType.width <= maxHeight) {
				list.push({vaultTypeName: vaultType.name, rotate: true});
			}
		}
	}, this);
	
	return list.length > 0 ? util.randElem(list) : null;
};
/*global gs, game, util, console*/
/*jshint laxbreak: true, loopfunc: true, esversion: 6*/
'use strict';
var frameSelector = {};

frameSelector.init = function () {
	this.createWallMasks();
	this.createPitMasks();
};

// SELECT_FRAME:
// ************************************************************************************************
frameSelector.selectFrame = function (tileType) {
	if (!gs.zoneType().tileFrames) {
		throw gs.zoneName + 'does not have valid tileFrames';
	}
	
	if (!tileType) {
		throw 'selectFrame failed, invalid tileType: ' + tileType;
	}
	
	// Use zone specific frame:
	if (gs.zoneType().tileFrames[tileType.name]) {
		return gs.zoneType().tileFrames[tileType.name].base;
	}
	// Use Default Frame:
	else {
		return tileType.frame;
	}
};

// SET_ALTERNATE_TILE_FRAMES:
// ************************************************************************************************
frameSelector.setAlternateTileFrames = function (startX, startY, endX, endY) {
	var x, y;
	
	startX = startX || 0;
	startY = startY || 0;
	endX = endX || gs.numTilesX;
	endY = endY || gs.numTilesY;

	for (x = startX; x < endX; x += 1) {
		for (y = startY; y < endY; y += 1) {
			if (gs.isInBounds(x, y)) {
				// Wall Frames:
				if (gs.getTile(x, y).type === gs.tileTypes.Wall) {
					this.selectWallFrame(x, y);
				}
				
				// Cave Wall Frames:												  
				if (gs.getTile(x, y).type === gs.tileTypes.CaveWall) {
					this.selectWallFrame(x, y);
				}
				
				// Pit Frames:
				if (gs.getTile(x, y).type === gs.tileTypes.Pit || gs.getTile(x, y).type === gs.tileTypes.CavePit) {
					this.selectPitFrame(x, y);
				}

				// Alternate Frames:
				if (gs.getTile(x, y).frame === this.selectFrame(gs.getTile(x, y).type)
					&& gs.zoneType().tileFrames[gs.getTile(x, y).type.name]
					&& gs.zoneType().tileFrames[gs.getTile(x, y).type.name].alternate
					&& util.frac() <= 0.30) {

					gs.getTile(x, y).frame = util.randElem(gs.zoneType().tileFrames[gs.getTile(x, y).type.name].alternate);
				}

				if (isNaN(gs.getTile(x, y).frame)) {
					console.log(gs.zoneType().tileFrames[gs.getTile(x, y).type.name].alternate);
					console.log(gs.getTile(x, y));
					throw 'frame was set to NaN';
				}

				// Object Frames:
				if (gs.getObj(x, y) && gs.zoneType().tileFrames[gs.getObj(x, y).type.name]) {
					gs.getObj(x, y).sprite.frame = gs.zoneType().tileFrames[gs.getObj(x, y).type.name].base;
				}
			}
		}
	}
	
	
};



// SET_WATER_TILE_FRAMES:
// ************************************************************************************************
frameSelector.setWaterTileFrames = function (startX, startY, endX, endY) {
	var baseFrame = gs.tileTypes.Water.frame,
		isFloor,
		isCave,
		offset;
	
	startX = startX || 0;
	startY = startY || 0;
	endX = endX || gs.numTilesX;
	endY = endY || gs.numTilesY;
	
	isFloor = function (x, y) {
		return !gs.isInBounds(x, y) 
			|| gs.getTile(x, y).type.name === 'Floor' 
			|| gs.getTile(x, y).type.name === 'Wall'
			|| gs.getTile(x, y).type.name === 'Pit';
	};
	
	isCave = function (x, y) {
		return !gs.isInBounds(x, y) 
			|| gs.inArray(gs.getTile(x, y).type.name, ['CaveFloor', 'CavePit', 'CaveWall']);
	};
		
	
	gs.getIndexInBox(startX, startY, endX, endY).forEach(function (index) {
		if (gs.getTile(index).type.name === 'Water' || gs.getTile(index).type.name === 'Lava') {
			baseFrame = this.selectFrame(gs.getTile(index).type);
			offset = 0;
			
			// Dungeon:
			if (isFloor(index.x - 1, index.y) && isFloor(index.x + 1, index.y) && isFloor(index.x, index.y - 1)) {
				offset = 13;
			}
			else if (isFloor(index.x - 1, index.y) && isFloor(index.x + 1, index.y) && isFloor(index.x, index.y + 1)) {
				offset = 14;
			}
			else if (isFloor(index.x, index.y - 1) && isFloor(index.x, index.y + 1) && isFloor(index.x - 1, index.y)) {
				offset = 11;
			}
			else if (isFloor(index.x, index.y - 1) && isFloor(index.x, index.y + 1) && isFloor(index.x + 1, index.y)) {
				offset = 12;
			}
			else if (isFloor(index.x - 1, index.y) && isFloor(index.x + 1, index.y)) {
				offset = 10;
			}
			else if (isFloor(index.x, index.y - 1) && isFloor(index.x, index.y + 1)) {
				offset = 9;
			}
			else if (isFloor(index.x - 1, index.y) && isFloor(index.x, index.y - 1)) {
				offset = 5;
			}
			else if (isFloor(index.x + 1, index.y) && isFloor(index.x, index.y - 1)) {
				offset = 6;
			}
			else if (isFloor(index.x - 1, index.y) && isFloor(index.x, index.y + 1)) {
				offset = 7;
			}
			else if (isFloor(index.x + 1, index.y) && isFloor(index.x, index.y + 1)) {
				offset = 8;
			}
			else if (isFloor(index.x - 1, index.y)) {
				offset = 3;
			}
			else if (isFloor(index.x + 1, index.y)) {
				offset = 4;
			}
			else if (isFloor(index.x, index.y - 1)) {
				offset = 1;
			}
			else if (isFloor(index.x, index.y + 1)) {
				offset = 2;
			}
			
			// Cave
			if (isCave(index.x - 1, index.y) && isCave(index.x + 1, index.y) && isCave(index.x, index.y - 1)) {
				offset = 27 + 18;
			}
			else if (isCave(index.x - 1, index.y) && isCave(index.x + 1, index.y) && isCave(index.x, index.y + 1)) {
				offset = 28 + 18;
			}
			else if (isCave(index.x, index.y - 1) && isCave(index.x, index.y + 1) && isCave(index.x - 1, index.y)) {
				offset = 25 + 18;
			}
			else if (isCave(index.x, index.y - 1) && isCave(index.x, index.y + 1) && isCave(index.x + 1, index.y)) {
				offset = 26 + 18;
			}
			else if (isCave(index.x - 1, index.y) && isCave(index.x + 1, index.y)) {
				offset = 24 + 18;
			}
			else if (isCave(index.x, index.y - 1) && isCave(index.x, index.y + 1)) {
				offset = 23 + 18;
			}
			else if (isCave(index.x - 1, index.y) && isCave(index.x, index.y - 1)) {
				offset = 19 + 18;
			}
			else if (isCave(index.x + 1, index.y) && isCave(index.x, index.y - 1)) {
				offset = 20 + 18;
			}
			else if (isCave(index.x - 1, index.y) && isCave(index.x, index.y + 1)) {
				offset = 21 + 18;
			}
			else if (isCave(index.x + 1, index.y) && isCave(index.x, index.y + 1)) {
				offset = 22 + 18;
			}
			else if (isCave(index.x - 1, index.y)) {
				offset = 17 + 18;
			}
			else if (isCave(index.x + 1, index.y)) {
				offset = 18 + 18;
			}
			else if (isCave(index.x, index.y - 1)) {
				offset = 15 + 18;
			}
			else if (isCave(index.x, index.y + 1)) {
				offset = 16 + 18;
			}
			
			
			gs.getTile(index).frame = baseFrame + offset;
		}
	}, this);
};



// DRESS_FLOOR_BORDER_TILES:
// Based on the presence of solid walls
// ************************************************************************************************
frameSelector.dressFloorBorderTiles = function () {
	var isWall,
		isSolid,
		baseFrame;
		
	isSolid = function (x, y) {
		return !gs.getTile(x, y) || !gs.getTile(x, y).type.passable;
	};
		
	// Need to test if the index is a wall or a hallway
	isWall = function (x, y) {		
		return isSolid(x, y) || (isSolid(x + 1, y) && isSolid(x - 1, y)) || (isSolid(x, y + 1) && isSolid(x, y - 1));
	};
	
	
	gs.getAllIndex().forEach(function (index) {
		if (gs.getTile(index).type.name === 'Floor' && gs.getTile(index).type.passable && gs.getTile(index).frame === this.selectFrame(gs.tileTypes.Floor)) {
			baseFrame = gs.getTile(index).frame;
			
			
			
			if (isWall(index.x - 1, index.y) && isWall(index.x, index.y - 1) && !isWall(index.x + 1, index.y + 1) && !isWall(index.x + 1, index.y) && !isWall(index.x, index.y + 1)) {
				gs.getTile(index).frame = baseFrame + 10;
			}
			else if (isWall(index.x + 1, index.y) && isWall(index.x, index.y - 1) && !isWall(index.x - 1, index.y + 1) && !isWall(index.x - 1, index.y) && !isWall(index.x, index.y + 1)) {
				gs.getTile(index).frame = baseFrame + 11;
			}
			else if (isWall(index.x - 1, index.y) && isWall(index.x, index.y + 1) && !isWall(index.x + 1, index.y - 1) && !isWall(index.x + 1, index.y) && !isWall(index.x, index.y - 1)) {
				gs.getTile(index).frame = baseFrame + 8;
			}
			else if (isWall(index.x + 1, index.y) && isWall(index.x, index.y + 1) && !isWall(index.x - 1, index.y - 1) && !isWall(index.x - 1, index.y) && !isWall(index.x, index.y - 1)) {
				gs.getTile(index).frame = baseFrame + 9;
			}
			else if (isWall(index.x - 1, index.y) && !isWall(index.x + 1, index.y) && !isWall(index.x, index.y + 1) && !isWall(index.x, index.y - 1)) {
				gs.getTile(index).frame = baseFrame + 7;
			}
			else if (isWall(index.x + 1, index.y) && !isWall(index.x - 1, index.y) && !isWall(index.x, index.y + 1) && !isWall(index.x, index.y - 1)) {
				gs.getTile(index).frame = baseFrame + 6;
			}
			else if (isWall(index.x, index.y - 1) && !isWall(index.x, index.y + 1) && !isWall(index.x + 1, index.y) && !isWall(index.x - 1, index.y)) {
				gs.getTile(index).frame = baseFrame + 5;
			}
			else if (isWall(index.x, index.y + 1) && !isWall(index.x, index.y - 1) && !isWall(index.x + 1, index.y) && !isWall(index.x - 1, index.y)) {
				gs.getTile(index).frame = baseFrame + 4;
			}
		}
		
		// Doors and halls:
		if (gs.getTile(index).type.name === 'Floor' &&
		   ((isSolid(index.x + 1, index.y) && isSolid(index.x - 1, index.y)) ||
		   (isSolid(index.x, index.y + 1) && isSolid(index.x, index.y - 1)))) {
			
			gs.getTile(index).frame = baseFrame + 3;
		}
	}, this);
};

// CREATE_WALL_MASKS:
// During this function later masks can overwrite earlier masks
// Use later masks to specify more specific masks
// ************************************************************************************************
frameSelector.createWallMasks = function () {
	var X = 2;
	
	this.wallMasks = [
		{mask: [[X, 1, X],
				[0, 1, 1],
				[0, 0, X]],
		 offset: 1
		},
		{mask: [[X, 1, X],
			    [1, 1, 0],
				[X, 0, 0]],
		 offset: 2
		},
		{mask: [[X, 1, X],
			    [0, 1, 1],
				[X, 1, X]],
		 offset: 3
		},
		{mask: [[X, 1, X],
			    [1, 1, 0],
				[X, 1, X]],
		 offset: 4
		},
		{mask: [[0, 0, X],
			    [0, 1, 1],
				[X, 1, X]],
		 offset: 5
		},
		{mask: [[X, 0, X],
			    [1, 1, 1],
				[X, 1, X]],
		 offset: 6
		},
		{mask: [[X, 0, 0],
			    [1, 1, 0],
				[X, 1, X]],
		 offset: 7
		},
		
		{mask: [[1, 1, X],
			    [1, 1, 1],
				[X, 1, 0]],
		 offset: 4
		},
		{mask: [[X, 1, 1],
			    [1, 1, 1],
				[0, 1, X]],
		 offset: 3
		},
		
		{mask: [[X, 1, 0],
			    [1, 1, 1],
				[1, 1, X]],
		 offset: 10
		},
		{mask: [[0, 1, X],
			    [1, 1, 1],
				[X, 1, 1]],
		 offset: 11
		},
		{mask: [[X, 1, X],
			    [0, 1, 0],
				[X, 0, X]],
		 offset: 12
		},
		{mask: [[0, 1, 0],
			    [1, 1, 0],
				[0, 1, 0]],
		 offset: 13
		},
		{mask: [[0, 1, X],
			    [0, 1, 1],
				[0, 1, 0]],
		 offset: 13
		},
		{mask: [[X, 1, X],
			    [0, 1, 0],
				[X, 1, X]],
		 offset: 13
		},
		{mask: [[1, 1, X],
			    [1, 1, 0],
				[0, 1, 0]],
		 offset: 13
		},
		{mask: [[0, 1, 1],
			    [0, 1, 1],
				[1, 1, 0]],
		 offset: 13
		},
		{mask: [[X, 0, X],
			    [0, 1, 0],
				[X, 1, X]],
		 offset: 14
		},
		{mask: [[0, 0, 0],
			    [1, 1, 1],
				[0, 1, 0]],
		 offset: 14
		},
		{mask: [[0, 0, 0],
			    [1, 1, 0],
				[0, 1, 0]],
		 offset: 14
		},
		{mask: [[0, 1, 1],
			    [1, 1, 1],
				[0, 1, 1]],
		 offset: 3
		},
		{mask: [[0, 0, 0],
			    [1, 1, 1],
				[1, 1, 0]],
		 offset: 7
		},
		{mask: [[0, 0, X],
			    [1, 1, 1],
				[0, 1, 1]],
		 offset: 5
		},
		{mask: [[1, 1, 0],
			    [1, 1, 1],
				[1, 1, 0]],
		 offset: 4
		},
		{mask: [[0, 0, 1],
			    [1, 1, 1],
				[1, 1, 0]],
		 offset: 7
		},
		{mask: [[1, 0, 0],
			    [1, 1, 1],
				[0, 1, 0]],
		 offset: 14
		},
		{mask: [[1, 1, 1],
			    [0, 1, 1],
				[0, 1, 0]],
		 offset: 13
		},
		{mask: [[1, 1, 0],
			    [1, 1, 0],
				[0, 1, 1]],
		 offset: 13
		},
		{mask: [[0, 0, 1],
			    [1, 1, 1],
				[0, 1, 0]],
		 offset: 14
		},
		{mask: [[0, 1, 0],
			    [1, 1, 1],
				[0, 1, 0]],
		 offset: 13
		},
		{mask: [[1, 0, 0],
			    [1, 1, 0],
				[0, 1, 0]],
		 offset: 14
		},
		{mask: [[0, 1, 1],
			    [1, 1, 1],
				[1, 1, 0]],
		 offset: 7
		},
		{mask: [[1, 1, 1],
			    [1, 1, 1],
				[0, 1, 0]],
		 offset: 14
		},
		
		
		// Corner edge correction
		{mask: [[X, X, X],
			    [1, 1, X],
				[1, 0, 0]],
		 offset: 1
		},
		
		{mask: [[X, X, X],
			    [X, 1, 1],
				[0, 0, 1]],
		 offset: 2
		},
		
		// Corners:
		{mask: [[0, 1, 0],
			    [1, 1, 1],
				[1, 1, 1]],
		 offset: 9
		},
		
		// Etc:
		{mask: [[0, 0, 0],
			    [0, 1, 1],
				[0, 1, 0]],
		 offset: 14
		},
		
		{mask: [[0, 1, X],
			    [1, 1, 0],
				[1, 1, 0]],
		 offset: 15
		},
		
		{mask: [[X, 1, 0],
			    [0, 1, 1],
				[0, 1, 1]],
		 offset: 16
		},
		
		{mask: [[0, 1, 1],
			    [0, 1, 1],
				[0, 1, 0]],
		 offset: 13
		},
		
		{mask: [[0, 1, 0],
			    [0, 1, 1],
				[1, 1, 1]],
		 offset: 16
		},
	
		{mask: [[0, 1, 0],
			    [1, 1, 0],
				[1, 1, 1]],
		 offset: 15
		},
		
		{mask: [[1, 0, 0],
			    [1, 1, 1],
				[0, 1, 1]],
		 offset: 5
		},
		
		{mask: [[0, 0, 0],
			    [1, 1, 0],
				[0, 1, 1]],
		 offset: 14
		},
		
		{mask: [[1, 1, 0],
			    [1, 1, 1],
				[0, 1, 1]],
		 offset: 5
		},
		/*
		// Top and bottom wall:
		{mask: [[X, 0, X],
			    [X, 1, X],
				[X, 0, X]],
		 offset: 31
		},
		*/
		
	];
};

// SELECT_WALL_FRAMES
// ************************************************************************************************
frameSelector.selectWallFrame = function (x, y) {
	var i, frame;

	frame = gs.getTile(x, y).frame;
	
	if (!gs.isBaseTileFrame(frame)) {
		return;
	}
	
	if (!this.matchMask(x, y, [[1,1,1],[1,1,1],[1,1,1]])) {
		for (i = 0; i < this.wallMasks.length; i += 1) {
			if (this.matchMask(x, y, this.wallMasks[i].mask)) {
				frame = gs.getTile(x, y).frame + this.wallMasks[i].offset;
			}
		}
	}
	
	gs.getTile(x, y).frame = frame;
};

// CREATE_PIT_MASKS:
// During this function later masks can overwrite earlier masks
// Use later masks to specify more specific masks
// ************************************************************************************************
frameSelector.createPitMasks = function () {
	var X = 2;
	
	this.pitMasks = [
		// Straight:
		{mask: [[X, 0, X],
				[1, 1, 1],
				[X, 1, X]],
		 offset: 2
		},
		
		{mask: [[X, 1, X],
				[0, 1, 1],
				[X, 1, X]],
		 offset: 4
		},
		
		{mask: [[X, 1, X],
				[1, 1, 0],
				[X, 1, X]],
		 offset: 5
		},
		
		{mask: [[X, 1, X],
				[1, 1, 1],
				[X, 0, X]],
		 offset: 7
		},
		
		// Inner Corner:
		{mask: [[0, 0, X],
				[0, 1, X],
				[X, X, X]],
		 offset: 1
		},
		
		{mask: [[X, 0, 0],
				[X, 1, 0],
				[X, X, X]],
		 offset: 3
		},
		
		{mask: [[X, X, X],
				[0, 1, X],
				[0, 0, X]],
		 offset: 6
		},
		
		{mask: [[X, X, X],
				[X, 1, 0],
				[X, 0, 0]],
		 offset: 8
		},
		
		// Outter Corner:
		{mask: [[X, X, X],
				[X, 1, 1],
				[X, 1, 0]],
		 offset: 9
		},
		
		{mask: [[X, X, X],
				[1, 1, X],
				[0, 1, X]],
		 offset: 10
		},
		
		{mask: [[X, 1, 0],
				[X, 1, 1],
				[X, X, X]],
		 offset: 11
		},
		
		{mask: [[0, 1, X],
				[1, 1, X],
				[X, X, X]],
		 offset: 12
		},
	];
};

// SELECT_PIT_FRAME:
// ************************************************************************************************
frameSelector.selectPitFrame = function (x, y) {
	var i, frame, pred, name, baseFrame;
	
	baseFrame = this.selectFrame(gs.getTile(x, y).type);
	frame = baseFrame;
	name = gs.getTile(x, y).type.name;
	
	pred = function (x, y) {
		return !gs.getTile(x, y).type.isPit
			&& gs.getTile(x, y).type.name !== 'Bridge' 
			&& gs.getTile(x, y).type.name !== 'HalfWall';
	};
	
	if (!this.matchMask(x, y, [[1,1,1],[1,1,1],[1,1,1]], pred)) {
		for (i = 0; i < this.pitMasks.length; i += 1) {
			if (this.matchMask(x, y, this.pitMasks[i].mask, pred)) {
				frame = baseFrame + this.pitMasks[i].offset;
			}
		}
	}
	
	gs.getTile(x, y).frame = frame;
};

// MATCH_MASK:
// ************************************************************************************************
frameSelector.matchMask = function (x, y, bitMask, pred) {
	var itX, itY;
	
	pred = pred || function (x, y) {
		return gs.getTile(x, y).type.passable || gs.getTile(x, y).type.name === 'Pit';
	};
	
	
	for (itX = 0; itX < 3; itX += 1) {
		for (itY = 0; itY < 3; itY += 1) {
			if (bitMask[itY][itX] === 1 && gs.isInBounds(x + itX - 1, y + itY - 1) && pred(x + itX - 1, y + itY - 1)) {
				return false;
			}
			if (bitMask[itY][itX] === 0 && (!gs.isInBounds(x + itX - 1, y + itY - 1) || !pred(x + itX - 1, y + itY - 1))) {
				return false;
			}
		}
	}
	
	return true;
};/*global game, gs, Phaser, console, frameSelector, util*/
/*global Item*/
/*global levelFiller, roomGenerator, levelController, levelVerification*/
/*global NUM_TILES_X, NUM_TILES_Y, TIER_III_ZONES*/
/*global featureGenerator, baseGenerator*/
/*global bspGenerator, sewerRoadsGenerator, sewerTunnelsGenerator, caveGenerator, rogueGenerator, jungleGenerator, cryptGenerator, arcaneGenerator*/
/*global cycleGenerator, swampGenerator, caveRoomGenerator, ringGenerator, cave2Generator, lairGenerator, feastHallGenerator*/
/*global STATIC_LEVEL_CHANCE, */
/*global SPAWN_STREAMER_PERCENT, DOUBLE_STREAMER_PERCENT, MIN_STREAMER_LENGTH, STREAMER_MIN_LEVEL*/
/*jshint white: true, esversion: 6, laxbreak: true, loopfunc: true*/

'use strict';

gs.generateLevel = function () {
	var success = false,
		attempt = 0;
	
	while (!success) {
		// Seed Generator:
		// Note we must add the attempt in order to not just keep regening same seed
		if (this.seed) {
			game.rnd.sow([this.seed + this.zoneName + this.zoneLevel + attempt]);
		}
		
		success = this.generateLevelFunc();
		
		if (!success) {
			console.log('Failed to generate level, attempting again');
			gs.destroyLevel();
			attempt += 1;
		}
	}
	
	return true;
};

// GENERATE_LEVEL:
// ************************************************************************************************
gs.generateLevelFunc = function () {
	this.isStaticLevel = false;
	this.dressingTypeCounts = {};
	this.staticLevelName = null;
	this.levelTriggers = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
	this.areaList = [];
	this.shouldPopulateLevel = true;
	featureGenerator.resetFeatureTypeCounts();
	
	// TEST_LEVEL:
	if (gs.debugProperties.testLevel || this.zoneName === 'TestLevel') {
		this.loadJSONLevel('TestLevel');
	}
	// END_LEVEL:
	else if (this.shouldLoadEndLevel()) {
		this.loadEndLevel();
	}
	// STATIC_LEVEL:
	else if (this.shouldLoadStaticLevel()) {
		this.loadStaticLevel();
	}
	// RANDOM_LEVEL:
	else {
		if (!this.generateRandomLevel()) {
			return false;
		}
	}
	
	// Place Stairs:
	if (!this.generateStairs()) {
		console.log('failed to place stairs');
		return false;	
	}
	
	// Generate Global Stuff:
	if (this.debugProperties.generateGlobalStuff && this.zoneName !== 'TestLevel') {
		this.generateGlobalStuff();
	}
	
	// Trim Hazards (call before setting water frames):
	// Call before populating level (so lava spawning monsters can choose valid spawns)
	if (!this.isStaticLevel) {
		this.trimHazards();
	}
	
	// Populate Level (NPCs):
	if (this.debugProperties.spawnMobs && this.shouldPopulateLevel) {
		if (this.zoneName === 'TestLevel') {
			this.populateTestLevel();
		}
		else {	
			this.populateLevel();
			this.spawnUniques();
		}
	}
	
	// Calling before secondRoom pass (to maintain pool boarders)
	frameSelector.setWaterTileFrames();
	
	// Second Pass Room Dressing:
	levelFiller.secondRoomDressingPass();
	
	// Trim side rooms:
	this.trimDoors();
	this.trimObjects();
	
	// Set Alternate Tile Frames:
	frameSelector.setAlternateTileFrames();
	
	this.placeWallDressing();
	
	if (!this.isStaticLevel && this.zoneName !== 'TheArcaneTower' && this.zoneName !== 'TestLevel' && !levelVerification.isConnected()) {
		//console.log('Disconnected level detected. Seed: ' + this.seed + ', ' + this.zoneName + ', ' + this.zoneLevel);
		return false;
	}
	
	levelController.onGenerateLevel();
	
	
	
	return true;
};

// SHOULD_LOAD_STATIC_LEVEL:
// ************************************************************************************************
gs.shouldLoadStaticLevel = function () {
	// Never static level on first level of tierIII (to make room for library):
	if (gs.inArray(gs.zoneName, TIER_III_ZONES) && gs.zoneLevel === 1) {
		return false;
	}
	
	return this.dangerLevel() > 1 && this.getStaticLevelList().length > 0 && util.frac() < STATIC_LEVEL_CHANCE;
};

// LOAD_STATIC_LEVEL:
// Call to load a static level instead of proc-genning a dungeon:
// ************************************************************************************************
gs.loadStaticLevel = function () {
	this.staticLevelName = util.randElem(this.getStaticLevelList()).fileName;
	this.loadJSONLevel(this.staticLevelName);
	this.isStaticLevel = true;
	frameSelector.dressFloorBorderTiles();
	
	this.previouslySpawnedStaticLevels.push(this.staticLevelName);
};

// SHOULD_LOAD_END_LEVEL:
// ************************************************************************************************
gs.shouldLoadEndLevel = function () {
	return this.zoneLevel === 4 && gs.inArray(this.zoneName, ['TheSewers', 'TheArcaneTower', 'TheCore', 'TheIceCaves', 'VaultOfYendor']);
};

// LOAD_END_LEVEL:
// ************************************************************************************************
gs.loadEndLevel = function () {
	
	// THE_SEWERS_END_LEVEL:
	if (this.zoneName === 'TheSewers' && this.zoneLevel === 4) {
		this.staticLevelName = util.randElem(['TheSewers-EndLevel01', 'TheSewers-EndLevel02']);		
	}
	// ARCANE_TOWER_END_LEVEL:
	else if (this.zoneName === 'TheArcaneTower' && this.zoneLevel === 4) {
		this.staticLevelName = util.randElem(['TheArcaneTower-EndLevel01', 'TheArcaneTower-EndLevel02']);
		this.shouldPopulateLevel = false;
	}
	// THE_CORE_END_LEVEL:
	else if (this.zoneName === 'TheCore' && this.zoneLevel === 4) {
		this.staticLevelName = util.randElem(['TheCore-EndLevel01', 'TheCore-EndLevel02']);
	}
	// THE_ICE_CAVES_END_LEVEL:
	else if (this.zoneName === 'TheIceCaves' && this.zoneLevel === 4) {
		this.staticLevelName = util.randElem(['TheIceCaves-EndLevel01', 'TheIceCaves-EndLevel02']);
	}
	// VAULT_OF_YENDOR_END_LEVEL:
	else if (this.zoneName === 'VaultOfYendor' && this.zoneLevel === 4) {
		this.staticLevelName = util.randElem(['VaultOfYendor-EndLevel01', 'VaultOfYendor-EndLevel02']);
		this.shouldPopulateLevel = false;
	}
	
	this.loadJSONLevel(this.staticLevelName);
	this.isStaticLevel = true;
	frameSelector.dressFloorBorderTiles();
};

// GENERATE_RANDOM_LEVEL:
// ************************************************************************************************
gs.generateRandomLevel = function () {
	var generator, generatorFlags = {};
	
	generator = this.chooseRandom(this.zoneType().generators);
	
	// THE_ORC_FORTRESS:
	if (this.zoneName === 'TheOrcFortress' && gs.zoneLevel === 4 && util.frac() < 0.25) {
		generator = lairGenerator;
	}
	// THE_DARK_TEMPLE:
	else if (this.zoneName === 'TheDarkTemple' && gs.zoneLevel === 1) {
		generator = cycleGenerator;
		generatorFlags = {includeVaults: ['Library']};
	}
	// THE_IRON_FORTRESS:
	else if (this.zoneName === 'TheIronFortress' && gs.levelFeatures.PitTurret && game.rnd.frac() <= 1/12) {
		generatorFlags = {PitTurret: true};
		gs.levelFeatures.PitTurret = false;
		generator = rogueGenerator;
	}
	// THE_ARCANE_TOWER:
	else if (this.zoneName === 'TheArcaneTower' && gs.levelFeatures.GolemWorkshop && game.rnd.frac() <= 1/12) {
		generatorFlags = {GolemWorkshop: true};
		gs.levelFeatures.GolemWorkshop = false;
		generator = arcaneGenerator;
	}
	// THE_CRYPT:
	else if (this.zoneName === 'TheCrypt' && gs.zoneLevel === 1) {
		generator = cycleGenerator;
		generatorFlags = {includeVaults: ['Library']};
	}
	
	// Clear the tileMap before generation:
	gs.initiateTileMap();

	if (!generator.generate(generatorFlags)) {
		return false;
	}

	if (this.zoneType().spawnPits && this.zoneLevel < 4) {
		baseGenerator.replaceIslands(gs.createBox(0, 0, this.numTilesX, this.numTilesY));
	}
	
	

	this.trimDiagonalWalls();
	
	frameSelector.dressFloorBorderTiles();

	// Dress Rooms:
	featureGenerator.placeSpecialFeatures();
	this.dressRooms();
	roomGenerator.dressRooms();
	featureGenerator.placeDressingFeatures();
	
	// Streamers:
	this.streamer = false;
	if (this.dangerLevel() >= STREAMER_MIN_LEVEL && this.zoneType().spawnStreamers && game.rnd.frac() < SPAWN_STREAMER_PERCENT) {	
		this.createStreamer();
		this.streamer = true;

		if (game.rnd.frac() < DOUBLE_STREAMER_PERCENT) {
			this.createStreamer();
		}
	}
	
	this.trimPits();
	
	return true;
};

// GENERATE_STAIRS:
// Returns false upon failure
// ************************************************************************************************
gs.generateStairs = function () {
	var branches, success = true;
	
	// Brach Down Stairs:
	branches = gs.zoneConnections.filter(branch => branch.fromZoneName === gs.zoneName && branch.fromZoneLevel === gs.zoneLevel);
	branches = branches.filter(branch => gs.inArray(branch.toZoneName, gs.branches));
	branches.forEach(function (branch) {
		if (!gs.placeStairs('DownStairs', branch.toZoneName, branch.toZoneLevel, 0)) {
			success = false;
		}
	}, this);
	
	// Branch Up Stairs:
	branches = gs.zoneConnections.filter(branch => branch.toZoneName === gs.zoneName && branch.toZoneLevel === gs.zoneLevel);
	branches = branches.filter(branch => gs.inArray(branch.fromZoneName, gs.branches));
	branches.forEach(function (branch) {
		if (!gs.placeStairs('UpStairs', branch.fromZoneName, branch.fromZoneLevel, 3)) {
			success = false;
		}
	}, this);
	
	// Up stairs only if not first level:
	if (this.zoneLevel > 1) {
		if (!this.placeStairs('UpStairs', this.zoneName, this.zoneLevel - 1, 3)) {
			return false;
		}
	}
	
	// Down stairs only if not last level:
	if (this.zoneLevel < this.zoneType().numLevels) {
		if (!this.placeStairs('DownStairs', this.zoneName, this.zoneLevel + 1, 0)) {
			return false;
		}
	}
	
	return success;
};

// PLACE_STAIRS:
// ************************************************************************************************
gs.placeStairs = function (stairsType, toZoneName, toZoneLevel, closeRadius = 0) {
	var tileIndex, obj;
	
	// Find if unconnected stairs already exist (static level):
	obj = this.findObj(obj => obj.type.name === stairsType && !obj.toZoneName);
	if (obj) {
		tileIndex = obj.tileIndex;
		gs.destroyObject(obj);
	}
	else {
		tileIndex = this.getStairIndex();
	}
	
	// Cannot locate a valid location for stairs:
	if (!tileIndex) {
		return false;
	}
	
	this.createZoneLine(tileIndex, stairsType, toZoneName, toZoneLevel);
	
	// Close tiles to spawning:
	this.getIndexInRadius(tileIndex, closeRadius).forEach(function (index) {
		this.getTile(index).isClosed = true;
	}, this);
	
	return true;
};

// CREATE_STREAMER:
// ************************************************************************************************
gs.createStreamer = function () {
	var edgeNames, tileIndex1, tileIndex2, randPositionOnEdge, count = 0, width = 1, widthDelta = 1, MAX_WIDTH = 3, streamerType;
	
	streamerType = util.randElem(['WATER', 'RUBBLE']);
	streamerType = 'RUBBLE';
	
	randPositionOnEdge = function (edgeName) {
		if (edgeName === 'LEFT') {
			return {x: 2, y: util.randInt(2, gs.numTilesY - 3)};
		}
		if (edgeName === 'RIGHT') {
			return {x: gs.numTilesX - 3, y: util.randInt(2, gs.numTilesY - 3)};
		}
		if (edgeName === 'UP') {
			return {x: util.randInt(2, gs.numTilesX - 3), y: 2};
		}
		if (edgeName === 'DOWN') {
			return {x: util.randInt(2, gs.numTilesX - 3), y: gs.numTilesY - 3};
		}
	};
	
	do {
		// Select points on two edges of the map
		edgeNames = this.randSubset(['LEFT', 'RIGHT', 'DOWN'], 2);
		tileIndex1 = randPositionOnEdge(edgeNames[0]);
		tileIndex2 = randPositionOnEdge(edgeNames[1]);
		
		count += 1;
		if (count > 1000) {
			throw 'Loop count exceeded';
		}
	} while (gs.distance(tileIndex1, tileIndex2) < MIN_STREAMER_LENGTH);
		
	// Lay down cave floor and destroy objects:
	this.getIndexInRay(tileIndex1, tileIndex2).forEach(function (index) {
		// Changing width:
		if (game.rnd.frac() < 0.1) {
			if (widthDelta === 1 && width === MAX_WIDTH) {
				widthDelta = -1;
				width -= 1;
			} else if (widthDelta === 1) {
				width += 1;
			} else if (widthDelta === -1 && width === 1) {
				widthDelta = 1;
				width += 1;
			} else if (widthDelta === -1) {
				width -= 1;
			}
		}
		
		this.getIndexInRadius(index, width).forEach(function (index) {
			if (index.x !== 0 && index.y !== 0 && index.x !== this.numTilesX - 1 && index.y !== this.numTilesY - 1) {
				if (!this.getTile(index).isClosed && !gs.getTile(index).type.isPit) {
					this.setTileType(index, this.tileTypes.CaveFloor);
					if (this.getObj(index)) {
						this.destroyObject(this.getObj(index));
					}
				}
			}
		}, this);
	}, this);
	
	// Center:
	MAX_WIDTH -=1;
	this.getIndexInRay(tileIndex1, tileIndex2).forEach(function (index) {
		// Changing width:
		if (game.rnd.frac() < 0.1) {
			if (widthDelta === 1 && width === MAX_WIDTH) {
				widthDelta = -1;
				width -= 1;
			} else if (widthDelta === 1) {
				width += 1;
			} else if (widthDelta === -1 && width === 1) {
				widthDelta = 1;
				width += 1;
			} else if (widthDelta === -1) {
				width -= 1;
			}
		}
		
		this.getIndexInRadius(index, Math.max(1, Math.ceil(width / 2))).forEach(function (index) {
			if (index.x !== 0 && index.y !== 0 && index.x !== this.numTilesX - 1 && index.y !== this.numTilesY - 1) {
				if (!this.getTile(index).isClosed && !gs.getTile(index).type.isPit) {
					if (streamerType === 'WATER') {
						this.setTileType(index, this.tileTypes.Water);
					} else if (streamerType === 'RUBBLE') {
						if (game.rnd.frac() < 0.05 && !this.getObj(index) && this.isPassable(index)) {
							this.createObject(index, 'Rubble');
						}
					} else if (streamerType === 'LAVA') {
						this.setTileType(index, this.tileTypes.Lava);
					}
				}
			}
		}, this);
	}, this);
};

// TRIM_HAZARDS:
// ************************************************************************************************
gs.trimHazards = function () {
	// Trimming Lava from walls:
	
	gs.getAllIndex().forEach(function (tileIndex) {
		var indexList;
		if (this.getTile(tileIndex).type.name === 'Lava') {
			indexList = this.getIndexListCardinalAdjacent(tileIndex);
			indexList = indexList.filter(index => !this.getTile(index).type.passable);
			
			if (indexList.length > 0) {
				this.setTileType(tileIndex, this.tileTypes.CaveFloor);
				
				if (gs.getChar(tileIndex) && gs.getChar(tileIndex).type.spawnInLava) {
					gs.getChar(tileIndex).destroy();
				}
				
			}
		}
	}, this);
	
	// Trimming single lava:
	gs.getAllIndex().forEach(function (tileIndex) {
		var indexList;
		if (this.getTile(tileIndex).type.name === 'Lava') {
			indexList = this.getIndexListCardinalAdjacent(tileIndex);
			indexList = indexList.filter(index => this.getTile(index).type.name === 'Lava');
			
			if (indexList.length === 0) {
				this.setTileType(tileIndex, this.tileTypes.CaveFloor);
			}
		}
			
	}, this);
};


// TRIM_OBJECTS:
// ************************************************************************************************
gs.trimObjects = function () {
	gs.getAllIndex().forEach(function (index) {
		if (gs.getObj(index, 'LongGrass') && gs.getTile(index).type.name === 'Water') {
			gs.destroyObject(gs.getObj(index));
		}
	}, this);
};

// TRIM_DOORS:
// Remove all short hall doors
// ************************************************************************************************
gs.trimDoors = function () {
	gs.getIndexInBox(1, 1, NUM_TILES_X - 1, NUM_TILES_Y - 1).forEach(function (index) {
		// Horizontal short halls:
		if (gs.isPassable(index) && 
			(!gs.getArea(index) || gs.getArea(index).isVault === false) &&
			gs.getObj(index.x + 1, index.y, obj => obj.type.name === 'Door') &&
			gs.getObj(index.x - 1, index.y, obj => obj.type.name === 'Door')) {
		
			gs.destroyObject(gs.getObj(index.x + 1, index.y));
			gs.destroyObject(gs.getObj(index.x - 1, index.y));
		}
		
		// Vertical short halls:
		if (gs.isPassable(index) && 
			(!gs.getArea(index) || gs.getArea(index).isVault === false) &&
			gs.getObj(index.x, index.y + 1, obj => obj.type.name === 'Door') &&
			gs.getObj(index.x, index.y - 1, obj => obj.type.name === 'Door')) {
		
			gs.destroyObject(gs.getObj(index.x, index.y + 1));
			gs.destroyObject(gs.getObj(index.x, index.y - 1));
		}
		
		// Freestanding doors:
		if (gs.getObj(index, obj => obj.type.name === 'Door') && gs.getIndexListCardinalAdjacent(index).filter(idx => !gs.isPassable(idx)).length <= 1) {
			gs.destroyObject(gs.getObj(index));
		}
		
		
		
	}, this);
};

// TRIM_DIAGONAL_WALLS:
// ************************************************************************************************
gs.trimDiagonalWalls = function () {
	for (let x = 0; x < gs.numTilesX - 1; x += 1) {
		for (let y = 0; y < gs.numTilesY - 1; y += 1) {
			// X O
			// O X
			if (!gs.getTile(x, y).type.passable &&
				!gs.getTile(x + 1, y + 1).type.passable  &&
				gs.getTile(x + 1, y).type.passable && 
				gs.getTile(x, y + 1).type.passable) {
				
				if (gs.getTile(x, y).type.name === 'Wall') {
					gs.setTileType({x: x, y: y}, gs.tileTypes.Floor);
				}
				else if (gs.getTile(x, y).type.name === 'CaveWall') {
					gs.setTileType({x: x, y: y}, gs.tileTypes.CaveFloor);
				}
			}
			
			// O X
			// X O
			if (gs.getTile(x, y).type.passable &&
				gs.getTile(x + 1, y + 1).type.passable  &&
				!gs.getTile(x + 1, y).type.passable && 
				!gs.getTile(x, y + 1).type.passable) {
				
				if (gs.getTile(x, y).type.name === 'Wall') {
					gs.setTileType({x: x, y: y}, gs.tileTypes.Floor);
				}
				else if (gs.getTile(x, y).type.name === 'CaveWall') {
					gs.setTileType({x: x, y: y}, gs.tileTypes.CaveFloor);
				}
			}
		}
	}
};

// TRIM_PITS:
// Remove single pits
// ************************************************************************************************
gs.trimPits = function () {
	var isSinglePit, change = true;
	
	isSinglePit = function (x, y) {
		if (gs.getTile(x, y).type.name === 'Pit') {
			if ((gs.getTile(x + 1, y).type.name !== 'Pit' && gs.getTile(x - 1, y).type.name !== 'Pit')
			|| 	(gs.getTile(x, y + 1).type.name !== 'Pit' && gs.getTile(x, y - 1).type.name !== 'Pit')) {
				return true;
			}
		}
	
		if (gs.getTile(x, y).type.name === 'CavePit') {
			if ((gs.getTile(x + 1, y).type.name !== 'CavePit' && gs.getTile(x - 1, y).type.name !== 'CavePit')
			|| 	(gs.getTile(x, y + 1).type.name !== 'CavePit' && gs.getTile(x, y - 1).type.name !== 'CavePit')) {
				return true;
			}
		}
		
		if (gs.getTile(x, y).type.name === 'Pit') {
			if (gs.getIndexListCardinalAdjacent({x: x, y: y}).filter(idx => gs.getTile(idx).type.name === 'Pit').length <= 1) {
				return true;
			}
		}
		
		return false;
	};
	
	while (change) {
		change = false;
		gs.getAllIndex().forEach(function (tileIndex) {
			if (isSinglePit(tileIndex.x, tileIndex.y)) {
				
				if (gs.getTile(tileIndex).type.name === 'CavePit') {
					gs.setTileType(tileIndex, gs.tileTypes.CaveFloor);
				}
				else {
					gs.setTileType(tileIndex, gs.tileTypes.Floor);
				}
				
				//gs.setTileType(tileIndex, gs.tileTypes.Sand)
				change = true;
			}
		}, this);
	}
};/*global gs, game, util, console*/
/*jshint esversion: 6*/
'use strict';

var levelController = {};

// UPDATE_TURN:
// ************************************************************************************************
levelController.updateTurn = function () {
	if (gs.zoneName === 'TheSunlessDesert') {
		for (let i = 0; i < this.dustStorms.length; i += 1) {
			this.updateDustStorm(this.dustStorms[i]);
			
			
		}
	}
};

// UPDATE_DUST_STORM:
// ************************************************************************************************
levelController.updateDustStorm = function (dustStorm) {
	// Creating dust:
	gs.getIndexInFlood(dustStorm.tileIndex, gs.isStaticPassable, 2).forEach(function (tileIndex) {
		if (!gs.getCloud(tileIndex)) {
			gs.createCloud(tileIndex, 'Dust', 0, 5);
		}
	}, this);
		
	
	
	// Only move every 3 turns:
	if (gs.turn % 3 === 0) {
		// Moving:
		var toTileIndex = {x: dustStorm.tileIndex.x + dustStorm.wanderVector.x,
						   y: dustStorm.tileIndex.y + dustStorm.wanderVector.y};

		if (gs.isStaticPassable(toTileIndex)) {
			// Changing direction:
			if (game.rnd.frac() < 0.05) {
				dustStorm.wanderVector = {x: util.randInt(-1, 1), y: util.randInt(-1, 1)};
			}

			dustStorm.tileIndex.x = toTileIndex.x;
			dustStorm.tileIndex.y = toTileIndex.y;
		}
		// Hit a wall:
		else {
			dustStorm.wanderVector = {x: util.randInt(-1, 1), y: util.randInt(-1, 1)};
		}
	}
	

};

// ON_GENERATE_LEVEL:
// ************************************************************************************************
levelController.onGenerateLevel = function () {
	if (gs.zoneName === 'TheSunlessDesert') {
		this.dustStorms = [];
		
		for (let i = 0; i < 3; i += 1) {
			this.dustStorms.push({
				tileIndex: gs.getPassableIndexInBox(0, 0, gs.numTilesX, gs.numTilesY),
				wanderVector: {x: util.randInt(-1, 1), y: util.randInt(-1, 1)}
			});
		}
	}
};

// TO_DATA:
// ************************************************************************************************
levelController.toData = function () {
	var data = {};
	
	if (gs.zoneName === 'TheSunlessDesert') {
		data.dustStorms = this.dustStorms;
	}
	
	return data;
};

// LOAD_DATA:
// ************************************************************************************************
levelController.loadData = function (data) {
	if (gs.zoneName === 'TheSunlessDesert') {
		this.dustStorms = data.dustStorms;
	}
};

// ON_TRIGGER_GROUP:
// ************************************************************************************************
levelController.onTriggerGroup = function (groupId) {
	// Pass if the trigger has already been triggered
	if (gs.levelTriggers[groupId]) {
		return;
	}
	
	// Flag the trigger as triggered:
	gs.levelTriggers[groupId] = 1;
	
	if (gs.staticLevelName === 'VaultOfYendor-EndLevel01') {
		// Left Side:
		if (groupId === 1) {
			gs.explodeWall([{x: 5, y: 4}, {x: 6, y: 4}, {x: 7, y: 4}, {x: 8, y: 4}]);
			
		}
		
		// Right Side:
		if (groupId === 2) {
			gs.explodeWall([{x: 30, y: 4}, {x: 31, y: 4}, {x: 32, y: 4}, {x: 33, y: 4}]);
			
		}
	}
};

// ON_OPEN_DOOR:
// ************************************************************************************************
levelController.onOpenDoor = function (door) {
	if (gs.staticLevelName === 'TheSewers-EndLevel01' && door.type.name === 'StoneDoor') {
		gs.objectList.filter(obj => obj.type.name === 'StoneDoor').forEach(function (obj) {
			if (!obj.isOpen) {
				obj.openDoor();
			}
		}, this);
	}
	
	if (gs.staticLevelName === 'TheSewers-EndLevel02' && door.type.name === 'StoneDoor') {
		gs.objectList.filter(obj => obj.type.name === 'StoneDoor').forEach(function (obj) {
			if (!obj.isOpen) {
				obj.openDoor();
			}
		}, this);
	}
	
	if (gs.staticLevelName === 'TheCore-EndLevel01' && door.type.name === 'StoneDoor') {
		gs.objectList.filter(obj => obj.type.name === 'StoneDoor').forEach(function (obj) {
			if (!obj.isOpen) {
				obj.openDoor();
			}
		}, this);
	}
	
	if (gs.staticLevelName === 'TheIceCaves-EndLevel01' && door.type.name === 'StoneDoor') {
		gs.objectList.filter(obj => obj.type.name === 'StoneDoor').forEach(function (obj) {
			if (!obj.isOpen) {
				obj.openDoor();
			}
		}, this);
	}
	
	if (gs.staticLevelName === 'TheArcaneTower-EndLevel02' && door.type.name === 'StoneDoor') {
		gs.objectList.filter(obj => obj.type.name === 'StoneDoor').forEach(function (obj) {
			if (!obj.isOpen) {
				obj.openDoor();
			}
		}, this);
	}
	
	if (gs.staticLevelName === 'VaultOfYendor-EndLevel01' && door.type.name === 'StoneDoor') {
		gs.objectList.filter(obj => obj.type.name === 'StoneDoor').forEach(function (obj) {
			if (!obj.isOpen) {
				obj.openDoor();
			}
		}, this);
	}
};/*global gs, console*/
/*jshint laxbreak: true, esversion: 6*/

'use strict';

var levelVerification = {};

// RUN:
// ************************************************************************************************
levelVerification.run = function () {
	this.verifyConnectivity();
	this.verifyZoneLines();
};

// VERIFY_ZONE_LINES:
// ************************************************************************************************
levelVerification.verifyZoneLines = function () {
	if (!gs.findObj(obj => obj.type.name === 'DownStairs')) {
		console.log('Missing down stairs');
	}
	
	if (!gs.findObj(obj => obj.type.name === 'UpStairs')) {
		console.log('Missing up stairs');
	}
};

// IS_CONNECTED:
// Verify that all areas of the level are connected
// ************************************************************************************************
levelVerification.isConnected = function () {
	var tileIndex, floodList, indexList, testFunc;
	
	testFunc = function (index) {
		return gs.isStaticPassable(index)
			|| gs.getObj(index, obj => obj.isDoor())
			|| gs.isDropWall(index);
	};
	
	// Flood from a passable point:
	tileIndex = gs.getPassableIndexInBox(0, 0, gs.numTilesX, gs.numTilesY);
	floodList = gs.getIndexInFlood(tileIndex, testFunc, 1000, true);
	
	// Get list of all passable index:
	indexList = gs.getAllIndex();
	indexList = indexList.filter(index => testFunc(index));
	
	if (floodList.length !== indexList.length) {
		// Color missing tiles:
		indexList.forEach(function (index) {
			if (!floodList.find(idx => gs.vectorEqual(idx, index))) {
				gs.getTile(index).color = '#ff0000';
			}
		}, this);
		
		return false;
	}
	
	return true;
};/*global game, gs, console, util*/
/*global baseGenerator, Item*/
/*global GOOD_DROP_TABLE_LIST, MAX_MONSTER_ZOO_NPCS, TIMED_GATE_TIME, LOCKED_STAIRS_ROOM_CHANCE*/
/*global MAX_DROP_WALL_NPCS, FLOATING_FEATURE_PERCENT, TIER_III_ZONES, BRANCH_I_ZONES, BRANCH_II_ZONES*/
/*jshint esversion: 6, laxbreak: true, loopfunc: true*/
'use strict';
var featureGenerator = {};


// SIZES:
// minSize and maxSize refer to the total size of the room including its walls
// The floor space will generally be these sizes - 2

// SIDE_ROOMS:
// A side room must be placed adjacent to a non-side room. 
// One of its walls must overlap with an existing wall
// Doors will be placed on these overlapping walls
// minOverlap is used to control this overlapping and can be used to force a min number of doors to spawn

// ROOM_LOCATION:
// A tileIndex, width, height and overlap list representing a valid location for a room
// This is used b/c searching for a room generates enough data to pass to the actual generator
// This way the generator can use this data without recalculating it.

// RESET_FEATURE_TYPE_COUNTS:
// Call before generating a new level to reset all feature type counts
// ************************************************************************************************
featureGenerator.resetFeatureTypeCounts = function () {
	this.featureTypeCounts = {};
	gs.forEachType(this.specialFeatureTypes, function (type) {
		this.featureTypeCounts[type.name] = 0;
	}, this);
};

// PLACE_SPECIAL_FEATURES:
// ************************************************************************************************
featureGenerator.placeSpecialFeatures = function () {
	this.placeLockedStairs();
	this.placeFloatingFeatures();
	this.placeSideFeatures();
	
};

// PLACE_DRESSING_FEATURES:
// ************************************************************************************************
featureGenerator.placeDressingFeatures = function () {
	
	this.dressingFeatureTypeList.forEach(function (type) {
		if (gs.arrayIntersect(type.tags, gs.zoneType().vaultTags).length > 0 && game.rnd.frac() < type.spawnPercent) {
			this.placeDressingFeatureType(type);
		}
	}, this);
	
	
	

};

// PLACE_DRESSING_FEATURE_TYPE:
// ************************************************************************************************
featureGenerator.placeDressingFeatureType = function (type) {
	var indexList, maskIndex, maskList = [];
	
	for (let i = 0; i < type.maxPerLevel; i += 1) {
		indexList = gs.getAllIndex();
		maskList = [];
		
		indexList.forEach(function (tileIndex) {
			maskIndex = this.getDressingFeatureMask(tileIndex, type);
			if (maskIndex >= 0) {
				maskList.push({tileIndex: {x: tileIndex.x, y: tileIndex.y}, maskIndex: maskIndex});
			}
		}, this);

		if (maskList.length > 0) {
			let e = util.randElem(maskList);
			this.placeDressingFeatureMask(e.tileIndex, type, e.maskIndex);
		}
	}
};

// GET_DRESSING_FEATURE_MASK:
// ************************************************************************************************
featureGenerator.getDressingFeatureMask = function (tileIndex, featureType) {
	return this.predMask(tileIndex, featureType.predMasks, featureType.predFuncs);
};

// PLACE_DRESSING_FEATURE_MASK:
// ************************************************************************************************
featureGenerator.placeDressingFeatureMask = function (tileIndex, featureType, maskIndex) {
	var mask = featureType.genMasks[maskIndex];
	
	for (let y = 0; y < mask.length; y += 1) {
		for (let x = 0; x < mask[0].length; x += 1) {
			if (featureType.genFuncs[mask[y][x]]) {
				featureType.genFuncs[mask[y][x]].call(this, {x: tileIndex.x + x, y: tileIndex.y + y});
			}		
		}
	}
};

// PLACE_LOCKED_STAIRS:
// ************************************************************************************************
featureGenerator.placeLockedStairs = function () {
	var zones = TIER_III_ZONES.concat(BRANCH_I_ZONES).concat(BRANCH_II_ZONES);
	zones.push('VaultOfYendor');
	
	if (gs.inArray(gs.zoneName, zones) && gs.zoneLevel < 4 && util.frac() <= LOCKED_STAIRS_ROOM_CHANCE) {
		this.placeSpecialFeature(this.specialFeatureTypes.LockedStairsRoom);
	}
};

// PLACE_SIDE_FEATURES:
// ************************************************************************************************
featureGenerator.placeSideFeatures = function () {
	var num, featureType;
	
	// Random number of special features per level:
	num = util.randInt(0, Math.min(3, gs.zoneLevel));

	// Generate features:
	for (let i = 0; i < num; i += 1) {
		featureType = this.selectFeatureType();
		
		if (featureType ) {
			this.placeSpecialFeature(featureType);
		}
	}
	
	// Forcing side features from debugProperties:
	if (gs.debugProperties.forceSideFeature) {
		featureType = this.specialFeatureTypes[gs.debugProperties.forceSideFeature];
		this.placeSpecialFeature(featureType);
	}
};

// PLACE_FLOATING_FEATURES:
// ************************************************************************************************
featureGenerator.placeFloatingFeatures = function () {
	var type;
	
	type = this.selectFloatingFeature();
	
	
	if (type && util.frac() < FLOATING_FEATURE_PERCENT) {
		type.generate();
		gs.previouslySpawnedFeatures.push(type.name);
	}
};

// SELECT_FLOATING_FEATURE:
// Selects a floating feature that can be generated on the level
// Based on restriction of floating feature type
// Will never spawn features twice
// ************************************************************************************************
featureGenerator.selectFloatingFeature = function () {
	var featureList = this.floatingFeatureList;
	
	// Never double spawn:
	featureList = featureList.filter(type => !gs.inArray(type.name, gs.previouslySpawnedFeatures));
	
	// Restricted by zoneType:
	featureList = featureList.filter(type => gs.inArray(type.name, gs.zoneType().floatingFeatures));
	
	// Restircted by DL:
	featureList = featureList.filter(type => gs.dangerLevel() >= type.minDL);
	
	// Restrict by canGenerate:
	featureList = featureList.filter(type => type.canGenerate());
	
	return featureList.length > 0 ? util.randElem(featureList) : null;
};

// SELECT_FEATURE_TYPE:
// Randomly select a feature from the zoneType
// Handle features with a maxCount
// ************************************************************************************************
featureGenerator.selectFeatureType = function () {
	var table = gs.zoneType().specialFeatures.slice(0);
	
	// Dont exceed max count:
	table = table.filter(element => this.featureTypeCounts[element.name] < this.specialFeatureTypes[element.name].maxCount);
	
	// Min DL:
	table = table.filter(element => gs.dangerLevel() >= this.specialFeatureTypes[element.name].minDL);
	
	return table.length > 0 ? this.specialFeatureTypes[gs.chooseRandom(table)] : null;
};

// PLACE_SPECIAL_FEATURE:
// Returns false if unable to place the feature
// ************************************************************************************************
featureGenerator.placeSpecialFeature = function (type) {
	var roomLocationList,
		roomLocation;
	
	// Get all possible locations:
	roomLocationList = this.getSideRoomLocationList(type);
	
	if (roomLocationList.length === 0) {
		return false;
	}
	
	// Randomly select a location:
	roomLocation = util.randElem(roomLocationList);
	
	// Generate the feature:
	type.generate(roomLocation);
	
	// Close Tiles:
	// Including walls to disable tunneling through them
	gs.getIndexInBox(roomLocation.floorBox.startX - 1, roomLocation.floorBox.startY - 1, roomLocation.floorBox.endX + 1, roomLocation.floorBox.endY + 1).forEach(function (index) {
		gs.getTile(index).isClosed = true;
	}, this);
	
	// Count the feature:
	this.featureTypeCounts[type.name] += 1;
	
	return true;
};

// CREATING_DRESSING_FEATURE_TYPES:
// ************************************************************************************************
featureGenerator.createDressingFeatureTypes = function () {
	this.dressingFeatureTypes = {};
	
	// BARRELS:
	this.dressingFeatureTypes.Barrel = {
		maxPerLevel: 10,
		spawnPercent: 0.1,
		tags: ['TheUpperDungeon', 'TheOrcFortress']
	};
	this.dressingFeatureTypes.Barrel.predMasks = [
		[[1, 1, 1],
		 [0, 0, 1],
		 [0, 0, 1]
		],
		[[1, 1, 1],
		 [1, 0, 0],
		 [1, 0, 0]
		],
		[[1, 1, 1, 1],
		 [0, 0, 0, 0],
		 [0, 0, 0, 0]
		],
		[[0, 0, 0, 0],
		 [0, 0, 0, 0],
		 [0, 0, 0, 0],
		 [0, 0, 0, 0],
		],
		
	];
	this.dressingFeatureTypes.Barrel.genMasks = [
		[[1, 1, 1],
		 [1, 0, 1]
		],
		[[1, 1, 1],
		 [1, 0, 1]
		],
		[[1, 1, 1, 1],
		 [1, 0, 0, 1],
		 [1, 1, 1, 1]
		],
		[[1, 1, 1, 1],
		 [1, 2, 2, 1],
		 [1, 2, 2, 1],
		 [1, 1, 1, 1],
		],
	];
	this.dressingFeatureTypes.Barrel.predFuncs = [
		function (index) {
			return gs.isIndexOpen(index);
		},
			
		function (index) {
			return gs.isInBounds(index) && !gs.getTile(index).type.passable;
		}
	];
	this.dressingFeatureTypes.Barrel.genFuncs = [
		function (tileIndex) {
			gs.createObject({x: tileIndex.x, y: tileIndex.y}, 'Barrel');
		},
		
		null,
		
		function (tileIndex) {
			if (game.rnd.frac() < 0.75) {
				gs.createObject({x: tileIndex.x, y: tileIndex.y}, 'Barrel');
			}
		},
	];
	
	this.dressingFeatureTypeList = [];
	gs.forEachType(this.dressingFeatureTypes, function (type) {
		this.dressingFeatureTypeList.push(type);
	}, this);
};

// PRED_MASK:
// ************************************************************************************************
featureGenerator.predMask = function (tileIndex, masks, preds) {
	var func, list = [];
	
	func = function (mask) {
		for (let y = 0; y < mask.length; y += 1) {
			for (let x = 0; x < mask[0].length; x += 1) {
				if (gs.isInBounds({x: tileIndex.x + x, y: tileIndex.y + y}) &&  gs.getTile({x: tileIndex.x + x, y: tileIndex.y + y}).isClosed) {
					return false;
				}
				
				if (preds[mask[y][x]] && !preds[mask[y][x]].call(this, {x: tileIndex.x + x, y: tileIndex.y + y})) {
					return false;
				}
			}
		}
		
		return true;
	};
	
	for (let i = 0; i < masks.length; i += 1) {
		if (func(masks[i])) {
			list.push(i);
		}
	}
	
	
	
	return list.length > 0 ? util.randElem(list) : -1;
};



// CREATE_TYPES:
// ************************************************************************************************
featureGenerator.createTypes = function () {
	this.specialFeatureTypes = {};
	this.floatingFeatureTypes = {};
	
	// LOCKED_STAIRS:
	this.specialFeatureTypes.LockedStairsRoom = {};
	this.specialFeatureTypes.LockedStairsRoom.minSize = 5;
	this.specialFeatureTypes.LockedStairsRoom.maxSize = 6;
	this.specialFeatureTypes.LockedStairsRoom.minOverlap = 1;
	
	// MONSTER_ZOO:
	this.specialFeatureTypes.MonsterZoo = {};
	this.specialFeatureTypes.MonsterZoo.minSize = 5;
	this.specialFeatureTypes.MonsterZoo.maxSize = 6;
	this.specialFeatureTypes.MonsterZoo.minOverlap = 2;
	this.specialFeatureTypes.MonsterZoo.maxCount = 1;
	
	// DROP_WALL_ROOM:
	this.specialFeatureTypes.DropWallRoom = {};
	this.specialFeatureTypes.DropWallRoom.minSize = 5;
	this.specialFeatureTypes.DropWallRoom.maxSize = 6;
	this.specialFeatureTypes.DropWallRoom.minOverlap = 3;
	this.specialFeatureTypes.DropWallRoom.minDL = 2;
	
	// TREASURE_ROOM:
	this.specialFeatureTypes.TreasureRoom = {};
	this.specialFeatureTypes.TreasureRoom.minSize = 5;
	this.specialFeatureTypes.TreasureRoom.maxSize = 7;
	this.specialFeatureTypes.TreasureRoom.minOverlap = 1;
	
	// TIMED_TREASURE_ROOM:
	this.specialFeatureTypes.TimedTreasureRoom = {};
	this.specialFeatureTypes.TimedTreasureRoom.minSize = 5;
	this.specialFeatureTypes.TimedTreasureRoom.maxSize = 7;
	this.specialFeatureTypes.TimedTreasureRoom.minOverlap = 1;
	this.specialFeatureTypes.TimedTreasureRoom.maxCount = 1;
	
	// STORAGE_ROOM:
	this.specialFeatureTypes.StorageRoom = {};
	this.specialFeatureTypes.StorageRoom.minSize = 5;
	this.specialFeatureTypes.StorageRoom.maxSize = 8;
	this.specialFeatureTypes.StorageRoom.minOverlap = 1;
	
	// LIBRARY:
	this.specialFeatureTypes.Library = {};
	this.specialFeatureTypes.Library.minSize = 5;
	this.specialFeatureTypes.Library.maxSize = 6;
	this.specialFeatureTypes.Library.minOverlap = 1;
	
	// GOLD_ROOM:
	this.specialFeatureTypes.GoldRoom = {};
	this.specialFeatureTypes.GoldRoom.minSize = 5;
	this.specialFeatureTypes.GoldRoom.maxSize = 6;
	this.specialFeatureTypes.GoldRoom.minOverlap = 1;
	
	// FOOD_ROOM:
	this.specialFeatureTypes.FoodRoom = {};
	this.specialFeatureTypes.FoodRoom.minSize = 5;
	this.specialFeatureTypes.FoodRoom.maxSize = 6;
	this.specialFeatureTypes.FoodRoom.minOverlap = 1;
	
	// POTION_ROOM:
	this.specialFeatureTypes.PotionRoom = {};
	this.specialFeatureTypes.PotionRoom.minSize = 5;
	this.specialFeatureTypes.PotionRoom.maxSize = 6;
	this.specialFeatureTypes.PotionRoom.minOverlap = 1;
	
	// SCROLL_ROOM:
	this.specialFeatureTypes.ScrollRoom = {};
	this.specialFeatureTypes.ScrollRoom.minSize = 5;
	this.specialFeatureTypes.ScrollRoom.maxSize = 6;
	this.specialFeatureTypes.ScrollRoom.minOverlap = 1;
	
	// CHOICE_TREASURE_ROOM:
	this.specialFeatureTypes.ChoiceTreasureRoom = {};
	this.specialFeatureTypes.ChoiceTreasureRoom.minSize = 7;
	this.specialFeatureTypes.ChoiceTreasureRoom.maxSize = 7;
	this.specialFeatureTypes.ChoiceTreasureRoom.minOverlap = 1;
	
	// FLOATING_FEATURE_TYPES:
	// ************************************************************************************************
	// VAULT_ROOMS:
	this.floatingFeatureTypes.BallistaRoom = 	{vaultTypeName: 'BallistaRoom'};
	this.floatingFeatureTypes.OrcPriestTemple = {vaultTypeName: 'OrcPriestTemple'};
	this.floatingFeatureTypes.OrcFortress = 	{vaultTypeName: 'OrcFortress'};
	this.floatingFeatureTypes.GoblinFarm =		{vaultTypeName: 'GoblinFarm'};
	this.floatingFeatureTypes.TreasureTrap =	{vaultTypeName: 'TreasureTrap'};
    this.floatingFeatureTypes.FireTrap =        {vaultTypeName: 'FireTrap'};
    this.floatingFeatureTypes.WishFountain =    {vaultTypeName: 'WishFountain'};
    this.floatingFeatureTypes.MerchantShop =    {vaultTypeName: 'MerchantShop'};
    this.floatingFeatureTypes.PrisonRoom =      {vaultTypeName: 'PrisonRoom'};
	this.floatingFeatureTypes.IceRoom =         {vaultTypeName: 'IceRoom'};
    this.floatingFeatureTypes.BigPitTrap =      {vaultTypeName: 'BigPitTrap'};
    this.floatingFeatureTypes.PitFallRoom =     {vaultTypeName: 'PitFallRoom'};
    this.floatingFeatureTypes.IglooRoom =       {vaultTypeName: 'IglooRoom'};
    
	// OGRE_CAVE:
	this.floatingFeatureTypes.OgreCave = {};
	this.floatingFeatureTypes.OgreCave.width = 10;
	this.floatingFeatureTypes.OgreCave.height = 10;
	
	// BEAR_CAVE:
	this.floatingFeatureTypes.BearCave = {};
	this.floatingFeatureTypes.BearCave.width = 11;
	this.floatingFeatureTypes.BearCave.height = 11;
	
	// RAT_CAVE:
	this.floatingFeatureTypes.RatCave = {};
	this.floatingFeatureTypes.RatCave.width = 11;
	this.floatingFeatureTypes.RatCave.height = 11;
	this.floatingFeatureTypes.RatCave.minDL = 2;
	
	// ANT_CAVE:
	this.floatingFeatureTypes.AntCave = {};
	this.floatingFeatureTypes.AntCave.width = 11;
	this.floatingFeatureTypes.AntCave.height = 11;
	
	// BEE_HIVE:
	this.floatingFeatureTypes.BeeHive = {};
	this.floatingFeatureTypes.BeeHive.width = 11;
	this.floatingFeatureTypes.BeeHive.height = 11;
	
	this.createTypeGenerators();
	gs.nameTypes(this.specialFeatureTypes);
	
	// Set special feature defaults:
	gs.forEachType(this.specialFeatureTypes, function (type) {
		if (!type.hasOwnProperty('maxCount')) {
			type.maxCount = 1000;
		}
		
		type.minDL = type.minDL || 0;
		
	}, this);
	
	// Set floating feature defaults:
	gs.nameTypes(this.floatingFeatureTypes);
	this.floatingFeatureList = [];
	gs.forEachType(this.floatingFeatureTypes, function (type) {
		this.floatingFeatureList.push(type);
		
		type.minDL = type.minDL || 0;
		
		if (type.vaultTypeName) {
			if (!gs.vaultTypes[type.vaultTypeName]) throw 'Invalid vaultTypeName: ' + type.vaultTypeName;
			
			type.width = gs.vaultTypes[type.vaultTypeName].width;
			type.height = gs.vaultTypes[type.vaultTypeName].height;
			
			type.generate = function () {
				featureGenerator.placeFloatingVault(this.vaultTypeName);
			};
			
			type.canGenerate = function () {
				return baseGenerator.getOpenBox(this.width, this.height);
			};
		}
	}, this);
	
	this.createDressingFeatureTypes();
};

// CREATE_TYPE_GENERATORS:
// ************************************************************************************************
featureGenerator.createTypeGenerators = function () {
	
	// LOCKED_STAIRS_ROOM:
	// ********************************************************************************************
	this.specialFeatureTypes.LockedStairsRoom.generate = function (roomLocation) {
		var tileIndex, indexList, obj;
		
		// Create side room:
		featureGenerator.createSideRoom(roomLocation, 'SwitchGate', true);
		
		// Lock Door:
		gs.getObj(roomLocation.doorTileIndex).isLocked = true;
		
		// Create Down Stairs:
		tileIndex = gs.getWideOpenIndexInBox(roomLocation.floorBox);
		gs.createObject(tileIndex, 'DownStairs');
		
		// Create internal safety switch:
		tileIndex = gs.getOpenIndexInBox(roomLocation.floorBox);
		obj = gs.createObject(tileIndex, 'Switch');
		obj.toTileIndex = {x: roomLocation.doorTileIndex.x, y: roomLocation.doorTileIndex.y};
		
		// Close tiles early (so switch doesn't get spawned in here):
		gs.getIndexInBox(roomLocation.floorBox.startX - 1, roomLocation.floorBox.startY - 1, roomLocation.floorBox.endX + 1, roomLocation.floorBox.endY + 1).forEach(function (index) {
			gs.getTile(index).isClosed = true;
		}, this);
		
		// Find a tileIndex as far from downStairs as possible:
		indexList = gs.getAllIndex();
		indexList = indexList.filter(index => gs.isWideOpen(index));
		indexList.sort((a, b) => gs.distance(b, tileIndex) - gs.distance(a, tileIndex));
	
		// Create a switch:
		obj = gs.createObject(indexList[0], 'Switch');
		obj.toTileIndex = {x: roomLocation.doorTileIndex.x, y: roomLocation.doorTileIndex.y};
	};
	
	// MONSTER_ZOO:
	// ********************************************************************************************
	this.specialFeatureTypes.MonsterZoo.generate = function (roomLocation) {
		var overlap,
			maxMobs;
		
		maxMobs = Math.ceil(MAX_MONSTER_ZOO_NPCS + gs.dangerLevel() / 3);
		
		featureGenerator.createMobClosest(roomLocation, maxMobs, true, GOOD_DROP_TABLE_LIST);
		
		// Placing doors on an overlap:
		overlap = util.randElem(roomLocation.overlapList);
		for (let i = 0; i < this.minOverlap; i += 1) {
			gs.setTileType(overlap[i], gs.tileTypes.Floor);
			gs.createDoor(overlap[i], 'StoneDoor', gs.objectTypes.StoneDoor.frame, false, true);
		}
	};
	
	// DROP_WALL_ROOM:
	// ********************************************************************************************
	this.specialFeatureTypes.DropWallRoom.generate = function (roomLocation) {
		var overlap;
		
		featureGenerator.createMobClosest(roomLocation, MAX_DROP_WALL_NPCS, false);
		
		// Placing drop walls on an overlap:
		gs.dropWallList.push(util.randElem(roomLocation.overlapList));
	};
	
	// TREASURE_ROOM:
	// ********************************************************************************************
	this.specialFeatureTypes.TreasureRoom.generate = function (roomLocation) {
		var door, indexList, doorTileIndex;
		
		door = featureGenerator.createSideRoom(roomLocation, 'Gate');
		door.isLocked = true;
		doorTileIndex = door.tileIndex;
		roomLocation.doorTileIndex = doorTileIndex; // Allows chaining to timed-treasure-room
		
		// Place item within view of the gate:
		indexList = gs.getIndexInBox(roomLocation.floorBox);
		indexList = indexList.filter(index => !gs.isPassable(doorTileIndex.x - 1, doorTileIndex.y) || gs.isRayClear(index, {x: doorTileIndex.x - 1, y: doorTileIndex.y}));
		indexList = indexList.filter(index => !gs.isPassable(doorTileIndex.x + 1, doorTileIndex.y) || gs.isRayClear(index, {x: doorTileIndex.x + 1, y: doorTileIndex.y}));
		indexList = indexList.filter(index => !gs.isPassable(doorTileIndex.x, doorTileIndex.y - 1) || gs.isRayClear(index, {x: doorTileIndex.x, y: doorTileIndex.y - 1}));
		indexList = indexList.filter(index => !gs.isPassable(doorTileIndex.x, doorTileIndex.y + 1) || gs.isRayClear(index, {x: doorTileIndex.x, y: doorTileIndex.y + 1}));
		gs.createRandomFloorItem(util.randElem(indexList), util.randElem(GOOD_DROP_TABLE_LIST));
		
		// Place some gold:
		indexList = gs.getIndexInBox(roomLocation.floorBox);
		indexList = indexList.filter(index => !gs.getItem(index));
		indexList = gs.randSubset(indexList, util.randInt(2, 4));
		indexList.forEach(function (index) {
			gs.createFloorItem(index, Item.createItem('GoldCoin', {amount: gs.dropGoldAmount()}));
		});
	};
	
	// TIMED_TREASURE_ROOM:
	// ********************************************************************************************
	this.specialFeatureTypes.TimedTreasureRoom.generate = function (roomLocation) {
		var door, tileIndex, obj;
		
		featureGenerator.specialFeatureTypes.TreasureRoom.generate(roomLocation);
		
		
		// Replace door with timed gate:
		gs.destroyObject(gs.getObj(roomLocation.doorTileIndex));
		door = gs.createDoor(roomLocation.doorTileIndex, 'TimedGate');

		// Start open:
		door.isOpen = true;
		door.sprite.frame += 1;
		door.timer = TIMED_GATE_TIME;
		
		// Place Switch:
		tileIndex = gs.getOpenIndexInBox(roomLocation.floorBox);
		if (tileIndex) {
			obj = gs.createObject(tileIndex, 'Switch');
			obj.toTileIndex = {x: door.tileIndex.x, y: door.tileIndex.y};
		}
	};
	
	// STORAGE_ROOM:
	// ********************************************************************************************
	this.specialFeatureTypes.StorageRoom.generate = function (roomLocation) {
		var modX, modY;
		
		featureGenerator.createSideRoom(roomLocation);
		
		modX = (roomLocation.floorBox.startX + 1) % 2;
		modY = (roomLocation.floorBox.startY + 1) % 2;
		
		gs.getIndexInBox(roomLocation.floorBox).forEach(function (tileIndex) {
			if (tileIndex.x % 2 === modX && tileIndex.y % 2 === modY && util.frac() < 0.50 ) {
				gs.createNPC(tileIndex, 'Crate');
			}
			
		}, this);
	};
	
	// LIBRARY:
	// ********************************************************************************************
	this.specialFeatureTypes.Library.generate = function (roomLocation) {
		featureGenerator.createSideRoom(roomLocation);
		
		var count = 0;
		
		gs.getIndexInBox(roomLocation.floorBox).forEach(function (index) {
			if (gs.isGoodWallIndex(index) && index.y === roomLocation.floorBox.startY && util.frac() < 0.50 && count < 2) {
				gs.createObject(index, 'BookShelf');
				count += 1;
			}
		}, this);
	};
	
	// GOLD_ROOM:
	// ********************************************************************************************
	this.specialFeatureTypes.GoldRoom.generate = function (roomLocation) {
		var num, tileIndex;
		
		featureGenerator.createSideRoom(roomLocation);
		
		num = util.randInt(3, 6);
		for (let i = 0; i < num; i += 1) {
			tileIndex = gs.getOpenIndexInBox(roomLocation.floorBox);
			if (tileIndex) {
				gs.createFloorItem(tileIndex, Item.createItem('GoldCoin', {amount: gs.dropGoldAmount()}));
			}
		}
	};
	
	// FOOD_ROOM:
	// ********************************************************************************************
	this.specialFeatureTypes.FoodRoom.generate = function (roomLocation) {
		var num, tileIndex;
		
		featureGenerator.createSideRoom(roomLocation);
		
		num = util.randInt(2, 3);
		for (let i = 0; i < num; i += 1) {
			tileIndex = gs.getOpenIndexInBox(roomLocation.floorBox);
			if (tileIndex) {
				gs.createFloorItem(tileIndex, Item.createItem('Meat'));
			}
		}
	};
	
	// POTION_ROOM:
	// ********************************************************************************************
	this.specialFeatureTypes.PotionRoom.generate = function (roomLocation) {
		var num, tileIndex;
		
		featureGenerator.createSideRoom(roomLocation);
		
		num = util.randInt(2, 3);
		for (let i = 0; i < num; i += 1) {
			tileIndex = gs.getOpenIndexInBox(roomLocation.floorBox);
			if (tileIndex) {
				gs.createRandomFloorItem(tileIndex, 'Potions');
			}
		}
	};
	
	// SCROLL_ROOM:
	// ********************************************************************************************
	this.specialFeatureTypes.ScrollRoom.generate = function (roomLocation) {
		var num, tileIndex;
		
		featureGenerator.createSideRoom(roomLocation);
		
		num = util.randInt(2, 3);
		for (let i = 0; i < num; i += 1) {
			tileIndex = gs.getOpenIndexInBox(roomLocation.floorBox);
			if (tileIndex) {
				gs.createRandomFloorItem(tileIndex, 'Scrolls');
			}
		}
	};
	
	// CHOICE_TREASURE_ROOM:
	// ********************************************************************************************
	this.specialFeatureTypes.ChoiceTreasureRoom.generate = function (roomLocation) {
		let dropTables = gs.randSubset(GOOD_DROP_TABLE_LIST, 3);
		
		featureGenerator.createSideRoom(roomLocation);
		
		gs.createCrystalChestGroup();
		
		for (let i = 0; i < 3; i += 1) {
			let tileIndex = gs.getWideOpenIndexInBox(roomLocation.floorBox);
			if (tileIndex) {
				let obj = gs.createCrystalChest(tileIndex);
				obj.item = gs.createRandomItem(dropTables[i], true);
			}
		}
	};
	
	
	// OGRE_CAVE:
	// ********************************************************************************************
	this.floatingFeatureTypes.OgreCave.generate = function () {
		var tileIndex, box, area, npcBox;
		
		tileIndex = baseGenerator.getOpenBox(this.width, this.height);
		box = gs.createBox(tileIndex.x, tileIndex.y, tileIndex.x + this.width, tileIndex.y + this.height);	
		area = featureGenerator.createCave(box);
		
		npcBox = gs.getOpenBoxInArea(area, 4, 4);
		if (npcBox) {
			gs.createObject({x: npcBox.centerX, y: npcBox.centerY}, 'CampFire');
			if (gs.debugProperties.spawnMobs) {
				gs.createNPC(gs.getOpenIndexInBox(npcBox), 'OgreShaman');
				gs.createNPC(gs.getOpenIndexInBox(npcBox), 'Ogre');
				gs.createNPC(gs.getOpenIndexInBox(npcBox), 'Ogre');
			}
		}
		else {
			return false;
		}
		
		// Meat rack:
		tileIndex = gs.getWideOpenIndexInArea(area);
		if (tileIndex) {
			gs.createObject(tileIndex, 'MeatRack');
		}
		
		// Chest:
		tileIndex = gs.getWideOpenIndexInArea(area);
		if (tileIndex) {
			gs.createContainer(tileIndex, 'Chest');
		}

		// Gold:
		for (let i = 0; i < 3; i += 1) {
			tileIndex = gs.getOpenIndexInArea(area);
			if (tileIndex) {
				gs.createFloorItem(tileIndex, Item.createItem('GoldCoin', {amount: util.randInt(Math.ceil(gs.dropGoldAmount() / 2), gs.dropGoldAmount())}));
			}
		}
		
		// Stallagmites:
		for (let i = 0; i < 4; i += 1) {
			tileIndex = gs.getWideOpenIndexInArea(area);
			if (tileIndex) {
				gs.createObject(tileIndex, 'Stalagmite');
			}
		}

		// Bones:	
		for (let i = 0; i < 3; i += 1) {
			tileIndex = gs.getOpenIndexInArea(area);
			if (tileIndex) {
				gs.createVinePatch(tileIndex, util.randInt(1, 3), 'Bones', 0.5);
			}
		}

		// Closing tiles:
		gs.getIndexInBox(area).forEach(function (tileIndex) {
			gs.getTile(tileIndex).isClosed = true;
		}, this);
	};
	
	this.floatingFeatureTypes.OgreCave.canGenerate = function () {
		return baseGenerator.getOpenBox(this.width, this.height);
	};
	
	// BEAR_CAVE:
	// ********************************************************************************************
	this.floatingFeatureTypes.BearCave.generate = function () {
		var tileIndex, box, area, npcBox;
		
		tileIndex = baseGenerator.getOpenBox(this.width, this.height);
		box = gs.createBox(tileIndex.x, tileIndex.y, tileIndex.x + this.width, tileIndex.y + this.height);	
		area = featureGenerator.createCave(box);
		
		npcBox = gs.getOpenBoxInArea(area, 4, 4);
		if (npcBox) {
			if (gs.debugProperties.spawnMobs) {
				gs.createNPC(gs.getOpenIndexInBox(npcBox), 'PolarBear');
				gs.createNPC(gs.getOpenIndexInBox(npcBox), 'PolarBear');
				gs.createNPC(gs.getOpenIndexInBox(npcBox), 'PolarBear');
			}
		}
		else {
			return false;
		}
		
		// Meat rack:
		tileIndex = gs.getWideOpenIndexInArea(area);
		if (tileIndex) {
			gs.createObject(tileIndex, 'MeatRack');
		}
	
		// Stallagmites:
		for (let i = 0; i < 4; i += 1) {
			tileIndex = gs.getWideOpenIndexInArea(area);
			if (tileIndex) {
				gs.createObject(tileIndex, 'Stalagmite');
			}
		}

		// Bones:	
		for (let i = 0; i < 3; i += 1) {
			tileIndex = gs.getOpenIndexInArea(area);
			if (tileIndex) {
				gs.createVinePatch(tileIndex, util.randInt(1, 3), 'Bones', 0.5);
			}
		}

		// Closing tiles:
		gs.getIndexInBox(area).forEach(function (tileIndex) {
			gs.getTile(tileIndex).isClosed = true;
		}, this);
	};
	
	this.floatingFeatureTypes.BearCave.canGenerate = function () {
		return baseGenerator.getOpenBox(this.width, this.height);
	};
	
	// RAT_CAVE:
	// ********************************************************************************************
	this.floatingFeatureTypes.RatCave.generate = function () {
		var tileIndex, box, area, npcBox;
		
		tileIndex = baseGenerator.getOpenBox(this.width, this.height);
		box = gs.createBox(tileIndex.x, tileIndex.y, tileIndex.x + this.width, tileIndex.y + this.height);	
		area = featureGenerator.createCave(box);
		
		for (let i = 0; i < 3; i += 1) {
			tileIndex = gs.getWideOpenIndexInArea(area);
			if (tileIndex) {
				gs.createNPC(tileIndex, 'RatNest');
				
			}
		}
		
		// Stallagmites:
		for (let i = 0; i < 4; i += 1) {
			tileIndex = gs.getWideOpenIndexInArea(area);
			if (tileIndex) {
				gs.createObject(tileIndex, 'Stalagmite');
			}
		}

		// Closing tiles:
		gs.getIndexInBox(area).forEach(function (tileIndex) {
			gs.getTile(tileIndex).isClosed = true;
		}, this);
	};
	
	this.floatingFeatureTypes.RatCave.canGenerate = function () {
		return baseGenerator.getOpenBox(this.width, this.height);
	};
	
	// ANT_CAVE:
	// ********************************************************************************************
	this.floatingFeatureTypes.AntCave.generate = function () {
		var tileIndex, box, area, npcBox;
		
		tileIndex = baseGenerator.getOpenBox(this.width, this.height);
		box = gs.createBox(tileIndex.x, tileIndex.y, tileIndex.x + this.width, tileIndex.y + this.height);	
		area = featureGenerator.createCave(box);
		
		for (let i = 0; i < 10; i += 1) {
			tileIndex = gs.getOpenIndexInArea(area);
			if (tileIndex) {
				gs.createNPC(tileIndex, 'GiantAnt');
				
			}
		}
		
		// Stallagmites:
		for (let i = 0; i < 4; i += 1) {
			tileIndex = gs.getWideOpenIndexInArea(area);
			if (tileIndex) {
				gs.createObject(tileIndex, 'Stalagmite');
			}
		}

		// Closing tiles:
		gs.getIndexInBox(area).forEach(function (tileIndex) {
			gs.getTile(tileIndex).isClosed = true;
		}, this);
	};
	
	this.floatingFeatureTypes.AntCave.canGenerate = function () {
		return baseGenerator.getOpenBox(this.width, this.height);
	};
	
	// BEE_HIVE:
	// ********************************************************************************************
	this.floatingFeatureTypes.BeeHive.generate = function () {
		var tileIndex, box, area, npcBox;
		
		tileIndex = baseGenerator.getOpenBox(this.width, this.height);
		box = gs.createBox(tileIndex.x, tileIndex.y, tileIndex.x + this.width, tileIndex.y + this.height);	
		area = featureGenerator.createCave(box);
		
		for (let i = 0; i < 10; i += 1) {
			tileIndex = gs.getOpenIndexInArea(area);
			if (tileIndex) {
				gs.createNPC(tileIndex, 'GiantBee');
				
			}
		}
		
		// Stallagmites:
		for (let i = 0; i < 4; i += 1) {
			tileIndex = gs.getWideOpenIndexInArea(area);
			if (tileIndex) {
				gs.createObject(tileIndex, 'Stalagmite');
			}
		}

		// Closing tiles:
		gs.getIndexInBox(area).forEach(function (tileIndex) {
			gs.getTile(tileIndex).isClosed = true;
		}, this);
	};
	
	this.floatingFeatureTypes.BeeHive.canGenerate = function () {
		return baseGenerator.getOpenBox(this.width, this.height);
	};
	
};

// PLACE_FLOATING_VAULT:
// Generic code used by floating features
// ************************************************************************************************
featureGenerator.placeFloatingVault = function (vaultTypeName) {
	var vaultType, area, indexList, tileIndex, centerTileIndex;
		
	vaultType = gs.vaultTypes[vaultTypeName];
	
	tileIndex = baseGenerator.getOpenBox(vaultType.width, vaultType.height);

	area = baseGenerator.placeVault(tileIndex, {vaultTypeName: vaultTypeName});

	// Find nearest tileIndex:
	indexList = gs.getAllIndex();
	indexList = indexList.filter(index => gs.isHallIndex(index));
	indexList = indexList.filter(index => !gs.getArea(index) || gs.getArea(index) !== area);
	centerTileIndex = {x: area.centerX, y: area.centerY};
	indexList = indexList.sort((a, b) => gs.distance(a, centerTileIndex) - gs.distance(b, centerTileIndex));

	// Connect w/ hall
	baseGenerator.placeAStarHall(gs.getHallIndex(area), indexList[0]);

	// Close tiles:
	gs.getIndexInBox(area).forEach(function (index) {
		gs.getTile(index).isClosed = true;
	});
};

// CREATE_CAVE:
// Generic code used by many floating feature generators
// Returns the area
// ************************************************************************************************
featureGenerator.createCave = function (box) {
	var area, indexList;
	
	// Creating cave:
	baseGenerator.placeTileCave(box.startTileIndex, box.endTileIndex, gs.tileTypes.CaveWall);
		
	// Creating area:
	area = baseGenerator.createArea(box.startX, box.startY, box.endX, box.endY);
	area.type = 'FeatureCave';
	
	
	// Find nearest tileIndex:
	indexList = gs.getAllIndex();
	indexList = indexList.filter(index => gs.isHallIndex(index));
	indexList = indexList.filter(index => !gs.getArea(index) || gs.getArea(index) !== area);
	indexList = indexList.sort((a, b) => gs.distance(a, area.centerTileIndex) - gs.distance(b, area.centerTileIndex));


	// Connecting to main cave:
	baseGenerator.createHall(gs.getOpenIndexInArea(area), indexList[0], 3, gs.tileTypes.CaveFloor);
	
	return area;
};

// CREATE_SIDE_ROOM:
// Generic code used by many side rooms
// Creates the room and door
// Returns the door for post processing
// ************************************************************************************************
featureGenerator.createSideRoom = function (roomLocation, doorTypeType = 'Door') {
	var floorBox, tileIndex, door;
	
	floorBox = gs.createBox(roomLocation.tileIndex.x + 1,
							roomLocation.tileIndex.y + 1,
							roomLocation.tileIndex.x + roomLocation.width - 1,
							roomLocation.tileIndex.y + roomLocation.height - 1);
	
	roomLocation.floorBox = floorBox;
	
	// Carving out floor:
	baseGenerator.placeTileSquare(floorBox.startTileIndex, floorBox.endTileIndex, gs.tileTypes.Floor);

	// Placing doors on an overlap:
	tileIndex = util.randElem(util.randElem(roomLocation.overlapList));
	gs.setTileType(tileIndex, gs.tileTypes.Floor);
	door = gs.createDoor(tileIndex, doorTypeType);
	roomLocation.doorTileIndex = {x: tileIndex.x, y: tileIndex.y};
	
	
	return door;
};

// CREATE_MOB_CLOSET:
// Generic code used by drop wall rooms and monster zoos:
// ************************************************************************************************
featureGenerator.createMobClosest = function (roomLocation, maxNPCs, hasChest, dropTable) {
	var floorBox, indexList;
		
	// Floor Box:
	floorBox = gs.createBox(roomLocation.tileIndex.x + 1,
							roomLocation.tileIndex.y + 1,
							roomLocation.tileIndex.x + roomLocation.width - 1,
							roomLocation.tileIndex.y + roomLocation.height - 1);
	roomLocation.floorBox = floorBox;
	
	// Carving out floor:
	baseGenerator.placeTileSquare(floorBox.startTileIndex, floorBox.endTileIndex, gs.tileTypes.Floor);

	
	if (!gs.getWideOpenIndexInBox(floorBox)) {
		console.log(floorBox);
		console.log(roomLocation);
		throw 'error';
	}
	
	// Placing chest:
	if (hasChest) {
		if (dropTable) {
			gs.createContainer(gs.getWideOpenIndexInBox(floorBox), 'Chest', false, false, util.randElem(dropTable));
		}
		else {
			gs.createContainer(gs.getWideOpenIndexInBox(floorBox), 'Chest', false, false);
		}
	}
	

	// Placing monsters:
	if (gs.debugProperties.spawnMobs) {
		indexList = gs.getIndexInBox(floorBox);
		indexList = indexList.filter(index => gs.isPassable(index));
		
		// Maximum number of monsters:
		indexList = gs.randSubset(indexList, Math.min(maxNPCs, indexList.length));

		for (let i = 0; i < indexList.length; i += 1) {
			gs.spawnMonsterZooNPC(indexList[i]);
			gs.getChar(indexList[i]).isAsleep = false;
		}
	}

	// Close Tiles:
	// Including walls to disable tunneling through them
	gs.getIndexInBox(floorBox.startX - 1, floorBox.startY - 1, floorBox.endX + 1, floorBox.endY + 1).forEach(function (index) {
		gs.getTile(index).isClosed = true;
	}, this);
};



// GET_SIDE_ROOM_LOCATION_LIST:
// Return a list of {tileIndex, width, height} which represent valid locations where a side room can be generated
// ************************************************************************************************
featureGenerator.getSideRoomLocationList = function (specialFeatureType) {
	var validList = [], roomLocation;
	
	// Iterating over all possible sizes of the room:
	for (let x = specialFeatureType.minSize; x <= specialFeatureType.maxSize; x += 1) {
		for (let y = specialFeatureType.minSize; y <= specialFeatureType.maxSize; y += 1) {
			
			// Iterating over all possible tileIndices:
			gs.getAllIndex().forEach(function (tileIndex) {
				roomLocation = this.getSideRoomLocation(tileIndex, x, y, specialFeatureType.minOverlap);
				if (roomLocation) {
					validList.push(roomLocation);
				}
			}, this);
			
		}
	}
	
	return validList;
};

// EFFICIENCY_NOTES:
// use a blockSideRoom flag that is reset on each pass
// by going from smallest to largest, if a tile is invalid for a small room it will be invalid for anything larger
// this will help to speed up generation

// IS_OVERLAP:
// Is tile cardinally adjacent to at least one passable tile
// ************************************************************************************************
featureGenerator.isOverlap = function (x, y) {
	return gs.isPassable(x - 1, y) && !gs.getTile(x - 1, y).isClosed
		|| gs.isPassable(x + 1, y) && !gs.getTile(x + 1, y).isClosed
		|| gs.isPassable(x, y - 1) && !gs.getTile(x, y - 1).isClosed
		|| gs.isPassable(x, y + 1) && !gs.getTile(x, y + 1).isClosed;
};

// GET_SIDE_ROOM_LOCATION:
// Will test if the position is valid (returns null if invalid)
// If it is valid it will return a validLocation obj
// validRoomLocation: {tileIndex, width, height, wallList}
// Wall list is a list of arrays containing contiguous overlaps
// ************************************************************************************************
featureGenerator.getSideRoomLocation = function (tileIndex, width, height, minOverlap) {
	var indexList, count, validRoomLocation, tempOverlap = [], overlapIterate;
	
	validRoomLocation = {
		tileIndex: {x: tileIndex.x, y: tileIndex.y},
		width: width,
		height: height,
		overlapList: []
	};
	
	// Testing that all tiles are not passable i.e. some type of wall:
	indexList = gs.getIndexInBox(tileIndex.x, tileIndex.y, tileIndex.x + width, tileIndex.y + height);
	indexList = indexList.filter(index => !gs.getTile(index).type.passable);
	indexList = indexList.filter(index => !gs.getTile(index).isClosed);
	if (indexList.length !== width * height) {
		return null;
	}
	
	
	
	// Test each wall of the potential side room to see what the overlap is:
	// Note that we are not testing the corners
	// Note that count is reset in order to guarantee continuous overlap
	// Upper Wall:
	
	overlapIterate = function (x, y) {
		if (this.isOverlap(x, y)) {
			count += 1;
			tempOverlap.push({x: x, y: y});
		}
		else {
			if (count >= minOverlap) {
				validRoomLocation.overlapList.push(tempOverlap);
			}
			tempOverlap = [];
			count = 0;
		}
	}.bind(this);
	
	// Upper Wall:
	count = 0;
	tempOverlap = [];
	for (let x = tileIndex.x + 1; x < tileIndex.x + width - 1; x += 1) {
		overlapIterate(x, tileIndex.y);
	}
	
	// Lower Wall:
	count = 0;
	tempOverlap = [];
	for (let x = tileIndex.x + 1; x < tileIndex.x + width - 1; x += 1) {
		overlapIterate(x, tileIndex.y + height - 1);
	}
	
	// Left Wall:
	count = 0;
	tempOverlap = [];
	for (let y = tileIndex.y + 1; y < tileIndex.y + height - 1; y += 1) {
		overlapIterate(tileIndex.x, y);
	}
	
	// Right Wall:
	count = 0;
	tempOverlap = [];
	for (let y = tileIndex.y + 1; y < tileIndex.y + height - 1; y += 1) {
		overlapIterate(tileIndex.x + width - 1, y);
	}
	
	if (validRoomLocation.overlapList.length > 0) {
		return validRoomLocation;
	}
	else {
		return null;
	}
	
};/*global gs, game, console, Phaser, util*/
/*global baseGenerator*/
/*global VAULT_ROOM_PERCENT*/
/*jshint esversion: 6, laxbreak: true, loopfunc: true*/
'use strict';

// PLACE VS PLACE RANDOM:
// Generally, generators will use placeRandom and pass it an area

// ROOM_TYPE:
// Each room type handles the initial generation of tiles
// It then has custom functions for handling the placement of pillars and water that fit its unique shape
// Each room types generator will return the roomArea correctly filled in with tiles

// GENERATE:
// Given a box, place a room of random size within its bounds.
// Will create and return an area with tiles correctly set

// BOXS:
// Note: all boxes are lower bound inclusive and upper bound exclusive
// Note: all sizes of rooms include the walls i.e. floor space is width - 2, height - 2

var roomGenerator = {};

var MIN_ROOM_SIZE = 5;

// CREATE_ROOM_TYPES:
// ************************************************************************************************
roomGenerator.createRoomTypes = function () {
	this.roomTypes = {};
	this.roomTypeList = [];
	
	this.createSquareRoomType();
	this.createCrossRoomType();
	
	
	// CIRCLE:
	// ********************************************************************************************
	this.roomTypes.Circle = {};
	this.roomTypes.Circle.generate = function (boundsBox, roomDesc, useMaxSize) {
		var box, radius;
		
		if (useMaxSize) {
			box = boundsBox;
		}
		else {
			box = roomGenerator.randomBox(boundsBox);
		}
		
		radius = Math.floor(Math.max(box.width, box.height) / 2) - 1;
		baseGenerator.placeTileCircle(box.centerTileIndex, radius, gs.tileTypes.Wall);
		baseGenerator.placeTileCircle(box.centerTileIndex, radius - 1, gs.tileTypes.Floor);
		
		
		return baseGenerator.createArea(box.startX, box.startY, box.endX, box.endY);
	};
	
	// VAULT:
	// ********************************************************************************************
	this.roomTypes.Vault = {};
	this.roomTypes.Vault.generate = function (boundsBox, roomDesc, maxSize) {
		var tileIndex, roomArea;
		
		
		roomArea = baseGenerator.placeVault(boundsBox.startTileIndex, roomDesc.vaultDesc);
		
		return roomArea;
	};
	
	gs.nameTypes(this.roomTypes);
	gs.forEachType(this.roomTypes, function (roomType) {
		this.roomTypeList.push(roomType);
	}, this);
};

// PLACE_RANDOM_ROOM:
// Returns the area
// ************************************************************************************************
roomGenerator.placeRandomRoom = function (boundsBox, vaultTags, useMaxSize) {
	var roomTypeList = [], vaultDesc;
	
	vaultTags = vaultTags || gs.zoneType().vaultTags;
	
	// All rooms can be square:
	roomTypeList.push({roomType: 'Square'});
	
	// Only square bounds can be crosses:
	if (util.boxType(boundsBox) === 'SQUARE') {
		roomTypeList.push({roomType: 'Cross'});
	}
	
	if (util.boxType(boundsBox) === 'SQUARE' && boundsBox.width >= 7) {
		roomTypeList.push({roomType: 'Circle'});
	}
	
	
	// Vault:
	vaultDesc = gs.randVaultType(boundsBox.width / 2, boundsBox.height / 2, boundsBox.width, boundsBox.height, vaultTags);
	if (vaultDesc && util.frac() < VAULT_ROOM_PERCENT) {
		roomTypeList.push({roomType: 'Vault', vaultDesc: vaultDesc});
	}
	
	
	roomTypeList = roomTypeList.filter(type => gs.inArray(type.roomType, gs.zoneType().roomTags));

	return this.placeRoom(boundsBox, util.randElem(roomTypeList), useMaxSize);
};

// PLACE_ROOM:
// Returns the area
// ************************************************************************************************
roomGenerator.placeRoom = function (boundsBox, roomDesc, useMaxSize) {
	var roomArea;
	
	if (!this.roomTypes.hasOwnProperty(roomDesc.roomType)) {
		throw 'Invalid roomTypeName: ' + roomDesc.roomType;
	} 
	
	roomArea = this.roomTypes[roomDesc.roomType].generate(boundsBox, roomDesc, useMaxSize);
	
	return roomArea;
};

// DRESS_ROOMS:
// ************************************************************************************************
roomGenerator.dressRooms = function () {
	gs.areaList.forEach(function (area) {
		this.dressRoom(area);
	}, this);
};

// DRESS_ROOM:
// ************************************************************************************************
roomGenerator.dressRoom = function (area) {
	if (area.roomType) {
		this.roomTypes[area.roomType].dressRoom(area);
	}
};

// RANDOM_BOX:
// Given a box in which a room will be placed, return a new box with random width and height
// Also with a random position within the box that does not exceed the bounds
// Width and height can vary from half to full size
// ************************************************************************************************
roomGenerator.randomBox = function (box) {
	var startX, startY, width, height;
	
	width = Math.max(MIN_ROOM_SIZE, util.randInt(box.width / 2 + 1, box.width));
	height = Math.max(MIN_ROOM_SIZE, util.randInt(box.height / 2 + 1, box.height));
	
	// Don't allow super long narrow rooms:
	width = Math.min(box.width, Math.max(Math.floor(height * 0.5), width));
	height = Math.min(box.height, Math.max(Math.floor(width * 0.5), height));
	
	
	startX = box.startX + util.randInt(0, box.width - width);
	startY = box.startY + util.randInt(0, box.height - height);
	
	return gs.createBox(startX, startY, startX + width, startY + height);
};

// RANDOM_TALL_BOX
// ************************************************************************************************
roomGenerator.randomTallBox = function (box) {
	var startX, startY, width, height;
	
	width = Math.max(MIN_ROOM_SIZE, util.randInt(box.width * 0.4, box.width * 0.6));
	height = Math.max(MIN_ROOM_SIZE, Math.ceil(box.height * 0.5) + util.randInt(box.height * 0.25, box.height * 0.5));
	
	startX = box.startX + Math.round((util.randInt(0, box.width - width) + util.randInt(0, box.width - width)) / 2);
	startY = box.startY + util.randInt(0, box.height - height);
	
	return gs.createBox(startX, startY, startX + width, startY + height);
};

// RANDOM_WIDE_BOX
// ************************************************************************************************
roomGenerator.randomWideBox = function (box) {
	var startX, startY, width, height;
	
	width = Math.max(MIN_ROOM_SIZE, Math.ceil(box.width * 0.5) + util.randInt(box.width * 0.25, box.width * 0.5));
	height = Math.max(MIN_ROOM_SIZE, util.randInt(box.height * 0.4, box.height * 0.60));
	
	startX = box.startX + util.randInt(0, box.width - width);
	startY = box.startY + Math.round((util.randInt(0, box.height - height) + util.randInt(0, box.height - height)) / 2);
	
	return gs.createBox(startX, startY, startX + width, startY + height);
};

// CREATE_SQUARE_ROOM_TYPE:
// A square or rectangular room
// ************************************************************************************************
roomGenerator.createSquareRoomType = function () {
	this.roomTypes.Square = {};
	
	// GENERATE:
	// ********************************************************************************************
	this.roomTypes.Square.generate = function (boundsBox, roomDesc, maxSize) {
		var area, box;
		
		if (maxSize) {
			box = boundsBox;
		}
		else {
			box = roomGenerator.randomBox(boundsBox);
		}
		
		// Wall:
		baseGenerator.placeTileSquare(box.startTileIndex, box.endTileIndex, gs.tileTypes.Wall);
		
		// Floor:
		baseGenerator.placeTileSquare({x: box.startX + 1, y: box.startY + 1}, {x: box.endX - 1, y: box.endY - 1}, gs.tileTypes.Floor);
		
		// Solid Walls:
		gs.getTile(box.startX, box.startY).isSolidWall = true;
		gs.getTile(box.startX, box.endY - 1).isSolidWall = true;
		gs.getTile(box.endX - 1, box.startY).isSolidWall = true;
		gs.getTile(box.endX - 1, box.endY - 1).isSolidWall = true;
		
		area = baseGenerator.createArea(box.startX, box.startY, box.endX, box.endY);
		area.roomType = 'Square';
		
		return area;
	};
	
	// DRESS_ROOM:
	// ********************************************************************************************
	this.roomTypes.Square.dressRoom = function (area) {
		var list = [], objectTypeName = 'Pillar';
		
		if (gs.zoneName === 'TheIronFortress' && game.rnd.frac() < 0.25) {
			objectTypeName = 'GasLamp';
		}
		
		if (gs.zoneName === 'TheDarkTemple' && game.rnd.frac() < 0.25) {
			objectTypeName = 'Brazer';
		}
		
		// Pillars:
		if (Math.min(area.width, area.height) > 7 && util.frac() < 0.25) {
			this.placePillars(area, objectTypeName);
		}
		
		// Water:
		if (Math.min(area.width, area.height) > 5 && util.frac() < 0.25 && !gs.zoneType().spawnLava) {
			this.placeWater(area);
		}
		
		// Lava:
		if (Math.min(area.width, area.height) > 5 && util.frac() < 0.25 && gs.zoneType().spawnLava) {
			this.placeLava(area);
		}
		
		// Pit:
		if (!area.hasWater && Math.min(area.width, area.height) > 5 && util.frac() < 0.25 && gs.zoneLevel < 4 && gs.zoneType().spawnPits) {
			this.placePit(area);
		}
		
		// Other Dressing Types:
		if (!area.hasWater && !area.hasPillars && util.frac() < 0.25) {
			
			if (gs.zoneName === 'TheCrypt') {
				if (Math.min(area.width, area.height) > 6) {
					list.push(roomGenerator.dressCrypt);
				}
			}
			else {
				if (Math.min(area.width, area.height) > 7) {
					list.push(roomGenerator.dressDiningRoom);
					list.push(roomGenerator.dressPracticeRoom);
				}

				if (Math.min(area.width, area.height) > 7 && util.boxType(area) === 'SQUARE') {
					list.push(roomGenerator.dressBedRoom);
				}
			}
		
			if (list.length > 0) {
				util.randElem(list).call(this, area);
			}
			
		}
	};
	
	// PLACE_PILLARS:
	// ********************************************************************************************
	this.roomTypes.Square.placePillars = function (area, objectTypeName = 'Pillar') {
		var type;
		
		if (util.boxType(area) === 'TALL') {
			type = 'SIDES';
		}
		else if (util.boxType(area) === 'WIDE') {
			type = 'TOP';
		}
		else {
			type = 'BOX';
		}
		
		// Pillars are along left and right walls:
		for (let x = area.startX + 2; x < area.endX - 2; x += 1) {
			for (let y = area.startY + 2; y < area.endY - 2; y += 1) {
				// Left and Right walls:
				if (type === 'SIDES' && (x === area.startX + 2 || x === area.endX - 3) && y % 3 === 0) {
					if (!gs.getObj(x, y)) {
						gs.createObject({x: x, y: y}, objectTypeName);
					}
				}

				// Top and Bottom walls:
				if (type === 'TOP' && (y === area.startY + 2 || y === area.endY - 3) && x % 3 === 0) {
					if (!gs.getObj(x, y)) {
						gs.createObject({x: x, y: y}, objectTypeName);
					}
				}
			}
		}
		
		// Box:
		if (type === 'BOX') {
			if (!gs.getObj(area.startX + 2, area.startY + 2)) {
				gs.createObject({x: area.startX + 2, y: area.startY + 2}, objectTypeName);
			}
			if (!gs.getObj(area.startX + 2, area.endY - 3)) {
				gs.createObject({x: area.startX + 2, y: area.endY - 3}, objectTypeName);
			}
			if (!gs.getObj(area.endX - 3, area.startY + 2)) {
				gs.createObject({x: area.endX - 3, y: area.startY + 2}, objectTypeName);
			}
			if (!gs.getObj(area.endX - 3, area.endY - 3)) {
				gs.createObject({x: area.endX - 3, y: area.endY - 3}, objectTypeName);
			}
		}
		
		area.hasPillars = true;
	};
	
	// PLACE_FILL_TILE:
	// Used to place pits or water
	// ********************************************************************************************
	this.roomTypes.Square.placeFillTile = function (area, tileType) {
		var indexList,
			fillTypes,
			fillType,
			radius;
		
		
		fillTypes = [
			{name: 'STANDARD', percent: 80},
		];
		
		if (!area.hasPillars) {
			fillTypes.push({name: 'RANDOM', percent: 20});
		}
		
		if (util.boxType(area) === 'SQUARE' && Math.min(area.width, area.height) > 7 && area.width % 2 === 1 && area.height % 2 === 1) {
			fillTypes.push({name: 'CIRCLE', percent: 25000});
		}
		
		fillType = gs.chooseRandom(fillTypes);
		
	
	
		// Random Size:
		if (fillType === 'RANDOM') {
			indexList = gs.getIndexInBox(area.startX + 2 + util.randInt(0, Math.floor(area.width / 4)), 
									 area.startY + 2 + util.randInt(0, Math.floor(area.height / 4)), 
									 area.endX - 2 - util.randInt(0, Math.floor(area.width / 4)), 
									 area.endY - 2 - util.randInt(0, Math.floor(area.height / 4)));
		}
		// Standard Size:
		else if (fillType === 'STANDARD') {
			indexList = gs.getIndexInBox(area.startX + 2, area.startY + 2, area.endX - 2, area.endY - 2);
		}
		// Circle
		else if (fillType === 'CIRCLE') {
			radius = Math.floor(Math.min(area.width, area.height) / 2) - 3;
			gs.getIndexInRadius(area.centerTileIndex, radius + 1).forEach(function (index) {
				if (!gs.getTile(index).mustBeFloor && gs.isPassable(index) && gs.distance(area.centerTileIndex, index) < radius + 1) {
					gs.setTileType(index, gs.tileTypes.Water);
				}
			}, this);
			
			return;
		}
		

		indexList.forEach(function (index) {
			if (!gs.getTile(index).mustBeFloor && gs.isPassable(index)) {
				gs.setTileType(index, tileType);
			}
		}, this);
	};	
	
	// PLACE_WATER:
	// ********************************************************************************************
	this.roomTypes.Square.placeWater = function (area) {
		area.hasWater = true;
		this.placeFillTile(area, gs.tileTypes.Water);
	};
	
	// PLACE_LAVA:
	// ********************************************************************************************
	this.roomTypes.Square.placeLava = function (area) {
		area.hasWater = true;
		this.placeFillTile(area, gs.tileTypes.Lava);
	};
	
	// PLACE_PIT:
	// ********************************************************************************************
	this.roomTypes.Square.placePit = function (area) {
		area.hasPit = true;
		this.placeFillTile(area, gs.tileTypes.Pit);
	};
	
};

// CREATE_CROSS_ROOM_TYPE:
// ************************************************************************************************
roomGenerator.createCrossRoomType = function () {
	this.roomTypes.Cross = {};
	
	// GENERATE:
	// ********************************************************************************************
	this.roomTypes.Cross.generate = function (boundsBox, roomDesc, maxSize) {
		var area,
			tallBox = roomGenerator.randomTallBox(boundsBox),
			wideBox = roomGenerator.randomWideBox(boundsBox);
		
		// Walls:
		baseGenerator.placeTileSquare(tallBox.startTileIndex, tallBox.endTileIndex, gs.tileTypes.Wall);
		baseGenerator.placeTileSquare(wideBox.startTileIndex, wideBox.endTileIndex, gs.tileTypes.Wall);
		
		// Floors:
		baseGenerator.placeTileSquare({x: tallBox.startX + 1, y: tallBox.startY + 1}, {x: tallBox.endX - 1, y: tallBox.endY - 1}, gs.tileTypes.Floor);
		baseGenerator.placeTileSquare({x: wideBox.startX + 1, y: wideBox.startY + 1}, {x: wideBox.endX - 1, y: wideBox.endY - 1}, gs.tileTypes.Floor);
		
		// Create Area:
		area = baseGenerator.createArea(boundsBox.startX, boundsBox.startY, boundsBox.endX, boundsBox.endY);
		area.roomType = 'Cross';
		area.tallBox = tallBox;
		area.wideBox = wideBox;
		area.centerBox = util.intersectBox(tallBox, wideBox);
		
		return area;
	};
	
	// DRESS_ROOM:
	// ********************************************************************************************
	this.roomTypes.Cross.dressRoom = function (area) {
		var objectTypeName = 'Pillar';
		
		if (gs.zoneName === 'TheIronFortress' && game.rnd.frac() < 0.25) {
			objectTypeName = 'GasLamp';
		}
		
		if (gs.zoneName === 'TheDarkTemple' && game.rnd.frac() < 0.25) {
			objectTypeName = 'Brazer';
		}
		
		if (Math.min(area.tallBox.width, area.tallBox.height) > 7 || Math.min(area.wideBox.width, area.wideBox.height) > 7 && util.frac() < 0.25) {	
			this.placePillars(area, objectTypeName);
		}
		
		if (util.frac() < 0.25 && !gs.zoneType().spawnLava) {
			this.placeWater(area);
		}
		
		if (util.frac() < 0.25 && gs.zoneType().spawnLava) {
			this.placeLava(area);
		}
	};
	
	// PLACE_PILLARS:
	// ********************************************************************************************
	this.roomTypes.Cross.placePillars = function (area, objectTypeName = 'Pillar') {
		var innerWideBox = gs.createBox(area.wideBox.startX + 2, area.wideBox.startY + 2, area.wideBox.endX - 2, area.wideBox.endY - 2),
			innerTallBox = gs.createBox(area.tallBox.startX + 2, area.tallBox.startY + 2, area.tallBox.endX - 2, area.tallBox.endY - 2),
			innerCenterBox = gs.createBox(area.centerBox.startX + 1, area.centerBox.startY + 1, area.centerBox.endX - 1, area.centerBox.endY - 1);
		
		util.edgeBoxIndexList(innerWideBox).forEach(function (tileIndex) {
			if (!util.isInBox(tileIndex, innerCenterBox) && tileIndex.x % 3 === innerWideBox.startX % 3 && tileIndex.y % 3 === innerWideBox.startY % 3) {
				if (!gs.getObj(tileIndex)) {
					gs.createObject(tileIndex, objectTypeName);
				}
			}
		}, this);
		
		util.edgeBoxIndexList(innerTallBox).forEach(function (tileIndex) {
			if (!util.isInBox(tileIndex, innerCenterBox) && tileIndex.x % 3 === innerTallBox.startX % 3 && tileIndex.y % 3 === innerTallBox.startY % 3) {
				if (!gs.getObj(tileIndex)) {
					gs.createObject(tileIndex, objectTypeName);
				}
				
			}
		}, this);
		
		area.hasPillars = true;
			
	};
	
	// PLACE_WATER:
	// ********************************************************************************************
	this.roomTypes.Cross.placeFillTile = function (area, tileType) {
			var indexList;
		
		area.hasWater = true;
		
		// Center water:
		if (util.frac() < 0.5) {
			indexList = gs.getIndexInBox(area.centerBox.startX + 1, area.centerBox.startY + 1, area.centerBox.endX - 1, area.centerBox.endY - 1);
			indexList.forEach(function (tileIndex) {
				if (!gs.getTile(tileIndex).mustBeFloor && gs.isPassable(tileIndex)) {
					gs.setTileType(tileIndex, tileType);
				}
			}, this);
		}
		else {
			if (area.tallBox.width > 5) {
				indexList = gs.getIndexInBox(area.tallBox.startX + 2, area.tallBox.startY + 2, area.tallBox.endX - 2, area.tallBox.endY - 2);
				indexList.forEach(function (tileIndex) {
					if (!gs.getTile(tileIndex).mustBeFloor && gs.isPassable(tileIndex)) {
						gs.setTileType(tileIndex, tileType);
					}
				}, this);
			}

			if (area.wideBox.height > 5) {
				indexList = gs.getIndexInBox(area.wideBox.startX + 2, area.wideBox.startY + 2, area.wideBox.endX - 2, area.wideBox.endY - 2);
				indexList.forEach(function (tileIndex) {
					if (!gs.getTile(tileIndex).mustBeFloor && gs.isPassable(tileIndex)) {
						gs.setTileType(tileIndex, tileType);
					}
				}, this);
			}
		}
	};
	
	
	// PLACE_WATER:
	// ********************************************************************************************
	this.roomTypes.Cross.placeWater = function (area) {
		area.hasWater = true;
		this.placeFillTile(area, gs.tileTypes.Water);
	};
	
	// PLACE_LAVA:
	this.roomTypes.Cross.placeLava = function (area) {
		area.hasWater = true;
		this.placeFillTile(area, gs.tileTypes.Lava);
	};
	
	// PLACE_PIT:
	// ********************************************************************************************
	this.roomTypes.Cross.placePit = function (area) {
		area.hasPit = true;
		this.placeFillTile(area, gs.tileTypes.Pit);
	};
	
};

// IS_GOOD_OBJ_INDEX:
// ************************************************************************************************
roomGenerator.isGoodObjIndex = function (tileIndex) {
	return gs.isPassable(tileIndex)
		&& !gs.getTile(tileIndex).type.isPit
		&& !gs.getObj(tileIndex)
		&& !gs.getTile(tileIndex).isClosed;
};

// DRESS_DINING_ROOM:
// ************************************************************************************************
roomGenerator.dressDiningRoom = function (area) {
	util.innerAreaIndexList(area).forEach(function (tileIndex) {
		if (tileIndex.y % 2 === 0 && roomGenerator.isGoodObjIndex(tileIndex) && game.rnd.frac() < 0.50) {
			gs.createObject(tileIndex, 'Table');
		}
	}, this);
};

// DRESS_PRACTICE_ROOM:
// ************************************************************************************************
roomGenerator.dressPracticeRoom = function (area) {
	util.innerAreaIndexList(area).forEach(function (tileIndex) {
		
		gs.setTileType(tileIndex, gs.tileTypes.CaveFloor, 320);
		
		if (tileIndex.y % 2 === 0 && tileIndex.x % 2 === 0 && roomGenerator.isGoodObjIndex(tileIndex) && game.rnd.frac() < 0.50) {
			gs.createObject(tileIndex, 'PracticeDummy');
		}
	}, this);
};

// DRESS_BED_ROOM:
// ************************************************************************************************
roomGenerator.dressBedRoom = function (area) {
	util.innerAreaIndexList(area).forEach(function (tileIndex) {		
		if (tileIndex.y % 2 === 0 && tileIndex.x % 2 === 0 && roomGenerator.isGoodObjIndex(tileIndex) && game.rnd.frac() < 0.50) {
			gs.createObject(tileIndex, 'Bed');
		}
	}, this);
};

// DRESS_CRYPT:
// large room with caskets placed down the center in one or more columns providing cover from projectiles.
// ************************************************************************************************
roomGenerator.dressCrypt = function (area) {
	util.innerAreaIndexList(area).forEach(function (tileIndex) {		
		if (tileIndex.y % 2 === 0 && tileIndex.x % 2 === 0 && roomGenerator.isGoodObjIndex(tileIndex) && game.rnd.frac() < 0.50) {
			gs.createObject(tileIndex, 'Casket');
		}
	}, this);
};/*global game, gs, console, util, Phaser*/
/*global TILE_SIZE, SCALE_FACTOR, NUM_TILES_X, NUM_TILES_Y*/
/*jshint white: true, laxbreak: true, esversion: 6, loopfunc: true*/
'use strict';

var baseGenerator = new BaseGenerator();

// CONSTRUCTOR:
// ************************************************************************************************
function BaseGenerator() {
	this.numTilesX = NUM_TILES_X;
	this.numTilesY = NUM_TILES_Y;
}

// CREATE_AREA:
// ************************************************************************************************
BaseGenerator.prototype.createArea = function (startX, startY, endX, endY) {
	var x, y, area = gs.createBox(startX, startY, endX, endY);
	
	// Flag tiles as belonging to area:
	for (x = area.startX; x < area.endX; x += 1) {
		for (y = area.startY; y < area.endY; y += 1) {
			if (gs.isPassable(x, y)) {
				gs.getTile(x, y).area = area;
			}
		}
	}
	
	return area;
};

// REMOVE_ALL_AREA_FLAGS:
// ************************************************************************************************
BaseGenerator.prototype.removeAllAreaFlags = function () {
	var x, y;
	for (x = 0; x < this.numTilesX; x += 1) {
		for (y = 0; y < this.numTilesY; y += 1) {
			gs.getTile(x, y).area = null;
		}
	}
};

// GET_OPEN_BOX:
// Return the top left tileIndex of a box of size width/height such that non of the tiles are isSolidWalls
// ************************************************************************************************
BaseGenerator.prototype.getOpenBox = function (width, height) {
	var x, y, list = [];
	
	gs.getAllIndex().forEach(function (tileIndex) {
		var indexList;
		
		indexList = gs.getIndexInBox(tileIndex.x - 1, tileIndex.y - 1, tileIndex.x + width + 1, tileIndex.y + height + 1);
		
		indexList = indexList.filter(index => !gs.getTile(index).isSolidWall && !gs.getTile(index).isClosed && !gs.getTile(index).area);
		indexList = indexList.filter(index => !gs.isPassable(index));
	
		if (indexList.length === (width + 2) * (height + 2)) {
			list.push(tileIndex);
		}
	}, this);
	
	return list.length > 0 ? util.randElem(list) : null;
};

// PLACE_DOOR:
// ************************************************************************************************
BaseGenerator.prototype.placeDoor = function (tileIndex) {
	if ((gs.isPassable(tileIndex.x + 1, tileIndex.y) && gs.isPassable(tileIndex.x - 1, tileIndex.y))
	 || (gs.isPassable(tileIndex.x, tileIndex.y + 1) && gs.isPassable(tileIndex.x, tileIndex.y - 1))) {
		gs.setTileType(tileIndex, gs.tileTypes.Floor);
		gs.createDoor(tileIndex, 'Door');
	}
};

// PLACE_DOOR_ON_BOX:
// Given a box representing a wall square
// Place a door on one of its edges such that the interior of the box and the exterior are connected
// ************************************************************************************************
BaseGenerator.prototype.placeDoorOnBox = function (box) {
	var x, y, canPlaceDoor;
	
	canPlaceDoor = function (x, y) {
		return (gs.isPassable(x, y - 1) && gs.isPassable(x, y + 1))
			|| (gs.isPassable(x - 1, y) && gs.isPassable(x + 1, y));
	};
	
	for (x = box.startX; x < box.endX; x += 1) {
		for (y = box.startY; y < box.endY; y += 1) {
			if (x === box.startX || y === box.startY || x === box.endX - 1 || y === box.endY - 1) {
				if (canPlaceDoor(x, y)) {
					this.placeDoor({x: x, y: y});
					return;
				}
			}
		}
	}
};


// PLACE_TILE_LINE:
// Place a straight line of tiles
// ************************************************************************************************
BaseGenerator.prototype.placeTileLine = function (fromTileIndex, toTileIndex, width, tileType, func) {
	var deltaVec = gs.getNormal(fromTileIndex, toTileIndex),
		perpVec = {x: -deltaVec.y, y: deltaVec.x},
		currentTileIndex = {x: fromTileIndex.x, y: fromTileIndex.y},
		count = 0,
		i;

	
	func = func || function (tileIndex) {return true; };
	
	while (!gs.vectorEqual(currentTileIndex, toTileIndex)) {
		for (i = -Math.floor(width / 2); i < Math.ceil(width / 2); i += 1) {
			if (func({x: currentTileIndex.x + perpVec.x * i, y: currentTileIndex.y + perpVec.y * i})) {
				if (currentTileIndex.x + perpVec.x * i > 0
				   && currentTileIndex.x + perpVec.x * i < NUM_TILES_X - 1
				   && currentTileIndex.y + perpVec.y * i > 0
				   && currentTileIndex.y + perpVec.y * i < NUM_TILES_Y - 1) {
					gs.setTileType({x: currentTileIndex.x + perpVec.x * i,
									y: currentTileIndex.y + perpVec.y * i},
								   tileType);
				}
				
			}
		}
		
		currentTileIndex.x += deltaVec.x;
		currentTileIndex.y += deltaVec.y;
		
		count += 1;
		if (count > 1000) {
			throw 'break';
		}
	}
	
	// Make sure we catch the last one:
	for (i = -Math.floor(width / 2); i < Math.ceil(width / 2); i += 1) {
		if (func({x: currentTileIndex.x + perpVec.x * i, y: currentTileIndex.y + perpVec.y * i})) {
			gs.setTileType({x: currentTileIndex.x + perpVec.x * i, y: currentTileIndex.y + perpVec.y * i}, tileType);
		}
	}
};


// PLACE_TILE_SQUARE:
// ************************************************************************************************
// Place a square of tiles fromTileIndex (inclusive) to toTileIndex (exclusive):
BaseGenerator.prototype.placeTileSquare = function (fromTileIndex, toTileIndex, tileType, onlyEdge) {
	var x, y;
	for (x = fromTileIndex.x;  x < toTileIndex.x; x += 1) {
        for (y = fromTileIndex.y; y < toTileIndex.y; y += 1) {
			if (!onlyEdge || x === fromTileIndex.x || x === toTileIndex.x - 1 || y === fromTileIndex.y || y === toTileIndex.y -1) {
				gs.setTileType({x: x, y: y}, tileType);
			}
		}
	}
};

// PLACE_TILE_CIRCLE:
// // ************************************************************************************************
BaseGenerator.prototype.placeTileCircle = function (centerTileIndex, radius, tileType) {
    gs.getIndexInRadius(centerTileIndex, radius + 1).forEach(function (index) {
		
		if (gs.distance(centerTileIndex, index) < radius + 1) {
			gs.setTileType(index, tileType);
		}
    }, this);
};

// PLACE_TILE_CAVE:
// *****************************************************************************
BaseGenerator.prototype.placeTileCave = function (fromTileIndex, toTileIndex, wallTileType, mask) {
	var count = 0;
	
	mask = mask || [[0, 0, 0, 0],
					[0, 0, 0, 0],
					[0, 0, 0, 0],
					[0, 0, 0, 0]];
	
	// Fill with cave wall:
	gs.getIndexInBox(fromTileIndex.x - 1, fromTileIndex.y - 1, toTileIndex.x + 1, toTileIndex.y + 1).forEach(function (index) {
		gs.setTileType(index, gs.tileTypes.CaveWall);
	}, this);
	
    while (true) {
        if (this.placeTileCaveFunc(fromTileIndex, toTileIndex, wallTileType, mask)) {
			break;
		}
		
		count += 1;
		if (count > 100) {
			throw 'unable to fill cave';
		}
    }
};


// PLACE_TILE_CAVE_FUNC:
// *****************************************************************************
BaseGenerator.prototype.placeTileCaveFunc = function (fromTileIndex, toTileIndex, wallTileType, mask) {
    var areaMap,
        areaWidth = toTileIndex.x - fromTileIndex.x,
        areaHeight = toTileIndex.y - fromTileIndex.y,
        i,
        x,
        y,
		minOpenPercent = 0.40, // 0.10
		initialWeight = 0.40,
        inBounds,
        countWalls,
        iterateFunc1,
        iterateFunc2,
        floodFunc,
        floodResult,
        success = false;
    
    // IN BOUNDS:
    // *************************************************************************
    inBounds = function (x, y) {
        return x >= 0 &&  y >= 0 && x < areaWidth && y < areaHeight;
    };
    
    // COUNT WALLS:
    // *************************************************************************
    countWalls = function (mapIn, xIn, yIn, dist) {
        var x, y, count = 0;
        for (x = xIn - dist; x <= xIn + dist; x += 1) {
            for (y = yIn - dist; y <= yIn + dist; y += 1) {
				
                if (inBounds(x, y)) {
					count += mapIn[x][y] === 'Wall' || mapIn[x][y] === 'SuperWall' ? 1 : 0;
				} else {
					count += 1;
				}
				
				
				//count += (!inBounds(x, y) || mapIn[x][y] === 'Wall' || mapIn[x][y] === 'SuperWall')  ? 1 : 0;
            }
        }
        return count;
    };
    
    // ITERATE FUNC 1:
    // *************************************************************************
    iterateFunc1 = function (oldMap) {
        var newMap = [];
        for (x = 0;  x < areaWidth; x += 1) {
            newMap[x] = [];
            for (y = 0; y < areaHeight; y += 1) {
				if (countWalls(oldMap, x, y, 1) < 5 && countWalls(oldMap, x, y, 2) > 2 && oldMap[x][y] !== 'SuperWall') {
					newMap[x][y] = 'Floor';
				} else {
					newMap[x][y] = 'Wall';
				}
            }
        }
        return newMap;
    };
    
    // ITERATE FUNC 2:
    // *************************************************************************
    iterateFunc2 = function (oldMap) {
        var newMap = [];
        for (x = 0;  x < areaWidth; x += 1) {
            newMap[x] = [];
            for (y = 0; y < areaHeight; y += 1) {
				if (countWalls(oldMap, x, y, 1) < 5 && oldMap[x][y] !== 'SuperWall') {
					newMap[x][y] = 'Floor';
				} else {
					newMap[x][y] = 'Wall';
				}
            }
        }
        return newMap;
    };
    
    // FLOOD FUNC:
	// Returns a count of all floor tiles
	// Returns a floodMap in which 2 indicates a floor tile
    // *************************************************************************
    floodFunc = function (map, startX, startY) {
        var x, y, floodMap, count = 0, iterFunc;
        
        // Trivial case:
        if (map[startX][startY] === 'Wall') {
            return 0;
        }
        
        floodMap = [];
        for (x = 0; x < areaWidth; x += 1) {
            floodMap[x] = [];
            for (y = 0; y < areaHeight; y += 1) {
                floodMap[x][y] = map[x][y] === 'Wall' ? 1 : 0;
            }
        }
        
        iterFunc = function (x, y) {
            count += 1;
            floodMap[x][y] = 2;
            if (inBounds(x + 1, y) && floodMap[x + 1][y] === 0) {
                iterFunc(x + 1, y);
            }
            if (inBounds(x - 1, y) && floodMap[x - 1][y] === 0) {
                iterFunc(x - 1, y);
            }
            if (inBounds(x, y + 1) && floodMap[x][y + 1] === 0) {
                iterFunc(x, y + 1);
            }
            if (inBounds(x, y - 1) && floodMap[x][y - 1] === 0) {
                iterFunc(x, y - 1);
            }
        };
        
        iterFunc(startX, startY);
        return {count: count, map: floodMap};
    };
    
    // FILL CAVE:
    // *************************************************************************
    // Initial Noise:
    areaMap = [];
    for (x = 0; x < areaWidth; x += 1) {
        areaMap[x] = [];
        for (y = 0; y < areaHeight; y += 1) {
            if (game.rnd.frac() <= initialWeight) {
                areaMap[x][y] = 'Wall';
            } else {
                areaMap[x][y] = 'Floor';
            }
        }
    }
	
	
	// Insert Super Wall:
	for (x = 0; x < areaWidth; x += 1) {
        for (y = 0; y < areaHeight; y += 1) {
			// Note: flipping mask here as its easier to input the masks in reverse order:
			if (mask[Math.floor(y / (areaHeight / 4))][Math.floor(x / (areaWidth / 4))]) {
				areaMap[x][y] = 'SuperWall';
			}
		}
	}
    
    // First Iteration:
    for (i = 0; i < 4; i += 1) {
        areaMap = iterateFunc1(areaMap);
    }
    
	
    // Second Iteration:
    for (i = 0; i < 3; i += 1) {
        areaMap = iterateFunc2(areaMap);
    }
    
	
	
	// Find an area which has a high enough number of floor tiles:
	// We try 50 times to find such an area before giving up.
	for (i = 0; i < 50; i += 1) {
		// Select a random position:
		x = util.randInt(0, areaWidth - 1);
		y = util.randInt(0, areaHeight - 1);

		// Flood from that position (gives us a count of floors, and a map in which 2 indicates a floor):
		floodResult = floodFunc(areaMap, x, y);

		// If we have found a large enough area then copy it into the area map (all other areas become solid):
		if (floodResult.count > areaWidth * areaHeight * minOpenPercent) {
			for (x = 0; x < areaWidth; x += 1) {
				for (y = 0; y < areaHeight; y += 1) {
					// 2 Indicates a floor in the largest open area:
					if (floodResult.map[x][y] === 2) {
						areaMap[x][y] = 'Floor';
					} 
					else {
						areaMap[x][y] = 'Wall';
					}
				}
			}
			success = true;
			break;
		}
	}
	
	if (!success) {
		return false;
	}
	

    // Copy area map back to map:
    for (x = 0; x < areaWidth; x += 1) {
        for (y = 0; y < areaHeight; y += 1) {
			if (areaMap[x][y] === 'Wall') {
				gs.setTileType({x: fromTileIndex.x + x, y: fromTileIndex.y + y}, wallTileType);
			} 
			else {
				gs.setTileType({x: fromTileIndex.x + x, y: fromTileIndex.y + y}, gs.tileTypes.CaveFloor);
			}
        }
    }
    
    return success;
};

// PLACE_VAULT:
// Places a vault at the tileIndex by destroying all existing objects and replacing all existing tiles.
// Will create and return a new area.
// Will flag all tiles as belonging to that area.
// vaultDesc: {vaultTypeName, [rotate], [reflect]}
// ************************************************************************************************
BaseGenerator.prototype.placeVault = function (tileIndex, vaultDesc) {
	var vaultType, tileTypeMap, data, i, object, frame, x, y, npc, area, obj, frameOffset;
	
	vaultType = gs.vaultTypes[vaultDesc.vaultTypeName];
	
	// Get data:
	data = game.cache.getJSON(vaultDesc.vaultTypeName);
	
	if (data.tilesets[1]) {
		frameOffset = data.tilesets[1].firstgid - 1;
	}
	
	// Create the tileMap:
	tileTypeMap = gs.parseJSONMap(vaultDesc.vaultTypeName, vaultDesc.rotate);
	gs.createTileMap(tileIndex, tileTypeMap);
	
	// Load NPCs and items:
	for (i = 0; i < data.layers[1].objects.length; i += 1) {
		object = data.layers[1].objects[i];
		frame = object.gid - 1;
		x = Math.round(object.x / (TILE_SIZE / SCALE_FACTOR)) + tileIndex.x;
		y = Math.round(object.y / (TILE_SIZE / SCALE_FACTOR)) - 1 + tileIndex.y;
		
		// NPC:
		if (data.tilesets[1]) {
			if (gs.getNameFromFrame(frame - frameOffset, gs.npcTypes)) {
				npc = gs.createNPC({x: x, y: y}, gs.getNameFromFrame(frame - frameOffset, gs.npcTypes), object.name);
			}
		}
	}
	
	// Creating area:
	if (vaultDesc.rotate) {
		area = this.createArea(tileIndex.x, tileIndex.y, tileIndex.x + vaultType.height, tileIndex.y + vaultType.width);
	}
	else {
		area = this.createArea(tileIndex.x, tileIndex.y, tileIndex.x + vaultType.width, tileIndex.y + vaultType.height);
	}
	
	area.type = vaultDesc.vaultTypeName;
	area.isVault = true;
	
	// Init:
	if (vaultType.initFunc) {
		vaultType.initFunc(area);
	}

	return area;
};

// FILL_BORDER_WALL:
// ************************************************************************************************
BaseGenerator.prototype.fillBorderWall = function () {
	var x, y;
	for (x = 0; x < this.numTilesX; x += 1) {
		for (y = 0; y < this.numTilesY; y += 1) {
			if (x === 0 || y === 0 || x === this.numTilesX - 1 || y === this.numTilesY - 1) {
				gs.setTileType({x: x, y: y}, gs.tileTypes.Wall);
			}
		}
	}
};

// PLACE_SIDE_ROOM_DOOR:
// Given a box representing a wall square
// Place a door on one of its edges such that the interior of the box and the exterior are connected
// ************************************************************************************************
BaseGenerator.prototype.placeSideRoomDoor = function (area) {
	var x, y, canPlaceDoor, isSideRoom, box, indexList = [], tileIndex;
	
	box = {startX: area.startX - 1, startY: area.startY - 1, endX: area.endX + 1, endY: area.endY + 1};
	
	isSideRoom = function (x, y) {
		return gs.getTile(x, y).area && gs.getTile(x, y).area.type === 'SideRoom';
	};
	
	canPlaceDoor = function (x, y) {
		if (gs.isPassable(x, y - 1) && gs.isPassable(x, y + 1)) {
			if (!isSideRoom(x, y - 1) && isSideRoom(x, y + 1)) {
				return true;
			}
			
			if (!isSideRoom(x, y + 1) && isSideRoom(x, y - 1)) {
				return true;
			}
		}
		
		if (gs.isPassable(x - 1, y) && gs.isPassable(x + 1, y)) {
			if (!isSideRoom(x - 1, y) && isSideRoom(x + 1, y)) {
				return true;
			}
			
			if (!isSideRoom(x + 1, y) && isSideRoom(x - 1, y)) {
				return true;
			}
		}
		return false;
	};
	
	for (x = box.startX; x < box.endX; x += 1) {
		for (y = box.startY; y < box.endY; y += 1) {
			if (x === box.startX || y === box.startY || x === box.endX - 1 || y === box.endY - 1) {
				if (canPlaceDoor(x, y)) {
					indexList.push({x: x, y: y});
				}
			}
		}
	}
	
	// Choose a random door:
	if (indexList.length > 0) {
		tileIndex = util.randElem(indexList);
		area.doorTileIndex = tileIndex;
		this.placeDoor(tileIndex);
		return true;
	}
	// No possible door:
	else {
		return false;
	}
};

// CREATE_HALL:
// *************************************************************************
BaseGenerator.prototype.createHall = function (startTileIndex, endTileIndex, width, tileType) {
    var rand, func;
	
	width = width || util.randElem(gs.range(1, this.MAX_HALL_WIDTH));
	tileType = tileType || gs.tileTypes.Floor;
	
	if (!startTileIndex || !endTileIndex) {
		console.log('Failed to create hall');
		return;
	}
	
	func = function (tileIndex) {
		return gs.isInBounds(tileIndex) && !gs.getTile(tileIndex).type.isPit;
	};
	
	this.placeTileLine(startTileIndex, {x: endTileIndex.x, y: startTileIndex.y}, width, tileType, func);
	this.placeTileLine({x: endTileIndex.x, y: startTileIndex.y}, endTileIndex, width, tileType, func);
};

// CLEAR_TO_WALL:
// Return true if there is at least 'distance' tiles of open space between center and the nearest solid
// ************************************************************************************************
BaseGenerator.prototype.clearToWall = function (centerX, centerY, distance) {
	var x, y;
	for (x = centerX - distance; x < centerX + distance; x += 1) {
		for (y = centerY - distance; y < centerY + distance; y += 1) {
			if (game.math.distance(x, y, centerX, centerY) <= distance && gs.isInBounds(x, y) && !gs.isPassable(x, y)) {
				return false;
			}
		}
	}
	
	return true;
};

// CREATE_MASKS
// Call in order to create a huge list of masks for FA to use when generating caves and jungle
// ************************************************************************************************
BaseGenerator.prototype.createMasks = function () {
    this.masks = [];
    
    this.masks = this.masks.concat(this.getMaskRotations([[1, 1, 0, 1],
                                                          [1, 1, 0, 0],
                                                          [0, 0, 0, 0],
                                                          [1, 0, 0, 1]]));
    
    this.masks = this.masks.concat(this.getMaskRotations([[1, 0, 0, 1],
                                                          [0, 1, 0, 0],
                                                          [0, 0, 0, 1],
                                                          [1, 0, 1, 1]]));
    
    this.masks = this.masks.concat(this.getMaskRotations([[1, 0, 0, 1],
                                                          [0, 0, 0, 0],
                                                          [0, 0, 0, 0],
                                                          [1, 0, 0, 1]]));
    
    this.masks = this.masks.concat(this.getMaskRotations([[1, 1, 0, 1],
                                                          [0, 0, 0, 1],
                                                          [1, 0, 0, 0],
                                                          [1, 0, 1, 1]]));
    
    this.masks = this.masks.concat(this.getMaskRotations([[1, 0, 0, 1],
                                                          [0, 1, 0, 0],
                                                          [0, 0, 0, 0],
                                                          [1, 0, 0, 1]]));
    
    this.masks = this.masks.concat(this.getMaskRotations([[0, 0, 0, 1],
                                                          [0, 1, 0, 0],
                                                          [0, 0, 1, 0],
                                                          [1, 0, 0, 0]]));
    
    this.masks = this.masks.concat(this.getMaskRotations([[0, 0, 0, 0],
                                                          [0, 1, 0, 0],
                                                          [0, 1, 1, 0],
                                                          [0, 0, 0, 0]]));
};

// GET_MASK_ROTATIONS:
// ************************************************************************************************
BaseGenerator.prototype.getMaskRotations = function (mask) {
    var rotations = [mask], x, y, newMask;
    
    // Y-Axis Flip:
    newMask = gs.create2DArray(4, 4, (x,y) => 0);
    for (x = 0; x < 4; x += 1) {
        for (y = 0; y < 4; y += 1) {
            newMask[x][y] = mask[3-x][y];
        }
    }
    rotations.push(newMask);
    
    // X-Axis Flip:
    newMask = gs.create2DArray(4, 4, (x,y) => 0);
    for (x = 0; x < 4; x += 1) {
        for (y = 0; y < 4; y += 1) {
            newMask[x][y] = mask[x][3-y];
        }
    }
    rotations.push(newMask);
    
    // XY-Axis Flip:
    newMask = gs.create2DArray(4, 4, (x,y) => 0);
    for (x = 0; x < 4; x += 1) {
        for (y = 0; y < 4; y += 1) {
            newMask[x][y] = mask[3-x][3-y];
        }
    }
    rotations.push(newMask);
    
    return rotations;
};

// TRIM_WALLS:
// ************************************************************************************************
BaseGenerator.prototype.trimWalls = function () {
	for (let i = 0; i < 10; i += 1) {
		let indexList = gs.getAllIndex();
		
		indexList = indexList.filter(function (index) {
			return gs.getTile(index).type.name === 'Wall'
				&& !gs.getTile(index).isClosed
				&& !gs.getTile(index).isSolidWall
				&& gs.getIndexListCardinalAdjacent(index).filter(idx => gs.isPassable(idx)).length >= 3;
		});
		
		indexList.forEach(function (index) {
			gs.setTileType(index, gs.tileTypes.Floor);
		}, this);
	}
	
};

// PLACE_A_STAR_HALL:
// *************************************************************************
BaseGenerator.prototype.placeAStarHall = function (startTileIndex, endTileIndex, width) {
	var isValidTileIndex, calculateH, path, i, tileIndex, color = gs.randomColor(), inArea;
	
	width = width || util.randElem([1, 1, 1, 1, 2, 2, 3]);
	
	
	
	/*
	gs.getTile(startTileIndex).color = color;
	gs.getTile(endTileIndex).color = color;
	*/
	
	if (!startTileIndex) {
		console.log('createAStarHall: invalid startTileIndex');
		gs.haltGen = true;
		return;
		//throw 'createAStarHall: invalid startTileIndex';
	}
	
	if (!endTileIndex) {
		console.log('createAStarHall: invalid endTileIndex');
		gs.haltGen = true;
		return;
		//throw 'createAStarHall: invalid endTileIndex';
	}
	
	
	if (gs.debugProperties.logAStarTunnels) {
		gs.getTile(startTileIndex).color = color;
		gs.getTile(endTileIndex).color = color;
	}
	
	
	if (gs.distance(startTileIndex, endTileIndex) > 20 ) {
		width = 1;
	}
	
	isValidTileIndex = function (tileIndex) {
		return !gs.getTile(tileIndex).isSolidWall 
			&& tileIndex.x >= 1
			&& tileIndex.y >= 1
			&& tileIndex.x < NUM_TILES_X - 1
			&& tileIndex.y < NUM_TILES_Y - 1;
	};
	
	calculateH = function (tileIndex) {
		return Math.abs(tileIndex.x - endTileIndex.x) + Math.abs(tileIndex.y - endTileIndex.y);
	};

	path = gs.findPath(startTileIndex, endTileIndex, {isValidTileIndex: isValidTileIndex, calculateH: calculateH});
		
	if (path) {
		for (i = 0; i < path.length; i += 1) {
			tileIndex = path[i];
			
			// Setting floor:
			if (!gs.getArea(tileIndex) && !gs.getTile(tileIndex).type.passable) {

				if (gs.getTile(tileIndex).type.name === 'Wall') {
					gs.setTileType(tileIndex, gs.tileTypes.Floor);
				}
				else if (gs.getTile(tileIndex).type.name === 'CaveWall') {
					gs.setTileType(tileIndex, gs.tileTypes.CaveFloor);
				}

			}

			if (width > 1) {
				gs.getIndexInBox(Math.floor(tileIndex.x - width / 2),
								 Math.floor(tileIndex.y - width / 2),
								 Math.ceil(tileIndex.x + width / 2), 
								 Math.ceil(tileIndex.y + width / 2)).forEach(function (index) {
					if (index.x > 1 &&
						index.y > 1 &&
						index.x < NUM_TILES_X - 1 &&
						index.y < NUM_TILES_Y - 1 &&
						!gs.getArea(index) && !gs.getArea(tileIndex) && !gs.getTile(index).type.passable && !gs.getTile(index).isSolidWall) {

						if (gs.getTile(index).type.name === 'Wall') {
							gs.setTileType(index, gs.tileTypes.Floor);
						}
						else if (gs.getTile(index).type.name === 'CaveWall') {
							gs.setTileType(index, gs.tileTypes.CaveFloor);
						}
					}
				}, this);
			}

		}
	}
	else {
		console.log('AStarPath failed');
		if (gs.debugProperties.logAStarTunnels) {
			gs.getTile(startTileIndex).color = color;
			gs.getTile(endTileIndex).color = color;
		}
		
		
	}
};

// CLEAN_TILE_AREAS:
// *****************************************************************************
BaseGenerator.prototype.cleanAreaTiles = function () {
	// Clean Area Tiles:
	gs.getAllIndex().forEach(function (tileIndex) {
		if (gs.getTile(tileIndex).type.name === 'Floor' && gs.getTile(tileIndex).area && gs.getTile(tileIndex).area.type === 'Cave') {
			gs.setTileType(tileIndex, gs.tileTypes.CaveFloor);
		}
		
		if (gs.getTile(tileIndex).type.name === 'Wall' && gs.getTile(tileIndex).area && gs.getTile(tileIndex).area.type === 'Cave') {
			gs.setTileType(tileIndex, gs.tileTypes.CaveWall);
		}
	});
};

// PLACE_DOORS:
// *****************************************************************************
BaseGenerator.prototype.placeDoors = function () {
	var x, y, isRoom;
	
	for (x = 0; x < this.numTilesX; x += 1) {
		for (y = 0; y < this.numTilesY; y += 1) {
			if (this.canPlaceDoor(x, y)) {
				this.placeDoor({x: x, y: y});
			}
		}
	}
};

// CAN_PLACE_DOOR:
// *****************************************************************************
BaseGenerator.prototype.canPlaceDoor = function (x, y) {
	var isRoom, isWall;
	
	isWall = function (x, y) {
		return !gs.isInBounds(x, y) || gs.getTile(x, y).type.name === 'Wall';
	};
	
	isRoom = function (x, y) {
		return gs.isInBounds(x, y) && gs.getTile(x, y).area && gs.getTile(x, y).area.type !== 'HallPoint';
	};
	
	return gs.getTile(x, y).type.name === 'Floor'
		&& !gs.getObj(x, y)
		&& !isRoom(x, y)
		&& ((isWall(x + 1, y) && isWall(x - 1, y) && (isRoom(x, y - 1) || isRoom(x, y + 1)))
		   || ((isWall(x, y + 1) && isWall(x, y - 1) && (isRoom(x + 1, y) || isRoom(x - 1, y)))));
};

// DISTANCE_TO_TILE:
// Return the distance (in tiles) to the nearest tile that satisfies the predicate function.
// If no such tile exists then return null;
// ************************************************************************************************
BaseGenerator.prototype.distanceToTile = function (tileIndex, func) {
    var list;
    list = gs.getAllIndex();
    list = list.filter(func);
    list = list.sort((a, b) => gs.distance(a, tileIndex) - gs.distance(b, tileIndex));
    
    return list.length > 0 ? gs.distance(tileIndex, list[0]) : null;
};


// FIND_ISLANDS:
// ************************************************************************************************
BaseGenerator.prototype.findIslands = function (area) {
	var mask, x, y, i = 0, islandList = [], func;
	
	mask = [];
	for (x = 0; x < area.width; x += 1) {
		mask[x] = [];
		for (y = 0; y < area.height; y += 1) {
			mask[x][y] = 0;
		}
	}
	
	func = function (idx) {
		return (gs.getTile(idx).type.name === 'Wall' || gs.getTile(idx).type.name === 'CaveWall')
			&& util.isInBox(idx, area);
	};
	
	
	gs.getIndexInBox(area).forEach(function (tileIndex) {
		var indexList;
		
		if (func(tileIndex) && !mask[tileIndex.x - area.startX][tileIndex.y - area.startY]) {
			islandList[i] = [];
			
			indexList = gs.getIndexInFlood(tileIndex, func);
			indexList.forEach(function (index) {
				mask[index.x - area.startX][index.y - area.startY] = 1;
				islandList[i].push(index);
			}, this);
			
			i += 1;
		}
	}, this);
	
	return islandList;
};

// REPLACE_ISLANDS:
// *****************************************************************************
BaseGenerator.prototype.replaceIslands = function (area) {
	var islandList, getType;
	
	getType = function (indexList) {
		if (indexList.reduce((pv, nv) => pv + (gs.getTile(nv).type.name === 'Wall' ? 1 : 0), 0) > indexList.length / 2) {
			return 'Wall';
		}
		else {
			return 'CaveWall';
		}
	};
	
	islandList = this.findIslands(area);
	
	// Remove any islands touching the map boarders:
	islandList = islandList.filter(function (list) {
		return !list.find(index => index.x === 0 || index.y === 0 || index.x === NUM_TILES_X - 1 || index.y === NUM_TILES_Y - 1)
			&& !list.find(index => gs.getTile(index).isClosed);
	});
	
	islandList.forEach(function (indexList) {
		var box, type;
		
		box = util.getBoundingBox(indexList);
		type = getType(indexList);
		
		if (indexList.length > 16 
			&& indexList.length < 100
			&& box.width > 3 && box.height > 3 // Min bounds
			&& (Math.min(box.width, box.height) / Math.max(box.width, box.height)) > 0.5 // Must be mostly square
			&& indexList.length > box.width * box.height * 0.5 // Must be mostly full
		   	&& util.frac() < 0.25) {
			
			indexList.forEach(function (index) {
				if (type === 'CaveWall') {
					gs.setTileType(index, gs.tileTypes.CavePit);
				}
				else {
					gs.setTileType(index, gs.tileTypes.Pit);
				}
			}, this);
		}
	}, this);
	
	
};/*global game, util, gs, console, Phaser*/
/*global BaseGenerator*/
/*global roomGenerator*/
/*jshint esversion: 6, laxbreak: true, loopfunc: true*/
'use strict';

// CONSTRUCTOR:
// ************************************************************************************************
function RogueGenerator() {}
RogueGenerator.prototype = new BaseGenerator();
var rogueGenerator = new RogueGenerator();

// GENERATE:
// ************************************************************************************************
RogueGenerator.prototype.generate = function (flags) {
	var x, y;
	
	this.flags = flags || {};

	
	// Properties:
	this.areaGridSize = 3;
	this.areaWidth = Math.floor(this.numTilesX / this.areaGridSize);
	this.areaHeight = Math.floor(this.numTilesY / this.areaGridSize);
	this.minRoomWidth = util.randInt(4, this.areaWidth - 4);
	this.minRoomHeight = util.randInt(4, this.areaHeight - 4);
	this.MAX_HALL_WIDTH = util.randInt(1, 4);
	
	// Initial Fill:
	this.placeTileSquare({x: 0, y: 0}, {x: this.numTilesX, y: this.numTilesY}, gs.tileTypes.Wall);
	this.roomAreaList = [];
	
	this.roomAreaGrid = [];
	for (x = 0; x < this.areaGridSize; x += 1) {
		this.roomAreaGrid[x] = [];
		for (y = 0; y < this.areaGridSize; y += 1) {
			this.roomAreaGrid[x][y] = null;
		}
	}
	
	this.selectMask();
	this.createRooms();
	//this.connectRooms();
	
	this.superConnectRooms();
	
	this.fillBorderWall();
	
	// Place Doors:
	this.placeDoors();
	
	// Room List:
	gs.areaList = this.roomAreaList;
	
	return true;
};

// CREATE_ROOMS:
// ************************************************************************************************
RogueGenerator.prototype.createRooms = function () {
	var area, box;
	
	for (let x = 0; x < this.areaGridSize; x += 1) {
		for (let y = 0; y < this.areaGridSize; y += 1) {
			// Bounding box for the room:
			box = gs.createBox(x * this.areaWidth, y * this.areaHeight, (x + 1) * this.areaWidth,  (y + 1) * this.areaHeight);
			
			
			if (this.mask[x][y]) {
				
				if (this.flags.PitTurret && x === 1 && y === 1) {
					area = this.placeVault({x: x * this.areaWidth,
											y: y * this.areaHeight},
										   {vaultTypeName: 'IronFortressBallista'});
					this.roomAreaList.push(area);
					this.roomAreaGrid[x][y] = area;
					
				}
				else {
					this.createRoom(box, x, y);
				}
			}
		}
	}
};

// CREATE_ROOM:
// ************************************************************************************************
RogueGenerator.prototype.createRoom = function (box, gridX, gridY) {
	var roomArea;
	
	roomArea = roomGenerator.placeRandomRoom(box);
	//roomArea.type = 'LargeRoom';
	
	this.roomAreaList.push(roomArea);
	this.roomAreaGrid[gridX][gridY] = roomArea;
	
};

// CONNECT_ROOMS:
// ************************************************************************************************
RogueGenerator.prototype.connectRooms = function () {
	var x, y;
	// Horizontal Halls:
	for (x = 0; x < this.areaGridSize - 1; x += 1) {
		for (y = 0; y < this.areaGridSize; y += 1) {
			if (this.roomAreaGrid[x][y] && this.roomAreaGrid[x + 1][y]) {
				this.placeAStarHall(gs.getHallIndex(this.roomAreaGrid[x][y]), gs.getHallIndex(this.roomAreaGrid[x + 1][y]));
			}
		}
	}
	
	// Vertical Halls:
	for (x = 0; x < this.areaGridSize; x += 1) {
		for (y = 0; y < this.areaGridSize - 1; y += 1) {
			if (this.roomAreaGrid[x][y] && this.roomAreaGrid[x][y + 1]) {
				this.placeAStarHall(gs.getHallIndex(this.roomAreaGrid[x][y]), gs.getHallIndex(this.roomAreaGrid[x][y + 1]));
			}
		}
	}
};

// SUPER_CONNECT_ROOMS:
// ************************************************************************************************
RogueGenerator.prototype.superConnectRooms = function () {	
	this.connectRooms();
	
	for (let i = 0; i < this.roomAreaList.length; i += 1) {
		for (let j = i + 1; j < this.roomAreaList.length; j += 1) {
			if (game.rnd.frac() <= 0.05 * gs.dangerLevel()) {
				this.placeAStarHall(gs.getHallIndex(this.roomAreaList[i]), gs.getHallIndex(this.roomAreaList[j]), 1);
			}
		}
	}
	
	this.trimWalls();
};



// SELECT_MASK:
// ************************************************************************************************
RogueGenerator.prototype.selectMask = function () {
	if (this.flags.PitTurret) {
		this.mask = [[1, 1, 1],
					 [1, 1, 1],
					 [1, 1, 1]];
		return;
	}
	
	if (game.rnd.frac() < 0.25) {
		this.mask = [[1, 1, 1],
					 [1, 1, 1],
					 [1, 1, 1]];
		return;
	}
	
	this.mask = util.randElem([[[1, 1, 1],
									 [1, 0, 1],
									 [1, 1, 1]],
									
									[[1, 1, 1],
									 [1, 0, 0],
									 [1, 1, 1]],
									 
									[[1, 1, 1],
									 [0, 0, 1],
									 [1, 1, 1]],
									
									[[1, 0, 1],
									 [1, 0, 1],
									 [1, 1, 1]],
									
									[[1, 1, 1],
									 [1, 0, 1],
									 [1, 0, 1]],
									
									[[0, 1, 1],
									 [1, 1, 1],
									 [1, 1, 1]],
									
									[[1, 1, 1],
									 [1, 1, 1],
									 [1, 1, 0]],
									
									[[1, 1, 0],
									 [1, 1, 1],
									 [1, 1, 1]],
									
									[[1, 1, 1],
									 [1, 1, 1],
									 [0, 1, 1]],
									
									[[0, 1, 0],
									 [1, 1, 1],
									 [0, 1, 0]],
									
									[[0, 1, 0],
									 [0, 1, 0],
									 [1, 1, 1]],
									
									[[1, 1, 1],
									 [0, 1, 0],
									 [0, 1, 0]],
									
									[[1, 0, 0],
									 [1, 1, 1],
									 [1, 0, 0]],
									
									[[0, 0, 1],
									 [1, 1, 1],
									 [0, 0, 1]]
								   ]);
	
};/*global game, gs, Phaser, console, BaseGenerator, util*/
/*jshint esversion: 6*/
'use strict';

// CONSTRUCTOR:
// ************************************************************************************************
function SewerRoadsGenerator() {}
SewerRoadsGenerator.prototype = new BaseGenerator();
var sewerRoadsGenerator = new SewerRoadsGenerator();

// GENERATE:
// ************************************************************************************************
SewerRoadsGenerator.prototype.generate = function (flags) {
	var x, y, i, area;

	this.flags = flags || {};
	gs.areaList = [];

	// Properties:
	this.ROAD_SPACING = 10;
	this.ROAD_WIDTH = 2;
		
	// Initial Fill:
	this.placeTileSquare({x: 0, y: 0}, {x: this.numTilesX, y: this.numTilesY}, gs.tileTypes.Floor);
	
	
	// Roads:
	this.placeRoads();
	this.fillBorderWall();
	
	// Building Areas:
	this.buildingAreaList = [];
	this.createBuildingAreas();
	
	// Remove area flags (placeBuildings is going to flag all rooms)
	this.removeAllAreaFlags();
	
	// Place Buildings:
	this.roomAreaList = [];
	this.placeBuildings();
	
	this.placeTileSquare({x: 1, y: 1}, {x: this.numTilesX - 1, y: this.numTilesY - 1}, gs.tileTypes.Wall, true);
	
	gs.areaList = this.roomAreaList;
	
	return true;
};

// PLACE_ROADS:
// Partition the map with a set of intersecting roads
// The partition refers to the land in between in which buildings will be places
// ************************************************************************************************
SewerRoadsGenerator.prototype.placeRoads = function () {
	var possibleVerticalIndices,
		possibleHorizontalIndices;
	
	// Full Vertical Road:
	possibleVerticalIndices = gs.range(this.ROAD_SPACING, this.numTilesX - this.ROAD_SPACING, this.ROAD_SPACING);
	possibleVerticalIndices = gs.randSubset(possibleVerticalIndices, 3);
	this.placeTileLine({x: possibleVerticalIndices[0], y: 0}, {x: possibleVerticalIndices[0], y: this.numTilesY - 1}, this.ROAD_WIDTH, gs.tileTypes.Water);
	
	// Full Horizontal Road:
	possibleHorizontalIndices = gs.range(this.ROAD_SPACING, this.numTilesY - this.ROAD_SPACING, this.ROAD_SPACING);
	possibleHorizontalIndices = gs.randSubset(possibleHorizontalIndices, 3);
	this.placeTileLine({x: 0, y: possibleHorizontalIndices[0]}, {x: this.numTilesX - 1, y: possibleHorizontalIndices[0]}, this.ROAD_WIDTH, gs.tileTypes.Water);
	
	// Half Vertical Road:
	if (game.rnd.frac() < 0.75) {
		this.placeTileLine({x: possibleVerticalIndices[1], y: 0}, {x: possibleVerticalIndices[1], y: possibleHorizontalIndices[0]}, this.ROAD_WIDTH, gs.tileTypes.Water);
	}
	// Half Vertical Road:
	if (game.rnd.frac() < 0.25) {
		this.placeTileLine({x: possibleVerticalIndices[2], y: this.numTilesY}, {x: possibleVerticalIndices[2], y: possibleHorizontalIndices[0]}, this.ROAD_WIDTH, gs.tileTypes.Water);
	}
	
	// Half Horizontal Road:
	if (game.rnd.frac() < 0.75) {
		this.placeTileLine({x: 0, y: possibleHorizontalIndices[1]}, {x: possibleVerticalIndices[0], y: possibleHorizontalIndices[1]}, this.ROAD_WIDTH, gs.tileTypes.Water);
	}
	// Half Horizontal Road:
	if (game.rnd.frac() < 0.25) {
		this.placeTileLine({x: this.numTilesX, y: possibleHorizontalIndices[2]}, {x: possibleVerticalIndices[0], y: possibleHorizontalIndices[2]}, this.ROAD_WIDTH, gs.tileTypes.Water);
	}
};

// CREATE_BUILDING_AREAS:
// Creates a list of areas in which a building could exist between roads
// ************************************************************************************************
SewerRoadsGenerator.prototype.createBuildingAreas = function () {
	// Find unmarked floor tiles and expand an area on it:
	for (let x = 0; x < this.numTilesX; x += 1) {
		for (let y = 0; y < this.numTilesY; y += 1) {
			if (gs.getTile(x, y).type.name === 'Floor' && !gs.getTile(x, y).area) {
				this.createBuildingArea({x: x, y: y});
			}
		}
	}
};

// CREATE_BUILDING_AREA:
// ************************************************************************************************
SewerRoadsGenerator.prototype.createBuildingArea = function (tileIndex) {
	var endX, endY, width, height;

	// Find width:
	for (endX = tileIndex.x; endX < this.numTilesX; endX += 1) {
		if (gs.getTile(endX, tileIndex.y).type.name !== 'Floor' || gs.getTile(endX, tileIndex.y).area) {
			break;
		}
	}

	// Find height:
	for (endY = tileIndex.y; endY < this.numTilesY; endY += 1) {
		if (gs.getTile(tileIndex.x, endY).type.name !== 'Floor' || gs.getTile(tileIndex.x, endY).area) {
			break;
		}
	}
	
	width = endX - tileIndex.x;
	height = endY - tileIndex.y;
	
	
	// Split Vertical:
	if (height > 16 || height > 2 * width) {
		this.buildingAreaList.push(this.createArea(tileIndex.x, tileIndex.y, endX, tileIndex.y + Math.floor(height / 2)));
	} 
	// Split Horizontal:
	else if (width > 16 || width > 2 * height) {
		this.buildingAreaList.push(this.createArea(tileIndex.x, tileIndex.y, tileIndex.x + Math.floor(width / 2), endY));
	}
	// Single Area:
	else {
		this.buildingAreaList.push(this.createArea(tileIndex.x, tileIndex.y, endX, endY));
	}
};

// PLACE_BULDINGS:
// ************************************************************************************************
SewerRoadsGenerator.prototype.placeBuildings = function () {
	for (let i = 0; i < this.buildingAreaList.length; i += 1) {
		this.placeBuilding(this.buildingAreaList[i]);
	}
};

// PLACE_BUILDING:
// ************************************************************************************************
SewerRoadsGenerator.prototype.placeBuilding = function (area) {

	// Never place buildings with no access to road
	if (!this.isRoad(area, 'RIGHT') &&
		!this.isRoad(area, 'LEFT') &&
		!this.isRoad(area, 'UP') &&
		!this.isRoad(area, 'DOWN')) {
		return;
	}
	
	// Possible chance to place solid wall:
	if (game.rnd.frac() < 0.30) {
		this.placeTileSquare({x: area.startX + 1, y: area.startY + 1}, {x: area.endX - 1, y: area.endY - 1}, gs.tileTypes.Wall);
		return;
	}
	
	// Possible chance to place nothing:
	if (game.rnd.frac() < 0.10) {
		return;
	}
	
	// Hallway Building:
	if (area.width > 12 && area.height > 12) {
		this.placeHallwayBuilding(area);
		
	// Partition Building:
	} else if (area.width >= area.height * 1.5 || area.height >= area.width * 1.5) {
		this.placePartitionedBuilding(area);
		
	} else {
		this.placeSimpleBuilding(area);
	}
};

// PLACE_HALLWAY_BUILDING:
// ************************************************************************************************
SewerRoadsGenerator.prototype.placeHallwayBuilding = function (area) {
	var rand = util.randInt(0, 2);
	
	// Walls:
	this.placeTileSquare({x: area.startX + 1, y: area.startY + 1}, {x: area.endX - 1, y: area.endY - 1}, gs.tileTypes.Wall);
	this.placeTileSquare({x: area.startX + 2, y: area.startY + 2}, {x: area.endX - 2, y: area.endY - 2}, gs.tileTypes.Floor);
	
	if (rand === 0) {
		this.placeSquareHallwayBuilding(area);
	} else if (rand === 1) {
		this.placeWideHallwayBuilding(area);
	} else {
		this.placeTallHallwayBuilding(area);
	}
};
	
// PLACE_SQUARE_HALLWAY_BUIDLING:
// XXXXXXX
// XXX XXX
// XXX XXX
// X     X
// XXX XXX
// XXX XXX
// XXXXXXX
// ************************************************************************************************
SewerRoadsGenerator.prototype.placeSquareHallwayBuilding = function (area) {
	// Horizontal Hallway:
	this.placeTileLine({x: area.startX + 2, y: area.centerY - 2}, {x: area.endX - 2, y: area.centerY - 2}, 1, gs.tileTypes.Wall);
	this.placeTileLine({x: area.startX + 2, y: area.centerY + 2}, {x: area.endX - 2, y: area.centerY + 2}, 1, gs.tileTypes.Wall);
	
	// Vertical Hallway:
	this.placeTileLine({x: area.centerX - 2, y: area.startY + 2}, {x: area.centerX - 2, y: area.endY - 2}, 1, gs.tileTypes.Wall);
	this.placeTileLine({x: area.centerX + 2, y: area.startY + 2}, {x: area.centerX + 2, y: area.endY - 2}, 1, gs.tileTypes.Wall);
	
	// CrossRoad:
	this.placeTileSquare({x: area.centerX - 2, y: area.centerY - 1},
						 {x: area.centerX + 3, y: area.centerY + 2},
						 gs.tileTypes.Floor);
	
	this.placeTileSquare({x: area.centerX - 1, y: area.centerY - 2},
						 {x: area.centerX + 2, y: area.centerY + 3},
						 gs.tileTypes.Floor);
	
	// Horizontal Internal Doors:
	this.placeDoor({x: area.startX + Math.round(area.width * 0.25), y: area.centerY - 2});
	this.placeDoor({x: area.startX + Math.round(area.width * 0.75), y: area.centerY - 2});
	this.placeDoor({x: area.startX + Math.round(area.width * 0.25), y: area.centerY + 2});
	this.placeDoor({x: area.startX + Math.round(area.width * 0.75), y: area.centerY + 2});
	
	// Vertical Internal Doors:
	this.placeDoor({x: area.centerX - 2, y: area.startY + Math.round(area.height * 0.25)});
	this.placeDoor({x: area.centerX - 2, y: area.startY + Math.round(area.height * 0.75)});
	this.placeDoor({x: area.centerX + 2, y: area.startY + Math.round(area.height * 0.25)});
	this.placeDoor({x: area.centerX + 2, y: area.startY + Math.round(area.height * 0.75)});
	
	// Outside Doors:
	if (this.isRoad(area, 'RIGHT')) {
		this.placeDoor({x: area.endX - 2, y: area.centerY});
	}
	if (this.isRoad(area, 'LEFT')) {
		this.placeDoor({x: area.startX + 1, y: area.centerY});
	}
	if (this.isRoad(area, 'DOWN')) {
		this.placeDoor({x: area.centerX, y: area.endY - 2});
	}
	if (this.isRoad(area, 'UP')) {
		this.placeDoor({x: area.centerX, y: area.startY + 1});
	}
	
	// Flag Areas:
	this.roomAreaList.push(this.createRoomArea(area.startX + 2, area.startY + 2, area.centerX - 2, area.centerY - 2));
	this.roomAreaList.push(this.createRoomArea(area.startX + 2, area.centerY + 3, area.centerX - 2, area.endY - 2));
	
	this.roomAreaList.push(this.createRoomArea(area.centerX + 3, area.startY + 2, area.endX - 2, area.centerY - 2));
	this.roomAreaList.push(this.createRoomArea(area.centerX + 3, area.centerY + 3, area.endX - 2, area.endY - 2));
};

// PLACE_WIDE_HALLWAY_BUILDING:
// XXXXXXXXXXXXXXXXXX
// X				X
// XXXXXXXXXXXXXXXXXX
// ************************************************************************************************
SewerRoadsGenerator.prototype.placeWideHallwayBuilding = function (area) {
	// Hallway:
	this.placeTileLine({x: area.startX + 2, y: area.centerY - 2}, {x: area.endX - 2, y: area.centerY - 2}, 1, gs.tileTypes.Wall);
	this.placeTileLine({x: area.startX + 2, y: area.centerY + 2}, {x: area.endX - 2, y: area.centerY + 2}, 1, gs.tileTypes.Wall);
	
	// Room Partitions:
	this.placeTileLine({x: area.centerX, y: area.startY + 2}, {x: area.centerX, y: area.centerY - 3}, 1, gs.tileTypes.Wall);
	this.placeTileLine({x: area.centerX, y: area.centerY + 2}, {x: area.centerX, y: area.endY - 2}, 1, gs.tileTypes.Wall);
	
	// Internal Doors:
	this.placeDoor({x: area.startX + Math.round(area.width * 0.25), y: area.centerY - 2});
	this.placeDoor({x: area.startX + Math.round(area.width * 0.75), y: area.centerY - 2});
	this.placeDoor({x: area.startX + Math.round(area.width * 0.25), y: area.centerY + 2});
	this.placeDoor({x: area.startX + Math.round(area.width * 0.75), y: area.centerY + 2});
	
	// External Doors:
	// Placing doorway regardless of road (otherwise the door may not spawn)
	if (this.isRoad(area, 'RIGHT')) {
		this.placeDoor({x: area.endX - 2, y: area.centerY});
	}
	if (this.isRoad(area, 'LEFT')) {
		this.placeDoor({x: area.startX + 1, y: area.centerY});
	}
	

	
	// Flag Areas:
	this.roomAreaList.push(this.createRoomArea(area.startX + 2, area.startY + 2, area.centerX, area.centerY - 2));
	this.roomAreaList.push(this.createRoomArea(area.centerX + 1, area.startY + 2, area.endX - 2, area.centerY - 2));
	this.roomAreaList.push(this.createRoomArea(area.startX + 2, area.centerY + 3, area.centerX, area.endY - 2));
	this.roomAreaList.push(this.createRoomArea(area.centerX + 1, area.centerY + 3, area.endX - 2, area.endY - 2));
};

// PLACE_TALL_HALLWAY_BUILDING:
// XXX
// X X
// X X
// X X
// X X
// XXX
// ************************************************************************************************
SewerRoadsGenerator.prototype.placeTallHallwayBuilding = function (area) {
	// Hallway:
	this.placeTileLine({x: area.centerX - 2, y: area.startY + 2}, {x: area.centerX - 2, y: area.endY - 2}, 1, gs.tileTypes.Wall);
	this.placeTileLine({x: area.centerX + 2, y: area.startY + 2}, {x: area.centerX + 2, y: area.endY - 2}, 1, gs.tileTypes.Wall);
	
	// Room Partitions:
	this.placeTileLine({x: area.startX + 2, y: area.centerY}, {x: area.centerX - 3, y: area.centerY}, 1, gs.tileTypes.Wall);
	this.placeTileLine({x: area.centerX + 2, y: area.centerY}, {x: area.endX - 2, y: area.centerY}, 1, gs.tileTypes.Wall);
	
	// Internal Doors:
	this.placeDoor({x: area.centerX - 2, y: area.startY + Math.round(area.height * 0.25)});
	this.placeDoor({x: area.centerX - 2, y: area.startY + Math.round(area.height * 0.75)});
	this.placeDoor({x: area.centerX + 2, y: area.startY + Math.round(area.height * 0.25)});
	this.placeDoor({x: area.centerX + 2, y: area.startY + Math.round(area.height * 0.75)});
	
	// External Doors:
	// Placing doorway regardless of road (otherwise the door may not spawn)
	if (this.isRoad(area, 'DOWN')) {
		this.placeDoor({x: area.centerX, y: area.endY - 2});
	}
	if (this.isRoad(area, 'UP')) {
		this.placeDoor({x: area.centerX, y: area.startY + 1});
	}
	
	// Flag Areas:
	this.roomAreaList.push(this.createRoomArea(area.startX + 2, area.startY + 2, area.centerX - 2, area.centerY));
	this.roomAreaList.push(this.createRoomArea(area.startX + 2, area.centerY + 1, area.centerX - 2, area.endY - 2));
	this.roomAreaList.push(this.createRoomArea(area.centerX + 3, area.startY + 2, area.endX - 2, area.centerY));
	this.roomAreaList.push(this.createRoomArea(area.centerX + 3, area.centerY + 1, area.endX - 2, area.endY - 2));
};

// PLACE_SIMPLE_BUILDING:
// ************************************************************************************************
SewerRoadsGenerator.prototype.placeSimpleBuilding = function (area) {
	// Walls:
	this.placeTileSquare({x: area.startX + 1, y: area.startY + 1}, {x: area.endX - 1, y: area.endY - 1}, gs.tileTypes.Wall);
	this.placeTileSquare({x: area.startX + 2, y: area.startY + 2}, {x: area.endX - 2, y: area.endY - 2}, gs.tileTypes.Floor);
	
	// Doors:
	if (this.isRoad(area, 'DOWN')) {
		this.placeDoor({x: area.startX + Math.floor((area.endX - area.startX) / 2), y: area.endY - 2});
	}
	if (this.isRoad(area, 'UP')) {
		this.placeDoor({x: area.startX + Math.floor((area.endX - area.startX) / 2), y: area.startY + 1});
	}
	if (this.isRoad(area, 'RIGHT')) {
		this.placeDoor({x: area.endX - 2, y: area.startY + Math.floor((area.endY - area.startY) / 2)});
	}
	if (this.isRoad(area, 'LEFT')) {
		this.placeDoor({x: area.startX + 1, y: area.startY + Math.floor((area.endY - area.startY) / 2)});
	}
		
	// Flag Area:
	this.roomAreaList.push(this.createRoomArea(area.startX + 2, area.startY + 2, area.endX - 2, area.endY - 2));
};

// PLACE_PARTITIONED_BUILDING:
// ************************************************************************************************
SewerRoadsGenerator.prototype.placePartitionedBuilding = function (area) {
	var partitionType;
	
	if (area.width > area.height) {
		partitionType = 'WIDE';
	} else {
		partitionType = 'TALL';
	}
	
	// Walls:
	this.placeTileSquare({x: area.startX + 1, y: area.startY + 1}, {x: area.endX - 1, y: area.endY - 1}, gs.tileTypes.Wall);
	this.placeTileSquare({x: area.startX + 2, y: area.startY + 2}, {x: area.endX - 2, y: area.endY - 2}, gs.tileTypes.Floor);
	
	// Internal Wall:
	if (partitionType === 'WIDE') {
		this.placeTileLine({x: area.centerX, y: area.startY + 1}, {x: area.centerX, y: area.endY - 2}, 1, gs.tileTypes.Wall);
	} else {
		this.placeTileLine({x: area.startX + 1, y: area.centerY}, {x: area.endX - 2, y: area.centerY}, 1, gs.tileTypes.Wall);
	}
	
	// Internal Door:
	this.placeDoor({x: area.centerX, y: area.centerY});
	
	// External Doors:
	if (this.isRoad(area, 'DOWN')) {
		this.placeDoor({x: area.startX + Math.floor((area.endX - area.startX) * 0.25), y: area.endY - 2});
		this.placeDoor({x: area.startX + Math.floor((area.endX - area.startX) * 0.75), y: area.endY - 2});
	}
	if (this.isRoad(area, 'UP')) {
		this.placeDoor({x: area.startX + Math.floor((area.endX - area.startX) * 0.25), y: area.startY + 1});
		this.placeDoor({x: area.startX + Math.floor((area.endX - area.startX) * 0.75), y: area.startY + 1});
	}
	if (this.isRoad(area, 'RIGHT')) {
		this.placeDoor({x: area.endX - 2, y: area.startY + Math.floor((area.endY - area.startY) * 0.25)});
		this.placeDoor({x: area.endX - 2, y: area.startY + Math.floor((area.endY - area.startY) * 0.75)});
	}
	if (this.isRoad(area, 'LEFT')) {
		this.placeDoor({x: area.startX + 1, y: area.startY + Math.floor((area.endY - area.startY) * 0.25)});
		this.placeDoor({x: area.startX + 1, y: area.startY + Math.floor((area.endY - area.startY) * 0.75)});
	}
	
	
	// Flag Area:
	if (partitionType === 'WIDE') {
		this.roomAreaList.push(this.createRoomArea(area.startX + 2, area.startY + 2, area.centerX, area.endY - 2));
		this.roomAreaList.push(this.createRoomArea(area.centerX + 1, area.startY + 2, area.endX - 2, area.endY - 2));
		
	} else {
		this.roomAreaList.push(this.createRoomArea(area.startX + 2, area.startY + 2, area.endX - 2, area.centerY));
		this.roomAreaList.push(this.createRoomArea(area.startX + 2, area.centerY + 1, area.endX - 2, area.endY - 2));
	}
};

// IS_ROAD:
// Returns true if the road exists in adjacent to area in dir: [DOWN, UP, LEFT, RIGHT]
// ************************************************************************************************
SewerRoadsGenerator.prototype.isRoad = function (area, dir) {
	if (dir === 'DOWN' && gs.isInBounds(area.startX, area.endY + 1) && gs.isPassable(area.startX, area.endY + 1)) {
		return true;
	}
	if (dir === 'UP' && gs.isInBounds(area.startX, area.startY - 1) && gs.isPassable(area.startX, area.startY - 1)) {
		return true;
	}
	if (dir === 'LEFT' && gs.isInBounds(area.startX - 1, area.startY) && gs.isPassable(area.startX - 1, area.startY)) {
		return true;
	}
	if (dir === 'RIGHT' && gs.isInBounds(area.endX + 1, area.startY) && gs.isPassable(area.endX + 1, area.startY)) {
		return true;
	}
};

// CREATE_ROOM_AREA:
// ************************************************************************************************
SewerRoadsGenerator.prototype.createRoomArea = function (startX, startY, endX, endY) {
	var area = this.createArea(startX, startY, endX, endY);
	
	// Setting properties for room dresser (depth is still pissing me off):
	if (area.width < 3 || area.height < 3) {
		area.depth = 5;
		area.type = 'SideRoom';
	} else {
		area.depth = 3;
		area.type = 'LargeRoom';
	}
	
	return area;
};

// FLAG_OUTDOOR_AREA:
// ************************************************************************************************
SewerRoadsGenerator.prototype.flagOutdoorArea = function () {
	var func,
		indexList,
		area;
	
	func = function (tileIndex) {
		return gs.isPassable(tileIndex);
	};
	
	indexList = gs.getIndexInFlood({x: 0, y: 0}, func);
	
	area = {};
	area.startX = 0;
	area.startY = 0;
	area.endX = this.numTilesX;
	area.endY = this.numTilesY;
	area.width = area.endX - area.startX;
	area.height = area.endY - area.startY;
	area.centerX = area.startX + Math.round(area.width / 2);
	area.centerY = area.startY + Math.round(area.height / 2);

	// Flag tiles as belonging to area:
	indexList.forEach(function (tileIndex) {
		gs.getTile(tileIndex).area = area;
	}, this);
	
	area.depth = 0;
	area.type = 'Cave';
	
	this.roomAreaList.push(area);
};/*global game, gs, console, Phaser, util*/
/*global BaseGenerator, roomGenerator*/
/*jshint laxbreak: true*/
'use strict';

// CONSTRUCTOR:
// ************************************************************************************************
function BSPGenerator() {}
BSPGenerator.prototype = new BaseGenerator();
var bspGenerator = new BSPGenerator();

// GENERATE:
// ************************************************************************************************
BSPGenerator.prototype.generate = function (flags) {
	var x, y, i, baseArea;

	this.flags = flags || {};
	
	// Properties:
	//this.PARTITION_FACTOR = [1.0, 1.0, 1.0, 0.70, 0.25, 0];
	this.PARTITION_FACTOR = [1.0, 0.80, 0.80, 0.50, 0.25, 0];
	this.ROOM_MARGIN = 1;
	this.MAX_HALL_WIDTH = util.randInt(1, 4);
	
	// Initial Fill:
	this.placeTileSquare({x: 0, y: 0}, {x: this.numTilesX, y: this.numTilesY}, gs.tileTypes.Wall);
	
	// Partition Map:
	this.leafAreaList = [];
	baseArea = this.createArea(0, 0, this.numTilesX, this.numTilesY);
	baseArea.depth = 0;
	this.partitionArea(baseArea);
	this.removeAllAreaFlags();
	
	// Place Rooms:
	this.roomAreaList = [];
	this.placeRooms();
	
	
	// Connect Rooms:
	this.connectAreas(baseArea);
	
	// Place Doors:
	this.placeDoors();
	
	//this.fillBorderWall();
	this.cleanAreaTiles();
	
	// Room List:
	gs.areaList = this.roomAreaList;
	
	return true;
};

// PARTITION_AREA:
// The result of this function is that areaList will be populated with all the leaf areas.
// A binary tree has also been constructed starting from rootArea whose leaves are the leaf areas.
// *************************************************************************
BSPGenerator.prototype.partitionArea = function (area) {
	var partitionVertical, partitionHorizontal;
	
	partitionVertical = function () {
		// Create sub areas:
		area.subArea1 = this.createArea(area.startX, area.startY, area.centerX, area.endY);
		area.subArea1.depth = area.depth + 1;
		this.partitionArea(area.subArea1);
		
		area.subArea2 = this.createArea(area.centerX, area.startY, area.endX, area.endY);
		area.subArea2.depth = area.depth + 1;
		this.partitionArea(area.subArea2);
	}.bind(this);
	
	partitionHorizontal = function () {
		// Create sub areas:
		area.subArea1 = this.createArea(area.startX, area.startY, area.endX, area.centerY);
		area.subArea1.depth = area.depth + 1;
		this.partitionArea(area.subArea1);
		
		area.subArea2 = this.createArea(area.startX, area.centerY, area.endX, area.endY);
		area.subArea2.depth = area.depth + 1;
		this.partitionArea(area.subArea2);
	}.bind(this);
	
	// BASE CASE (minimum area size reached):
	if (game.rnd.frac() > this.PARTITION_FACTOR[area.depth]) {
		area.subArea1 = null;
		area.subArea2 = null;
		area.isLeaf = true;
		this.leafAreaList.push(area);

	
	} 
	// RANDOM_PARTITION:
	else if (area.width === area.height) {
		if (game.rnd.frac() <= 0.5) {
			partitionVertical();
		}
		else {
			partitionHorizontal();
		}
	}
	// PARTITION VERTICALLY:
	else if (area.width > area.height) {
		partitionVertical();
	} 
	// PARTITION HORIZONTALLY:
	else {
		partitionHorizontal();
	}
};

// PLACE_ROOMS:
// *************************************************************************
BSPGenerator.prototype.placeRooms = function () {
	var roomArea;
	
	this.leafAreaList.forEach(function (area) {
		if (area.depth > 2) {
			this.placeRoom(area);
		} else {
			this.placeTileCave({x: area.startX + 2,
								y: area.startY + 2},
							   {x: area.endX - 2,
								y: area.endY - 2},
							   gs.tileTypes.CaveWall);
			
			roomArea = this.createArea(area.startX, area.startY, area.endX, area.endY);
			roomArea.depth = area.depth;
			roomArea.type = 'Cave';
			this.roomAreaList.push(roomArea);
		}
	}, this);
};

// PLACE_ROOM:
// *****************************************************************************
BSPGenerator.prototype.placeRoom = function (area) {
	/*
    var minRoomWidth = area.width / 2 + 1,
        minRoomHeight = area.height / 2 + 1,
        startX,
        startY,
        endX,
        endY,
		roomArea;
	
	// Get Room Dimensions:
    startX = util.randInt(area.startX + this.ROOM_MARGIN, area.endX - minRoomWidth - this.ROOM_MARGIN);
    startY = util.randInt(area.startY + this.ROOM_MARGIN, area.endY - minRoomHeight - this.ROOM_MARGIN);
    endX = util.randInt(startX + minRoomWidth, area.endX - this.ROOM_MARGIN);
    endY = util.randInt(startY + minRoomHeight, area.endY - this.ROOM_MARGIN);
	
	// Place Room Tiles:
	this.placeTileSquare({x: startX - 1, y: startY - 1}, {x: endX + 1, y: endY + 1}, gs.tileTypes.Wall);
	this.placeTileSquare({x: startX, y: startY}, {x: endX, y: endY}, gs.tileTypes.Floor);
	*/
	
	var roomArea;
	roomArea = roomGenerator.placeRandomRoom(area);
	roomArea.type = 'LargeRoom';
	this.roomAreaList.push(roomArea);
};

// CONNECT_AREA:
// *************************************************************************
BSPGenerator.prototype.connectAreas = function (area) {
	// Base case (area is leaf):
	if (area.isLeaf) {
		return;
	} 
	else {
		this.connectAreas(area.subArea1);
		this.connectAreas(area.subArea2);
	
		// DEPTH 0:
		if (area.depth === 0) {
			this.placeAStarHall(gs.getHallIndex(area.subArea1), gs.getHallIndex(area.subArea2));
			this.placeAStarHall(gs.getHallIndex(area.subArea1), gs.getHallIndex(area.subArea2));

			if (game.rnd.frac() < 0.5) {
				this.placeAStarHall(gs.getHallIndex(area.subArea1), gs.getHallIndex(area.subArea2));
			}
		} 
		// DEPTH 1:
		else if (area.depth === 1) {
			this.placeAStarHall(gs.getHallIndex(area.subArea1), gs.getHallIndex(area.subArea2));
			this.placeAStarHall(gs.getHallIndex(area.subArea1), gs.getHallIndex(area.subArea2));
		} 
		// DEPTH 2:
		else if (area.depth === 2) {
			this.placeAStarHall(gs.getHallIndex(area.subArea1), gs.getHallIndex(area.subArea2));

			if (game.rnd.frac() < 0.5) {
				this.placeAStarHall(gs.getHallIndex(area.subArea1), gs.getHallIndex(area.subArea2));
			}
		} 
		// DEPTH 3+:
		else {
			this.placeAStarHall(gs.getHallIndex(area.subArea1), gs.getOpenIndexInBox(area.subArea2));
		}
		
	}
};



/*global game, gs, console, Phaser, util*/
/*global BaseGenerator*/
/*jshint esversion: 6, loopfunc: true*/
'use strict';

// CONSTRUCTOR:
// ************************************************************************************************
function CaveGenerator() {}
CaveGenerator.prototype = new BaseGenerator();
var caveGenerator = new CaveGenerator();

// GENERATE:
// ************************************************************************************************
CaveGenerator.prototype.generate = function (flags) {
	var area;
	
	flags = flags || {};
	this.flags = flags;
	
	this.roomAreaList = [];
	
	// Initial Fill:
	this.placeTileSquare({x: 0, y: 0}, {x: this.numTilesX, y: this.numTilesY}, gs.tileTypes.CaveWall);
	
	// Cave fill:
	this.placeTileCave({x: 1, y: 1}, {x: this.numTilesX - 1, y: this.numTilesY - 1}, gs.tileTypes.CaveWall, this.chooseMask());
	
	if (game.rnd.frac() < 0.5 && gs.zoneName !== 'TheSunlessDesert' && !flags.neverNarrow) {
		this.makeNarrowTunnels();
	}
    
    // Area:
	this.mainCaveArea = this.createArea(0, 0, this.numTilesX, this.numTilesY);
	this.mainCaveArea.type = 'Cave';
	this.mainCaveArea.depth = 0;
	this.roomAreaList.push(this.mainCaveArea);
	
	
	gs.areaList = this.roomAreaList;
	
	return true;
};



// CHOOSE_MASK:
// *****************************************************************************
CaveGenerator.prototype.chooseMask = function () {
	if (game.rnd.frac() < 0.3) {
		return [[0, 0, 0, 0],
				[0, 0, 0, 0],
				[0, 0, 0, 0],
				[0, 0, 0, 0]];
	} 
	else {
		return util.randElem([[[1, 1, 0, 0],
									[1, 1, 0, 0],
									[0, 0, 0, 0],
									[0, 0, 0, 0]],

								   [[0, 0, 1, 1],
									[0, 0, 1, 1],
									[0, 0, 0, 0],
									[0, 0, 0, 0]],

								   [[0, 0, 0, 0],
									[0, 0, 0, 0],
									[1, 1, 0, 0],
									[1, 1, 0, 0]],

								   [[0, 0, 0, 0],
									[0, 0, 0, 0],
									[0, 0, 1, 1],
									[0, 0, 1, 1]],

								   [[1, 0, 0, 1],
									[0, 0, 0, 0],
									[0, 0, 0, 0],
									[1, 0, 0, 1]],

								   [[0, 0, 1, 0],
									[1, 0, 0, 0],
									[0, 0, 0, 1],
									[0, 1, 0, 0]],

								   [[0, 0, 0, 0],
									[0, 1, 1, 0],
									[0, 1, 1, 0],
									[0, 0, 0, 0]]

								  ]);
	}
	
};

CaveGenerator.prototype.makeNarrowTunnels = function () {
    var x, y, markedTiles, tileIndices;
    for (x = 0; x < this.numTilesX; x += 1) {
		for (y = 0; y < this.numTilesY; y += 1) {
			if (gs.isPassable(x, y) && this.clearToWall(x, y, 3)) {
				gs.getTile(x, y).clearToWall = true;
				//gs.getTile(x, y).color = 'rgb(255,0,0)';
			}
		}
	}
    
    markedTiles = gs.create2DArray(this.numTilesX, this.numTilesY, index => false);

	
	for (x = 0; x < this.numTilesX; x += 1) {
		for (y = 0; y < this.numTilesY; y += 1) {
			if (gs.getTile(x, y).clearToWall && !markedTiles[x][y]) {
				tileIndices = gs.getIndexInFlood({x: x, y: y}, function (index) {
					return gs.getTile(index).clearToWall && !markedTiles[index.x][index.y];
				});
				
				if (tileIndices.length < 100 && tileIndices.length > 2) {
					tileIndices.forEach(function(index) {
						gs.setTileType(index, gs.tileTypes.CaveWall);
					}, this);
				}
				
				tileIndices.forEach(function(index) {
					markedTiles[index.x][index.y] = true;
				}, this);
			}
		}
	}
};
/*global game, gs, console, Phaser, util*/
/*global CaveGenerator*/
/*jshint esversion: 6, loopfunc: true*/
'use strict';

// CONSTRUCTOR:
// ************************************************************************************************
function Cave2Generator() {}
Cave2Generator.prototype = new CaveGenerator();
var cave2Generator = new Cave2Generator();

// CHOOSE_MASK:
// *****************************************************************************
Cave2Generator.prototype.chooseMask = function () {
	
	return [[0, 0, 0, 0],
			[0, 0, 0, 0],
			[0, 0, 0, 0],
			[0, 0, 0, 0]];
};



// PLACE_TILE_CAVE_FUNC:
// *****************************************************************************
Cave2Generator.prototype.placeTileCaveFunc = function (fromTileIndex, toTileIndex, wallTileType, mask) {
    var areaMap,
        areaWidth = toTileIndex.x - fromTileIndex.x,
        areaHeight = toTileIndex.y - fromTileIndex.y,
        i,
        x,
        y,
		minOpenPercent = 0.40, // 0.40 (Sept 25 2018)
		initialWeight = 0.35, // 0.4 (sept 25)
        inBounds,
        countWalls,
        iterateFunc1,
        iterateFunc2,
        floodFunc,
        floodResult,
        success = false,
		removeDisconnectedAreas = true;
    
    // IN BOUNDS:
    // *************************************************************************
    inBounds = function (x, y) {
        return x >= 0 &&  y >= 0 && x < areaWidth && y < areaHeight;
    };
    
    
    // COUNT WALLS:
    // *************************************************************************
    countWalls = function (mapIn, xIn, yIn, dist) {
        var x, y, count = 0;
        for (x = xIn - dist; x <= xIn + dist; x += 1) {
            for (y = yIn - dist; y <= yIn + dist; y += 1) {
                if (!inBounds(x, y) || mapIn[x][y] === 'Wall' || mapIn[x][y] === 'SuperWall') {
					count += 1;
				} 
            }
        }
        return count;
    };
    
    
    
    // ITERATE FUNC 1:
    // *************************************************************************
    iterateFunc1 = function (oldMap) {
        var newMap = [];
        for (x = 0;  x < areaWidth; x += 1) {
            newMap[x] = [];
            for (y = 0; y < areaHeight; y += 1) {
				if (countWalls(oldMap, x, y, 1) >= 5 || countWalls(oldMap, x, y, 2) <= 2) {
					newMap[x][y] = 'Wall';
				}
				else {
					newMap[x][y] = oldMap[x][y];
				}
            }
        }
        return newMap;
    };
    

    // ITERATE FUNC 2:
    // *************************************************************************
    iterateFunc2 = function (oldMap) {
        var newMap = [];
        for (x = 0;  x < areaWidth; x += 1) {
            newMap[x] = [];
            for (y = 0; y < areaHeight; y += 1) {
				if (countWalls(oldMap, x, y, 1) < 5 && oldMap[x][y] !== 'SuperWall') {
					newMap[x][y] = 'Floor';
				} 
				else {
					newMap[x][y] = 'Wall';
				}
            }
        }
        return newMap;
    };
    
    // FLOOD FUNC:
	// Returns a count of all floor tiles
	// Returns a floodMap in which 2 indicates a floor tile
    // *************************************************************************
    floodFunc = function (map, startX, startY) {
        var x, y, floodMap, count = 0, iterFunc;
        
        // Trivial case:
        if (map[startX][startY] === 'Wall') {
            return 0;
        }
        
        floodMap = [];
        for (x = 0; x < areaWidth; x += 1) {
            floodMap[x] = [];
            for (y = 0; y < areaHeight; y += 1) {
                floodMap[x][y] = map[x][y] === 'Wall' ? 1 : 0;
            }
        }
        
        iterFunc = function (x, y) {
            count += 1;
            floodMap[x][y] = 2;
            if (inBounds(x + 1, y) && floodMap[x + 1][y] === 0) {
                iterFunc(x + 1, y);
            }
            if (inBounds(x - 1, y) && floodMap[x - 1][y] === 0) {
                iterFunc(x - 1, y);
            }
            if (inBounds(x, y + 1) && floodMap[x][y + 1] === 0) {
                iterFunc(x, y + 1);
            }
            if (inBounds(x, y - 1) && floodMap[x][y - 1] === 0) {
                iterFunc(x, y - 1);
            }
        };
        
        iterFunc(startX, startY);
        return {count: count, map: floodMap};
    };
    
    // FILL CAVE:
    // *************************************************************************
    // Initial Noise:
    areaMap = [];
    for (x = 0; x < areaWidth; x += 1) {
        areaMap[x] = [];
        for (y = 0; y < areaHeight; y += 1) {
            if (game.rnd.frac() <= initialWeight) {
                areaMap[x][y] = 'Wall';
            } 
            else {
                areaMap[x][y] = 'Floor';
            }
        }
    }
	
	
	// Insert Super Wall:
	for (x = 0; x < areaWidth; x += 1) {
        for (y = 0; y < areaHeight; y += 1) {
			// Note: flipping mask here as its easier to input the masks in reverse order:
			if (mask[Math.floor(y / (areaHeight / 4))][Math.floor(x / (areaWidth / 4))]) {
				areaMap[x][y] = 'SuperWall';
			}
		}
	}
    
    // First Iteration:
    for (i = 0; i < 4; i += 1) {
        areaMap = iterateFunc1(areaMap);
    }
    
	
    // Second Iteration:
    for (i = 0; i < 3; i += 1) {
        areaMap = iterateFunc2(areaMap);
    }
    
        
	if (removeDisconnectedAreas) {
		// Find an area which has a high enough number of floor tiles:
		// We try 50 times to find such an area before giving up.
		for (i = 0; i < 50; i += 1) {
			// Select a random position:
			x = util.randInt(0, areaWidth - 1);
			y = util.randInt(0, areaHeight - 1);

			// Flood from that position (gives us a count of floors, and a map in which 2 indicates a floor):
			floodResult = floodFunc(areaMap, x, y);

			// If we have found a large enough area then copy it into the area map (all other areas become solid):
			if (floodResult.count > areaWidth * areaHeight * minOpenPercent) {
				for (x = 0; x < areaWidth; x += 1) {
					for (y = 0; y < areaHeight; y += 1) {
						// 2 Indicates a floor in the largest open area:
						if (floodResult.map[x][y] === 2) {
							areaMap[x][y] = 'Floor';
						} else {
							areaMap[x][y] = 'Wall';
						}
					}
				}
				success = true;
				break;
			}
		}
	} else {
		success = true;
	}

    // Copy area map back to map:
    for (x = 0; x < areaWidth; x += 1) {
        for (y = 0; y < areaHeight; y += 1) {
            
			if (areaMap[x][y] === 'Wall') {
				gs.setTileType({x: fromTileIndex.x + x, y: fromTileIndex.y + y}, wallTileType);
			} 
			else {
				gs.setTileType({x: fromTileIndex.x + x, y: fromTileIndex.y + y}, gs.tileTypes.CaveFloor);
			}
            
        }
    }
    
    return success;
};/*global game, gs, console, Phaser*/
/*global BaseGenerator*/
'use strict';

// CONSTRUCTOR:
// ************************************************************************************************
function SewerTunnelsGenerator() {}
SewerTunnelsGenerator.prototype = new BaseGenerator();
var sewerTunnelsGenerator = new SewerTunnelsGenerator();

// GENERATE:
// ************************************************************************************************
SewerTunnelsGenerator.prototype.generate = function (flags) {
	var area, nodes;

	this.flags = flags || {};
	this.roomAreaList = [];

	// Properties:
	this.NUM_NODES = util.randInt(3, 5); // 4
	this.TUNNEL_WIDTH = util.randInt(2, 4); // 4
	this.TUNNEL_WATER_PERCENT = util.randElem([0.25, 0.50, 0.75, 1.0]);
	this.HIGH_CONNECTIVITY = game.rnd.frac() <= 0.25;
	this.BLANK_PERCENT = util.randElem([0.5, 0.75]);
	
	// Initial Fill:
	this.placeTileSquare({x: 0, y: 0}, {x: this.numTilesX, y: this.numTilesY}, gs.tileTypes.Wall);

	// Layout Map:
	this.layoutMap();

	// Place Tunnels
	this.placeTunnels();

	// Place Node Rooms:
	this.placeNodeRooms(nodes);
	
	this.fillBorderWall();
	
	gs.areaList = this.roomAreaList;
	
	return true;
};

// LAYOUT_MAP:
// ************************************************************************************************
SewerTunnelsGenerator.prototype.layoutMap = function () {
	var x, y, nodes, edges, getNextNode, createRandomPath, connectNode;

	// GET_NEXT_NODE:
	getNextNode = function (fromNode) {
		var list = [];
		if (fromNode.x < sewerTunnelsGenerator.NUM_NODES - 1) {
			list.push({x: fromNode.x + 1, y: fromNode.y});
		}
		if (fromNode.y < sewerTunnelsGenerator.NUM_NODES - 1) {
			list.push({x: fromNode.x, y: fromNode.y + 1});
		}
		return util.randElem(list);
	};

	// CREATE_RANDOM_PATH:
	createRandomPath = function () {
		var currentNode, nextNode;
		currentNode = nodes[0][0];
		nodes[0][0].isConnected = true;
		while (currentNode.x !== sewerTunnelsGenerator.NUM_NODES - 1 || currentNode.y !== sewerTunnelsGenerator.NUM_NODES - 1) {
			nextNode = getNextNode(currentNode);
			edges.push({node1: {x: currentNode.x, y: currentNode.y},
						node2: {x: nextNode.x, y: nextNode.y}});
			currentNode = nextNode;
			nodes[nextNode.x][nextNode.y].isConnected = true;
			nodes[nextNode.x][nextNode.y].partOfPath = true;
		}
	};

	// CONNECT_NODE:
	connectNode = function (node) {
		var list = [], node2;
		if (node.x > 0 && nodes[node.x - 1][node.y].isConnected) {
			list.push(nodes[node.x - 1][node.y]);
		}
		if (node.y > 0 && nodes[node.x][node.y - 1].isConnected) {
			list.push(nodes[node.x][node.y - 1]);
		}

		if (list.length > 0) {
			node2 = util.randElem(list);
			edges.push({node1: {x: node.x, y: node.y},
						node2: {x: node2.x, y: node2.y}});
			node.isConnected = true;
		}
	};

	// Create Nodes:
	nodes = [];
	for (x = 0;  x < this.NUM_NODES; x += 1) {
		nodes[x] = [];
		for (y = 0; y < this.NUM_NODES; y += 1) {
			nodes[x][y] = {x: x, y: y, isConnected: false};
		}
	}

	// Create initial random paths through nodes:
	edges = [];
	createRandomPath();
	createRandomPath();

	// Connect Remaining Nodes:
	for (x = 0;  x < this.NUM_NODES; x += 1) {
		for (y = 0; y < this.NUM_NODES; y += 1) {
			if (game.rnd.frac() < this.BLANK_PERCENT && !nodes[x][y].partOfPath) {
				nodes[x][y].isBlank = true;
			} else {
				if (!nodes[x][y].isConnected || this.HIGH_CONNECTIVITY) {
					connectNode(nodes[x][y]);
				}
			}
		}
	}

	// Make any unconnected node blank:
	for (x = 0;  x < this.NUM_NODES; x += 1) {
		for (y = 0; y < this.NUM_NODES; y += 1) {
			if (!nodes[x][y].isConnected) {
				nodes[x][y].isBlank = true;
			}
		}
	}
	
	this.nodes = nodes;
	this.edges = edges;
};

// PLACE_TUNNELS:
// ************************************************************************************************
SewerTunnelsGenerator.prototype.placeTunnels = function () {
	var i, func, width;

	func = function (tileIndex) {
		return gs.getTile(tileIndex).type.name === 'Wall';
	};

	// Connect with Tunnels:
	for (i = 0; i < this.edges.length; i += 1) {
		this.placeTileLine({x: Math.round((this.edges[i].node1.x + 0.5) * this.numTilesX / this.NUM_NODES), y: Math.round((this.edges[i].node1.y + 0.5) * this.numTilesY / this.NUM_NODES)},
						   {x: Math.round((this.edges[i].node2.x + 0.5) * this.numTilesX / this.NUM_NODES), y: Math.round((this.edges[i].node2.y + 0.5) * this.numTilesY / this.NUM_NODES)},
						   this.TUNNEL_WIDTH,
						   gs.tileTypes.Floor,
						   func);
	}


	// Connect with Water:
	for (i = 0; i < this.edges.length; i += 1) {
		if (game.rnd.frac() < this.TUNNEL_WATER_PERCENT) {
			
			if (game.rnd.frac() < 0.5) {
				width = this.TUNNEL_WIDTH / 2;
			} else {
				width = this.TUNNEL_WIDTH;
			}
			
			this.placeTileLine({x: Math.round((this.edges[i].node1.x + 0.5) * this.numTilesX / this.NUM_NODES), y: Math.round((this.edges[i].node1.y + 0.5) * this.numTilesY / this.NUM_NODES)},
							   {x: Math.round((this.edges[i].node2.x + 0.5) * this.numTilesX / this.NUM_NODES), y: Math.round((this.edges[i].node2.y + 0.5) * this.numTilesY / this.NUM_NODES)},
							   width,
							   gs.tileTypes.Water);
		}
	}
};

// PLACE_NODE_ROOMS:
// ************************************************************************************************
SewerTunnelsGenerator.prototype.placeNodeRooms = function (nodes) {
	var x, y;

	for (x = 0;  x < this.NUM_NODES; x += 1) {
		for (y = 0; y < this.NUM_NODES; y += 1) {
			if (!this.nodes[x][y].isBlank) {
				this.placeNodeRoom(this.nodes[x][y]);
			}
		}
	}
};

// PLACE_NODE_ROOM:
// ************************************************************************************************
SewerTunnelsGenerator.prototype.placeNodeRoom = function (node) {
	var testFunc, nodeCenter, size, area, waterBorderSize;

	// TEST_FUNC:
	testFunc = function (tileIndex) {
		return gs.getTile(tileIndex).type.name === 'Wall';
	};

	// Center of Node:
	nodeCenter = this.getNodeCenter(node);

	// Random room dimensions:
	//size = util.randInt(Math.ceil(this.TUNNEL_WIDTH / 2), Math.floor(this.TUNNEL_WIDTH * 1.25));

	size = Math.round(util.randInt(Math.ceil(this.numTilesX / (this.NUM_NODES * 3)), Math.floor(this.numTilesX / this.NUM_NODES) - 1) / 2 - 1);
	
	/*
	// Create wall and floor:
	if (size >= 5) {
		this.createCircleRoom({x: nodeCenter.x - size - 1, y: nodeCenter.y - size - 1}, {x: nodeCenter.x + size + 1, y: nodeCenter.y + size + 1}, 'Wall', this.WALL_FRAME, testFunc);
		this.createCircleRoom({x: nodeCenter.x - size, y: nodeCenter.y - size}, {x: nodeCenter.x + size, y: nodeCenter.y + size}, 'Floor', this.FLOOR_FRAME);

		// Water:
		if (size > Math.ceil(this.TUNNEL_WIDTH / 2) + 1 && game.rnd.frac() < 0.75) {
			this.createCircleRoom({x: nodeCenter.x - size + 2, y: nodeCenter.y - size + 2}, {x: nodeCenter.x + size - 2, y: nodeCenter.y + size - 2}, 'Water', this.WATER_FRAME);
		}

	} else {
	*/
	this.placeTileSquare({x: nodeCenter.x - size, y: nodeCenter.y - size}, {x: nodeCenter.x + size, y: nodeCenter.y + size}, gs.tileTypes.Floor);

	// Water:
	if (size > Math.ceil(this.TUNNEL_WIDTH / 2) + 1 && game.rnd.frac() < 0.75) {
		waterBorderSize = util.randElem([0, 1, 2, 3]);
		this.placeTileSquare({x: nodeCenter.x - size + waterBorderSize, y: nodeCenter.y - size + waterBorderSize}, {x: nodeCenter.x + size - waterBorderSize, y: nodeCenter.y + size - waterBorderSize}, gs.tileTypes.Water);
	
		// Island:
		
		if (size > 4) {
			this.placeTileSquare({x: nodeCenter.x - Math.floor(size  / 2), y: nodeCenter.y - Math.floor(size  / 2)},
								 {x: nodeCenter.x + Math.floor(size  / 2), y: nodeCenter.y + Math.floor(size  / 2)},
								 gs.tileTypes.Floor);
	
		}
	}

	//}

	// Define Area:
	area = this.createArea(nodeCenter.x - size, nodeCenter.y - size, nodeCenter.x + size, nodeCenter.y + size);
	area.depth = 4;
	area.type = 'Large';
	this.roomAreaList.push(area);
};

// GET_NODE_CENTER:
// ************************************************************************************************
SewerTunnelsGenerator.prototype.getNodeCenter = function (node) {
	return {x: Math.round((node.x + 0.5) * this.numTilesX / this.NUM_NODES),
			y: Math.round((node.y + 0.5) * this.numTilesY / this.NUM_NODES)};
};/*global game, gs, console, Phaser, util*/
/*global BaseGenerator, roomGenerator*/
/*jshint esversion: 6, loopfunc: true*/
'use strict';

// CONSTRUCTOR:
// ************************************************************************************************
function ArcaneGenerator() {}
ArcaneGenerator.prototype = new BaseGenerator();
var arcaneGenerator = new ArcaneGenerator();

// GENERATE:
// ************************************************************************************************
ArcaneGenerator.prototype.generate = function (flags) {
	var x, y;
	
	this.flags = flags || {};
	
	// Properties:
	this.areaGridSize = 3;
	this.areaWidth = Math.floor(this.numTilesX / this.areaGridSize);
	this.areaHeight = Math.floor(this.numTilesY / this.areaGridSize);
	this.areaBoarder = 0;
	this.minRoomWidth = util.randInt(8, this.areaWidth - 3);
	this.minRoomHeight = util.randInt(8, this.areaHeight - 3);
	
	this.MAX_HALL_WIDTH = util.randInt(2, 4);
	
	// Initial Fill:
	this.placeTileSquare({x: 0, y: 0}, {x: this.numTilesX, y: this.numTilesY}, gs.tileTypes.Wall);
	this.roomAreaList = [];
	
	this.roomAreaGrid = [];
	for (x = 0; x < this.areaGridSize; x += 1) {
		this.roomAreaGrid[x] = [];
		for (y = 0; y < this.areaGridSize; y += 1) {
			this.roomAreaGrid[x][y] = null;
		}
	}
	
	this.selectMask();
	this.createRooms();
	this.selectConnectionTypes();
	this.portalConnectRooms();
	this.hallwayConnectRooms();
	this.placeDoors();
	this.fillBorderWall();
	
	// Room List:
	gs.areaList = this.roomAreaList;
	
	return true;
};

// CREATE_ROOMS:
// ************************************************************************************************
ArcaneGenerator.prototype.createRooms = function () {
	var x, y, area, vaultIndex;
	
	if (this.flags.GolemWorkshop) {
		vaultIndex = {x: util.randInt(0, 2), y: util.randInt(0, 2)};
	}
	
	for (x = 0; x < this.areaGridSize; x += 1) {
		for (y = 0; y < this.areaGridSize; y += 1) {
			if (this.mask[x][y]) {
				if (this.flags.GolemWorkshop && x === vaultIndex.x && y === vaultIndex.y) {
					area = this.placeVault({x: x * this.areaWidth + this.areaBoarder,
											y: y * this.areaHeight + this.areaBoarder},
										   {vaultTypeName: 'GolemWorkshop'});
					this.roomAreaList.push(area);
					this.roomAreaGrid[x][y] = area;
				}
				else {
					area = this.createArea(x * this.areaWidth + this.areaBoarder,
									   y * this.areaHeight + this.areaBoarder,
									   (x + 1) * this.areaWidth - this.areaBoarder,
									   (y + 1) * this.areaHeight - this.areaBoarder);
					this.createRoom(area, x, y);
				}
			}
		}
	}
};

// CREATE_ROOM:
// ************************************************************************************************
ArcaneGenerator.prototype.createRoom = function (area, gridX, gridY) {
	var x, y, startX, startY, width, height, roomArea, box;
	
	
	do {
		startX = util.randInt(area.startX, area.endX - 1);
		startY = util.randInt(area.startY, area.endY - 1);
		width = util.randInt(this.minRoomWidth, area.width);
		height = util.randInt(this.minRoomHeight, area.height);
	} while (startX + width > area.endX || startY + height > area.endY);
		
	box = gs.createBox(startX, startY, startX + width, startY + height);
	
	
	
	//roomArea = roomGenerator.roomTypes.Square.generate(box, null, true);
	
	roomArea = roomGenerator.placeRandomRoom(box, null, true);
	gs.getTile(roomArea.centerX, roomArea.centerY).isClosed = true;
	
	this.roomAreaList.push(roomArea);
	this.roomAreaGrid[gridX][gridY] = roomArea;
	
};

// SELECT_CONNECTION_TYPES:
// First select how we will connect each room. Make the decision first so that all portals can all be placed first.
// Then all hallways can be placed in a second pass in such a way as to never cross over a portal.
// ************************************************************************************************
ArcaneGenerator.prototype.selectConnectionTypes = function () {
	var portalPercent = 0.75;
	
	for (let x = 0; x < this.areaGridSize; x += 1) {
		for (let y = 0; y < this.areaGridSize; y += 1) {
			if (this.roomAreaGrid[x][y]) {
				// Connecting left to right:
				if (x < this.areaGridSize - 1 && this.roomAreaGrid[x + 1][y]) {
					if (game.rnd.frac() < portalPercent) {
						this.roomAreaGrid[x][y].connectRight = 'PORTAL';
					}
					else {
						this.roomAreaGrid[x][y].connectRight = 'HALLWAY';
					}
				}
				
				// Connecting top to bottom:
				if (y < this.areaGridSize - 1 && this.roomAreaGrid[x][y + 1]) {
					if (game.rnd.frac() < portalPercent) {
						this.roomAreaGrid[x][y].connectDown = 'PORTAL';
					}
					else {
						this.roomAreaGrid[x][y].connectDown = 'HALLWAY';
					}
				}
			}
		}
	}
};

// PORTAL_CONNECT_ROOMS:
// ************************************************************************************************
ArcaneGenerator.prototype.portalConnectRooms = function () {
	var indexList, object;
	
	for (let x = 0; x < this.areaGridSize; x += 1) {
		for (let y = 0; y < this.areaGridSize; y += 1) {
			// Horizontal Portals:
			if (this.roomAreaGrid[x][y] && this.roomAreaGrid[x][y].connectRight === 'PORTAL') {
				// Portal right:
				indexList = gs.getIndexInBox(this.roomAreaGrid[x][y]);
				indexList = indexList.filter(index => gs.isIndexOpen(index));
				indexList = indexList.sort((a, b) => b.x - a.x);
				indexList = indexList.filter(index => index.x === indexList[0].x);
				indexList = indexList.sort((a, b) => Math.abs(a.y - this.roomAreaGrid[x][y].centerY) - Math.abs(b.y - this.roomAreaGrid[x][y].centerY));
				object = gs.createObject(indexList[0], 'Portal');
				gs.getTile(indexList[0]).isSolidWall = true; // Stops hallways from tunneling over portals
				object.toTileIndex = {x: this.roomAreaGrid[x + 1][y].centerX, y: this.roomAreaGrid[x + 1][y].centerY};
				gs.setTileType(object.toTileIndex, gs.tileTypes.Floor);
				gs.getTile(object.toTileIndex).mustBeFloor = true;


				// Portal left:
				indexList = gs.getIndexInBox(this.roomAreaGrid[x + 1][y]);
				indexList = indexList.filter(index => gs.isIndexOpen(index));
				indexList = indexList.sort((a, b) => a.x - b.x);
				indexList = indexList.filter(index => index.x === indexList[0].x);
				indexList = indexList.sort((a, b) => Math.abs(a.y - this.roomAreaGrid[x + 1][y].centerY) - Math.abs(b.y - this.roomAreaGrid[x + 1][y].centerY));
				object = gs.createObject(indexList[0], 'Portal');
				gs.getTile(indexList[0]).isSolidWall = true; // Stops hallways from tunneling over portals
				object.toTileIndex = {x: this.roomAreaGrid[x][y].centerX, y: this.roomAreaGrid[x][y].centerY};
				gs.setTileType(object.toTileIndex, gs.tileTypes.Floor);
				gs.getTile(object.toTileIndex).mustBeFloor = true;
			}
			
			// Vertical Portals:
			if (this.roomAreaGrid[x][y] && this.roomAreaGrid[x][y].connectDown === 'PORTAL') {
				// Portal down:
				indexList = gs.getIndexInBox(this.roomAreaGrid[x][y]);
				indexList = indexList.filter(index => gs.isIndexOpen(index));
				indexList = indexList.sort((a, b) => b.y - a.y);
				indexList = indexList.filter(index => index.y === indexList[0].y);
				indexList = indexList.sort((a, b) => Math.abs(a.x - this.roomAreaGrid[x][y].centerX) - Math.abs(b.x - this.roomAreaGrid[x][y].centerX));
				object = gs.createObject(indexList[0], 'Portal');
				gs.getTile(indexList[0]).isSolidWall = true; // Stops hallways from tunneling over portals
				object.toTileIndex = {x: this.roomAreaGrid[x][y + 1].centerX, y: this.roomAreaGrid[x][y + 1].centerY};
				gs.setTileType(object.toTileIndex, gs.tileTypes.Floor);
				gs.getTile(object.toTileIndex).mustBeFloor = true;

				// Portal up:
				indexList = gs.getIndexInBox(this.roomAreaGrid[x][y + 1]);
				indexList = indexList.filter(index => gs.isIndexOpen(index));
				indexList = indexList.sort((a, b) => a.y - b.y);
				indexList = indexList.filter(index => index.y === indexList[0].y);
				indexList = indexList.sort((a, b) => Math.abs(a.x - this.roomAreaGrid[x][y + 1].centerX) - Math.abs(b.x - this.roomAreaGrid[x][y + 1].centerX));
				object = gs.createObject(indexList[0], 'Portal');
				gs.getTile(indexList[0]).isSolidWall = true; // Stops hallways from tunneling over portals
				object.toTileIndex = {x: this.roomAreaGrid[x][y].centerX, y: this.roomAreaGrid[x][y].centerY};
				gs.setTileType(object.toTileIndex, gs.tileTypes.Floor);
				gs.getTile(object.toTileIndex).mustBeFloor = true;
			
			}
		}
	}
};

// HALLWAY_CONNECT_ROOMS:
// ************************************************************************************************
ArcaneGenerator.prototype.hallwayConnectRooms = function () {
	for (let x = 0; x < this.areaGridSize; x += 1) {
		for (let y = 0; y < this.areaGridSize; y += 1) {
			// Horizontal Hallways:
			if (this.roomAreaGrid[x][y] && this.roomAreaGrid[x][y].connectRight === 'HALLWAY') {
				this.placeAStarHall(gs.getHallIndex(this.roomAreaGrid[x][y]), gs.getHallIndex(this.roomAreaGrid[x + 1][y]));

			}
			
			// Vertical Hallways:
			if (this.roomAreaGrid[x][y] && this.roomAreaGrid[x][y].connectDown === 'HALLWAY') {
				this.placeAStarHall(gs.getHallIndex(this.roomAreaGrid[x][y]), gs.getHallIndex(this.roomAreaGrid[x][y + 1]));
			}
		}
	}
			
};

// SELECT_MASK:
// ************************************************************************************************
ArcaneGenerator.prototype.selectMask = function () {
	if (this.flags.GolemWorkshop) {
		this.mask = [[1, 1, 1],
					 [1, 1, 1],
					 [1, 1, 1]];
		return;
	}
	if (game.rnd.frac() < 0.25) {
		this.mask = [[1, 1, 1],
					 [1, 1, 1],
					 [1, 1, 1]];
		return;
	}
	
	this.mask = util.randElem([[[1, 1, 1],
									 [1, 0, 1],
									 [1, 1, 1]],
									
									[[1, 1, 1],
									 [1, 0, 0],
									 [1, 1, 1]],
									 
									[[1, 1, 1],
									 [0, 0, 1],
									 [1, 1, 1]],
									
									[[1, 0, 1],
									 [1, 0, 1],
									 [1, 1, 1]],
									
									[[1, 1, 1],
									 [1, 0, 1],
									 [1, 0, 1]],
									
									[[0, 1, 1],
									 [1, 1, 1],
									 [1, 1, 1]],
									
									[[1, 1, 1],
									 [1, 1, 1],
									 [1, 1, 0]],
									
									[[1, 1, 0],
									 [1, 1, 1],
									 [1, 1, 1]],
									
									[[1, 1, 1],
									 [1, 1, 1],
									 [0, 1, 1]],
									
									[[0, 1, 0],
									 [1, 1, 1],
									 [0, 1, 0]],
									
									[[0, 1, 0],
									 [0, 1, 0],
									 [1, 1, 1]],
									
									[[1, 1, 1],
									 [0, 1, 0],
									 [0, 1, 0]],
									
									[[1, 0, 0],
									 [1, 1, 1],
									 [1, 0, 0]],
									
									[[0, 0, 1],
									 [1, 1, 1],
									 [0, 0, 1]]
								   ]);
	
};/*global game, gs, console, Phaser, util*/
/*global BaseGenerator*/
/*jshint laxbreak: true*/
'use strict';

// CONSTRUCTOR:
// ************************************************************************************************
function CryptGenerator() {}
CryptGenerator.prototype = new BaseGenerator();
var cryptGenerator = new CryptGenerator();

// GENERATE:
// ************************************************************************************************
CryptGenerator.prototype.generate = function (flags) {
	var x, y, i, baseArea;

	this.flags = flags || {};
	
	// Initial Fill:
	this.placeTileSquare({x: 0, y: 0}, {x: this.numTilesX, y: this.numTilesY}, gs.tileTypes.Wall);
	this.placeTileSquare({x: 1, y: 1}, {x: this.numTilesX - 1, y: this.numTilesY - 1}, gs.tileTypes.Floor);
	
	// The crypt is divided into a grid into which rooms can be placed. Unlike the rogue generator the tiles between rooms are floors rather than walls.
	// The crypt therefore looks like a huge open space with individual 'crypts' placed within it. There is a boarder around each grid cell so that
	// movement is never restricted by the crypts. In this way we can technically place all sorts of interesting structures in a cell if we want.
	this.areaGridSize = 3;
	this.areaWidth = Math.floor(this.numTilesX / this.areaGridSize);
	this.areaHeight = Math.floor(this.numTilesY / this.areaGridSize);
	this.areaBoarder = 1;
	this.minRoomWidth = 6;
	this.minRoomHeight = 6;
	
	this.roomAreaList = [];
	this.createRooms();
	
	this.roomAreaList.forEach(function (area) {
		this.placeSideRoomDoor(area);
		if (area.width * area.height > 25) {
			area.type = 'Crypt';
			area.depth = 4;
		}
	}, this);
	
	// Room List:
	gs.areaList = this.roomAreaList;
	
	return true;
};

// CREATE_ROOMS:
// ************************************************************************************************
CryptGenerator.prototype.createRooms = function () {
	var x, y, area;
	
	for (x = 0; x < this.areaGridSize; x += 1) {
		for (y = 0; y < this.areaGridSize; y += 1) {
			area = {startX: x * this.areaWidth,
				    startY: y * this.areaHeight,
				    endX: (x + 1) * this.areaWidth - this.areaBoarder,
				    endY: (y + 1) * this.areaHeight - this.areaBoarder,
				   };
			area.width = area.endX - area.startX;
			area.height = area.endY - area.startY;
			this.createRoom(area, x, y);
		}
	}
};

// CREATE_ROOM:
// ************************************************************************************************
CryptGenerator.prototype.createRoom = function (area, gridX, gridY) {
	var rand = util.randInt(0, 5);
	
	if (rand === 0 || rand === 1) {
		this.fillGridCell(area, gridX, gridY);
	}
	else if (rand === 2) {
		this.bigSquareRoom(area, gridX, gridY);
	}
	else if (rand >= 3) {
		this.randSquareRoom(area, gridX, gridY);
	}
	
	
};

CryptGenerator.prototype.fillGridCell = function (area, gridX, gridY) {
	// Corners:
	if ((gridX === 0 && gridY === 0) 
	|| (gridX === 0 && gridY === this.areaGridSize - 1)
	|| (gridX === this.areaGridSize - 1 && gridY === 0)
	|| (gridX === this.areaGridSize - 1 && gridY === this.areaGridSize - 1)) {
		this.placeTileSquare({x: area.startX, y: area.startY}, {x: area.endX + 1, y: area.endY + 1}, gs.tileTypes.Wall);
	}
	// Center:
	else if (gridX === 1 && gridY === 1) {
		this.placeTileSquare({x: area.startX + 1, y: area.startY + 1}, {x: area.endX, y: area.endY}, gs.tileTypes.Wall);
	}
	// Left and Right Edges:
	else if (gridY === 1) {
		this.placeTileSquare({x: area.startX, y: area.startY + 3},
							 {x: area.endX + 1, y:area.endY - 2},
							 gs.tileTypes.Wall);
	}
	// Top and Bottom Edges:
	else if (gridX === 1) {
		this.placeTileSquare({x: area.startX + 3, y: area.startY},
							 {x: area.endX - 2, y:area.endY + 1},
							 gs.tileTypes.Wall);
	}
	
};

CryptGenerator.prototype.bigSquareRoom = function (area, gridX, gridY) {
	var roomArea;
	
	this.placeTileSquare({x: area.startX + 1, y: area.startY + 1}, {x: area.endX, y: area.endY}, gs.tileTypes.Wall);
	this.placeTileSquare({x: area.startX + 2, y: area.startY + 2}, {x: area.endX - 1, y: area.endY - 1}, gs.tileTypes.Floor);
	
	roomArea = this.createArea(area.startX + 1, area.startY + 1, area.endX - 1, area.endY - 1);
	roomArea.depth = 5;
	roomArea.type = 'SideRoom';
	this.roomAreaList.push(roomArea);
};

CryptGenerator.prototype.randSquareRoom = function (area, gridX, gridY) {
	var x, y, startX, startY, width, height, roomArea;
	
	do {
		startX = util.randInt(area.startX, area.endX - 1);
		startY = util.randInt(area.startY, area.endY - 1);
		width = util.randInt(this.minRoomWidth, area.width);
		height = util.randInt(this.minRoomHeight, area.height);
	} while (startX + width >= area.endX || startY + height >= area.endY);
	
	this.placeTileSquare({x: startX, y: startY}, {x: startX + width, y: startY + height}, gs.tileTypes.Wall);
	this.placeTileSquare({x: startX + 1, y: startY + 1}, {x: startX + width - 1, y: startY + height - 1}, gs.tileTypes.Floor);
	
	roomArea = this.createArea(startX + 1, startY + 1, startX + width - 1, startY + height - 1);
	roomArea.depth = 5;
	roomArea.type = 'SideRoom';
	this.roomAreaList.push(roomArea);
};/*global game, gs, console, Phaser, util*/
/*global BaseGenerator, roomGenerator*/
/*jshint esversion: 6*/
'use strict';

// CONSTRUCTOR:
// ************************************************************************************************
function CycleGenerator() {}
CycleGenerator.prototype = new BaseGenerator();
var cycleGenerator = new CycleGenerator();

// GENERATE:
// ************************************************************************************************
CycleGenerator.prototype.generate = function (flags = {}) {
	
	this.flags = flags;
	
	this.DUNGEON_PITS = util.frac() < 0.5;
	
	// Initial Fill:
	this.placeTileSquare({x: 0, y: 0}, {x: this.numTilesX, y: this.numTilesY}, gs.tileTypes.Wall);
	this.roomAreaList = [];
	
	// Generation:
	this.selectRooms();
	this.createRooms();
	this.superConnectRooms();
	//this.replaceIslands(gs.createBox(0, 0, this.numTilesX, this.numTilesY));
	
	
	this.cleanAreaTiles();
	
	// Place Doors:
	this.placeDoors();
	
	gs.areaList = this.roomAreaList;
	
	return true;
};

// SELECT_ROOMS:
// ************************************************************************************************
CycleGenerator.prototype.selectRooms = function (vaultList) {
	this.roomDesc = [];
	
	// Can pass vaultList to force spawning of vaults:
	if (this.flags.includeVaults) {
		this.flags.includeVaults.forEach(function (name) {
			this.roomDesc.push({vault: name});
		}, this);
	}
	
	if (game.rnd.frac() < 0.25) {
		this.roomDesc.push({width: 16, height: 16, type: 'Cave'});
	}
	
	this.roomDesc.push({width: 16, height: 16});
	
	if (game.rnd.frac() < 0.5) {
		this.roomDesc.push({width: 16, height: 16});
	}
	else {
		this.roomDesc.push({width: 12, height: 12});
	}
	
	this.roomDesc.push({width: 12, height: 12});
	this.roomDesc.push({width: 12, height: 12});
	
	if (game.rnd.frac() < 0.5) {
		this.roomDesc.push({width: 12, height: 12});
	}
	else {
		this.roomDesc.push({width: 8, height: 8});
	}
	
	//this.roomDesc.push({width: 1, height: 1});
	this.roomDesc.push({width: 8, height: 8});
	this.roomDesc.push({width: 8, height: 8});
	this.roomDesc.push({width: 8, height: 8});
	this.roomDesc.push({width: 8, height: 8});
	
	
};

// CREATE_ROOMS:
// ************************************************************************************************
CycleGenerator.prototype.createRooms = function () {
	var i;
	
	for (i = 0; i < this.roomDesc.length; i += 1) {
		this.createRoom(this.roomDesc[i]);
	}
};

// CREATE_ROOM:
// ************************************************************************************************
CycleGenerator.prototype.createRoom = function (roomDesc) {
	var tileIndex, width, height, box, area;
	
	if (roomDesc.vault) {
		width = gs.vaultTypes[roomDesc.vault].width;
		height = gs.vaultTypes[roomDesc.vault].height;
	}
	else {
		width = roomDesc.width;
		height = roomDesc.height;
	}
	
	tileIndex = this.getOpenBox(width, height);
	if (tileIndex) {
		box = gs.createBox(tileIndex.x, tileIndex.y, tileIndex.x + width, tileIndex.y + height);
		
		// Vault:
		if (roomDesc.vault) {
			area = this.placeVault(box.startTileIndex, {vaultTypeName: roomDesc.vault, rotate: false, reflect: false});
		}
		// Cave:
		else if (roomDesc.type === 'Cave') {
			this.placeTileCave(box.startTileIndex, box.endTileIndex, gs.tileTypes.CaveWall);
			area = this.createArea(box.startX, box.startY, box.endX, box.endY);
			area.type = 'Cave';
			area.depth = 3;
		}
		// Room:
		else {
			if (box.width > 1 && box.height > 1) {
				area = roomGenerator.placeRandomRoom(box);
				area.type = 'LargeRoom';
			}
			else {
				this.placeTileSquare(box.startTileIndex, box.endTileIndex, gs.tileTypes.Floor);
				area = this.createArea(box.startX, box.startY, box.endX, box.endY);
				area.type = 'HallPoint';
			}
			
		}
		
		this.roomAreaList.push(area);
	}
};



// CONNECT_ROOMS:
// ************************************************************************************************
CycleGenerator.prototype.connectRooms = function () {
	var i;
	
	for (i = 0; i < this.roomAreaList.length - 1; i += 1) {
		this.placeAStarHall(gs.getHallIndex(this.roomAreaList[i]), gs.getHallIndex(this.roomAreaList[i + 1]));
	}
	
	this.placeAStarHall(gs.getHallIndex(this.roomAreaList[0]), gs.getHallIndex(this.roomAreaList[this.roomAreaList.length - 1]));
};

// SUPER_CONNECT_ROOMS:
// ************************************************************************************************
CycleGenerator.prototype.superConnectRooms = function () {
	this.connectRooms();
	
	for (let i = 0; i < this.roomAreaList.length; i += 1) {
		for (let j = i + 1; j < this.roomAreaList.length; j += 1) {
			if (game.rnd.frac() <= 0.025 * gs.dangerLevel()) {
				this.placeAStarHall(gs.getHallIndex(this.roomAreaList[i]), gs.getHallIndex(this.roomAreaList[j]), 1);
			}
		}
	}
	
	this.trimWalls();
};



// CONSTRUCTOR:
// ************************************************************************************************
function CenterGenerator() {}
CenterGenerator.prototype = new CycleGenerator();

// GENERATE:
// ************************************************************************************************
CenterGenerator.prototype.generate = function (numTilesX, numTilesY, vaultList = []) {
	var x, y;
	gs.numTilesX = this.numTilesX = numTilesX;
	gs.numTilesY = this.numTilesY = numTilesY;
	
	this.DUNGEON_PITS = util.frac() < 0.5;
	
	// Initial Fill:
	this.placeTileSquare({x: 0, y: 0}, {x: this.numTilesX, y: this.numTilesY}, gs.tileTypes.Wall);
	this.roomAreaList = [];
	
	// Generation:
	this.placeCenterRoom();
	this.selectRooms(vaultList);
	this.createRooms();
	this.connectRooms();
	//this.replaceIslands(gs.createBox(0, 0, this.numTilesX, this.numTilesY));
	
	// Place Doors:
	this.placeDoors();
	
	gs.areaList = this.roomAreaList;
	
	return true;
};

// PLACE_CENTER_ROOM:
// ************************************************************************************************
CenterGenerator.prototype.placeCenterRoom = function () {
	var box,
		vaultName = 'Center01',
		vaultDesc = gs.vaultTypes[vaultName];
	
	box = gs.createBox((this.numTilesX - vaultDesc.width) / 2,
					   (this.numTilesX - vaultDesc.height) / 2,
					   (this.numTilesX - vaultDesc.width) / 2 + vaultDesc.width,
					   (this.numTilesX - vaultDesc.height) / 2 + vaultDesc.height);
				
	
	this.centerRoom = this.placeVault(box, {fileName: 'Center01', rotate: false, reflect: false});
};

// CONNECT_ROOMS:
// ************************************************************************************************
CenterGenerator.prototype.connectRooms = function () {
	var i;
	
	for (i = 0; i < this.roomAreaList.length - 1; i += 1) {
		this.placeAStarHall(gs.getHallIndex(this.roomAreaList[i]), gs.getHallIndex(this.roomAreaList[i + 1]));
	}
	
	this.placeAStarHall(gs.getHallIndex(this.roomAreaList[0]), gs.getHallIndex(this.roomAreaList[this.roomAreaList.length - 1]));
};/*global game, gs, console, Phaser, util*/
/*global BaseGenerator, NUM_TILES_X, NUM_TILES_Y*/
/*jshint esversion: 6, loopfunc: true*/
'use strict';

// CONSTRUCTOR:
// ************************************************************************************************
function SwampGenerator() {}
SwampGenerator.prototype = new BaseGenerator();
var swampGenerator = new SwampGenerator();

// GENERATE:
// ************************************************************************************************
SwampGenerator.prototype.generate = function (flags = {}) {
	var area;
	
	this.flags = flags;
	
	// Initial Fill:
	this.placeTileSquare({x: 0, y: 0}, {x: this.numTilesX, y: this.numTilesY}, gs.tileTypes.CaveWall);
	this.roomAreaList = [];
	
	// Cave fill:
	this.placeTileCave({x: 1, y: 1}, {x: this.numTilesX - 1, y: this.numTilesY - 1}, gs.tileTypes.CaveWall, this.chooseMask());
	
	// Water:
	this.createWater();
	
	// Folliage:
	this.createFolliage();
	
    // Area:
	area = this.createArea(0, 0, this.numTilesX, this.numTilesY);
	area.type = 'Swamp';
	this.roomAreaList.push(area);

	gs.areaList = this.roomAreaList;
	
	return true;
};

// CREATE_WATER:
// *****************************************************************************
SwampGenerator.prototype.createWater = function () {
	var waterDistance = 2.5,
		indexList;
	
	// Initial fill (distance to wall):
	gs.getAllIndex().forEach(function (tileIndex) {
		if (gs.isPassable(tileIndex) && this.distanceToTile(tileIndex, index => !gs.isPassable(index)) >= waterDistance) {
			gs.setTileType(tileIndex, gs.tileTypes.Water);
		}
	}, this);
	
	// Flooding individual water tiles:
	indexList = gs.getAllIndex();
	indexList = indexList.filter(index => gs.getTile(index).type.name === 'Water');
	indexList = indexList.filter(index => gs.getIndexListCardinalAdjacent(index).reduce((pv, nv) => pv + (gs.getTile(nv).type.name === 'Water' ? 1 : 0), 0) < 2);
	
	indexList.forEach(function (index) {
		gs.getIndexInRadius(index, 2.5).forEach(function (idx) {
			if (gs.isPassable(idx)) {
				gs.setTileType(idx, gs.tileTypes.Water);
			}
		}, this);
		
	}, this);
};

// CREATE_FOLLIAGE:
SwampGenerator.prototype.createFolliage = function () {
	var indexList, num, i, tileIndex;
	
	// Tiki Torches:
	num = util.randInt(1, 12);
	for (i = 0; i < num; i += 1) {
		tileIndex = gs.getWideOpenIndexInLevel();
		if (tileIndex) {
			gs.createObject(tileIndex, 'TikiTorch');
		}
	}
	
	// Water Stalagemite:
	indexList = gs.getAllIndex();
	indexList = indexList.filter(index => gs.getTile(index).type.name === 'Water');
	gs.randSubset(indexList, 12).forEach(function (index) {
		gs.createObject(index, 'WaterStalagmite');
	}, this);
	
	// Water Tree:
	indexList = gs.getAllIndex();
	indexList = indexList.filter(index => gs.getTile(index).type.name === 'Water');
	indexList = indexList.filter(index => gs.isPassable(index));
	gs.randSubset(indexList, 12).forEach(function (index) {
		gs.createObject(index, 'WaterTree');
	}, this);
	
	// Trees:
	indexList = gs.getAllIndex();
	indexList = indexList.filter(index => gs.getTile(index).type.name === 'CaveFloor');
	indexList = indexList.filter(index => gs.isWideOpen(index));
	gs.randSubset(indexList, Math.min(12, indexList.length)).forEach(function (index) {
		gs.createObject(index, 'Tree');
	}, this);
	
	
	// Water grass:
	indexList = gs.getAllIndex();
	indexList = indexList.filter(index => gs.isIndexOpen(index));
	indexList = indexList.filter(index => gs.getIndexListCardinalAdjacent(index).reduce((pv, nv) => pv + (gs.getTile(nv).type.name === 'Water' ? 1 : 0), 0) >= 1);
	indexList.forEach(function (tileIndex) {
		if (util.frac() <= 0.1) {
			gs.createVinePatch(tileIndex, util.randInt(1, 2), 'LongGrass');
		}
	}, this);
	
	
};



// CHOOSE_MASK:
// *****************************************************************************
SwampGenerator.prototype.chooseMask = function () {
	
	
	
	if (util.frac() < 0.5) {
		return [[0, 0, 0, 0],
				[0, 0, 0, 0],
				[0, 0, 0, 0],
				[0, 0, 0, 0]];
	} 
	else {
		return util.randElem([
			[[1, 1, 0, 0],
			 [1, 1, 0, 0],
			 [0, 0, 0, 0],
			 [0, 0, 0, 0]],
			
			[[0, 0, 1, 1],
			 [0, 0, 1, 1],
			 [0, 0, 0, 0],
			 [0, 0, 0, 0]],

		   [[0, 0, 0, 0],
			[0, 0, 0, 0],
			[1, 1, 0, 0],
			[1, 1, 0, 0]],

		   [[0, 0, 0, 0],
			[0, 0, 0, 0],
			[0, 0, 1, 1],
			[0, 0, 1, 1]],

			
		   [[1, 0, 0, 1],
			[0, 0, 0, 0],
			[0, 0, 0, 0],
			[1, 0, 0, 1]],

		   [[0, 0, 1, 0],
			[1, 0, 0, 0],
			[0, 0, 0, 1],
			[0, 1, 0, 0]],

		   [[0, 0, 0, 0],
			[0, 1, 1, 0],
			[0, 1, 1, 0],
			[0, 0, 0, 0]]
			]);
	}
	
};


/*global gs, game, console, util*/
/*global BaseGenerator*/
/*global caveGenerator, roomGenerator*/
/*jshint esversion: 6, loopfunc: true, laxbreak: true*/
'use strict';

// CONSTRUCTOR:
// ************************************************************************************************
function CaveRoomGenerator() {}
CaveRoomGenerator.prototype = new BaseGenerator();
var caveRoomGenerator = new CaveRoomGenerator();

// GENERATE:
// ************************************************************************************************
CaveRoomGenerator.prototype.generate = function (flags) {
	// Initial Fill:
	this.placeTileSquare({x: 0, y: 0}, {x: this.numTilesX, y: this.numTilesY}, gs.tileTypes.CaveWall);
	
	// Cave fill:
	this.placeTileCave({x: 5, y: 5}, {x: this.numTilesX - 5, y: this.numTilesY - 5}, gs.tileTypes.CaveWall, this.chooseMask());
	this.mainCaveArea = this.createArea(0, 0, this.numTilesX, this.numTilesY);
	this.mainCaveArea.type = 'Cave';
	this.mainCaveArea.depth = 1;
	
	this.roomAreaList = [];
	
	this.placeRooms();
	
	this.connectRooms();
	
	this.placeDoors();
	
	this.roomAreaList.push(this.mainCaveArea);
	gs.areaList = this.roomAreaList;
	
	return true;
};

// PLACE_ROOMS:
// ************************************************************************************************
CaveRoomGenerator.prototype.placeRooms = function () {
	var tileIndex, roomArea, box, area, indexList, width, height;
	
	for (let i = 0; i < 20; i += 1) {
		width = util.randInt(8, 16);
		height = util.randInt(8, 16);
		
		tileIndex = this.findRoomLocation(width, height);
	
		if (tileIndex) {
			box = gs.createBox(tileIndex.x, tileIndex.y, tileIndex.x + width, tileIndex.y + height);

			/*
			this.placeTileSquare(box.startTileIndex, box.endTileIndex, gs.tileTypes.Wall);
			this.placeTileSquare({x: box.startX + 1, y: box.startY + 1}, {x: box.endX - 1, y: box.endY - 1}, gs.tileTypes.Floor);
			*/
			
			area = roomGenerator.placeRandomRoom(box);
			
			// Find nearest tileIndex in the cave:
			indexList = gs.getAllIndex();
			indexList = indexList.filter(index => gs.isHallIndex(index));
			indexList = indexList.filter(index => gs.getArea(index) === this.mainCaveArea);
			indexList = indexList.sort((a, b) => gs.distance(a, area.centerTileIndex) - gs.distance(b, area.centerTileIndex));
			
			this.placeAStarHall(gs.getHallIndex(area), indexList[0]);
			
			this.roomAreaList.push(area);
			
			if (this.roomAreaList.length > 5) {
				break;
			}
		}
	}
};


// CHOOSE_MASK:
// *****************************************************************************
CaveRoomGenerator.prototype.chooseMask = function () {

	return util.randElem(
		[[[1, 1, 0, 0],
		[1, 1, 0, 0],
		[0, 0, 0, 0],
		[0, 0, 0, 0]],

	   [[0, 0, 1, 1],
		[0, 0, 1, 1],
		[0, 0, 0, 0],
		[0, 0, 0, 0]],

	   [[0, 0, 0, 0],
		[0, 0, 0, 0],
		[1, 1, 0, 0],
		[1, 1, 0, 0]],

	   [[0, 0, 0, 0],
		[0, 0, 0, 0],
		[0, 0, 1, 1],
		[0, 0, 1, 1]],

	   [[1, 0, 0, 1],
		[0, 0, 0, 0],
		[0, 0, 0, 0],
		[1, 0, 0, 1]],

	   [[0, 0, 1, 0],
		[1, 0, 0, 0],
		[0, 0, 0, 1],
		[0, 1, 0, 0]],

	   [[0, 0, 0, 0],
		[0, 1, 1, 0],
		[0, 1, 1, 0],
		[0, 0, 0, 0]]

	  ]);
	
};

// FIND_ROOM_LOCATION:
// ************************************************************************************************
CaveRoomGenerator.prototype.findRoomLocation = function (width, height) {
	var validList = [], indexList, numCaveWalls, numCaveFloors, numFloors;
	
	for (let x = 0; x < this.numTilesX - width - 1; x += 1) {
		for (let y = 0; y < this.numTilesY - height - 1; y += 1) {
			indexList = gs.getIndexInBox(x, y, x + width, y + height);
			numCaveWalls = indexList.filter(index => gs.getTile(index).type.name === 'CaveWall').length;
			numCaveFloors = indexList.filter(index => gs.getTile(index).type.name === 'CaveFloor').length;
			numFloors = indexList.filter(index => gs.getTile(index).type.name === 'Floor').length;
			
			if (indexList.length === width * height
				&& numCaveWalls > width * height / 2 
				&& numCaveFloors > 1 
				&& numCaveFloors < Math.min(width, height) 
				&& numFloors === 0) {
				
				
				
				validList.push({x: x, y: y});
			}
		}
	}
	
	return validList.length > 0 ? util.randElem(validList) : null;
};

// CONNECT_ROOMS:
// ************************************************************************************************
CaveRoomGenerator.prototype.connectRooms = function () {
	var i;
	
	if (this.roomAreaList.length > 1) {
		for (let i = 0; i < this.roomAreaList.length - 1; i += 1) {
			this.placeAStarHall(gs.getHallIndex(this.roomAreaList[i]), gs.getHallIndex(this.roomAreaList[i + 1]), 1);
		}		
	}

};/*global game, gs, console, Phaser, util*/
/*global BaseGenerator*/
/*jshint esversion: 6, loopfunc: true*/
'use strict';

// CONSTRUCTOR:
// ************************************************************************************************
function RingGenerator() {}
RingGenerator.prototype = new BaseGenerator();
var ringGenerator = new RingGenerator();

// GENERATE:
// ************************************************************************************************
RingGenerator.prototype.generate = function (flags) {
	var area;
	
	flags = flags || {};
	this.flags = flags;
	
	// Initial Fill:
	this.placeTileSquare({x: 0, y: 0}, {x: this.numTilesX, y: this.numTilesY}, gs.tileTypes.Wall);

	this.createRings();
	//this.placeDoors();
	
	return true;
};

// CREATE_RINGS:
// ************************************************************************************************
RingGenerator.prototype.createRings = function () {
	var ringList = [
		{inner: 0, outer: 4, angles: []},
		{inner: 7, outer: 12, angles: []},
		{inner: 15, outer: 19, angles: []}
	];
	
	// Rings:
	ringList.forEach(function (ring) {
		this.createRing(ring.inner, ring.outer);
	}, this);
	
	// Wall Segments:
	ringList.forEach(function (ring) {
		if (ring.inner !== 0) {
			this.createSegmentWall(ring);
			this.createSegmentWall(ring);
		}
		
	}, this);
	
	// Ring Doors:
	this.createRingDoor(ringList[0], ringList[1]);
	this.createRingDoor(ringList[1], ringList[2]);
	
};

// CREATE_RING_DOORS:
// ************************************************************************************************
RingGenerator.prototype.createRingDoor = function (ring1, ring2) {
	var centerTileIndex, angle, normal, startTileIndex, endTileIndex, placeWall, placedDoor = 0;

	centerTileIndex = {x: this.numTilesX / 2, y: this.numTilesY / 2};
	
	[0, 90, 180, 270].forEach( function (angle) {
		if (!gs.inArray(angle, ring1.angles) && !gs.inArray(angle, ring2.angles)) {
			normal = gs.getNormalFromAngle(angle);
			startTileIndex = {x: Math.round(centerTileIndex.x + normal.x * ring1.outer),
							  y: Math.round(centerTileIndex.y + normal.y * ring1.outer)};
			endTileIndex = {x: Math.round(centerTileIndex.x + normal.x * ring2.inner),
							y: Math.round(centerTileIndex.y + normal.y * ring2.inner)};

			gs.setTileType(startTileIndex, gs.tileTypes.Floor);
			gs.createObject(startTileIndex, 'Door');
			gs.getIndexInRay(startTileIndex, endTileIndex).forEach(function (index) {
				gs.setTileType(index, gs.tileTypes.Floor);
			}, this);
			
			placedDoor += 1;
		}
		
	}, this);
	

	[45, 135, 225, 315].forEach( function (angle) {
		if (placedDoor < 2 && !gs.inArray(angle, ring1.angles) && !gs.inArray(angle, ring2.angles)) {
			normal = gs.getNormalFromAngle(angle);
			startTileIndex = {x: Math.round(centerTileIndex.x + normal.x * ring1.outer),
							  y: Math.round(centerTileIndex.y + normal.y * ring1.outer)};
			endTileIndex = {x: Math.round(centerTileIndex.x + normal.x * ring2.inner),
							y: Math.round(centerTileIndex.y + normal.y * ring2.inner)};

			gs.setTileType(startTileIndex, gs.tileTypes.Floor);
			gs.getIndexInRay(startTileIndex, endTileIndex).forEach(function (index) {
				gs.getIndexInRadius(index, 1.0).forEach(function (idx) {
					gs.setTileType(idx, gs.tileTypes.Floor);
				}, this);

			}, this);

			placedDoor += 1;
		}
		
	}, this);
	
};

// CREATE_RING:
// ************************************************************************************************
RingGenerator.prototype.createRing = function (innerRadius, outerRadius) {
	var centerTileIndex = {x: this.numTilesX / 2, y: this.numTilesY / 2};
	
	gs.getIndexInRadius(centerTileIndex, outerRadius).forEach(function (index) {
		if (gs.distance(centerTileIndex, index) < outerRadius && gs.distance(centerTileIndex, index) >= innerRadius) {
			gs.setTileType(index, gs.tileTypes.Floor);
		}
		
	}, this);
};

// CREATE_SEGMENT_WALL:
// ************************************************************************************************
RingGenerator.prototype.createSegmentWall = function (ring) {
	var centerTileIndex, angle, normal, startTileIndex, endTileIndex, placeWall, hallIndex, perp;

	centerTileIndex = {x: this.numTilesX / 2, y: this.numTilesY / 2};
	
	do {
		angle = util.randElem([0, 90, 180, 270]);
	} while (gs.inArray(angle, ring.angles));
	
	ring.angles.push(angle);
	
	normal = gs.getNormalFromAngle(angle);
	startTileIndex = {x: Math.round(centerTileIndex.x + normal.x * ring.inner),
					  y: Math.round(centerTileIndex.y + normal.y * ring.inner)};
	endTileIndex = {x: Math.round(centerTileIndex.x + normal.x * ring.outer),
					y: Math.round(centerTileIndex.y + normal.y * ring.outer)};
		
	
	placeWall = function (tileIndex) {
		gs.getIndexInRadius(tileIndex, 1).forEach(function (index) {
			gs.setTileType(index, gs.tileTypes.Wall);
		}, this);
	};
		
	placeWall(startTileIndex);
	placeWall(endTileIndex);
	gs.getIndexInRay(startTileIndex, endTileIndex).forEach(function (index) {
		placeWall(index);
	}, this);
	
	// Hall:
	hallIndex = {x: Math.round(startTileIndex.x + normal.x * (ring.outer - ring.inner) / 2),
				 y: Math.round(startTileIndex.y + normal.y * (ring.outer - ring.inner) / 2)};
	perp = gs.getOrthoVector(normal);
	gs.setTileType(hallIndex, gs.tileTypes.Floor);
	gs.createObject(hallIndex, 'Door');
	gs.setTileType({x: hallIndex.x + perp.x, y: hallIndex.y + perp.y}, gs.tileTypes.Floor);
	gs.setTileType({x: hallIndex.x - perp.x, y: hallIndex.y - perp.y}, gs.tileTypes.Floor);
};/*global game, gs, console, Phaser, util*/
/*global BaseGenerator, featureGenerator*/
/*jshint esversion: 6, loopfunc: true*/
'use strict';

// CONSTRUCTOR:
// ************************************************************************************************
function LairGenerator() {}
LairGenerator.prototype = new BaseGenerator();
var lairGenerator = new LairGenerator();

// GENERATE:
// ************************************************************************************************
LairGenerator.prototype.generate = function (flags) {
	var area;
	
	flags = flags || {};
	this.flags = flags;
	
	this.roomAreaList = [];
	
	// Initial Fill:
	this.placeTileSquare({x: 0, y: 0}, {x: this.numTilesX, y: this.numTilesY}, gs.tileTypes.CaveWall);
	
	// Cave fill:
	this.placeTileCave({x: 11, y: 11}, {x: this.numTilesX - 11, y: this.numTilesY - 11}, gs.tileTypes.CaveWall);
	
    // Area:
	this.mainCaveArea = this.createArea(0, 0, this.numTilesX, this.numTilesY);
	this.mainCaveArea.type = 'Cave';
	this.mainCaveArea.depth = 1;
	this.roomAreaList.push(this.mainCaveArea);
	
	// Lairs:
	for (let i = 0; i < 4; i += 1) {
		if (featureGenerator.floatingFeatureTypes.OgreCave.canGenerate()) {
			featureGenerator.floatingFeatureTypes.OgreCave.generate();
		}
	}
	
	gs.areaList = this.roomAreaList;
	
	return true;
};/*global game, gs, console, Phaser, util*/
/*global BaseGenerator, roomGenerator*/
/*jshint esversion: 6*/
'use strict';

// CONSTRUCTOR:
// ************************************************************************************************
function FeastHallGenerator() {}
FeastHallGenerator.prototype = new BaseGenerator();
var feastHallGenerator = new FeastHallGenerator();

// GENERATE:
// ************************************************************************************************
FeastHallGenerator.prototype.generate = function (flags = {}) {
	
	this.flags = flags;
	
	
	// Initial Fill:
	this.placeTileSquare({x: 0, y: 0}, {x: this.numTilesX, y: this.numTilesY}, gs.tileTypes.Wall);
	
	this.placeVault({x: 13, y: 5}, {vaultTypeName: 'FeastHallMain01'});
	
	
	
	// Place Doors:
	this.placeDoors();
	
	return true;
};/*global gs, util*/
/*global Item*/

/*global BRANCH_I_ZONES, BRANCH_II_ZONES*/
/*global TIER_I_ZONES, TIER_II_ZONES, TIER_III_ZONES*/
/*global MAX_RECOVERY_MUSHROOMS, MAX_FIRE_MUSHROOMS*/
/*global NUM_GOLD_PER_LEVEL, DOUBLE_GOLD_CHANCE*/
/*global NUM_CHESTS_PER_LEVEL*/
/*global NUM_FOUNTAINS_PER_LEVEL*/
/*global NUM_CAMP_FIRES*/
/*global MERCHANT_MIN_LEVEL, MERCHANT_SPAWN_PERCENT*/
/*global TALENT_TRAINER_MIN_LEVEL, TALENT_TRAINER_PERCENT*/
/*global SKILL_TRAINER_MIN_LEVEL, SKILL_TRAINER_PERCENT*/
/*global PRIEST_MIN_LEVEL, PRIEST_PERCENT*/
/*global ENCHANTMENT_TABLE_MIN_LEVEL, ENCHANTMENT_TABLE_PERCENT*/
/*global TRANSFERANCE_TABLE_MIN_LEVEL, TRANSFERANCE_TABLE_PERCENT*/
/*global MAX_FIRE_POTS, SPAWN_FIRE_POTS_PERCENT*/
/*global MAX_BEAR_TRAPS, SPAWN_BEAR_TRAPS_PERCENT*/
/*global MAX_FIRE_VENTS, SPAWN_FIRE_VENTS_PERCENT*/
/*global MAX_GAS_VENTS, SPAWN_GAS_VENTS_PERCENT*/
/*global MAX_GAS_POTS, SPAWN_GAS_POTS_PERCENT*/
/*global MAX_SPIKE_TRAPS, SPAWN_SPIKE_TRAPS_PERCENT*/
/*global PIT_TRAP_MIN_LEVEL, MAX_PIT_TRAPS, SPAWN_PIT_TRAP_PERCENT*/
/*global TELEPORT_TRAP_MIN_LEVEL, MAX_TELEPORT_TRAPS, SPAWN_TELEPORT_TRAP_PERCENT*/
/*global ALTER_MIN_LEVEL, SPAWN_ALTER_PERCENT*/
/*global MAX_VINES, SPAWN_VINE_PERCENT, SUPER_VINE_PERCENT*/
/*global MAX_ICE*/
/*jshint esversion: 6, laxbreak: true*/
'use strict';

// GENERATE_GLOBAL_STUFF:
// ************************************************************************************************
gs.generateGlobalStuff = function () {
	var num, i, tileIndex, indexList, religionName;
	
	
	// Guaranteed Food:
	if (this.zoneLevel % 4 === 0) {
		tileIndex = this.getOpenIndexInLevel();
		if (tileIndex) {
			this.createFloorItem(tileIndex, Item.createItem('Meat'));
		}
	}
	
	// Item Containers:
	num = NUM_CHESTS_PER_LEVEL;
	
	// Guaranteed food replaces one item:
	if (this.zoneLevel % 4 === 0) {
		num = NUM_CHESTS_PER_LEVEL - 1;
	}
	
	for (i = 0; i < num; i += 1) {
		tileIndex = this.getWideOpenIndexInLevel();
		if (tileIndex) {
			if (util.frac() <= 0.5) {
				this.createContainer(tileIndex, 'Chest');
			}
			else {
				this.createRandomFloorItem(tileIndex);
			}
		}
	}
	
	// Gold Piles:
	num = util.randInt(Math.ceil(NUM_GOLD_PER_LEVEL / 2), NUM_GOLD_PER_LEVEL);
	if (util.frac() <= DOUBLE_GOLD_CHANCE) {
		num = NUM_GOLD_PER_LEVEL * 2;
	}
	for (i = 0; i < num; i += 1) {
		tileIndex = this.getWideOpenIndexInLevel();
		if (tileIndex) {
			this.createFloorItem(tileIndex, Item.createItem('GoldCoin', {amount: util.randInt(Math.ceil(gs.dropGoldAmount() / 2), gs.dropGoldAmount())}));
		}
	}

	// Recovery Fountains:
	num = util.randInt(Math.ceil(NUM_FOUNTAINS_PER_LEVEL / 2), NUM_FOUNTAINS_PER_LEVEL);
	for (i = 0; i < num; i += 1) {
		tileIndex = this.getWideOpenIndexInLevel();
		if (tileIndex) {
			this.createObject(tileIndex, gs.chooseRandom([
				{name: 'HealthFountain', percent: 48},
				{name: 'EnergyFountain', percent: 28},
				{name: 'ExperienceFountain', percent: 18},
				{name: 'WellOfWishing', percent: 4},
				{name: 'AttributeFountain', percent: 2}
			]));
		}
	}

	// Camp Fires:
	if (this.zoneType().isCold) {
		for (i = 0; i < NUM_CAMP_FIRES; i += 1) {
			tileIndex = this.getWideOpenIndexInLevel();
			if (tileIndex) {
				this.createObject(tileIndex, 'CampFire');
			}
		}
	}
		
	// Merchants
	if (!gs.characterList.find(npc => npc.name === 'Merchant')) {
		if ((this.dangerLevel() >= MERCHANT_MIN_LEVEL && util.frac() < MERCHANT_SPAWN_PERCENT)
			|| (this.zoneLevel === 3 && this.inArray(this.zoneName, BRANCH_I_ZONES))
			|| (this.zoneLevel === 3 && this.inArray(this.zoneName, BRANCH_II_ZONES))
			|| (this.zoneLevel === 1 && this.inArray(this.zoneName, TIER_III_ZONES))) {

			tileIndex = this.getMerchantSpawnIndex();
			if (tileIndex) {
				this.createNPC(tileIndex, 'Merchant');
				this.stockMerchant();
			}
		}
	}
	
	// Talent Trainer:
	if (this.dangerLevel() >= TALENT_TRAINER_MIN_LEVEL && util.frac() < TALENT_TRAINER_PERCENT) {
		tileIndex = this.getMerchantSpawnIndex();
		if (tileIndex) {
			this.createNPC(tileIndex, 'TalentTrainer');
		}
	}
	
	// Skill Trainer:
	if (this.dangerLevel() >= SKILL_TRAINER_MIN_LEVEL && util.frac() < SKILL_TRAINER_PERCENT) {
		tileIndex = this.getMerchantSpawnIndex();
		if (tileIndex) {
			this.createNPC(tileIndex, 'SkillTrainer');
		}
	}
	
	// Priest:
	if (this.dangerLevel() >= PRIEST_MIN_LEVEL && util.frac() < PRIEST_PERCENT) {
		tileIndex = this.getMerchantSpawnIndex();
		if (tileIndex) {
			this.createNPC(tileIndex, 'Priest');
		}
	}

	// Enchantment Table:
	if (this.dangerLevel() >= ENCHANTMENT_TABLE_MIN_LEVEL && util.frac() < ENCHANTMENT_TABLE_PERCENT) {
		tileIndex = this.getWideOpenIndexInLevel();
		if (tileIndex) {
			this.createObject(tileIndex, 'EnchantmentTable');
		}
	}
	
	// Enchantment Table:
	if (this.dangerLevel() >= TRANSFERANCE_TABLE_MIN_LEVEL && util.frac() < TRANSFERANCE_TABLE_PERCENT) {
		tileIndex = this.getWideOpenIndexInLevel();
		if (tileIndex) {
			this.createObject(tileIndex, 'TransferanceTable');
		}
	}
	
	// Altar:
	if (this.dangerLevel() >= ALTER_MIN_LEVEL && this.remainingAltars.length > 0 && util.frac() < SPAWN_ALTER_PERCENT) {
		tileIndex = this.getWideOpenIndexInLevel();
		if (tileIndex) {
			religionName = util.randElem(this.remainingAltars);
			this.createAltar(tileIndex, 'AltarOf' + religionName);
			this.removeFromArray(religionName, this.remainingAltars);
		}
	}
	
	// Fire Mushrooms:
	if (this.zoneType().spawnFireShrooms) {
		num = util.randInt(Math.ceil(MAX_FIRE_MUSHROOMS / 2), MAX_FIRE_MUSHROOMS);
		for (i = 0; i < num; i += 1) {
			tileIndex = this.getOpenIndexInLevel();
			if (tileIndex) {
				this.spawnShroomTrap(tileIndex);
			}
		}
	}
	
	// Fire Glyph:
	if (this.zoneType().spawnFireGlyphs) {
		num = util.randInt(Math.ceil(MAX_FIRE_MUSHROOMS / 2), MAX_FIRE_MUSHROOMS);
		for (i = 0; i < num; i += 1) {
			tileIndex = this.getOpenIndexInLevel();
			if (tileIndex) {
				this.spawnShroomTrap(tileIndex, 'FireGlyph');
			}
		}
	}
	
	// Fire Pots:
	if (this.zoneType().spawnFirePots && util.frac() < SPAWN_FIRE_POTS_PERCENT) {
		num = util.randInt(Math.ceil(MAX_FIRE_POTS / 2), MAX_FIRE_POTS);
		for (i = 0; i < num; i += 1) {
			tileIndex = this.getWideOpenIndexInLevel();
			if (tileIndex) {
				gs.createNPC(tileIndex, 'FirePot');
			}
		}
	}
	
	// Bear Traps:
	if (this.zoneType().spawnBearTraps && util.frac() < SPAWN_BEAR_TRAPS_PERCENT) {
		num = util.randInt(Math.ceil(MAX_BEAR_TRAPS / 2), MAX_BEAR_TRAPS);
		for (i = 0; i < num; i += 1) {
			tileIndex = this.getWideOpenIndexInLevel();
			if (tileIndex) {
				gs.createObject(tileIndex, 'BearTrap');
			}
		}
	}
	
	// Fire Vents::
	if (this.zoneType().spawnFireVents && util.frac() < SPAWN_FIRE_VENTS_PERCENT) {
		num = util.randInt(Math.ceil(MAX_FIRE_VENTS / 2), MAX_FIRE_VENTS);
		for (i = 0; i < num; i += 1) {
			tileIndex = this.getWideOpenIndexInLevel();
			if (tileIndex) {
				gs.createObject(tileIndex, 'FireVent');
			}
		}
	}
	
	// Gas Vents:
	if (this.zoneType().spawnGasVents && util.frac() < SPAWN_GAS_VENTS_PERCENT) {
		num = util.randInt(Math.ceil(MAX_GAS_VENTS / 2), MAX_GAS_VENTS);
		for (i = 0; i < num; i += 1) {
			tileIndex = this.getWideOpenIndexInLevel();
			if (tileIndex) {
				gs.createObject(tileIndex, 'GasVent');
			}
		}
	}
	
	// Gas Pots:
	if (this.zoneType().spawnGasPots && util.frac() < SPAWN_GAS_POTS_PERCENT) {
		num = util.randInt(Math.ceil(MAX_GAS_POTS / 2), MAX_GAS_POTS);
		for (i = 0; i < num; i += 1) {
			tileIndex = this.getWideOpenIndexInLevel();
			if (tileIndex) {
				gs.createNPC(tileIndex, 'GasPot');
			}
		}
	}
	
	// Pit Traps:
	if (this.zoneLevel < this.zoneType().numLevels && this.dangerLevel() >= PIT_TRAP_MIN_LEVEL && util.frac() < SPAWN_PIT_TRAP_PERCENT) {
		for (i = 0; i < MAX_PIT_TRAPS; i += 1) {
			tileIndex = this.getWideOpenIndexInLevel();
			if (tileIndex) {
				gs.createObject(tileIndex, 'PitTrap');
			}
		}
	}
	
	// Teleport Traps:
	if (this.dangerLevel() >= TELEPORT_TRAP_MIN_LEVEL && util.frac() < SPAWN_TELEPORT_TRAP_PERCENT) {
		
		for (i = 0; i < MAX_TELEPORT_TRAPS; i += 1) {
			tileIndex = this.getWideOpenIndexInLevel();
			if (tileIndex) {
				gs.createObject(tileIndex, 'TeleportTrap');
			}
		}
	}
	
	// Spike Traps:
	if (this.zoneType().spawnSpikeTraps && util.frac() < SPAWN_SPIKE_TRAPS_PERCENT) {
		num = util.randInt(Math.ceil(MAX_SPIKE_TRAPS / 2), MAX_SPIKE_TRAPS);
		for (i = 0; i < num; i += 1) {
			tileIndex = this.getWideOpenIndexInLevel();
			if (tileIndex) {
				gs.createObject(tileIndex, 'SpikeTrap');
			}
		}
	}
	
	// Bone Patch:
	if (this.zoneType().spawnBones && util.frac() < SPAWN_VINE_PERCENT) {
		num = util.randInt(Math.ceil(MAX_VINES / 2), MAX_VINES);
		
		// Super Vines:
		if (this.dangerLevel() >= 2 && util.frac() < SUPER_VINE_PERCENT) {
			num = MAX_VINES * 5;
		}
		
		for (i = 0; i < num; i += 1) {
			tileIndex = this.getOpenIndexInLevel();
			if (tileIndex) {
				this.createVinePatch(tileIndex, util.randInt(2, 4), 'Bones', 0.5);
			}
		}
	}
	
	// Vine Patch:
	if (this.zoneType().spawnVines && util.frac() < SPAWN_VINE_PERCENT) {
		num = util.randInt(Math.ceil(MAX_VINES / 2), MAX_VINES);
		
		// Super Vines:
		if (this.dangerLevel() >= 2 && util.frac() < SUPER_VINE_PERCENT) {
			num = MAX_VINES * 5;
		}
		
		for (i = 0; i < num; i += 1) {
			tileIndex = this.getOpenIndexInLevel();
			if (tileIndex) {
				this.createVinePatch(tileIndex, util.randInt(2, 4), 'Vine');
			}
		}
	}
	
	// Oil Patch:
	if (this.zoneType().spawnOil && util.frac() < SPAWN_VINE_PERCENT) {
		num = util.randInt(Math.ceil(MAX_VINES / 2), MAX_VINES);
		
		// Super Oil:
		if (util.frac() < SUPER_VINE_PERCENT) {
			num = MAX_VINES * 5;
		}
		
		for (i = 0; i < num; i += 1) {
			tileIndex = this.getOpenIndexInLevel();
			if (tileIndex) {
				this.createVinePatch(tileIndex, util.randInt(2, 4), 'Oil');
			}
		}
	}
	
	// Oil Patch:
	if (this.zoneType().spawnOil && util.frac() < SPAWN_VINE_PERCENT + 1) {
		num = util.randInt(Math.ceil(MAX_VINES / 2), MAX_VINES);
		
		
		for (i = 0; i < num; i += 1) {
			tileIndex = this.getOpenIndexInLevel();
			if (tileIndex) {
				this.createVinePatch(tileIndex, util.randInt(2, 4), 'Scrap', 0.5);
			}
		}
	}
	
	// Ice Patch:
	if (this.zoneType().spawnIce) {
		num = util.randInt(Math.ceil(MAX_ICE / 2), MAX_ICE);
		
		// Super Vines:
		if (util.frac() < SUPER_VINE_PERCENT) {
			num = MAX_VINES * 5;
		}
		
		for (i = 0; i < num; i += 1) {
			tileIndex = this.getOpenIndexInLevel();
			if (tileIndex) {
				this.createVinePatch(tileIndex, util.randInt(2, 4), 'Ice');
			}
		}
	}
	
	// Blood:
	if (this.zoneType().spawnBlood) {
		indexList = this.getAllIndex();
		indexList = indexList.filter(index => gs.isPassable(index) && !gs.getObj(index) && gs.getTile(index).type !== gs.tileTypes.Water);
		indexList = indexList.filter(index => util.frac() < 0.02);
		indexList.forEach(function (index) {
			gs.createObject(index, 'Blood');
		});
	}
	

};

// PLACE_WALL_DRESSING:
// ************************************************************************************************
gs.placeWallDressing = function () {
	// Torches:
	let indexList = this.getAllIndex();
	indexList = indexList.filter(index => gs.isVisibleWall(index) && index.x % 2 === 0 && !gs.getObj(index) && util.frac() < 0.50);
	indexList.forEach(function (index) {
		gs.createObject(index, 'Torch');
	});
	
	// Wall Flags:
	if (this.zoneType().spawnWallFlags && util.frac() < 0.5) {
		indexList = this.getAllIndex();
		indexList = indexList.filter(index => gs.isVisibleWall(index) && gs.getTile(index).type.name === 'Wall' && index.x % 2 === 1 && !gs.getObj(index) && util.frac() < 0.10);
		indexList.forEach(function (index) {
			gs.createObject(index, 'WallFlag');
		});
	}
};

// SPAWN_SHROOM_TRAP:
// ************************************************************************************************
gs.spawnShroomTrap = function (tileIndex, objectTypeName) {
	objectTypeName = objectTypeName || 'FireShroom';
	
	gs.getIndexInRadius(tileIndex, 3).forEach(function (index) {
		if (gs.isIndexOpen(index) && util.frac() < 0.3) {
			gs.createObject(index, objectTypeName);
		}
	}, this);
};

// SPAWN_HEALING_SHROOM_PATCH:
// ************************************************************************************************
gs.spawnHealingShroomPatch = function (tileIndex) {
	gs.getIndexInRadius(tileIndex, 3).forEach(function (index) {
		if (gs.isIndexOpen(index) && util.frac() < 0.15) { // 0.3 Jan-19-2017
			gs.createObject(index, util.randElem(['HealingShroom', 'EnergyShroom']));
		}
	}, this);
};
/*global Phaser, game, gs, console, util*/
/*global SCALE_FACTOR, LARGE_WHITE_FONT, MAX_RAGE*/
/*global Abilities, StatusEffects, CharacterBody*/
/*global CHARACTER_HEALTH_FONT, CHARACTER_STATUS_FONT, SKILL_NAMES, RESISTANCE_MULTIPLIER*/
/*global MOVE_TIME, CRITICAL_PERCENT, CRIT_MULTIPLIER, TILE_SIZE*/
/*global SPELL_MULTIPLIER_PER_SKILL, RANGE_MULTIPLIER_PER_SKILL, INFERNO_RING_DAMAGE, SAVE_AMMO_PER_SKILL, MAX_DEFENSE*/
/*global PARTICLE_FRAMES, RAGE_POINT_PERCENT, RAGE_DECREASE_TURNS*/
/*global SUMMONED_RING_FRAME, ELITE_RING_FRAME, ALLY_RING_FRAME*/
/*global MOVEMENT_SPEED, FAST_MOVEMENT_SPEED, KNOCK_BACK_SPEED*/
/*global TIME_SCALAR, FACTION, CORRODE_PERCENT, CHARACTER_SIZE, MAX_EVASION_PERCENT, DAMAGE_TYPES, SHOUT_RANGE*/
/*jshint white: true, laxbreak: true, esversion: 6*/
'use strict';

// CONSTRUCTOR:
// ************************************************************************************************
function Character() {
	// Cant add any properties here cause theres only one Character shared prototype
}

Character.prototype.createSharedProperties = function () {
	this.isAlive = true;
	this.state = 'WAITING';
	this.waitTime = 0; // The time the character must wait to take next turn
	
	// Attributes:
	this.baseStrength = 10;
	this.baseDexterity = 10;
	this.baseIntelligence = 10;
	
	// Skills:
	this.skills = {};
	SKILL_NAMES.forEach(function (skillName) {
		this.skills[skillName] = 0;
	}, this);
	
	// Sub-Systems:
	this.abilities = new Abilities();
	this.statusEffects = new StatusEffects(this);
	this.body = new CharacterBody(this);

	// Pop up text:
	this.popUpTimer = 0;
	this.popUpQueue = [];
	
	// Defense:
	this.protection = 0;
	this.resistance = {Fire: 0, Cold: 0, Shock: 0, Toxic: 0};
	
	// Health and Mana:
	this.maxHp = 0;
	this.currentHp = 0;
	this.poisonDamage = 0;
	this.hpRegenTime = 0;
	this.mpRegenTime = 0;
	this.hpRegenTimer = 0;
	this.mpRegenTimer = 0;
	
	// Create sprite:
	this.sprite = gs.createSprite(0, 0, 'Tileset', gs.objectSpritesGroup);
	this.sprite.anchor.setTo(0.5, 0.5);
	this.sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	this.sprite.visible = false;
	
	// Ring Sprite:
	this.ringSprite = gs.createSprite(0, 0, 'Tileset', gs.characterHUDGroup);
	this.ringSprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	this.ringSprite.anchor.setTo(0.5, 0.5);
	this.ringSprite.visible = false;
	
	// Text:
	this.hpText = gs.createText(0, 0, '', CHARACTER_HEALTH_FONT, gs.characterHUDGroup);
	this.statusText = gs.createText(0, 0, '', CHARACTER_STATUS_FONT, gs.characterHUDGroup);
	gs.centerText(this.statusText);
	this.hpText.visible = false;
	this.statusText.visible = false;
};


// UPDATE_TURN_BASE:
// ************************************************************************************************
Character.prototype.updateTurnBase = function () {
	this.onTurnRegeneration();
	this.statusEffects.onUpdateTurn();
	this.onTurnPoison();
	
	// Take damage from Lava:
	if (gs.getTile(this.tileIndex).type.name === 'Lava' && !this.isFlying && !this.type.isLavaImmune) {
		this.takeDamage(4, 'Fire', {killer: 'Lava', neverCrit: true});
	}
	
	// Apply Effects (Poison Gas):
	if (gs.getCloud(this.tileIndex) && gs.getCloud(this.tileIndex).characterTurnEffect) {
		gs.getCloud(this.tileIndex).characterTurnEffect(this);
	}
	
	this.updateTerrainEffects();
	
	// Reduce Cooldown:
	if (this.characterClass !== 'Barbarian') {
		this.abilities.updateTurn();
	}

	// ASSERT:
	if (this.isAlive && gs.getChar(this.tileIndex) !== this) {
		console.log(this);
		throw 'Not on tileindex';
	}
};

// ON_TURN_REGENERATION:
// ************************************************************************************************
Character.prototype.onTurnRegeneration = function () {
	// Draining prevents regeneration:
	if (this.statusEffects.has('Draining')) {
		return;
	}
	
	// Health Regeneration:
	if (!this.type.noRegen) {
		this.hpRegenTimer += 1;
		if (this.hpRegenTimer >= this.hpRegenTime) {
			this.healHp(1);
			this.hpRegenTimer = 0;
		}
	}

	// Mana Regeneration:
	if (this === gs.pc) {
		this.mpRegenTimer += 1;
		if (this.mpRegenTimer >= this.mpRegenTime) {
			this.gainMp(1);
			this.mpRegenTimer = 0;
		}
	}
};

// ON_TURN_POISON:
// ************************************************************************************************
Character.prototype.onTurnPoison = function () {
	var damage;
	
	// Apply poison damage:
	if (this.poisonDamage > 0) {
		damage = Math.min(this.poisonDamage, Math.ceil(this.poisonDamage * 0.25)); // Poison damage will deal at most 5 damage per turn
		
		this.takeDamage(damage, 'Toxic', {killer: 'Poison', neverCrit: true});
		
		this.poisonDamage -= damage;
		this.poisonDamage = Math.max(0, this.poisonDamage);
	}
};


// UPDATE_TERRAIN_EFFECTS:
// ************************************************************************************************
Character.prototype.updateTerrainEffects = function () {
	// Unstable:
	if (this.isTileIndexUnstable(this.tileIndex) && !this.isFlying) {
		this.statusEffects.add('Unstable');
	} 
	else {
		this.statusEffects.remove('Unstable');
	}

	// Wet:
	if (this.isTileIndexWet(this.tileIndex) && !this.isFlying) {
		this.statusEffects.add('Wet');
	} 
	else {
		this.statusEffects.remove('Wet');
	}

	// Flammable:
	if (gs.getObj(this.tileIndex, 'Oil') && !this.isFlying) {
		this.statusEffects.add('Flammable');
	} 
	else {
		this.statusEffects.remove('Flammable');
	}
};

// UPDATE_FRAME:
// ************************************************************************************************
Character.prototype.updateFrame = function () {
    this.body.onUpdateFrame();
	
	// Update sprite position based on character position and offset:
	this.sprite.x = this.body.position.x + Math.round(this.body.offset.x);
	this.sprite.y = this.body.position.y + Math.round(this.body.offset.y);
	
	if (this.light) {
		this.light.sprite.x = this.sprite.x;
		this.light.sprite.y = this.sprite.y;
	}
	
	// Update sprite facing (some characters never face):
	if (this.body.facing === 'RIGHT' || this.type.dontFace) {
		this.sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	} 
	else {
		this.sprite.scale.setTo(-SCALE_FACTOR, SCALE_FACTOR);
	}

	// Crop sprite if submerged:
	if ((this.isTileIndexWet(this.tileIndex) || gs.getTile(this.tileIndex).type.name === 'Lava') && !this.isFlying) {
		this.sprite.crop(new Phaser.Rectangle(0, 0, TILE_SIZE / 2, TILE_SIZE / 3));
	} 
	else {
		this.sprite.crop(new Phaser.Rectangle(0, 0, TILE_SIZE / 2, TILE_SIZE / 2));
	}
    
	// Hide in shell:
	if (this.statusEffects.has('HideInShell')) {
		this.sprite.frame = this.type.frame + 1;
	}
	else {
		this.sprite.frame = this.type.frame;
	}
	
	// Multi-moving particle trail:
	if (this.isMultiMoving && gs.gameTime() % 2 === 0) {
		gs.createParticle(this.sprite.position, {frame: PARTICLE_FRAMES.WHITE, duration: 30, fadePct: 0.5});
	}
		
	// Set sprite visibility based on visibility of tile (Player is always visible):
	// Must test if gs.pc exists to know if we are in a randomMap i.e menu screen
	if (gs.pc) {
		this.setVisible(this.isAlive && gs.pc.canSeeCharacter(this) || this === gs.pc);
	}
	// Random maps:
	else {
		this.setVisible(true);
	}
	
	// Non-hostile mobs hide their interface sprites:
	if (this.faction === FACTION.NEUTRAL || this.faction === FACTION.DESTRUCTABLE) {
		this.hpText.visible = false;
		this.statusText.visible = false;
		this.ringSprite.visible = false;
	}
	
	this.updateUIFrame();
	this.processPopUpText();
	this.processEventQueue();
};


// PROCESS_EVENT_QUEUE
// ************************************************************************************************
Character.prototype.processEventQueue = function () {
	var event;
	
	if (this.eventQueue.length > 0 && this.eventTimer === 0) {
		event = this.eventQueue.shift();
		event.effect();
		this.eventTimer = event.delay;
	}
	
	if (this.eventTimer > 0) {
		this.eventTimer -= 1;
	}
};

// UPDATE_UI_FRAME:
// ************************************************************************************************
Character.prototype.updateUIFrame = function () {
	// Set Status:
	if (this.isHidden) {
		this.status = 'H';
	}
	else if (this.isAsleep) {
		this.status = 'ZZZ';
	} 
	else if (!this.isAgroed && this !== gs.pc) {
		this.status = '?';
	} 
	else if (this.isRunning) {
		this.status = '!';
	}
	else if (this !== gs.pc) {
		this.status = this.statusEffects.toUIString();
	}
	else {
		this.status = '';
	}
	
	// Text:
	if (this.hpText.visible) {
		this.hpText.setText(this.currentHp);
		this.statusText.setText(this.status);
	}
	
	// Position HP Text:
	this.hpText.x = this.body.position.x - 24;
	this.hpText.y = this.body.position.y + 4;
	

	// Position Status Text:
	this.statusText.x = this.body.position.x;
	this.statusText.y = this.body.position.y - 24;

	// Position elite sprite:
	this.ringSprite.x = this.body.position.x;
	this.ringSprite.y = this.body.position.y;
	
	// Set ring sprite:
	if (this.npcClassType || this.type.isUnique) {
		this.ringSprite.frame = ELITE_RING_FRAME;
	}
	else if (this.faction === FACTION.PLAYER && this !== gs.pc) {
		this.ringSprite.frame = ALLY_RING_FRAME;
	}
	else if (this.summonerID) {
		this.ringSprite.frame = SUMMONED_RING_FRAME;
	}
	else {
		this.ringSprite.frame = 0;
	}
};

// SET_VISIBLE:
// ************************************************************************************************
Character.prototype.setVisible = function (bool) {
	this.sprite.visible = bool;
	this.hpText.visible = bool;
	this.statusText.visible = bool;
	this.ringSprite.visible = bool;
	
	if (this.light) {
		this.light.sprite.visible = bool;
	}
	
	if (!this.ringSprite.frame) {
		this.ringSprite.visible = false;
	}
};


// ON_ENTER_TILE:
// Called once the character has actually finished moving and entered the tile
// Note that his tileIndex is already correct as it was set when beginning the move
// ************************************************************************************************
Character.prototype.onEnterTileBase = function () {
	
	// Fall down pit:
	if (gs.getTile(this.tileIndex).type.isPit && !this.isFlying) {
		this.fallDownPit();
	}
	
	// Step on object if it exists:
	if (gs.getObj(this.tileIndex)) {
		gs.getObj(this.tileIndex).stepOn(this);
	}
	
	// Enter Effect:
	if (gs.getCloud(this.tileIndex)) {
		gs.getCloud(this.tileIndex).stepOn(this);
	}
	
	this.updateTerrainEffects();
};

// IS_TILE_INDEX_UNSTABLE:
// Is the tileIndex unstable, for the character calling the function:
// ************************************************************************************************
Character.prototype.isTileIndexUnstable = function (tileIndex) {
	// Unstable Objects:
	if (gs.getObj(this.tileIndex, obj => obj.type.hasOwnProperty('isUnstable') && this.size <= obj.type.isUnstable)
			&& !this.type.isUnstableImmune // Spiders
			&& !this.isFlying) {
		return true;
	}
	
	// Water:
	if ((gs.getTile(this.tileIndex).type === gs.tileTypes.Water || gs.getTile(this.tileIndex).type === gs.tileTypes.Lava)
			&& !this.isFlying
			&& !this.type.isAquatic) {
		return true;
	}
	
	return false;
};

// IS_TILE_INDEX_WET:
// Is the tileIndex wet, for the character calling the function:
// ************************************************************************************************
Character.prototype.isTileIndexWet = function (tileIndex) {
	// Water:
	if (gs.getTile(this.tileIndex).type === gs.tileTypes.Water && !this.isFlying && !gs.getObj(this.tileIndex, obj => obj.type.name === 'Ice')) {
		return true;
	}
	
	return false;
};

// ADD_EVENT:
// ************************************************************************************************
Character.prototype.addEvent = function (event) {
	this.eventQueue.push(event);
};

// HEAL_HP:
// ************************************************************************************************
Character.prototype.healHp = function (amount) {
	this.currentHp += amount;
	this.currentHp = Math.min(this.currentHp, this.maxHp);
};

// CURE:
// Called from healing effects to cure poison, infection etc.
// ************************************************************************************************
Character.prototype.cure = function () {
	this.poisonDamage = 0;
	this.statusEffects.onCure();
	
};

// MENTAL_CURE:
// ************************************************************************************************
Character.prototype.mentalCure = function () {
	this.statusEffects.onMentalCure();
};

// GAIN_MP:
// ************************************************************************************************
Character.prototype.gainMp = function (amount) {
	this.currentMp += amount;
	this.currentMp = Math.min(this.currentMp, this.maxMp);
};

// LOSE_MP:
// ************************************************************************************************
Character.prototype.loseMp = function (amount) {
	this.currentMp -= amount;
	this.currentMp = Math.max(0, this.currentMp);
};

// RESET_ALL_COOLDOWNS:
// ************************************************************************************************
Character.prototype.resetAllCoolDowns = function () {
	this.abilities.resetAllCoolDowns();
};

// HAS_COOL_DOWN:
// ************************************************************************************************
Character.prototype.hasCoolDown = function () {
	return this.abilities.hasCoolDown();
};

// POP_UP_TEXT:
// ************************************************************************************************
Character.prototype.popUpText = function (text, color) {
	gs.createDamageText(this.body.position.x, this.body.position.y - 12, text, color);
};

// QUEUE_POP_UP_TEXT:
// ************************************************************************************************
Character.prototype.queuePopUpText = function (text, color) {
	this.popUpQueue.unshift({text: text, color: color});
	this.processPopUpText();
};

// PROCESS_POP_UP_TEXT:
// ************************************************************************************************
Character.prototype.processPopUpText = function () {
	var element, pos;

	
	if (this.popUpQueue.length > 0 && this.popUpTimer === 0) {
		element = this.popUpQueue.pop();
		pos = this.body.position;
		
		// Pop prev text higher:
		if (this.lastPopUpText && this.lastPopUpText.isAlive) {
			this.lastPopUpText.y -= 8;
			gs.initPopUpText(this.lastPopUpText, 80);
		}
		
		this.lastPopUpText = gs.createDamageText(pos.x, pos.y - 12, element.text, element.color);
		this.popUpTimer = 10;
	}
	
	if (this.popUpTimer > 0) {
		this.popUpTimer -= 1;
	}
};

// ADD_POISON_DAMAGE:
// ************************************************************************************************
Character.prototype.addPoisonDamage = function (amount) {
	this.queuePopUpText('Poisoned!', '#ff0000');
	this.poisonDamage += amount;
	this.poisonDamage = Math.min(this.poisonDamage, this.maxHp);
};

// TAKE_DAMAGE:
// Flags: isCrit, neverCrit, isSpecialAttack
// ************************************************************************************************
Character.prototype.takeDamage = function (amount, damageType, flags = {}) {
	var isCrit = false,
		critMultiplier;
	
	this.updateStats();
	
	if (this.type.damageImmune) {
		return 0;
	}
	
	if (flags.killer === gs.pc) {
		critMultiplier = gs.pc.critMultiplier;
	}
	else {
		critMultiplier = CRIT_MULTIPLIER;
	}
	
    // Reduce fire damage when wet:
	if (damageType === 'Fire' && this.isWet) {
		amount = Math.ceil(amount * 0.5);
	}
	
	// Flammable Crit:
	if (damageType === 'Fire' && this.isFlammable) {
		amount = Math.round(amount * critMultiplier);
		isCrit = true;
	}
	
	// Wet Shock:
    if (damageType === 'Shock' && this.isWet) {
		amount = Math.round(amount * critMultiplier);
		isCrit = true;
    }
    
	// Unstable Crit:
	if (damageType === 'Physical' && this.isUnstable) {
		amount = Math.round(amount * critMultiplier);
		isCrit = true;
	}
	
	// Any attacker can force a crit hit:
	if (flags.isCrit) {
		amount = Math.round(amount * critMultiplier);
		isCrit = true;
	}
	// Random Critical Hit:
	// Only NPCs can be critically hit by the player randomly
	else if (this !== gs.pc && (game.rnd.frac() <= CRITICAL_PERCENT || flags.isCrit) && !flags.neverCrit) {
		amount = Math.round(amount * critMultiplier);
		isCrit = true;
	}
	
	// Random damage roll for non-crits:
	// Critical hits and 'None' damageType are always max damage
	if (!isCrit && damageType !== 'None') {
		// Special Attacks deal max damage:
		if (flags.isSpecialAttack) {
			amount = amount;
		}
		// Physical is 1->amount (weighted to center)
		else if (damageType === 'Physical') {
			amount = Math.ceil((util.randInt(1, amount) + util.randInt(1, amount)) / 2);
		}
		// Non-physical is amount / 2 -> amount
		else {
			amount = Math.floor(amount / 2) + util.randInt(1, Math.ceil(amount / 2));
		}
	}
	
    // Defense mitigates damage:
	amount = this.mitigateDamage(amount, damageType);
	
	// Pop Up Text:
	if (isCrit) {
		this.queuePopUpText('Crit -' + amount, '#ff0000');
		if (!this.type.noBlood) {
			this.bloodSplatter();
		}
	} 
	else {
		this.queuePopUpText('-' + amount, '#ff0000');
		
	}

    // Cap damage to currentHp (for lifetaps):
	amount = Math.min(amount, this.currentHp);

    // Apply damage:
	if (!(this === gs.pc && gs.debugProperties.noDamage)) {
		this.currentHp -= amount;
	}
	
    // Hit Sound:
	if (this.currentHp > 0) {
		gs.playSound(gs.sounds.playerHit, this.tileIndex);
	}
	
    // Death:
	if (this.currentHp <= 0) {
		if (flags.killer && flags.killer.onKill) {
			flags.killer.onKill(this);
		}
		this.death(damageType, flags);
	}
    
    this.onTakeDamage();
	this.statusEffects.onTakeDamage(damageType);

	
	return amount;
};

// BLOOD_SPLATTER:
// When a critical hit lands we splatter some blood randomly
// ************************************************************************************************
Character.prototype.bloodSplatter = function () {
	var indexList = gs.getIndexInRadius(this.tileIndex, 1.5);
	indexList = indexList.filter(index => gs.getTile(index).type.passable && !gs.getTile(index).type.isPit);
	indexList = indexList.filter(index => !gs.getObj(index));
	
	if (indexList.length > 0) {
		gs.createObject(util.randElem(indexList), this.type.bloodTypeName);
	}
};

// IS_HOSTILE_TO_ME:
// ************************************************************************************************
Character.prototype.isHostileToMe = function (character) {
	if (character === this) {
		return false;
	}
	else if (this.isConfused && character.faction !== FACTION.NEUTRAL && character.faction !== FACTION.DESTRUCTABLE) {
		return true;
	}
	else if (this.faction === FACTION.PLAYER && character.faction === FACTION.HOSTILE) {
		return true;
	}
	else if (this.faction === FACTION.HOSTILE && character.faction === FACTION.PLAYER) {
		return true;
	}
	else {
		return false;
	}
};

// CAN_SEE_CHARACTER:
// ************************************************************************************************
Character.prototype.canSeeCharacter = function (character) {
	return (gs.getTile(gs.toTileIndex(character.body.position)).visible && (!character.isHidden || this.isTelepathic))
		|| gs.distance(character.tileIndex, this.tileIndex) < 1.5;
};

// UPDATE_CHARACTER_FRAMES:
// ************************************************************************************************
gs.updateCharacterFrames = function () {
    for (let i = 0; i < this.characterList.length; i += 1) {
        if (this.characterList[i].isAlive) {
            this.characterList[i].updateFrame();
        }
    }
};

// CHARACTER_DESC:
// ************************************************************************************************
gs.characterDesc = function (character) {
	var str = '';
	
	if (character === this.pc) {
		str = 'Player\n';
		str += 'Click yourself to wait a turn. Shift + click yourself to rest until full HP or full MP.';
		return str;
	}
	
	// Name:
	if (character.name) {
		str += this.capitalSplit(character.name) + '\n';
	} else {
		str += character.type.niceName + '\n';
	}
	
	// Level:
	str += 'Level: ' + character.level + '\n';
	
	// HP:
	str += 'HP: ' + character.currentHp + '/' + character.maxHp + '\n';
	
	// size:
	str += 'Size: ' + ['SMALL', 'MEDIUM', 'LARGE'][character.size] + '\n';

	// Defense:
	DAMAGE_TYPES.forEach(function (type) {
		if (character.resistance[type] > 0) {
			str += type + ' Resistant\n';
		}
		else if (character.resistance[type] < 0) {
			str += 'Vulnerable to ' + type + '\n';
		}
	}, this);
	
	// Reflective:
	if (character.reflection > 0) {
		str += 'Reflective\n';
	}
	
	str += 'Spot Chance: ' + gs.toPercentStr(character.detectPlayerPercent()) + '\n';
	
	
	return str;
};

// ATTACK_RESULT:
// When dealing physical damage, call this function to determine if the attack actually landed.
// Will return {'HIT', 'MISS', 'CRITICAL'}
// This should be called before takeDamage is called (so that missed projectilces can continue on their course)
// type = 'Range', 'Melee'
// ************************************************************************************************
Character.prototype.attackResult = function (attacker, type) {
    var result = game.rnd.frac(), critChance, blockChance, evasionChance;
	
	if (type !== 'Range' && type !== 'Melee') {
		throw 'Invalid attack type: ' + type;
	}
	
	if (type === 'Melee') {
		critChance = CRITICAL_PERCENT;
		blockChance = this.parryChance;
	} 
	else if (type === 'Range') {
		critChance = CRITICAL_PERCENT;
		blockChance = this.blockChance;
	}
	else {
		throw 'Invalid attackType: ' + type;
	}
	
	evasionChance = this.dodgePercent();
    
	if (this === gs.pc) {
		critChance = 0;
	}
	
	if (result < blockChance) {
		if (type === 'Melee') {
			return 'PARRY';
		}
		else {
			return 'BLOCK';
		}
	}
    else if (result <= evasionChance + blockChance) {
        return 'MISS';
    }
	else if (result <= evasionChance + blockChance + critChance) {
        return 'CRITICAL';
    }
	else {
        return 'HIT';
    }
};

// MITIGATE_DAMAGE:
// ************************************************************************************************
Character.prototype.mitigateDamage = function (amount, damageType) {
	// 'None' damageType is unmitigatable
	if (damageType === 'None') {
		return amount;
	}
	
	// Protection Mitigation:
	if (damageType === 'Physical') {
		amount -= util.randInt(0, this.protection);
	}
	// Resistance Mitigation
	else if (this.resistance[damageType] > 0) {
		let maxMitigate = amount * RESISTANCE_MULTIPLIER[this.resistance[damageType]];
		amount -= (util.randInt(1, maxMitigate) + util.randInt(1, maxMitigate)) / 2;
	}
	// Resistance Vulnerability:
	else if (this.resistance[damageType] < 0) {
		let maxVuln = amount * RESISTANCE_MULTIPLIER[Math.abs(this.resistance[damageType])];
		amount += (util.randInt(1, maxVuln) + util.randInt(1, maxVuln)) / 2;
	}
    	
    // Round and cap:
    amount = Math.round(amount);
    amount = Math.max(1, amount); 
    
	return amount;
};

// MELEE_ATTACK:
// A general purpose function whenever one character attacks another with melee
// Handles MISS, HIT and CRITICAL 
// Handles damage shields
// flags: {effectFunc, alwaysCrit, killer, neverMiss, knockBack, isSpecialAttack}
// effectFunc: has arguments (defender, damage)
// ************************************************************************************************
gs.meleeAttack = function (attacker, tileIndex, damage, flags = {}) {
    var attackResult, isCrit, damageAmount, knockBack, defender, animPos, animNormal;
	
	
	// Bounce and face:
	attacker.body.faceTileIndex(tileIndex);
	attacker.body.bounceTowards(tileIndex);
	
	
	defender = gs.getChar(tileIndex);
	
	

	// In case there is no character at the target tileIndex:
	if (!defender) {
		return;
	}
	
	// Hit Effect:
	animNormal = gs.getNormal(defender.sprite.position, attacker.sprite.position);
	animPos = {x: defender.sprite.position.x + animNormal.x * 15, y: defender.sprite.position.y + animNormal.y * 15};
	gs.createAnimEffect(animPos, 'Hit');
	
	attackResult = defender.attackResult(attacker, 'Melee');
	isCrit = attackResult === 'CRITICAL' || flags.alwaysCrit || attacker.alwaysCrit;
	knockBack = attacker.knockBackOnHit || flags.knockBack || 0;

	// Unaware crit:
	if (attacker === gs.pc && !defender.isAgroed) {
		damage = Math.round(damage + damage * 0.08 * gs.pc.stealth);
		isCrit = true;
	}

	// Reposte (ShieldsUp):
	if (defender.statusEffects.has('ShieldsUp')) {
		gs.meleeAttack(defender, attacker.tileIndex, defender.weaponDamage(), {neverMiss: true, isSpecialAttack: true});
		defender.popUpText('Blocked!', '#ffffff');
	}
	// Reposte (Blade Dancers):
	else if (defender.canReposteAttacker(attacker) && util.frac() <= 0.5) {
		gs.meleeAttack(defender, attacker.tileIndex, defender.abilities.abilityInSlot(0).type.attributes.damage.value(defender), {neverMiss: true});
		defender.popUpText('Reposte!', '#ffffff');
	}
	// Block:
	else if (attackResult === 'PARRY' && !isCrit) {
		defender.popUpText('Parry', '#ffffff');
	}
	// Miss:
	else if (attackResult === 'MISS' && !isCrit && !flags.neverMiss) {
		defender.popUpText('Miss', '#ffffff');
	}
	// Hit or Critical:  
	else {
		// Damage:
		damageAmount = defender.takeDamage(damage, 'Physical', {
			killer: attacker,
			isCrit: isCrit,
			isSpecialAttack: flags.isSpecialAttack
		});

		// Vampire:
		if (attacker.meleeLifeTap && !defender.type.noBlood) {
			attacker.healHp(attacker.meleeLifeTap);
		}

		// Damage Shield:
		if (defender.damageShield > 0) {
			if (attacker !== gs.pc || gs.pc.inventory.getWeapon().type.effect !== gs.weaponEffects.PoleArm) {
				attacker.takeDamage(defender.damageShield, 'None', {killer: defender, neverCrit: true});
			}
		}

		// Inferno:
		if (defender.hasInferno > 0) {
			gs.createFire(attacker.tileIndex, INFERNO_RING_DAMAGE, {killer: defender});
		}

		// Thunder:
		if (defender.hasThunder > 0) {
			gs.createShock(attacker.tileIndex, INFERNO_RING_DAMAGE, {killer: defender});
		}

		// Knockback:
		if (knockBack > 0 && defender.isAlive) {
			defender.body.applyKnockBack(this.getNormal(attacker.tileIndex, defender.tileIndex), knockBack);
		}

		// Ice Knockback:
		if (gs.getObj(defender.tileIndex, obj => obj.type.isSlippery) && defender.isAlive && !defender.isFlying) {
			defender.body.applyKnockBack(this.getNormal(attacker.tileIndex, defender.tileIndex), 1);
		}

		// Corrision:
		if (defender.type.isCorrosive && attacker === gs.pc && util.frac() < CORRODE_PERCENT) {
			gs.pc.corrodeWeapon();
		}

		// Additional Effect:
		if (flags.effectFunc && defender.isAlive) {
			flags.effectFunc(defender, attacker, damageAmount);
		}

	}
};

// CAN_REPOSTE_ATTACKER:
// ************************************************************************************************
Character.prototype.canReposteAttacker = function (attacker) {
	return this.type.reposteAttacks
		&& !this.shouldSkipTurn()
		&& (attacker !== gs.pc || gs.pc.inventory.getWeapon().type.effect !== gs.weaponEffects.PoleArm);
};

// Overwritten in Player type
Character.prototype.getActiveSummonList = function () {
	return [];
};

// GET_CHARACTER_WITH_ID:
// Returns the character with the unique ID or null if that character no longer exists.
// It is entirely possible for the character to no longer exist (for example he is dead)
// ************************************************************************************************
gs.getCharWithID = function (id) {
	if (typeof id !== 'number') {
		throw 'getCharWithID: id is not a number';
	}
	
	for (let i = 0; i < this.characterList.length; i += 1) {
		if (this.characterList[i].id === id && this.characterList[i].isAlive) {
			return this.characterList[i];
		}
	}
	
	return null;
};

// NUM_VISIBLE_NPCS:
// Count the number of hostile NPCs visible to the player
// ************************************************************************************************
gs.numVisibleNPCs = function () {
	var count = 0;
	
	gs.getAllNPCs().forEach(function (npc) {
		if (npc.isAlive && npc.faction === FACTION.HOSTILE && !npc.isHidden && gs.pc.canSeeCharacter(npc)) {
			count += 1;
		}
	}, this);
	
	return count;
};

// SHOUT:
// A global shout function that can be used to agro NPCs
// ************************************************************************************************
gs.shout = function (tileIndex, faction, missTurn = false) {
	var shoutRange;
	
	gs.getAllNPCs().forEach(function (npc) {
		// Sleeping enemies:
		if (npc.statusEffects.has('DeepSleep')) {
			shoutRange = 0;
		}
		else if (npc.isAsleep) {
			shoutRange = SHOUT_RANGE / 2;
		} 
		else {
			shoutRange = SHOUT_RANGE;
		}

		if (!npc.isAgroed
			&& !npc.type.neverRespondToShout
			&& npc.faction === faction
			&& gs.distance(tileIndex, npc.tileIndex) <= shoutRange
			&& gs.isRayClear(tileIndex, npc.tileIndex)) {
			
			npc.agroPlayer();
			npc.waitTime = 100;
		}
	
	}, this);
};

// GET_ALL_NPCS:
// ************************************************************************************************
gs.getAllNPCs = function () {
	return this.characterList.filter(char => char.isAlive && char !== gs.pc);
};

// GET_ALL_ALLIES:
// ************************************************************************************************
gs.getAllAllies = function () {
	return this.characterList.filter(char => char !== this.pc && char.faction === FACTION.PLAYER);
};

// AGROED_HOSTILE_LIST:
// ************************************************************************************************
gs.agroedHostileList = function () {
	return gs.characterList.filter(char => char.isAlive && char.faction === FACTION.HOSTILE && char.isAgroed);
};
/*global game, gs, console, util*/
/*global FACTION, DAMAGE_TYPES*/
/*global NPC, NPC_INITIAL_HP, NPC_HP_PER_LEVEL, NPC_INITIAL_DAMAGE, NPC_DAMAGE_PER_LEVEL*/
/*global STANDARD_DROP_PERCENT, LOS_DISTANCE, ABILITY_RANGE, CHARACTER_SIZE*/
/*global DANGER_LEVEL*/
/*jshint white: true, laxbreak: true, esversion: 6*/
'use strict';

// CREATE_NPC_TYPES:
// ************************************************************************************************
gs.createNPCTypes = function () {
	this.npcTypes = {
		// THE_UPPER_DUNGEON:
		// ****************************************************************************************
		Rat: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'LOW'}}
			],
			moveSpeed: 'MEDIUM',
			maxHp: 5,
			isRandomMover: true,
			size: CHARACTER_SIZE.SMALL,
		},
		
		Bat: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'LOW'}}
			],
			moveSpeed: 'FAST',
			maxHp: 2,
			isRandomMover: true,
			isFlying: true,
			size: CHARACTER_SIZE.SMALL,
		},
		
		RatNest: {
			abilityTypes: [
				{typeName: 'SpawnNPC', stats: {numSpawned: 2, coolDown: 10, npcTypeName: 'Rat'}}
			],
			moveSpeed: 'NONE',
			hitPointType: 'MHIGH',
			maxMp: 5,
			
			isUnstableImmune: true,
			neverSleep: true,
			neverRespawn: true,
			neverRun: true,
			noBlood: true,
			noRegen: true,
			neverSpawnInZoo: true,
		},
		
		GoblinWarrior: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MEDIUM'}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			size: CHARACTER_SIZE.SMALL,
		},
		
		GoblinArcher: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MLOW', projectileTypeName: 'Dart'}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			isKiter: true,
			size: CHARACTER_SIZE.SMALL,
		},
		
		GoblinBrute: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MHIGH'}},
			],
			moveSpeed: 'SLOW',
			hitPointType: 'HIGH',
		},
		
		GoblinFireMage: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MHIGH', coolDown: 5, projectileTypeName: 'FireArrow', shootEffect: 'FireShoot'}},
				{typeName: 'OrbOfFire', stats: {damageType: 'HIGH', coolDown: 10, mana: 0}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MLOW',
			isKiter: true,
			size: CHARACTER_SIZE.SMALL,
			resistance: {Fire: 1},
		},
		
		GoblinStormMage: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MHIGH', coolDown: 5, projectileTypeName: 'Spark', shootEffect: 'ElectricShoot'}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MLOW',
			isKiter: true,
			size: CHARACTER_SIZE.SMALL,
			resistance: {Shock: 1},
		},
		
		Centipede: {
			abilityTypes: [
				{typeName: 'PoisonAttack', stats: {damageType: 'MEDIUM'}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			size: CHARACTER_SIZE.SMALL,
		},
		
		GoblinShaman: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MHIGH', coolDown: 5, projectileTypeName: 'IceArrow', shootEffect: 'ColdShoot'}},
				{typeName: 'Heal', stats: {coolDown: 6, healPercent: 0.25}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MLOW',
			isKiter: true,
			size: CHARACTER_SIZE.SMALL,
		},
		
		// THE_UPPER_DUNGEON_UNIQUES:
		// ****************************************************************************************
		TheVampireBat: {
			abilityTypes: [
				{typeName: 'VampireAttack', stats: {damageType: 'MEDIUM'}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'HIGH',
			isRandomMover: true,
			isFlying: true,
			isUnique: true,
			size: CHARACTER_SIZE.SMALL,
		},
		
		TheRatPiper: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MLOW', projectileTypeName: 'Dart'}},
				{typeName: 'SummonMonsters', stats: {npcTypeName: 'Rat', num: 4, coolDown: 10}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'HIGH',
			isKiter: true,
			isUnique: true,
		},
		
		TheBridgeGuardian: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MHIGH'}},
			],
			moveSpeed: 'SLOW',
			hitPointType: 'MHIGH',
			updateTurn: this.npcUpdateTurn.Regenerate,
			resistance: {Fire: -1},
			isUnique: true,
		},
		
		// THE_ORC_FORTRESS:
		// ****************************************************************************************
		Wolf: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'LOW'}},
			],
			moveSpeed: 'FAST',
			hitPointType: 'LOW',
		},
		
		WolfKennel:	{
			abilityTypes: [
				{typeName: 'SpawnNPC', stats: {numSpawned: 2, coolDown: 8, npcTypeName: 'Wolf'}}
			],
			moveSpeed: 'NONE',
			hitPointType: 'MEDIUM',
			maxMp: 5,
			neverSleep: true,
			neverRespawn: true,
			noBlood: true,
			neverRun: true,
			neverSpawnInZoo: true,
			noRegen: true,
			
		},
		
		OrcWarrior: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MEDIUM'}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
		},
		
		OrcArcher: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MLOW', projectileTypeName: 'Dart', range: 6.0}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			isKiter: true,
		},
		
		Ogre: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MHIGH'}},
				{typeName: 'Berserk', stats: {coolDown: 100, mana: 0}}
			],
			moveSpeed: 'SLOW',
			hitPointType: 'HIGH',
			size: CHARACTER_SIZE.LARGE,
		},
		
		OgreShaman: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MHIGH', coolDown: 5, projectileTypeName: 'IceArrow', shootEffect: 'ColdShoot'}},
				{typeName: 'Heal', stats: {coolDown: 6, healPercent: 0.5}}
			],
			moveSpeed: 'SLOW',
			hitPointType: 'MHIGH',
			isKiter: true,
			size: CHARACTER_SIZE.LARGE,
		},
		
		OrcFireMage: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MHIGH', coolDown: 4, projectileTypeName: 'FireArrow', shootEffect: 'FireShoot'}},
				{typeName: 'OrbOfFire', stats: {damageType: 'HIGH', coolDown: 10, mana: 0}},
				{typeName: 'WallOfFire', stats: {damageType: 'MLOW', coolDown: 20, mana: 0}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MLOW',
			isKiter: true,
			resistance: {Fire: 1},
		},
		
		OrcStormMage: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MHIGH', coolDown: 4, projectileTypeName: 'Spark', shootEffect: 'ElectricShoot'}},
				{typeName: 'LightningBolt',	stats: {damageType: 'MHIGH', coolDown: 8, mana: 0}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MLOW',
			isKiter: true,
			resistance: {Shock: 1},
		},
		
		OrcPriest: {
			abilityTypes: [
				{typeName: 'Smite', stats: {damageType: 'HIGH', coolDown: 4}},
				{typeName: 'Heal', stats: {coolDown: 6, healPercent: 0.5}},
				{typeName: 'Haste', stats: {coolDown: 10}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MLOW',
			isKiter: true,
		},
		
		CorrosiveSlime: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MEDIUM'}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			isCorrosive: true,
			noRegen: true,
			noBlood: true,
			resistance: {Toxic: 1},
			gasImmune: true,
		},
		
		AcidicSlime: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MEDIUM'}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			noRegen: true,
			damageShield: 5,
			noBlood: true,
			resistance: {Toxic: 1},
			gasImmune: true,
		},
		
		OrcSummoner: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MHIGH', coolDown: 4, projectileTypeName: 'MagicMissile', shootEffect: 'MagicShoot'}},
				{typeName: 'SummonMonsters', stats: {npcTypeName: 'SpectralBlade', num: 4, coolDown: 20}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MLOW',
			isKiter: true,
		},
		
		Ballista: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MHIGH', range: LOS_DISTANCE, projectileTypeName: 'Dart'}}
			],
			moveSpeed: 'NONE',
			hitPointType: 'HIGH',
			dontFace: true,
			neverRun: true,
			neverSpawnInZoo: true,
			neverRespawn: true,
			bloodTypeName: 'Oil',
			noRegen: true,
			neverSleep: true,
			rotateAim: true,
			
		},
		
		// THE_ORC_FORTRESS_UNIQUES:
		// ****************************************************************************************
		KingMonRacar: {
			niceName: "Mon'Racar The Orc King",
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MHIGH'}},
				{typeName: 'Berserk', stats: {coolDown: 100, mana: 0}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'HIGH',
			size: CHARACTER_SIZE.LARGE,
			isUnique: true,
		},
		
		// THE_DARK_TEMPLE:
		// ****************************************************************************************
		DarkElfWarden: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MEDIUM'}},
				{typeName: 'SealDoors', stats: {coolDown: 40}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',	
		},
		
		DarkElfSentinel: {
			abilityTypes: [
				{typeName: 'ProjectileKite', stats: {damageType: 'MLOW', projectileTypeName: 'Dart', range: 7.0}},
				{typeName: 'WatchPlayer', stats: {coolDown: 20}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			isKiter: true,
		},
		
		DarkElfPyromancer: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MHIGH', coolDown: 4, projectileTypeName: 'FireArrow', shootEffect: 'FireShoot'}},
				{typeName: 'FireStorm', stats: {damageType: 'HIGH', coolDown: 20, mana: 0}},
				{typeName: 'WallOfFire', stats: {damageType: 'MLOW', coolDown: 20, mana: 0}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MLOW',
			isKiter: true,
			resistance: {Fire: 1},
		},
		
		DarkElfStormologist: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MHIGH', coolDown: 4, projectileTypeName: 'Spark', shootEffect: 'ElectricShoot'}},
				{typeName: 'LightningBolt',	stats: {damageType: 'MHIGH', coolDown: 8, mana: 0}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MLOW',
			isKiter: true,
			resistance: {Shock: 1},
		},
		
		DarkElfPriest: {
			abilityTypes: [
				{typeName: 'Smite', stats: {damageType: 'HIGH', coolDown: 3}},
				{typeName: 'Heal', stats: {coolDown: 6, healPercent: 0.75}},
				{typeName: 'Haste', stats: {coolDown: 10}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MLOW',
			isKiter: true,
		},
		
		DarkElfSummoner: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MHIGH', coolDown: 3, projectileTypeName: 'MagicMissile', shootEffect: 'MagicShoot'}},
				{typeName: 'SummonMonsters', stats: {npcTypeName: 'GreaterSpectralBlade', num: 4, coolDown: 20}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MLOW',
			isKiter: true,
		},
		
		EvilEye: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MHIGH', coolDown: 3, projectileTypeName: 'MagicMissile', shootEffect: 'MagicShoot'}},
				{typeName: 'NPCConfusion', stats: {coolDown: 20}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MLOW',
			isKiter: true,
			isFlying: true,
		},
		
		// THE_VAULT_OF_YENDOR:
		// ****************************************************************************************
		HellHound: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'LOW'}},
			],
			moveSpeed: 'FAST',
			hitPointType: 'LOW',
			onHit: this.npcOnHit.FireBlink,
			flamingCloudImmune: true,
			resistance: {Fire: 1},
		},
		
		DrachnidWarrior: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MEDIUM'}},
				{typeName: 'SpiderWeb',	stats: {coolDown: 100, range: 5.0}}
			],
			moveSpeed: 'FAST',
			hitPointType: 'MEDIUM',
		},
		
		DrachnidArcher: {
			abilityTypes: [
				{typeName: 'ProjectileKite', stats: {damageType: 'MLOW', projectileTypeName: 'Dart', range: 7.0}},
				{typeName: 'SpiderWeb',	stats: {coolDown: 100, range: 5.0}}
			],
			moveSpeed: 'FAST',
			hitPointType: 'MEDIUM',
			isKiter: true,
		},
		
		FleshGolem: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MEDIUM'}},
				{typeName: 'Constrict', stats: {coolDown: 10}},
				{typeName: 'Berserk', stats: {coolDown: 100, mana: 0}}
			],
			moveSpeed: 'SLOW',
			hitPointType: 'HIGH',
			neverSleep: true,
			noRegen: true,
			size: CHARACTER_SIZE.LARGE,
		},
		
		DarkElfBladeDancer: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MEDIUM'}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			reposteAttacks: true
		},
		
		CrystalGolem: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MEDIUM'}},
				{typeName: 'Berserk', stats: {coolDown: 100, mana: 0}}
			],
			moveSpeed: 'SLOW',
			hitPointType: 'MHIGH',
			noBlood: true,
			noRegen: true,
			reflection: 15,
			neverSleep: true,
			size: CHARACTER_SIZE.LARGE,
			
		},
		
		Succubus: {
			abilityTypes: [
				{typeName: 'VampireAttack', stats: {damageType: 'MEDIUM'}},
				{typeName: 'NPCCharm', stats: {coolDown: 20}},
				
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
		},
		
		/*
		Demonologist: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MHIGH', coolDown: 4, projectileTypeName: 'MagicMissile'}},
				{typeName: 'SummonMonsters', stats: {npcTypeName: 'IceImp', num: 1, coolDown: 20}},
				{typeName: 'SummonMonsters', stats: {npcTypeName: 'FireImp', num: 1, coolDown: 20}},
				{typeName: 'SummonMonsters', stats: {npcTypeName: 'StormImp', num: 1, coolDown: 20}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MLOW',
			isKiter: true,
		},
		
		*/
		
		
		// THE_SUNLESS_DESERT:
		// ****************************************************************************************
		Scarab: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'LOW'}}
			],
			moveSpeed: 'MEDIUM',
			maxHp: 8,
			isRandomMover: true,
			size: CHARACTER_SIZE.SMALL,
		},
		
		SpittingViper: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MLOW', projectileTypeName: 'Acid'}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			isKiter: true,
		},
		
		TrapDoorSpider: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MEDIUM'}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			neverWander: true,
			startHidden: true,
			ambushDistance: 3,
			neverSpawnInZoo: true,
			neverRespondToShout: true,
		},
		
		Scorpion: {
			abilityTypes: [
				{typeName: 'PoisonAttack', stats: {damageType: 'MEDIUM'}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
		},
		
		SunFlower: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MHIGH', coolDown: 3, range: LOS_DISTANCE, projectileTypeName: 'FireArrow', shootEffect: 'FireShoot'}},
				{typeName: 'WallOfFire', stats: {damageType: 'MLOW', coolDown: 20, mana: 0}}
			],
			moveSpeed: 'NONE',
			hitPointType: 'MHIGH',
			neverRun: true,
			neverSpawnInZoo: true,
			noRegen: true,
			neverSleep: true,
			resistance: {Fire: 1, Cold: -1},
			
		},
		
		Goat: {
			abilityTypes: [
				{typeName: 'TrampleAttack', stats: {damageType: 'MEDIUM'}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
		},
		
		Mummy: {
			abilityTypes: [
				{typeName: 'DrainingAttack', stats: {damageType: 'MHIGH'}},
				{typeName: 'Berserk', stats: {coolDown: 100, mana: 0}}
			],
			moveSpeed: 'SLOW',
			hitPointType: 'HIGH',
			resistance: {Fire: -1},
			
		},
		
		MummyPriest: {
			abilityTypes: [
				{typeName: 'Smite', stats: {damageType: 'HIGH', coolDown: 4}},
				{typeName: 'Heal', stats: {coolDown: 6, healPercent: 0.5}},
				{typeName: 'Haste', stats: {coolDown: 10}},
			],
			moveSpeed: 'SLOW',
			hitPointType: 'MEDIUM',
			isKiter: true,
			resistance: {Fire: -1},
			
		},
		
		CylomarTheAncientPyromancer: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MHIGH', coolDown: 4, projectileTypeName: 'FireArrow', shootEffect: 'FireShoot'}},
				{typeName: 'FireStorm', stats: {damageType: 'HIGH', coolDown: 20, mana: 0}},
				{typeName: 'WallOfFire', stats: {damageType: 'MLOW', coolDown: 20, mana: 0}}
			],
			moveSpeed: 'SLOW',
			hitPointType: 'MEDIUM',
			isKiter: true,
			resistance: {Fire: -1},
			isUnique: true
		},
		
		// THE_UNDER_GROVE:
		// ****************************************************************************************
		Jaguar: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MEDIUM'}},
			],
			moveSpeed: 'FAST',
			hitPointType: 'MEDIUM',
		},
		
		Spider: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MEDIUM'}},
				{typeName: 'SpiderWeb',	stats: {coolDown: 100}}
			],
			moveSpeed: 'MEDIUM',
			maxHp: 15, // hitPointType: 'MEDIUM', 20
			isUnstableImmune: true,
		},
		
		SpiderNest:	{
			abilityTypes: [
				{typeName: 'SpawnNPC', stats: {numSpawned: 1, coolDown: 8, npcTypeName: 'Spider'}}
			],
			moveSpeed: 'NONE',
			hitPointType: 'MEDIUM',
			maxMp: 5,
			isUnstableImmune: true,
			neverSleep: true,
			neverRun: true,
			noBlood: true,
			neverRespawn: true,
			neverSpawnInZoo: true,
			noRegen: true,
			
		},
		
		PoisonSpider: {
			abilityTypes: [
				{typeName: 'PoisonAttack', stats: {damageType: 'MEDIUM'}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			isUnstableImmune: true,
		},
		
		CentaurArcher: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MLOW', projectileTypeName: 'Dart' , range: 6.0}}
			],
			moveSpeed: 'FAST',
			maxHp: 16, // hitPointType: 'MEDIUM', 21
			isKiter: true,
		},
		
		CentaurWarrior: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MLOW'}},
				{typeName: 'TrampleAttack', stats: {damageType: 'MEDIUM'}},
			],
			moveSpeed: 'FAST',
			maxHp: 18, //hitPointType: 'MEDIUM', 21
		},
		
		Elephant: {
			abilityTypes: [
				{typeName: 'TrampleAttack', stats: {damageType: 'MHIGH'}},
			],
			moveSpeed: 'SLOW',
			hitPointType: 'HIGH',
			size: CHARACTER_SIZE.LARGE,
		},
		
		TheQueenSpider: {
			abilityTypes: [
				{typeName: 'PoisonAttack', stats: {damageType: 'MEDIUM'}},
				{typeName: 'SpawnNPC', stats: {numSpawned: 1, coolDown: 6, mana: 1, npcTypeName: 'SpiderEgg'}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'HIGH',
			isUnique: true,
			maxMp: 5,
		},
		
		GiantAnt: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MLOW'}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MLOW',
			isRandomMover: true,
		},
		
		GiantBee: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MLOW'}}
			],
			moveSpeed: 'FAST',
			hitPointType: 'MLOW',
			isFlying: true,
		},
		
		// THE_SWAMP:
		// ****************************************************************************************
		Pirahna: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'LOW'}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'LOW',
			neverWander: true,
			startHidden: true,
			ambushDistance: 5.0,
			spawnInWater: true,
			isAquatic: true,
			isSwimming: true,
			neverRun: true,
			neverSpawnInZoo: true,
		},
		
		PoisonViper: {
			abilityTypes: [
				{typeName: 'PoisonAttack', stats: {damageType: 'MEDIUM'}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
		},
		
		BlinkFrog: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MLOW'}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MLOW',
			onHit: this.npcOnHit.BlinkFrog,
			isAquatic: true,
		},
		
		Mosquito: {
			abilityTypes: [
				{typeName: 'VampireAttack', stats: {damageType: 'MEDIUM'}},
			],
			moveSpeed: 'FAST',
			hitPointType: 'MEDIUM',
			isFlying: true,
		},
		
		SpinyFrog : {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MEDIUM'}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			damageShield: 2,
			isAquatic: true,
		},
		
		ElectricEel: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MEDIUM', coolDown: 3, projectileTypeName: 'Spark', shootEffect: 'ElectricShoot'}},
			],
			resistance: {Shock: 1},
			moveSpeed: 'MEDIUM',
			hitPointType: 'MLOW',
			neverWander: true,
			startHidden: true,
			ambushDistance: 5.0,
			spawnInWater: true,
			isAquatic: true,
			isSwimming: true,
			neverRun: true,
			neverSpawnInZoo: true,
			neverRespawn: true,
		},
		
		BullFrog: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MEDIUM'}},
				{typeName: 'SlowCharge', stats: {damageType: 'HIGH'}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MHIGH',
		},
		
		SnappingTurtle: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MEDIUM'}},
				{typeName: 'HideInShell'}
			],
			moveSpeed: 'SLOW',
			hitPointType: 'MHIGH',
		},
		
		// THE_SWAMP_UNIQUES:
		// ****************************************************************************************
		KasicTheMosquitoPrince: {
			abilityTypes: [
				{typeName: 'VampireAttack', stats: {damageType: 'MEDIUM'}},
				{typeName: 'LifeSpike', stats: {damageType: 'LOW', mana: 0, coolDown: 10}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			isFlying: true,
			isUnique: true
		},
		
		// THE_IRON_FORTRESS:
		// ****************************************************************************************
		ClockworkRat: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'LOW'}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'LOW',
			noRegen: true,
			neverRun: true,
			bloodTypeName: 'Oil',
			isRandomMover: true,
			neverSleep: true,
			size: CHARACTER_SIZE.SMALL,
			
		},
		
		Bombomber: {
			abilityTypes: [
				{typeName: 'Suicide'}
			],
			onDeath: {typeName: 'Explode', stats: {damageType: 'MEDIUM'}},
			moveSpeed: 'MEDIUM',
			hitPointType: 'LOW',
			noBlood: true,
			neverRun: true,
			noRegen: true,
			size: CHARACTER_SIZE.SMALL,
			
		},
		
		ClockworkWarrior: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MEDIUM'}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			neverRun: true,
			bloodTypeName: 'Oil',
			noRegen: true,
			neverSleep: true,
			
		},
		
		ClockworkArcher: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MLOW', projectileTypeName: 'Dart', range: 6.0}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			isKiter: true,
			bloodTypeName: 'Oil',
			noRegen: true,
			neverSleep: true,
			
		},
		
		ClockworkFactory: {
			abilityTypes: [
				{typeName: 'SpawnNPC', stats: {numSpawned: 3, coolDown: 10, npcTypeName: 'ClockworkRat'}}
			],
			moveSpeed: 'NONE',
			hitPointType: 'MHIGH',
			maxMp: 5,
			
			isUnstableImmune: true,
			neverSleep: true,
			neverRespawn: true,
			neverRun: true,
			noBlood: true,
			noRegen: true,
			neverSpawnInZoo: true,
			
		},
		
		GoblinBomber: {
			abilityTypes: [
				{typeName: 'ThrowBomb', stats: {damageType: 'HIGH', coolDown: 4, range: 5}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			isKiter: true,
		},
		
		ClockworkPyro: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MHIGH', coolDown: 5, projectileTypeName: 'FireArrow', shootEffect: 'FireShoot'}},
				{typeName: 'ProjectileAttack', stats: {coolDown: 10, projectileTypeName: 'Oil'}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			isKiter: true,
			resistance: {Fire: 1},
			
		},
		
		ClockworkRhino: {
			abilityTypes: [
				{typeName: 'TrampleAttack', stats: {damageType: 'MHIGH'}},
				{typeName: 'SlowCharge', stats: {damageType: 'HIGH'}}
			],
			moveSpeed: 'SLOW',
			hitPointType: 'HIGH',
			noRegen: true,
			neverSleep: true,
			size: CHARACTER_SIZE.LARGE,
			
		},
		
		
		
		
		
		// THE_ARCANE_TOWER:
		// ****************************************************************************************
		ManaViper: {
			abilityTypes: [
				{typeName: 'ManaDrainAttack', stats: {damageType: 'MEDIUM'}},
			],
			moveSpeed: 'FAST',
			hitPointType: 'MEDIUM',
		},
			
		FireImp: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MEDIUM', coolDown: 4, projectileTypeName: 'FireArrow', shootEffect: 'FireShoot'}},
				{typeName: 'OrbOfFire', stats: {damageType: 'HIGH', coolDown: 10, mana: 0}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MLOW',
			isFlying: true,
			isKiter: true,
			onHit: this.npcOnHit.ImpBlink,
			size: CHARACTER_SIZE.SMALL,
			resistance: {Fire: 1},
			
		},
		
		StormImp: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MEDIUM', coolDown: 4, projectileTypeName: 'Spark', shootEffect: 'ElectricShoot'}},
				{typeName: 'LightningBolt',	stats: {damageType: 'MHIGH', coolDown: 10, mana: 0}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MLOW',
			isFlying: true,
			isKiter: true,
			onHit: this.npcOnHit.ImpBlink,
			size: CHARACTER_SIZE.SMALL,
			resistance: {Shock: 1},
			
		},
		
		IceImp: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MEDIUM', coolDown: 4, projectileTypeName: 'IceArrow', shootEffect: 'ColdShoot'}},
				{typeName: 'SummonIceBomb', stats: {damageType: 'HIGH', coolDown: 10}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MLOW',
			isFlying: true,
			isKiter: true,
			onHit: this.npcOnHit.ImpBlink,
			size: CHARACTER_SIZE.SMALL,
			resistance: {Cold: 1},
		},
		
		StoneGolem: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MHIGH'}},
				{typeName: 'Berserk', stats: {coolDown: 100, mana: 0}}
			],
			moveSpeed: 'SLOW',
			hitPointType: 'HIGH',
			noBlood: true,
			noRegen: true,
			neverSleep: true,
			size: CHARACTER_SIZE.LARGE,
			
		},
		
		FireStaffTurret: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MHIGH', coolDown: 5, range: LOS_DISTANCE, projectileTypeName: 'FireArrow', shootEffect: 'FireShoot'}},
				{typeName: 'OrbOfFire', stats: {damageType: 'HIGH', coolDown: 10, mana: 0}}
			],
			moveSpeed: 'NONE',
			hitPointType: 'HIGH',
			dontFace: true,
			noBlood: true,
			neverRun: true,
			neverSpawnInZoo: true,
			neverRespawn: true,
			noRegen: true,
			neverSleep: true,
			rotateAim: true,
			
		},
		
		StormStatue: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MHIGH', coolDown: 4, range: LOS_DISTANCE, projectileTypeName: 'Spark', shootEffect: 'ElectricShoot'}},
				{typeName: 'LightningBolt',	stats: {damageType: 'MHIGH', coolDown: 8, range: LOS_DISTANCE, mana: 0}},
				{typeName: 'Buffet', stats: {coolDown: 10}},
			],
			moveSpeed: 'NONE',
			hitPointType: 'MHIGH',
			noBlood: true,
			neverRun: true,
			neverSpawnInZoo: true,
			noRegen: true,
			neverSleep: true,
			resistance: {Shock: 1},
			
		},
		
		// THE_CRYPT:
		// ****************************************************************************************
		Maggot: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'LOW'}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'LOW',
			
			isRandomMover: true,
			size: CHARACTER_SIZE.SMALL,
			isUnstableImmune: true,
		},
		
		RottingCorpse: {
			abilityTypes: [
				{typeName: 'SpawnNPC', stats: {numSpawned: 3, coolDown: 5, npcTypeName: 'Maggot'}}
			],
			moveSpeed: 'NONE',
			hitPointType: 'MHIGH',
			maxMp: 5,
			isUnstableImmune: true,
			neverSleep: true,
			neverRespawn: true,
			neverRun: true,
			neverSpawnInZoo: true,
			noRegen: true,
			
		},
		
		SkeletonWarrior: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MEDIUM'}},
			],
			onDeath: {typeName: 'SkeletonCorpse'},
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			noBlood: true,
			neverRun: true,
			noRegen: true,
			neverSleep: true,
			resistance: {Toxic: 1},
			effectImmune: ['InfectiousDisease']
			
		},
		
		SkeletonArcher: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MLOW', projectileTypeName: 'Dart', range: 7.0}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			isKiter: true,
			onDeath: {typeName: 'SkeletonCorpse'},
			noBlood: true,
			neverRun: true,
			noRegen: true,
			neverSleep: true,
			resistance: {Toxic: 1},
			effectImmune: ['InfectiousDisease']
		},

		Necromancer: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MHIGH', coolDown: 4, projectileTypeName: 'PoisonArrow', shootEffect: 'ToxicShoot'}},
				{typeName: 'NPCPoisonCloud', stats: {damageType: 'MLOW', coolDown: 10}},
				{typeName: 'ReviveSkeleton', stats: {coolDown: 10}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MLOW',
			isKiter: true,
			resistance: {Toxic: 1},
		},
		
		ZombieBloat: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MHIGH'}},
				{typeName: 'Berserk', stats: {coolDown: 100, mana: 0}}
			],
			onDeath: {typeName: 'Bloat', stats: {damageType: 'MLOW'}},
			moveSpeed: 'SLOW',
			hitPointType: 'HIGH',
			neverRun: true,
			noRegen: true,
			neverSleep: true,
			resistance: {Toxic: 1},
			effectImmune: ['InfectiousDisease']
		},
		
		Wraith: {
			abilityTypes: [
				{typeName: 'EXPDrainAttack', stats: {damageType: 'MEDIUM'}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			noBlood: true,
			neverRun: true,
			noRegen: true,
			neverSleep: true,
			effectImmune: ['InfectiousDisease']
		},
		
		// THE_CRYPT_UNIQUE_NPCS:
		// ****************************************************************************************
		TheLichKing: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MEDIUM', projectileTypeName: 'PoisonArrow', shootEffect: 'ToxicShoot'}},
				{typeName: 'SummonMonsters', stats: {coolDown: 4, num: 1, npcTypeName: 'SkeletonWarrior'}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'HIGH',
			isKiter: true,
			isUnique: true,
			noRegen: true,
			neverRun: true,
			resistance: {Toxic: 1},
			effectImmune: ['InfectiousDisease']
		},
		
		// THE_SEWERS:
		// ****************************************************************************************
		GiantLeach: {
			abilityTypes: [
				{typeName: 'VampireAttack', stats: {damageType: 'MEDIUM'}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MHIGH',
			isAquatic: true,
		},
		
		BoaConstrictor: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MEDIUM'}},
				{typeName: 'Constrict', stats: {coolDown: 10}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			gasImmune: true,
		},
		
		Troll: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MHIGH'}},
			],
			moveSpeed: 'SLOW',
			hitPointType: 'MHIGH',
			updateTurn: this.npcUpdateTurn.Regenerate,
			resistance: {Fire: -1},
		},
		
		Crocodile: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MEDIUM'}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			neverWander: true,
			startHidden: true,
			ambushDistance: 3,
			neverRespondToShout: true,
			spawnInWater: true,
			isAquatic: true,
		},
		
		TentacleSpitter: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MEDIUM', range: LOS_DISTANCE, coolDown: 3, projectileTypeName: 'Acid'}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MLOW',
			neverWander: true,
			startHidden: true,
			ambushDistance: 5.0,
			spawnInWater: true,
			isAquatic: true,
			isSwimming: true,
			neverRun: true,
			gasImmune: true,
			neverSpawnInZoo: true,
			neverRespawn: true,
		},
		
		Bloat: {
			abilityTypes: [
				{typeName: 'Suicide'}
			],
			onDeath: {typeName: 'Bloat', stats: {damageType: 'MLOW'}},
			moveSpeed: 'MEDIUM',
			hitPointType: 'MLOW',
			noBlood: true,
			isFlying: true,
			neverRun: true,
			gasImmune: true,
		},
		
		Slime: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MLOW'}},
			],
			onHit: this.npcOnHit.SlimeSplit,
			moveSpeed: 'SLOW',
			hitPointType: 'HIGH',
			noBlood: true,
			neverRun: true,
			gasImmune: true,
			noRegen: true,
			resistance: {Toxic: -1},
		},
		
		ToxicStatue: {
			abilityTypes: [
				{typeName: 'PoisonCloudBolt', stats: {damageType: 'MEDIUM', coolDown: 5}},
				{typeName: 'WallOfPoisonGas', stats: {damageType: 'MEDIUM', coolDown: 10}},
				
			],
			moveSpeed: 'NONE',
			hitPointType: 'MHIGH',
			noBlood: true,
			neverRun: true,
			neverSpawnInZoo: true,
			noRegen: true,
			neverSleep: true,
			resistance: {Toxic: 1},
			
		},
		

		// ICE_CAVES:
		// ****************************************************************************************
		DireWolf: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'LOW'}},
			],
			moveSpeed: 'FAST',
			hitPointType: 'LOW',
			resistance: {Cold: 1, Fire: -1},
		},
		
		DireWolfKennel:	{
			abilityTypes: [
				{typeName: 'SpawnNPC', stats: {numSpawned: 3, coolDown: 8, npcTypeName: 'DireWolf'}}
			],
			moveSpeed: 'NONE',
			hitPointType: 'MEDIUM',
			maxMp: 5,
			neverSleep: true,
			neverRespawn: true,
			noBlood: true,
			neverRun: true,
			neverSpawnInZoo: true,
			noRegen: true,
			
		},
		
		Penguin: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MLOW', projectileTypeName: 'Snowball'}},
				{typeName: 'Slide'},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			isKiter: true,
			resistance: {Cold: 1, Fire: -1},
		},
		
		Yak: {
			abilityTypes: [
				{typeName: 'TrampleAttack', stats: {damageType: 'MEDIUM'}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			resistance: {Cold: 1, Fire: -1},
		},
		
		IceStatue: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MHIGH', range: LOS_DISTANCE, coolDown: 3, projectileTypeName: 'IceArrow', shootEffect: 'ColdShoot'}},
				{typeName: 'SummonIceBomb', stats: {damageType: 'HIGH', coolDown: 15}}
			],
			moveSpeed: 'NONE',
			hitPointType: 'MHIGH',
			noBlood: true,
			neverRun: true,
			neverSpawnInZoo: true,
			noRegen: true,
			neverSleep: true,
			resistance: {Cold: 1, Fire: -1},
			
		},
		
		PolarBear: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MHIGH'}},
				{typeName: 'Berserk', stats: {coolDown: 100, mana: 0}}
			],
			moveSpeed: 'SLOW',
			hitPointType: 'HIGH',
			size: CHARACTER_SIZE.LARGE,
			resistance: {Cold: 1, Fire: -1},
		},

		IceElemental: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MHIGH', range: ABILITY_RANGE, coolDown: 3, projectileTypeName: 'IceArrow', shootEffect: 'ColdShoot'}},
				{typeName: 'SummonIceBomb', stats: {damageType: 'HIGH', coolDown: 15}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			isKiter: true,
			noBlood: true,
			resistance: {Cold: 1, Fire: -1},
		},
		
		// THE_CORE:
		// ****************************************************************************************
		FireBat: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'LOW'}},
			],
			moveSpeed: 'FAST',
			hitPointType: 'LOW',
			isRandomMover: true,
			isFlying: true,
			size: CHARACTER_SIZE.SMALL,
			resistance: {Fire: 1, Cold: -1},
		},
		
		FireBatNest: {
			abilityTypes: [
				{typeName: 'SpawnNPC', stats: {numSpawned: 3, coolDown: 8, npcTypeName: 'FireBat'}}
			],
			moveSpeed: 'NONE',
			hitPointType: 'MEDIUM',
			maxMp: 5,
			isUnstableImmune: true,
			neverSleep: true,
			neverRespawn: true,
			neverRun: true,
			neverSpawnInZoo: true,
			noBlood: true,
			noRegen: true,
			
		},
		
		FireLizard: {
			abilityTypes: [
				{typeName: 'FlamingCloudBolt', stats: {damageType: 'MLOW', coolDown: 5}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			isKiter: true,
			isLavaImmune: true,
			resistance: {Fire: 1, Cold: -1},
		},
		
		LavaEel: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MHIGH', range: LOS_DISTANCE, projectileTypeName: 'FireArrow', coolDown: 3, shootEffect: 'FireShoot'}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MLOW',
			neverWander: true,
			startHidden: true,
			ambushDistance: 5.0,
			spawnInLava: true,
			noBlood: true,
			isSwimming: true,
			isAquatic: true,
			isLavaImmune: true,
			neverRun: true,
			neverSpawnInZoo: true,
			neverRespawn: true,
			resistance: {Fire: 1, Cold: -1},
		},
		
		FireStatue: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MHIGH', coolDown: 3, range: LOS_DISTANCE, projectileTypeName: 'FireArrow', shootEffect: 'FireShoot'}},
				{typeName: 'OrbOfFire', stats: {damageType: 'HIGH', coolDown: 10, mana: 0}}
			],
			moveSpeed: 'NONE',
			hitPointType: 'MHIGH',
			neverRun: true,
			neverSpawnInZoo: true,
			noRegen: true,
			neverSleep: true,
			resistance: {Fire: 1, Cold: -1},
			
		},
		
		FireElemental: {
			abilityTypes: [
				{typeName: 'ProjectileAttack', stats: {damageType: 'MHIGH', coolDown: 3, projectileTypeName: 'FireArrow', shootEffect: 'FireShoot'}},
				{typeName: 'SpawnNPC', stats: {coolDown: 8, numSpawned: 1, mana: 0, npcTypeName: 'FireBall', damageType: 'HIGH'}}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MEDIUM',
			isKiter: true,
			noBlood: true,
			isLavaImmune: true,
			resistance: {Fire: 1, Cold: -1},
		},
		
		ObsidianGolem: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MHIGH'}},
				{typeName: 'Berserk', stats: {coolDown: 100, mana: 0}}
			],
			moveSpeed: 'SLOW',
			hitPointType: 'HIGH',
			noBlood: true,
			noRegen: true,
			neverSleep: true,
			size: CHARACTER_SIZE.LARGE,
			resistance: {Fire: 1, Cold: -1},
		},
		
		FireBall: {
			abilityTypes: [
				{typeName: 'Suicide'}
			],
			onDeath: {typeName: 'Explode'}, // Set damage in SummonFireBall ability
			moveSpeed: 'MEDIUM',
			hitPointType: 'LOW',
			noBlood: true,
			isFlying: true,
			neverRun: true,
			isLavaImmune: true,
			noRegen: true,
			updateTurn: this.npcUpdateTurn.FireBall,
			light: {color: '#ff0000', radius: 120, startAlpha: 'aa'},
			resistance: {Fire: 1, Cold: -1},
			
		},
		
		
	
		// MISC:
		// ****************************************************************************************
		Skeleton: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'MEDIUM'}},
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'MHIGH',
			noBlood: true,
			neverRun: true,
			noRegen: true,
			resistance: {Toxic: 1},
			sustainedMpCost: 3,
			effectImmune: ['InfectiousDisease']
		},
		
		MagicEye: {
			abilityTypes: [
				{typeName: 'WatchPlayer'}
			],
			moveSpeed: 'MEDIUM',
			hitPointType: 'LOW',
			isKiter: true,
			noBlood: true,
			isFlying: true,
			neverSpawnInZoo: true,
		},
		
		OrbOfFire: {
			faction: FACTION.NEUTRAL,
			onDeath: {typeName: 'BigExplode'}, // Set damage in OrbOfFire ability
			damageImmune: true,
			maxHp: 100,
			dontFace: true,
			moveSpeed: 'FAST',
			isSlowProjectile: true,
			noBlood: true,
			neverRun: true,
			isFlying: true,
			light: {color: '#ff0000', radius: 120, startAlpha: 'aa'},
			isMindless: true,
			
			
		},
		
		InfernoOrb: {
			faction: FACTION.NEUTRAL,
			damageImmune: true,
			maxHp: 100,
			dontFace: true,
			moveSpeed: 'FAST',
			noBlood: true,
			neverRun: true,
			isFlying: true,
			light: {color: '#ff0000', radius: 120, startAlpha: 'aa'},
			isMindless: true,
		},
		
		FirePot: {
			faction: FACTION.DESTRUCTABLE,
			onDeath: {typeName: 'FirePotExplode'},
			maxHp: 1,
			moveSpeed: 'NONE',
			noBlood: true,
			neverRun: true,
			gasImmune: true,
			isMindless: true,
		},
		
		GasPot: {
			faction: FACTION.DESTRUCTABLE,
			onDeath: {typeName: 'BreakGasPot'},
			maxHp: 1,
			moveSpeed: 'NONE',
			noBlood: true,
			neverRun: true,
			gasImmune: true,
			isMindless: true,
		},
		
		Crate: {
			faction: FACTION.DESTRUCTABLE,
			maxHp: 1,
			moveSpeed: 'NONE',
			noBlood: true,
			gasImmune: true,
			neverRun: true,
			dropPercent: STANDARD_DROP_PERCENT,
			isMindless: true,
		},
		
		SpiderEgg: {
			faction: FACTION.DESTRUCTABLE,
			maxHp: 4,
			moveSpeed: 'NONE',
			noBlood: true,
			gasImmune: true,
			neverRun: true,
			updateTurn: this.npcUpdateTurn.SpiderEgg,
			isMindless: true,
		},
		
		SpectralBlade: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'LOW'}}
			],
			moveSpeed: 'FAST',
			hitPointType: 'LOW',
			isFlying: true,
			noCorpse: true,
			noBlood: true,
			neverSpawn: true,
			noRegen: true,
			neverRun: true,
			isMindless: true,
		},
		
		GreaterSpectralBlade: {
			abilityTypes: [
				{typeName: 'MeleeAttack', stats: {damageType: 'LOW'}}
			],
			moveSpeed: 'FAST',
			hitPointType: 'LOW',
			isFlying: true,
			noCorpse: true,
			noBlood: true,
			neverSpawn: true,
			noRegen: true,
			neverRun: true,
			isMindless: true,
		},
		
		Merchant: {
			faction: FACTION.NEUTRAL,
			maxHp: 100,
			dontFace: true,
			moveSpeed: 'NONE',
			noBlood: true,
			neverRun: true,
			gasImmune: true,
			damageImmune: true,
		},

		SkillTrainer: {
			faction: FACTION.NEUTRAL,
			maxHp: 100,
			dontFace: true,
			moveSpeed: 'NONE',
			noBlood: true,
			neverRun: true,
			gasImmune: true,
			damageImmune: true,
		},
		
		TalentTrainer: {
			faction: FACTION.NEUTRAL,
			maxHp: 100,
			dontFace: true,
			moveSpeed: 'NONE',
			noBlood: true,
			neverRun: true,
			gasImmune: true,
			damageImmune: true,
		},
		
		Priest: {
			faction: FACTION.NEUTRAL,
			maxHp: 100,
			dontFace: true,
			moveSpeed: 'NONE',
			noBlood: true,
			neverRun: true,
			gasImmune: true,
			damageImmune: true,
		},
        
		PracticeDummy: {
			faction: FACTION.HOSTILE,
			maxHp: 10000,
			moveSpeed: 'NONE',
			gasImmune: true,
			noRegen: true,
		},
	};
	
	this.setNPCTypeFrames();
	this.setNPCTypeLevels();
	this.setNPCTypeDefaultProperties();	
};

// SET_NPC_TYPE_LEVELS:
// ************************************************************************************************
gs.setNPCTypeLevels = function () {
	
	// TIER_I_ZONES:
	// ********************************************************************************************
	// THE_UPPER_DUNGEON (TIER_I):
	this.npcTypes.Rat.level = 						DANGER_LEVEL.TIER_I[1];
	this.npcTypes.Bat.level = 						DANGER_LEVEL.TIER_I[1];
	this.npcTypes.RatNest.level = 					DANGER_LEVEL.TIER_I[1];
	this.npcTypes.GoblinArcher.level = 				DANGER_LEVEL.TIER_I[1];
	this.npcTypes.GoblinWarrior.level = 			DANGER_LEVEL.TIER_I[1];
	this.npcTypes.GoblinBrute.level = 				DANGER_LEVEL.TIER_I[2];
	this.npcTypes.GoblinFireMage.level = 			DANGER_LEVEL.TIER_I[2];
	this.npcTypes.GoblinStormMage.level = 			DANGER_LEVEL.TIER_I[2];
	this.npcTypes.Centipede.level =					DANGER_LEVEL.TIER_I[2];
	this.npcTypes.GoblinShaman.level = 				DANGER_LEVEL.TIER_I[3];
	
	// Uniques:
	this.npcTypes.TheVampireBat.level = 			DANGER_LEVEL.TIER_I[4] + 1;
	this.npcTypes.TheRatPiper.level = 				DANGER_LEVEL.TIER_I[4] + 1;
	this.npcTypes.TheBridgeGuardian.level =			DANGER_LEVEL.TIER_I[4] + 1;
	
	// TIER_II_ZONES:
	// ********************************************************************************************
	// THE_ORC_FORTRESS (TIER_II):
	this.npcTypes.Wolf.level =						DANGER_LEVEL.TIER_II[1] - 1;
	this.npcTypes.OrcArcher.level = 				DANGER_LEVEL.TIER_II[1];
	this.npcTypes.OrcWarrior.level = 				DANGER_LEVEL.TIER_II[1];
	this.npcTypes.WolfKennel.level =				DANGER_LEVEL.TIER_II[2];
	this.npcTypes.Ogre.level = 						DANGER_LEVEL.TIER_II[2];
	this.npcTypes.OrcFireMage.level = 				DANGER_LEVEL.TIER_II[2];
	this.npcTypes.OrcStormMage.level = 				DANGER_LEVEL.TIER_II[2];
	this.npcTypes.OrcPriest.level = 				DANGER_LEVEL.TIER_II[3];
	this.npcTypes.OgreShaman.level = 				DANGER_LEVEL.TIER_II[3];
	this.npcTypes.OrcSummoner.level =				DANGER_LEVEL.TIER_II[4];
	this.npcTypes.SpectralBlade.level =				3;
	
	// Uniques:
	this.npcTypes.KingMonRacar.level = 		DANGER_LEVEL.TIER_II[4] + 1;
	
	// THE_IRON_FORTRESS (TIER_II):
	this.npcTypes.ClockworkRat.level =				DANGER_LEVEL.TIER_II[1] - 1;
	this.npcTypes.Bombomber.level =					DANGER_LEVEL.TIER_II[1];
	this.npcTypes.ClockworkArcher.level = 			DANGER_LEVEL.TIER_II[1];
	this.npcTypes.ClockworkWarrior.level = 			DANGER_LEVEL.TIER_II[1];
	this.npcTypes.ClockworkFactory.level = 			DANGER_LEVEL.TIER_II[2];
	this.npcTypes.GoblinBomber.level = 				DANGER_LEVEL.TIER_II[2];
	this.npcTypes.CorrosiveSlime.level = 			DANGER_LEVEL.TIER_II[2];
	this.npcTypes.ClockworkPyro.level =				DANGER_LEVEL.TIER_II[3];
	this.npcTypes.Ballista.level = 					DANGER_LEVEL.TIER_II[3];
	this.npcTypes.ClockworkRhino.level =			DANGER_LEVEL.TIER_II[4];
	
	
	
	
	// THE_SUNLESS_DESERT (TIER_II):
	this.npcTypes.Scarab.level =						DANGER_LEVEL.TIER_II[1] - 1;
	this.npcTypes.SpittingViper.level =					DANGER_LEVEL.TIER_II[1];
	this.npcTypes.TrapDoorSpider.level =				DANGER_LEVEL.TIER_II[1];
	this.npcTypes.Scorpion.level =						DANGER_LEVEL.TIER_II[2];
	this.npcTypes.SunFlower.level =						DANGER_LEVEL.TIER_II[2];
	this.npcTypes.Goat.level = 							DANGER_LEVEL.TIER_II[2];
	this.npcTypes.Mummy.level =							DANGER_LEVEL.TIER_II[2];
	this.npcTypes.MummyPriest.level =					DANGER_LEVEL.TIER_II[3];
	
	this.npcTypes.CylomarTheAncientPyromancer.level = 	DANGER_LEVEL.TIER_II[4] + 1;
	
	
	// THE_UNDER_GROVE (TIER_II):
	this.npcTypes.GiantBee.level =					DANGER_LEVEL.TIER_II[1];
	this.npcTypes.GiantAnt.level = 					DANGER_LEVEL.TIER_II[1];
	this.npcTypes.Jaguar.level = 					DANGER_LEVEL.TIER_II[1];
	this.npcTypes.Spider.level = 					DANGER_LEVEL.TIER_II[1];
	this.npcTypes.SpiderNest.level = 				DANGER_LEVEL.TIER_II[2];
	this.npcTypes.PoisonSpider.level = 				DANGER_LEVEL.TIER_II[2];
	this.npcTypes.CentaurArcher.level =				DANGER_LEVEL.TIER_II[2];
	this.npcTypes.CentaurWarrior.level =			DANGER_LEVEL.TIER_II[2];
	this.npcTypes.Elephant.level =					DANGER_LEVEL.TIER_II[3];
	
	// Uniques:
	this.npcTypes.TheQueenSpider.level = 			DANGER_LEVEL.TIER_II[4] + 1;
	
	// THE_SWAMP (TIER_II):
	this.npcTypes.Pirahna.level =					DANGER_LEVEL.TIER_II[1] - 1;
	this.npcTypes.PoisonViper.level = 				DANGER_LEVEL.TIER_II[1];
	this.npcTypes.BlinkFrog.level = 				DANGER_LEVEL.TIER_II[1];
	this.npcTypes.Mosquito.level =					DANGER_LEVEL.TIER_II[2];
	this.npcTypes.SpinyFrog.level = 				DANGER_LEVEL.TIER_II[2];
	this.npcTypes.ElectricEel.level = 				DANGER_LEVEL.TIER_II[2];
	this.npcTypes.BullFrog.level =					DANGER_LEVEL.TIER_II[3];
	this.npcTypes.SnappingTurtle.level =			DANGER_LEVEL.TIER_II[3];
	
	// Uniques:
	this.npcTypes.KasicTheMosquitoPrince.level = 	DANGER_LEVEL.TIER_II[4];
	
	// TIER_III_ZONES:
	// ********************************************************************************************
	// THE_DARK_TEMPLE (TIER_III):
	this.npcTypes.DarkElfWarden.level =				DANGER_LEVEL.TIER_III[1];
	this.npcTypes.DarkElfSentinel.level =			DANGER_LEVEL.TIER_III[1];
	this.npcTypes.DarkElfPyromancer.level = 		DANGER_LEVEL.TIER_III[2];
	this.npcTypes.DarkElfStormologist.level = 		DANGER_LEVEL.TIER_III[2];
	this.npcTypes.DarkElfPriest.level =				DANGER_LEVEL.TIER_III[3];
	this.npcTypes.DarkElfSummoner.level =  			DANGER_LEVEL.TIER_III[3];
	this.npcTypes.EvilEye.level =					DANGER_LEVEL.TIER_III[4];
	
	this.npcTypes.GreaterSpectralBlade.level = 6;
	
	// THE_CRYPT (TIER_III):
	this.npcTypes.Maggot.level = 					DANGER_LEVEL.TIER_III[1] - 1;
	this.npcTypes.RottingCorpse.level = 			DANGER_LEVEL.TIER_III[1];
	this.npcTypes.SkeletonWarrior.level = 			DANGER_LEVEL.TIER_III[1];
	this.npcTypes.SkeletonArcher.level = 			DANGER_LEVEL.TIER_III[1];
	this.npcTypes.Necromancer.level = 				DANGER_LEVEL.TIER_III[2];
	this.npcTypes.ZombieBloat.level = 				DANGER_LEVEL.TIER_III[3];
	this.npcTypes.Wraith.level = 					DANGER_LEVEL.TIER_III[4];
	
	// Uniques:
	this.npcTypes.TheLichKing.level = 				DANGER_LEVEL.TIER_III[4] + 1;
	
	// BRANCH_I_ZONES:
	// ********************************************************************************************
	// THE_ARCANE_TOWER (BRANCH_I):
	this.npcTypes.ManaViper.level =					DANGER_LEVEL.BRANCH_I[1];
	this.npcTypes.FireImp.level = 					DANGER_LEVEL.BRANCH_I[1];
	this.npcTypes.StormImp.level = 					DANGER_LEVEL.BRANCH_I[1];
	this.npcTypes.IceImp.level = 					DANGER_LEVEL.BRANCH_I[1];
	this.npcTypes.StoneGolem.level = 				DANGER_LEVEL.BRANCH_I[2];
	this.npcTypes.FireStaffTurret.level = 			DANGER_LEVEL.BRANCH_I[3];
	this.npcTypes.StormStatue.level = 				DANGER_LEVEL.BRANCH_I[4];
	
	// THE_SEWERS (BRANCH_I):
	this.npcTypes.GiantLeach.level =				DANGER_LEVEL.BRANCH_I[1];
	this.npcTypes.BoaConstrictor.level = 			DANGER_LEVEL.BRANCH_I[1];
	this.npcTypes.Troll.level =						DANGER_LEVEL.BRANCH_I[1];
	this.npcTypes.TentacleSpitter.level = 			DANGER_LEVEL.BRANCH_I[1];
	this.npcTypes.AcidicSlime.level = 				DANGER_LEVEL.BRANCH_I[2];
	this.npcTypes.Bloat.level = 					DANGER_LEVEL.BRANCH_I[2];
	this.npcTypes.Crocodile.level = 				DANGER_LEVEL.BRANCH_I[3];
	this.npcTypes.Slime.level = 					DANGER_LEVEL.BRANCH_I[4];
	this.npcTypes.ToxicStatue.level =				DANGER_LEVEL.BRANCH_I[4];
	
	// BRANCH_II_ZONES:
	// ********************************************************************************************
	// THE_CORE (BRANCH_II):
	this.npcTypes.FireBat.level = 					DANGER_LEVEL.BRANCH_II[1];
	this.npcTypes.FireBatNest.level = 				DANGER_LEVEL.BRANCH_II[1];
	this.npcTypes.FireLizard.level = 				DANGER_LEVEL.BRANCH_II[1];
	this.npcTypes.LavaEel.level = 					DANGER_LEVEL.BRANCH_II[2];
	this.npcTypes.FireStatue.level = 				DANGER_LEVEL.BRANCH_II[3];
	this.npcTypes.FireElemental.level = 			DANGER_LEVEL.BRANCH_II[4];
	this.npcTypes.ObsidianGolem.level =				DANGER_LEVEL.BRANCH_II[4];
	
	this.npcTypes.FireBall.level = 					8;
	
	// THE_ICE_CAVES (BRANCH_II):
	this.npcTypes.DireWolf.level = 					DANGER_LEVEL.BRANCH_II[1];
	this.npcTypes.DireWolfKennel.level = 			DANGER_LEVEL.BRANCH_II[1];
	this.npcTypes.Penguin.level =					DANGER_LEVEL.BRANCH_II[1];
	this.npcTypes.Yak.level =						DANGER_LEVEL.BRANCH_II[2];
	this.npcTypes.PolarBear.level = 				DANGER_LEVEL.BRANCH_II[2];
	this.npcTypes.IceStatue.level = 				DANGER_LEVEL.BRANCH_II[3];
	this.npcTypes.IceElemental.level = 				DANGER_LEVEL.BRANCH_II[4];
	
	// TIER_IV_ZONES:
	// ********************************************************************************************
	// THE_VAULT_OF_YENDOR:
	this.npcTypes.HellHound.level = 				DANGER_LEVEL.TIER_IV[1] - 1;
	this.npcTypes.DrachnidWarrior.level =			DANGER_LEVEL.TIER_IV[1];
	this.npcTypes.DrachnidArcher.level =			DANGER_LEVEL.TIER_IV[1];
	this.npcTypes.FleshGolem.level =				DANGER_LEVEL.TIER_IV[2];
	this.npcTypes.CrystalGolem.level =				DANGER_LEVEL.TIER_IV[3];
	this.npcTypes.DarkElfBladeDancer.level = 		DANGER_LEVEL.TIER_IV[3];
	this.npcTypes.Succubus.level =					DANGER_LEVEL.TIER_IV[4];
	
	// MISC:
	// ********************************************************************************************
	this.npcTypes.Skeleton.level = 4;
	this.npcTypes.OrbOfFire.level = 0;
	this.npcTypes.InfernoOrb.level = 0;
	this.npcTypes.MagicEye.level = 9;
	this.npcTypes.SpiderEgg.level = 1;
	this.npcTypes.FirePot.level = 1;
	this.npcTypes.GasPot.level = 1;
	this.npcTypes.Merchant.level = 1;
	this.npcTypes.SkillTrainer.level = 1;
	this.npcTypes.TalentTrainer.level = 1;
	this.npcTypes.Priest.level = 1;
	this.npcTypes.Crate.level = 1;
	this.npcTypes.PracticeDummy.level = 1;
};

// SET_NPC_TYPE_FRAMES:
// ************************************************************************************************
gs.setNPCTypeFrames = function () {
	// THE_UPPER_DUNGEON:
	// ********************************************************************************************
	this.npcTypes.Rat.frame = 512;
	this.npcTypes.Bat.frame = 513;
	this.npcTypes.RatNest.frame = 514;
	this.npcTypes.GoblinWarrior.frame = 515;
	this.npcTypes.GoblinArcher.frame = 516;
	this.npcTypes.GoblinBrute.frame = 517;
	this.npcTypes.GoblinFireMage.frame = 518;
	this.npcTypes.GoblinStormMage.frame = 519;
	this.npcTypes.GoblinShaman.frame = 520;
	this.npcTypes.TheRatPiper.frame = 521;
	this.npcTypes.TheVampireBat.frame = 522;
	this.npcTypes.Centipede.frame = 523;
	this.npcTypes.TheBridgeGuardian.frame = 524;
	
	// THE_ORC_FORTRESS:
	// ********************************************************************************************
	this.npcTypes.OrcWarrior.frame = 544;
	this.npcTypes.OrcArcher.frame = 545;
	this.npcTypes.Ogre.frame = 546;
	this.npcTypes.OrcFireMage.frame = 547;
	this.npcTypes.OrcStormMage.frame = 548;
	this.npcTypes.OrcPriest.frame = 549;
	this.npcTypes.OrcSummoner.frame = 550;
	this.npcTypes.OgreShaman.frame = 552;
	this.npcTypes.Wolf.frame = 554;
	this.npcTypes.WolfKennel.frame = 555;
	
	// Uniques:
	this.npcTypes.KingMonRacar.frame = 557;
	
	// THE_IRON_FORTRESS:
	// ********************************************************************************************
	this.npcTypes.ClockworkRat.frame = 640;
	this.npcTypes.ClockworkFactory.frame = 641;
	this.npcTypes.Bombomber.frame = 642;
	this.npcTypes.ClockworkWarrior.frame = 643;
	this.npcTypes.ClockworkArcher.frame = 644;
	this.npcTypes.GoblinBomber.frame = 645;
	this.npcTypes.Ballista.frame = 646;
	this.npcTypes.ClockworkRhino.frame = 647;
	this.npcTypes.ClockworkPyro.frame = 648;
	this.npcTypes.CorrosiveSlime.frame = 551;
	
	// THE_DARK_TEMPLE:
	// ********************************************************************************************
	this.npcTypes.DarkElfWarden.frame = 576;
	this.npcTypes.DarkElfSentinel.frame = 577;
	this.npcTypes.DarkElfPyromancer.frame = 578;
	this.npcTypes.DarkElfStormologist.frame = 579;
	this.npcTypes.DarkElfPriest.frame = 580;
	this.npcTypes.DarkElfSummoner.frame = 581;
	this.npcTypes.EvilEye.frame = 582;
	this.npcTypes.MagicEye.frame = 583;
	
	// THE_VAULT_OF_YENDOR:
	// ********************************************************************************************
	this.npcTypes.HellHound.frame = 960;
	this.npcTypes.DrachnidWarrior.frame = 961;
	this.npcTypes.DrachnidArcher.frame = 962;
	this.npcTypes.FleshGolem.frame = 963;
	this.npcTypes.CrystalGolem.frame = 964;
	this.npcTypes.DarkElfBladeDancer.frame = 965;
	this.npcTypes.Succubus.frame = 966;
	
	/*
	this.npcTypes.Demonologist.frame = 584;
	*/
	
	// THE_SUNLESS_DESERT:
	// ********************************************************************************************
	this.npcTypes.Scarab.frame = 928;
	this.npcTypes.SpittingViper.frame = 929;
	this.npcTypes.TrapDoorSpider.frame = 930;
	this.npcTypes.Scorpion.frame = 931;
	
	this.npcTypes.Mummy.frame = 932;
	this.npcTypes.Goat.frame = 933;
	this.npcTypes.MummyPriest.frame = 934;
	this.npcTypes.SunFlower.frame = 935;
	
	// Uniques:
	this.npcTypes.CylomarTheAncientPyromancer.frame = 936;
	
	//this.npcTypes.AncientWindCaller.frame =	933;
	
	// THE_UNDER_GROVE:
	// ********************************************************************************************
	this.npcTypes.Jaguar.frame = 608;
	this.npcTypes.Spider.frame = 609;
	this.npcTypes.SpiderNest.frame = 610;
	this.npcTypes.PoisonSpider.frame = 611;
	this.npcTypes.CentaurArcher.frame = 612;
	this.npcTypes.Elephant.frame = 613;
	this.npcTypes.GiantAnt.frame = 616;
	this.npcTypes.GiantBee.frame = 614;
	this.npcTypes.CentaurWarrior.frame = 617;
	
	
	this.npcTypes.TheQueenSpider.frame = 615;
	
	// THE_SWAMP:
	// ********************************************************************************************
	this.npcTypes.Pirahna.frame = 672;
	this.npcTypes.PoisonViper.frame = 673;
	this.npcTypes.BlinkFrog.frame = 674;
	this.npcTypes.Mosquito.frame = 675;
	this.npcTypes.SpinyFrog.frame = 676;
	this.npcTypes.ElectricEel.frame = 677;
	this.npcTypes.BullFrog.frame = 678;
	this.npcTypes.SnappingTurtle.frame = 680;
	
	// Uniques:
	this.npcTypes.KasicTheMosquitoPrince.frame = 679;
	
	
	
	// THE_CRYPT:
	// ********************************************************************************************
	this.npcTypes.Maggot.frame = 704;
	this.npcTypes.RottingCorpse.frame = 705;
	this.npcTypes.SkeletonWarrior.frame = 706;
	this.npcTypes.SkeletonArcher.frame = 707;
	this.npcTypes.Necromancer.frame = 708;
	this.npcTypes.ZombieBloat.frame = 709;
	this.npcTypes.Wraith.frame = 710;
	this.npcTypes.TheLichKing.frame = 711;
	
	// THE_ARCANE_TOWER:
	// ********************************************************************************************
	this.npcTypes.ManaViper.frame = 736;
	this.npcTypes.FireImp.frame = 737;
	this.npcTypes.StormImp.frame = 738;
	this.npcTypes.IceImp.frame = 739;
	this.npcTypes.StoneGolem.frame = 740;
	this.npcTypes.FireStaffTurret.frame = 741;
	this.npcTypes.StormStatue.frame = 742;
	
	// THE_ICE_CAVES:
	// ********************************************************************************************
	this.npcTypes.DireWolf.frame = 800;
	this.npcTypes.DireWolfKennel.frame = 801;
	this.npcTypes.IceStatue.frame = 802;
	this.npcTypes.PolarBear.frame = 803;
	this.npcTypes.IceElemental.frame = 804;
	this.npcTypes.Penguin.frame = 805;
	this.npcTypes.Yak.frame = 807;
	
	// THE_CORE:
	// ********************************************************************************************
	this.npcTypes.FireBat.frame = 832;
	this.npcTypes.FireBatNest.frame = 833;
	this.npcTypes.LavaEel.frame = 834;
	this.npcTypes.FireStatue.frame = 835;
	this.npcTypes.FireElemental.frame = 836;
	this.npcTypes.FireLizard.frame = 837;
	this.npcTypes.ObsidianGolem.frame = 838;
	
	// THE_SEWERS:
	// ********************************************************************************************
	this.npcTypes.BoaConstrictor.frame = 768;
	this.npcTypes.Troll.frame = 769;
	this.npcTypes.Crocodile.frame = 770;
	this.npcTypes.TentacleSpitter.frame = 771;
	this.npcTypes.Bloat.frame = 772;
	this.npcTypes.Slime.frame = 773;
	this.npcTypes.AcidicSlime.frame = 553;
	this.npcTypes.GiantLeach.frame = 777;
	this.npcTypes.ToxicStatue.frame = 778;
	
	// MISC:
	this.npcTypes.Skeleton.frame = 706;
	this.npcTypes.Merchant.frame = 896;

	this.npcTypes.SkillTrainer.frame = 897;
	this.npcTypes.TalentTrainer.frame = 898;
	this.npcTypes.Priest.frame = 899;
	this.npcTypes.OrbOfFire.frame = 900;
	this.npcTypes.InfernoOrb.frame = 900;
	this.npcTypes.FireBall.frame = 900;
	this.npcTypes.SpectralBlade.frame = 902;
	this.npcTypes.FirePot.frame = 903;
	this.npcTypes.GasPot.frame = 904;
	this.npcTypes.Crate.frame = 905;
	this.npcTypes.SpiderEgg.frame = 906;
	this.npcTypes.GreaterSpectralBlade.frame = 907;
	this.npcTypes.PracticeDummy.frame = 908;
};

// SET_NPC_TYPE_DEFAULT_PROPERTIES:
// ************************************************************************************************
gs.setNPCTypeDefaultProperties = function () {
	this.npcTypeList = [];
	
	this.nameTypes(this.npcTypes);
	
	gs.forEachType(this.npcTypes, function (npcType) {
		this.npcTypeList.push(npcType);
		
		if (!npcType.hasOwnProperty('level')) {
			throw 'npcType missing level: ' + npcType.name;
		}
		
		if (!npcType.hasOwnProperty('frame')) {
			throw 'npcType missing frame: ' + npcType.name;
		}
		
		if (!npcType.hasOwnProperty('faction')) {
			npcType.faction = FACTION.HOSTILE;
		}
		
		if (!npcType.hasOwnProperty('dropPercent')) {
			npcType.dropPercent = 0;
		}
		
		if (!npcType.hasOwnProperty('bloodTypeName')) {
			npcType.bloodTypeName = 'Blood';
		}
		
		if (!npcType.hasOwnProperty('isSlowProjectile')) {
			npcType.isSlowProjectile = false;
		}
		
		if (!npcType.hasOwnProperty('reflection')) {
			npcType.reflection = 0;
		}
		
		if (!npcType.hasOwnProperty('size')) {
			npcType.size = CHARACTER_SIZE.MEDIUM;
		}
		
		npcType.damageShield = npcType.damageShield || 0;
		
		// Max HP:
		if (!npcType.maxHp) {
			npcType.maxHp = this.npcMaxHp(npcType.level, npcType.hitPointType);
		}
		
		// Max EP:
		npcType.maxMp = npcType.maxMp || 0;
		
		// Abilities:
		if (npcType.abilityTypes) {
			for (let i = 0; i < npcType.abilityTypes.length; i += 1) {
				npcType.abilityTypes[i] = gs.createNPCAbilityType(npcType, npcType.abilityTypes[i].typeName, npcType.abilityTypes[i].stats);
			}
		}
		
		// On Death:
		if (npcType.onDeath) {
			npcType.onDeath = gs.createNPCAbilityType(npcType, npcType.onDeath.typeName, npcType.onDeath.stats);
		}
		
		// resistance:
		if (!npcType.hasOwnProperty('resistance')) {
			npcType.resistance = {};
		}
		
		npcType.protection = 0;
		DAMAGE_TYPES.forEach(function (damageType) {
			if (npcType.resistance[damageType]) {
				if (damageType === 'Physical') {
					npcType.protection = npcType.level;
				}
				else if (npcType.resistance[damageType] === 1) {
					npcType.resistance[damageType] = 2;
				}
				else if (npcType.resistance[damageType] === -1) {
					npcType.resistance[damageType] = -1;
				}
			}
			else {
				npcType.resistance[damageType] = 0;
			}
		}, this);
		
		npcType.evasion = 0;
		
		// Speed:
		npcType.movementSpeed = {NONE: 0, SLOW: 0, MEDIUM: 1, FAST: 2}[npcType.moveSpeed];
		if (npcType.moveSpeed === 'NONE') {
			npcType.cantMove = true;
		}
			
		// Exp:
		npcType.exp = npcType.level;
		
		npcType.effectImmune = npcType.effectImmune || [];
		
	}, this);
	
	// Some characters have no exp value:
	this.npcTypes.Skeleton.exp = 0;
	this.npcTypes.FirePot.exp = 0;
	this.npcTypes.OrbOfFire.exp = 0;
	this.npcTypes.InfernoOrb.exp = 0;
	this.npcTypes.FireBall.exp = 0;
	this.npcTypes.GasPot.exp = 0;
	this.npcTypes.Crate.exp = 0;
	
	this.npcTypes.Maggot.exp = Math.ceil(this.npcTypes.Maggot.exp / 2);
	this.npcTypes.FireBat.exp = Math.ceil(this.npcTypes.FireBat.exp / 2);
	this.npcTypes.DireWolf.exp = Math.ceil(this.npcTypes.DireWolf.exp / 2);
	this.npcTypes.Slime.exp = Math.ceil(this.npcTypes.Slime.exp / 2);
};

// NPC_DAMAGE:
// ************************************************************************************************
gs.npcDamage = function (level, type) {
	if (!NPC_INITIAL_DAMAGE[type]) throw 'Invalid damageType: ' + type;
	
	return Math.round(NPC_INITIAL_DAMAGE[type] + (level - 1) * NPC_DAMAGE_PER_LEVEL[type]);
};

// NPC_MAX_HP:
// ************************************************************************************************
gs.npcMaxHp = function (level, type) {
	if (!NPC_INITIAL_HP[type]) throw 'Invalid hpType: ' + type;
	
	return Math.round(NPC_INITIAL_HP[type] + (level - 1) * NPC_HP_PER_LEVEL[type]);
};

// CREATE_NPC_CLASS_TYPES:
// ************************************************************************************************
gs.createNPCClassTypes = function () {
	this.npcClassTypes = {};
	
	// TOUGH:
	this.npcClassTypes.Tough = {};
	this.npcClassTypes.Tough.effect = function (npc) {
		npc.bonusMaxHp += Math.ceil(npc.type.maxHp / 2);
	};
	
	// STRONG:
	this.npcClassTypes.Strong = {};
	this.npcClassTypes.Strong.effect = function (npc) {
		npc.meleePower += 10;
	};
	
	// BLINKING:
	this.npcClassTypes.Blinking = {};
	this.npcClassTypes.Blinking.onHit = this.npcOnHit.BlinkFrog;
	
	// REGENERATING:
	this.npcClassTypes.Regenerating = {};
	this.npcClassTypes.Regenerating.updateTurn = gs.npcUpdateTurn.Regenerate;
	
	// FAST:
	this.npcClassTypes.Fast = {};
	this.npcClassTypes.Fast.effect = function (npc) {
		npc.bonusMovementSpeed += 1;
	};
	
	// SPINY:
	this.npcClassTypes.Spiny = {};
	this.npcClassTypes.Spiny.effect = function (npc) {
		npc.bonusDamageShield += gs.npcDamage(npc.level, 'LOW');
	};
	
	this.nameTypes(this.npcClassTypes);
};

// GET_NPC_CLASS_TYPE:
// ************************************************************************************************
gs.getNPCClassType = function (npcTypeName) {
	var validList, type = this.npcTypes[npcTypeName];
	
	validList = ['Tough'];
	
	// Fast:
	if (type.movementSpeed < 2 && !type.cantMove) {
		validList.push('Fast');
	}
	
	// Strong:
	if (type.abilityTypes.find(e => e.name === 'MeleeAttack')) {
		validList.push('Strong');
	}
	
	// Regenerating:
	if (!type.noRegen && !type.updateTurn) {
		validList.push('Regenerating');
	}
	
	// Blinking:
	if (!type.onHit && !type.cantMove) {
		validList.push('Blinking');
	}
	
	// Spiny
	if (!type.damageShield) {
		validList.push('Spiny');
	}
	
	return this.npcClassTypes[util.randElem(validList)];
};/*global game, gs, console, util*/
/*global Character, ItemSlotList, StatusEffects, Item*/
/*global ASSERT_EQUAL*/
/*global TILE_SIZE, SCALE_FACTOR*/
/*global INVENTORY_SIZE*/
/*global MAX_AGRO_RANGE, SHOUT_RANGE, NPC_UNAGRO_TIME, LOS_DISTANCE*/
/*global RANDOM_MOVE_PERCENT, KITE_RANGE*/
/*global FONT_NAME, MOVE_TIME, DROP_GOLD_PERCENT*/
/*global ELITE_RING_FRAME, HP_REGEN_TIME*/
/*global FACTION, MAX_ABILITIES, MP_REGEN_TIME*/
/*jshint white: true, laxbreak: true, esversion: 6 */
'use strict';

// CREATE_NPC_POOL:
// ************************************************************************************************
gs.createNPCPool = function () {
	this.npcPool = [];
	for (let i = 0; i < 50; i += 1) {
		this.npcPool[i] = new NPC();
	}
	
	gs.nextCharacterID = 1;
};

// CREATE_NPC:
// Standard function for creating NPCs:
// ************************************************************************************************
gs.createNPC = function (tileIndex, typeName, flags) {
	if (gs.getChar(tileIndex)) {
		console.log('Trying to place ' + typeName + ' tileIndex is occupied by: ' + gs.getChar(tileIndex).type.name);
		return null;	
	}
	
	for (let i = 0; i < this.npcPool.length; i += 1) {
		if (!this.npcPool[i].isAlive && !this.inArray(this.npcPool[i], this.characterList)) {
			this.npcPool[i].init(tileIndex, typeName, flags);
			return this.npcPool[i];
		}
	}
	
	// Pool size exceeded:
	this.npcPool.push(new NPC());
	this.npcPool[this.npcPool.length - 1].init(tileIndex, typeName, flags);
	
	
	return this.npcPool[this.npcPool.length -1];
};

// CONSTRUCTOR:
// ************************************************************************************************
function NPC() {
	this.createSharedProperties();
	this.isAlive = false;
}
NPC.prototype = new Character();

// INIT:
// ************************************************************************************************
NPC.prototype.init = function (tileIndex, typeName, flags) {
	ASSERT_EQUAL(gs.npcTypes.hasOwnProperty(typeName), true, 'Invalid npcTypeName: ' + typeName);
	ASSERT_EQUAL(gs.getChar(tileIndex), null, 'TileIndex is already occupied');
	
	// Default Flags:
	flags = flags || {isAsleep: false, npcClassType: null, isWandering: false};
	
	// Type and name:
	this.type = gs.npcTypes[typeName];
	this.name = this.type.name;
	
	// Setting ID:
	if (flags.id) {
		this.id = flags.id;
	}
	else {
		this.id = gs.nextCharacterID;
		gs.nextCharacterID += 1;
	}
	
	// Negate Sleep:
	if (this.type.neverSleep) {
		flags.isAsleep = false;
	}
	
	// Negate Wandering:
	if (flags.isAsleep || this.type.neverWander) {
		flags.isWandering = false;
	}

	// Property Flags:
	this.isAlive = true;
	this.isAgroed = false;
	this.faction = this.type.faction;
	this.isAsleep = Boolean(flags.isAsleep);
	this.npcClassType = flags.npcClassType;
	this.isWandering = Boolean(flags.isWandering);
	this.isRunning = false;
	this.isFlying = Boolean(this.type.isFlying);
	this.burstDamage = flags.burstDamage || 0;
	this.actionQueue = [];
	this.moveDelta = {x: 0, y: 0};
	this.timeToHatch = 0;
	this.poisonDamage = 0;
	
	// Event Queue:
	this.eventTimer = 0;
	this.eventQueue = [];
	
	// Summon Properties:
	this.summonerID = flags.summonerID || null; // Summoned creatures store their owner here
	this.summonIDList = []; 					// The summoner stores all summoned creatures so they can poof upon death.
	this.summonDuration = 20;				// The duration before a summon creature will naturally poof
	
	// Hiding (only used for submerged enemies right now)
	if (this.type.startHidden) {
		this.isHidden = true;
		this.isAsleep = false;
	} 
	else {
		this.isHidden = false;
	}
	
	// AI:
	this.unagroTimer = 0;
	this.wanderVector = {x: util.randInt(-1, 1), y: util.randInt(-1, 1)};
	
	
	// Set Level and stats:
	this.level = flags.level || this.type.level;
	if (this.type.hitPointType) {
		this.maxHp = gs.npcMaxHp(this.level, this.type.hitPointType);
	}
	else {
		this.maxHp = this.type.maxHp;
	}
	
	this.maxMp = this.type.maxMp;
	this.exp = this.type.exp;
	this.movementSpeed = this.type.movementSpeed;
	this.regenTimer = 0;

	
	
	// Elite:
	if (this.npcClassType) {
		this.name = this.npcClassType.name + ' ' + this.type.name;
		this.exp = this.type.exp * 4;	
	}
	
	// Abilities:
	this.abilities.clearAbilities();
	if (this.type.abilityTypes) {
		this.type.abilityTypes.forEach(function (abilityType) {
			this.abilities.addAbility(abilityType);
		}, this);
	}
	
	// Status effects:
	this.statusEffects = new StatusEffects(this);
	
	// Pop up queue:
	this.popUpTimer = 0;
	this.popUpQueue = [];
	
	// Sprite:
	this.sprite.frame = this.type.frame;
	this.sprite.angle = 0;
	this.ringSprite.frame = 0;
	
	// Light:
	if (this.type.light) {
		this.light = gs.createLightCircle(this.sprite.position, this.type.light.color, this.type.light.radius, 0, this.type.light.startAlpha);
		this.light.fade = false;
		this.light.noLife = true;
	}
	else {
		this.light = null;
	}
	
	// Push to lists:
	if (gs.inArray(this, gs.characterList)) {
		console.log('In characterList');
	}
	
	gs.characterList.push(this);

	// Place in tileMap:
	this.body.snapToTileIndex(tileIndex);
	this.facing = game.rnd.frac() <= 0.5 ? 'RIGHT' : 'LEFT';
	
	
	// Initial rotation facing:
	if (this.type.rotateAim) {
		this.rotFacing = util.randElem(['UP', 'DOWN', 'LEFT', 'RIGHT']);
		this.rotateToFace();
	}
	
	this.updateStats();
	this.currentHp = this.maxHp;
	this.currentMp = this.maxMp;

	
};


// DESTROY:
// ************************************************************************************************
NPC.prototype.destroy = function () {
	this.isAlive = false;
	
	this.sprite.visible = false;
	this.hpText.visible = false;
	this.ringSprite.visible = false;
	this.statusText.visible = false;
	
	this.statusEffects.removeAll();
	
	// Destroy Light:
	if (this.light) {
		this.light.destroy();
		this.light = null;
	}

	gs.getTile(this.tileIndex).character = null;
};

// USE_ABILITY:
// ************************************************************************************************
NPC.prototype.useAbility = function (ability) {
	var char;
	
	// Dodging attacks:
	char = gs.getChar(ability.target);
	if (char && this.isHostileToMe(char) && 
		char.previousTileIndex && 
		util.frac() < char.evasion * 0.10 &&
		ability.type.canUseOn(this, char.previousTileIndex)) {
		
		ability.type.useOn(this, char.previousTileIndex);
	}
	else {
		ability.type.useOn(this, ability.target);
	}
	
	ability.coolDown = ability.type.coolDown;
	this.currentMp -= ability.type.mana || 0;
	this.updateStats();
	
	
	this.endTurn(100);
};

// CAN_MOVE:
// ************************************************************************************************
NPC.prototype.canMove = function () {
	return !this.isImmobile && !this.type.cantMove;
};

// MOVE_TO:
// Call this function to either move to a tile index or open a door if one is there
// ************************************************************************************************
NPC.prototype.moveTo = function (tileIndex, y) {
	if (typeof tileIndex === 'number') {
		tileIndex = {x: tileIndex, y: y};
	}

	// Moving:
	if (gs.isPassable(tileIndex)) {
		// Stick sprite if off screen:
		if (!gs.getTile(tileIndex).visible && !gs.getTile(this.tileIndex).visible) {
			this.body.snapToTileIndex(tileIndex);
		}
		else {
			this.body.moveToTileIndex(tileIndex);
		}
	} 
	// Opening Door:
	else if (gs.getObj(tileIndex, obj => obj.isDoor() && !obj.isOpen)) {
		gs.getObj(tileIndex).interact(this);
	} 
	else {
		throw 'moveTo failed';
	}
	
	// Has NPC Acted:
	if (gs.getTile(this.tileIndex).visible && this.faction === FACTION.HOSTILE) {
		gs.hasNPCActed = true;
	}
	
	this.endTurn(this.moveTime);
};

// CAN_MOVE_TO_TILE:
// Returns true if the NPC can move to the tile without regards to the tiles contents.
// This is just to test flying and swimming creatures
// ************************************************************************************************
NPC.prototype.canMoveToTile = function (tileIndex) {
	
	// Never move out of bounds:
	if (!gs.isInBounds(tileIndex)) {
		return false;
	}
	
	// Swimming enemies can't move out of water:
	if (this.type.isSwimming && gs.getTile(tileIndex).type.name !== 'Water' && gs.getTile(tileIndex).type.name !== 'Lava') {
		return false;
	}
	
	if (this.type.isSwimming && gs.getObj(tileIndex, obj => obj.type.name === 'Ice')) {
		return false;
	}
	
	// Non-flying enemies will not move to pits
	if (gs.getTile(tileIndex).type.isPit && !this.isFlying) {
		return false;
	}
	
	return true;
};

// CAN_MOVE_TO:
// Call this function to see if the npc can move to the tile index or open a door there
// Important Note: this function does not consider whether the NPC can move to the tileIndex from their current position
// i.e. it simply tests if the tileIndex is valid given the NPCs behaviour type
// This means it can be passed into path finding to 'test ahead' of the NPC
// ************************************************************************************************
NPC.prototype.canMoveTo = function (tileIndex, y) {
	if (typeof tileIndex === 'number') {
		tileIndex = {x: tileIndex, y: y};
	}
	
	if (!this.canMoveToTile(tileIndex)) {
		return false;
	}
	
	// Players allies will not move onto dangerous terrain:
	if (this.faction === FACTION.PLAYER && !gs.isIndexSafe(tileIndex)) {
		return false;
	}

	if (gs.isPassable(tileIndex)) {
		return true;
	} 
	else if (gs.getObj(tileIndex, obj => obj.isDoor() && !obj.isOpen) && !gs.getObj(tileIndex, obj => obj.isGuarded || obj.isLocked || obj.isSealed)) {
		return true;
	} 
	else {
		return false;
	}
};

// DETECT_PLAYER_PERCENT:
// ************************************************************************************************
NPC.prototype.detectPlayerPercent = function () {
	var pcStealth,
		npcPerception,
		detectPct;

	// Higher pcStealth means the pc is harder to spot:
	pcStealth = gs.distance(gs.pc.tileIndex, this.tileIndex) + gs.pc.stealth * 2.6;

	
	// Can't see:
	if (gs.distance(gs.pc.tileIndex, this.tileIndex) > MAX_AGRO_RANGE || !gs.isRayClear(this.tileIndex, gs.pc.tileIndex)) {
		return 0;		
	}
	// Deep Sleep:
	if (this.statusEffects.has('DeepSleep')) {
		return 0;
	}
	// Sleeping:
	else if (this.isAsleep) {
		if (gs.distance(gs.pc.tileIndex, this.tileIndex) > 1) {
			return 0;
		}

		npcPerception = 1;

		
	}
	// Normal:
	else {
		npcPerception = MAX_AGRO_RANGE * 0.3 + (this.type.level - 1);
	}

	// perc === stealth => 0.5 chance to detect
	return Math.max(0, Math.min(0.95, (npcPerception / pcStealth) * 0.5));
};

// TRY_TO_AGRO_PLAYER:
// ************************************************************************************************
NPC.prototype.tryToAgroPlayer = function () {
	if (!gs.debugProperties.npcCanAgro) {
		return;
	}
	
	
	// Hidden mobs are a special case (player must be in their ambushDistance):
	if (this.isHidden) {
		if (gs.distance(this.tileIndex, gs.pc.tileIndex) <= this.type.ambushDistance) {
			this.popUpText('Ambush!', '#ffffff');
			this.spotAgroPlayer();
		}

	// Other mobs agro normally:
	} else {
		this.spotAgroPlayer();
	}
	
};

// SPOT_AGRO_PLAYER:
// Call when the NPC spots the player for the first time
// This causes the NPC to miss a turn
// ************************************************************************************************
NPC.prototype.spotAgroPlayer = function () {
	gs.ASSERT(!this.isAgroed, 'spotAgroPlayer called on an already agroed NPC');
	
	this.waitTime = 100;
	
	this.agroPlayer();
};

// AGRO_PLAYER:
// ************************************************************************************************
NPC.prototype.agroPlayer = function () {
	if (this.faction !== FACTION.HOSTILE) {
		return;
	}
	
	this.isHidden = false;
	this.unagroTimer = 0;
	this.isAgroed = true;
	this.isAsleep = false;
	this.statusEffects.onAgroPlayer();
	
	
};

// SHOUT:
// ************************************************************************************************
NPC.prototype.shout = function () {
	gs.shout(this.tileIndex, this.faction);
};



// UPDATE_TURN:
// ************************************************************************************************
NPC.prototype.updateTurn = function () {
	// Don't update dead npcs:
	if (!this.isAlive) {
		return;
	}

	// Lose agro:
	if (this.isAgroed && !gs.getTile(this.tileIndex).visible) {
		this.unagroTimer += 1;
		if (this.unagroTimer >= NPC_UNAGRO_TIME) {
			this.isAgroed = false;
		}
	}
	
	// Special type updateTurn function:
	if (this.type.updateTurn) {
		this.type.updateTurn.call(this);
	}
	
	// An NPC may kill itself during its update turn call and we need to return before proceding:
	if (!this.isAlive) {
		return;
	}
	
	if (this.npcClassType && this.npcClassType.updateTurn) {
		this.npcClassType.updateTurn.call(this);
	}
	
	// Summon Duration:
	if (this.summonerID) {
		this.reduceSummonDuration();
	}

	this.updateTurnBase();
	this.updateStats();
};

// REDUCE_SUMMON_DURATION:
// ************************************************************************************************
NPC.prototype.reduceSummonDuration = function () {
	// Use summon duration -1 to indicate no duration
	if (this.summonDuration === -1) {
		return;
	}
	
	this.summonDuration -= 1;
	
	if (this.summonDuration <= 0) {
		// Poof:
		gs.createParticlePoof(this.tileIndex, 'PURPLE');
		this.popUpText('Poof', '#ffffff');
		
		// Tell summoner I'm dead:
		if (gs.getCharWithID(this.summonerID)) {
			gs.removeFromArray(this.id, gs.getCharWithID(this.summonerID).summonIDList);
		}
		
		this.destroy();
	}
};

// FALL_DOWN_PIT:
// ************************************************************************************************
NPC.prototype.fallDownPit = function () {
	this.death();
};

// ON_ENTER_TILE:
// Called once the character has actually finished moving and entered the tile
// Note that his tileIndex is already correct as it was set when beginning the move
// ************************************************************************************************
NPC.prototype.onEnterTile = function () {
	this.onEnterTileBase();
};

// ON_TAKE_DAMAGE:
// ************************************************************************************************
NPC.prototype.onTakeDamage = function () {
	// Damaged npc's always agro player:
	this.agroPlayer();

	// Does the NPC start to run:
	if (this.shouldStartRunning()) {
		this.isRunning = true;
		this.popUpText('Running!', '#ffffff');
	}

	// On Hit Functions:
	if (this.currentHp > 0) {
		if (this.type.onHit) {
			this.type.onHit(this);
		}
		
		if (this.npcClassType && this.npcClassType.onHit) {
			this.npcClassType.onHit(this);
		}
	}
};


// LOSE_EXP:
// ************************************************************************************************
NPC.prototype.loseExp = function () {
	
};

// KILLED_EXP:
// How much exp does the NPC give when killed
// ************************************************************************************************
NPC.prototype.killedExp = function () {
	let ability = this.abilities.getAbility('SpawnNPC'),
		exp = this.exp;
	
	// Handle granting exp for a spawners unspawned NPCs:
	if (ability) {
		exp += this.currentMp * ability.type.numSpawned * gs.npcTypes[ability.type.npcTypeName].exp;
	}
	
	// Summoned creatures give no exp:
	if (this.summonerID) {
		exp = 0;
	}
	
	return exp;
};

// DEATH:
// ************************************************************************************************
NPC.prototype.death = function (damageType, flags) {
	var itemName, dropIndex;
	flags = flags || {};

	
	this.destroy();
	
	// Random chance to shout upon death:
	if (game.rnd.frac() < 0.5) {
		this.shout();
	}
	
	// Gaining experience
	gs.pc.gainExperience(this.killedExp());

	// Blood:
	if (!gs.getObj(this.tileIndex) && !this.type.noBlood && !gs.getTile(this.tileIndex).type.isPit) {
		gs.createObject(this.tileIndex, this.type.bloodTypeName);
	}
	
	// Rage:
	if (gs.pc.hasRage && flags.killer === gs.pc) {
		gs.pc.gainRage(1);
	}
	
	// Poof my summoned mobs:
	this.summonIDList.forEach(function (id) {
		if (gs.getCharWithID(id)) {
			gs.getCharWithID(id).popUpText('Poof', '#ffffff');
			gs.getCharWithID(id).death();
		}
	});
	
	// Tell my summoner I'm dead:
	if (this.summonerID && gs.getCharWithID(this.summonerID)) {
		gs.removeFromArray(this.id, gs.getCharWithID(this.summonerID).summonIDList);
	}
	
	// Remove Charm:
	if (gs.pc.statusEffects.has('NPCCharm') && gs.pc.statusEffects.get('NPCCharm').npcId === this.id) {
		gs.pc.statusEffects.remove('NPCCharm');
	}
	
	// Poof:
	gs.createParticlePoof(this.tileIndex);
	
	// Sound:
	gs.playSound(gs.sounds.death, this.tileIndex);
	
	// Shake:
	game.camera.shake(0.005, 100);
	game.camera.flash(0xffffff, 10);
	
	// onDeath Func:
	if (this.type.onDeath) {
		this.type.onDeath.use(this);
	}
	
	// Drop Loot:
	this.dropLoot();
	
	gs.hasNPCActed = true;
	
	// End turn:
	if (gs.activeCharacter === this) {
		this.endTurn(100);
	}
};

// DROP_LOOT:
// Call when an NPC dies to drop loot
// ************************************************************************************************
NPC.prototype.dropLoot = function () {
	var tileIndex;
	
	tileIndex = gs.getValidDropIndex(this.tileIndex);
	if (this.type.dropPercent && tileIndex) {
		if (game.rnd.frac() <= this.type.dropPercent) {
			if (game.rnd.frac() <= DROP_GOLD_PERCENT) {
				gs.createFloorItem(tileIndex, Item.createItem('GoldCoin', {amount: util.randInt(Math.ceil(gs.dropGoldAmount() / 2), gs.dropGoldAmount())}));
			} 
			else {
				gs.createRandomFloorItem(tileIndex);
			}
		}
	}
};

// GO_TO_SLEEP:
// ************************************************************************************************
NPC.prototype.goToSleep = function () {
	if (!this.type.damageImmune) {
		this.isAgroed = false;
		this.isAsleep = true;
	}
	
};

// TO_DATA:
// ************************************************************************************************
NPC.prototype.toData = function () {
	var data, i; 
	
	data = {
		id:				this.id,
		typeName: 		this.type.name,
		isAsleep: 		this.isAsleep,
		isAgroed:		this.isAgroed,
		isHidden:		this.isHidden,
		faction: 		this.faction,
		tileIndex: 		this.tileIndex,
		currentHp: 		this.currentHp,
		currentMp:		this.currentMp,
		summonerID:		this.summonerID,
		summonIDList:	this.summonIDList,
		summonDuration: this.summonDuration,
		actionQueue: 	this.actionQueue,
		timeToHatch:	this.timeToHatch,
		level:			this.level,
	};
	
	if (this.npcClassType) {
		data.npcClassName = this.npcClassType.name;
	}
	
	// Move Delta (for slow fire balls):
	if (this.moveDelta) {
		data.moveDelta = this.moveDelta;
	}
	
	if (this.burstDamage) {
		data.burstDamage = this.burstDamage;
	}
	
	// Abilities:
	data.coolDowns = [];
	for (i = 0; i < MAX_ABILITIES; i += 1) {
		if (this.abilities.list[i]) {
			data.coolDowns[i] = this.abilities.list[i].coolDown;
		}
		else {
			data.coolDowns[i] = 0;
		}
	}
	
	// Status Effects:
	data.statusEffects = this.statusEffects.toData();
	
	return data;
};

// LOAD_NPC:
// ************************************************************************************************
gs.loadNPC = function (data) {
	var npc, flags;
	
	flags = {
		id:			data.id,
		isAsleep: 	data.isAsleep,
		level:		data.level,
		
	};
	
	if (data.npcClassName) {
		flags.npcClassType = gs.npcClassTypes[data.npcClassName];
	}
	
	// Create NPC:
	npc = this.createNPC(data.tileIndex, data.typeName, flags);
	
	
	// Test for failure:
	if (!npc) {
		throw 'Failed to create NPC';
	}
	
	// For slow fire ball:
	if (data.moveDelta) {
		npc.moveDelta = data.moveDelta;
	}
	
	if (data.burstDamage) {
		npc.burstDamage = data.burstDamage;
	}

	npc.isAgroed = data.isAgroed;
	npc.summonerID = data.summonerID;
	npc.summonIDList = data.summonIDList;
	npc.summonDuration = data.summonDuration;
	npc.actionQueue = data.actionQueue;
	npc.faction = data.faction;
	npc.isHidden = data.isHidden;
	npc.timeToHatch = data.timeToHatch;
	
	// Set HP																			
	npc.currentHp = data.currentHp;
	npc.currentMp = data.currentMp;

	// Load Ability Cooldowns:
	for (let i = 0; i < MAX_ABILITIES; i += 1) {
		if (npc.abilities.list[i]) {
			npc.abilities.list[i].coolDown = data.coolDowns[i];
		}
	}
	
	// Load Status Effects:
	npc.statusEffects.loadData(data.statusEffects);
	
	
	
	
	return npc;
};

// END_TURN:
// ************************************************************************************************
NPC.prototype.endTurn = function (waitTime) {
	// End Turn:
	// Need to add test in case enemies try to end their turn twice in a single turn
	// This occurs during kite projectile attacks where an enemies both fires and moves
	
	if (waitTime === 0) {
		throw 'Invalid waittime';
	}
	
	if (gs.activeCharacter === this) {
		
		this.waitTime = waitTime;
		
		// NPCs ending their turn visible to the player will halt his queued actions:
		if (gs.pc.canSeeCharacter(this) && this.faction === FACTION.HOSTILE && !this.type.isHidden) {
			gs.hasNPCActed = true;
		}
		
		gs.endTurn();
	}	
};


NPC.prototype.hasTalent = function (talentName) {
	return false;
};

NPC.prototype.loseExp = function () {
	// Pass
};

// DESTROY_ALL_NPCS:
// ************************************************************************************************
gs.destroyAllNPCs = function () {
	gs.getAllNPCs().forEach(function (npc) {
		npc.destroy();
	}, this);
	
	// Clear character list:
	gs.removeDeadCharacters();
};




/*global gs, util*/
/*global NPC*/
/*global FACTION*/
/*global RANDOM_MOVE_PERCENT, KITE_RANGE, LOS_DISTANCE*/
/*jshint laxbreak: true, esversion: 6*/
'use strict';

// SHOULD_SKIP_TURN:
// ************************************************************************************************
NPC.prototype.shouldSkipTurn = function () {
	// Dead npcs skip turn:
	if (!this.isAlive) {
		return true;
	}

	// Stunned and sleeping npcs skip turn:
	// Hidden enemies never take a turn (remember that spot agro checks are made before testing this):
	if (this.isStunned || this.isAsleep || this.isHidden) {
		return true;
	}

	// Non agroed npcs skip turn unless they are wandering around:
	if (!this.isAgroed && !this.isWandering) {
		return true;
	}

	if (!this.isSlowProjectile && (this.faction === FACTION.NEUTRAL || this.faction === FACTION.DESTRUCTABLE)) {
		return true;
	}
};



// GET_NEW_FACING:
// ************************************************************************************************
NPC.prototype.getNewFacing = function (tileIndex) {
	var targetFace = this.getFacingToTarget(tileIndex);
	if (this.rotFacing === 'UP' && (targetFace === 'LEFT' || targetFace === 'DOWN')) {
		return 'LEFT';
	}
	if (this.rotFacing === 'UP' && targetFace === 'RIGHT') {
		return 'RIGHT';
	}
	if (this.rotFacing === 'LEFT' && (targetFace === 'DOWN' || targetFace === 'RIGHT')) {
		return 'DOWN';
	}
	if (this.rotFacing === 'LEFT' && targetFace === 'UP') {
		return 'UP';
	}
	if (this.rotFacing === 'DOWN' && (targetFace === 'RIGHT' || targetFace === 'UP')) {
		return 'RIGHT';
	}
	if (this.rotFacing === 'DOWN' && targetFace === 'LEFT') {
		return 'LEFT';
	}
	if (this.rotFacing === 'RIGHT' && (targetFace === 'UP' || targetFace === 'LEFT')) {
		return 'UP';
	}
	if (this.rotFacing === 'RIGHT' && targetFace === 'DOWN') {
		return 'DOWN';
	}
};

// GET_FACING_TO_TARGET:
// ************************************************************************************************
NPC.prototype.getFacingToTarget = function (tileIndex) {
	var angle = util.angleToFace(this.tileIndex, tileIndex);
	
	if (angle <= 270 && angle > 180) {
		return 'UP';
	} else if (angle <= 180 && angle > 90) {
		return 'RIGHT';
	} else if (angle <= 90 && angle > 0) {
		return 'DOWN';
	} else {
		return 'LEFT';
	}
};

// ROTATE_TO_FACE:
// ************************************************************************************************
NPC.prototype.rotateToFace = function () {
	if (this.rotFacing === 'UP') {
		this.sprite.angle = 180;
	} else if (this.rotFacing === 'DOWN') {
		this.sprite.angle = 0;
	} else if (this.rotFacing === 'LEFT') {
		this.sprite.angle = 90;
	} else {
		this.sprite.angle = 270;
	}
};


// PROCESS_ACTION_QUEUE:
// ************************************************************************************************
NPC.prototype.processActionQueue = function () {
	var action, tileIndex;
	
	// Get the next action in the queue:
	action = this.actionQueue.pop();
	tileIndex = action.tileIndex;
	
	// Moving:
	if (this.canMoveTo(tileIndex)) {
		gs.createCloud(this.tileIndex, 'Smoke', 0, 2);
		this.moveTo(tileIndex);
		
		// Reaching destination:
		if (action.type === 'DEATH') {
			gs.createExplosion(tileIndex, 1.5, this.burstDamage, {killer: this});
			this.death();
		}
	}
	// Hitting a wall or character:
	else {
		gs.createExplosion(this.tileIndex, 1.5, this.burstDamage, {killer: this});
		this.death();
	}
};

// CHOOSE_ACTION:
// ************************************************************************************************
NPC.prototype.chooseAction = function () {
	var validAbilityList, tileIndex = null, nearestHostile, char;

	if (this.body.state === 'MOVING') {
		return;
	}

	// Following an existing actionQueue:
	if (this.actionQueue && this.actionQueue.length > 0) {
		this.processActionQueue();
		return;
	}
	
	// NPC's detect player:
	if (!this.isAgroed && this.faction === FACTION.HOSTILE && util.frac() < this.detectPlayerPercent()) {
		this.tryToAgroPlayer();
		
		if (this.waitTime > 0) {
			this.endTurn(this.waitTime);
			return;
		}
	}
	
	// Allies are always counted as agroed i.e. active:
	if (this.faction === FACTION.PLAYER) {
		this.isAgroed = true;
	}

	// Skip turn:
	if (this.shouldSkipTurn()) {
		this.endTurn(100);
		return;
	}
	
	// Monsters keep shouting for help when agroed:
	if (this.isAgroed && this.faction === FACTION.HOSTILE) {
		this.shout();
	}

	nearestHostile = this.getNearestHostile();
	
	// Stop running:
	if (this.isRunning && this.currentHp >= this.maxHp / 2 && !this.statusEffects.has('Feared')) {
		this.isRunning = false;
		this.agroPlayer();
	}
	
	// ROTATION:
	if (this.type.rotateAim && nearestHostile && this.rotFacing !== this.getFacingToTarget(nearestHostile.tileIndex)) {
		this.rotFacing = this.getNewFacing(nearestHostile.tileIndex);
		this.rotateToFace();
		this.endTurn(200);
		return;
	}
	
	// MOVEMENT:
	if (this.canMove()) {
		
		// SLOW_PROJECTILE:
		if (this.isSlowProjectile) {
			// Moving:
			if (this.canMoveTo(this.tileIndex.x + this.moveDelta.x, this.tileIndex.y + this.moveDelta.y)) {
				gs.createCloud(this.tileIndex, 'Smoke', 0, 2);
				this.moveTo(this.tileIndex.x + this.moveDelta.x, this.tileIndex.y + this.moveDelta.y);
			}
			// Hitting solid:
			else {
				if (this.statusEffects.has('SlowCharge')) {
					
					char = gs.getChar(this.tileIndex.x + this.moveDelta.x, this.tileIndex.y + this.moveDelta.y);
					if (char) {
						gs.meleeAttack(this, char.tileIndex, this.statusEffects.get('SlowCharge').damage, {neverMiss: true});
					}
					this.statusEffects.remove('SlowCharge');
					this.endTurn(100);
				}
				else {
					this.death();
				}
				
			}
			return;
		} 
		
		// RUN AWAY:
		if (this.isRunning && nearestHostile) {
			tileIndex = this.getMoveAwayIndex(nearestHostile);
			if (tileIndex) {
				this.moveTo(tileIndex);
				return;
			}
		}
		
		// SEEKING_MARKED_PLAYER:
		if (!this.isAgroed && this.isWandering && gs.pc.isMarked) {
			tileIndex = this.getMoveTowardsIndex(gs.pc.tileIndex);
			if (tileIndex) {
				this.moveTo(tileIndex);
				return;
			}
		}
		
		// WANDERING:
		if (!this.isAgroed && this.isWandering && !gs.pc.isMarked) {
			tileIndex = this.getWanderIndex();
			if (tileIndex) {
				this.moveTo(tileIndex);
				return;
			}
		}
		
		// MOVE_RANDOM:
		if (this.isAgroed && this.type.isRandomMover && util.frac() < RANDOM_MOVE_PERCENT) {
			tileIndex = this.getRandomMoveIndex();
			if (tileIndex) {
				this.moveTo(tileIndex);
				return;
			}
		}
		
		// MOVE_AWAY (KITING):
		if (this.isAgroed &&
			this.type.isKiter
			&& nearestHostile
			&& gs.distance(nearestHostile.tileIndex, this.tileIndex) <= KITE_RANGE
			&& gs.isRayPassable(this.tileIndex, nearestHostile)
			&& gs.getTile(this.tileIndex).visible
			&& util.frac() < 0.5) { // Changed 0.75 -> 0.5
			
			tileIndex = this.getMoveAwayIndex(nearestHostile);
			if (tileIndex) {
				this.moveTo(tileIndex);
				return;
			}
		}
	}
	
	// Use ability:
	if (this.isAgroed) {
		validAbilityList = this.getValidAbility();
		if (validAbilityList.length > 0) {
			// Returning to wait for player to complete movement
			if (gs.pc.body.state === 'MOVING') {
				this.state = 'PAUSE';
				return;
			}
			
			this.useAbility(util.randElem(validAbilityList));
			return;
		}
	}
	
	// MOVE_TOWARDS:
	if (this.isAgroed && this.canMove() && !this.isRunning) {
		if (nearestHostile) {
			// Kiters end their turn here:
			if (this.type.isKiter
				&& gs.distance(nearestHostile.tileIndex, this.tileIndex) <= KITE_RANGE + 1
				&& gs.isRayPassable(this.tileIndex, nearestHostile.tileIndex)) {
				this.endTurn(100);
				return;
			}
			
			// Moving to valid attack index (ranged enemies only):
			if (this.type.isKiter) {
				tileIndex = this.getNearestAttackIndex(nearestHostile);
				if (tileIndex) {
					tileIndex = this.getMoveTowardsIndex(tileIndex);
					if (tileIndex) {
						this.moveTo(tileIndex);
						return;
					}
				}
			}
			
			// Moving towards target:
			tileIndex = this.getMoveTowardsIndex(nearestHostile.tileIndex);
			if (tileIndex) {
				this.moveTo(tileIndex);
				return;
			}
		}
		
		// FOLLOW_PLAYER (ALLIES):
		if (this.faction === FACTION.PLAYER) {
			tileIndex = this.getMoveTowardsIndex(gs.pc.tileIndex);
			if (tileIndex) {
				this.moveTo(tileIndex);
				return;
			}
		}
		
		// As a last resort, agroed npcs try to move towards the player:
		tileIndex = this.getMoveTowardsIndex(gs.pc.tileIndex);
		if (tileIndex) {
			this.moveTo(tileIndex);
			return;
		}
		
	}

	// End Turn:
	this.endTurn(100);
};


// GET_NEAREST_HOSTILE:
// ************************************************************************************************
NPC.prototype.getNearestHostile = function () {
	var list = gs.characterList.slice(0);
	
	if (this.isConfused) {
		list = list.filter(char => char.faction === FACTION.HOSTILE || char.faction === FACTION.PLAYER);
	}
	else if (this.faction === FACTION.PLAYER) {
		list = list.filter(char => char.faction === FACTION.HOSTILE);
		list = list.filter(char => char.isAgroed);
	}
	else if (this.faction === FACTION.HOSTILE) {
		list = list.filter(char => char.faction === FACTION.PLAYER);
	}
	else {
		list = [];
	}
	
	list = list.filter(char => char !== this);
	list = list.filter(char => gs.distance(char.tileIndex, this.tileIndex) <= LOS_DISTANCE + 1);
	list = list.filter(char => gs.isRayClear(char.tileIndex, this.tileIndex));
	
	// Sorting to find nearest:
	list.sort((a, b) => gs.distance(this.tileIndex, a.tileIndex) - gs.distance(this.tileIndex, b.tileIndex));
	
	return list.length > 0 ? list[0] : null;
};

// GET_VALID_ABILITY:
// ************************************************************************************************
NPC.prototype.getValidAbility = function () {
	var validAbilities;

	validAbilities = this.abilities.list.filter(ability => ability);
	
	// Checking Energy and Cooldowns:
	validAbilities = validAbilities.filter(ability => ability.coolDown === 0);
	validAbilities = validAbilities.filter(ability => ability.type.mana <= this.currentMp);
	validAbilities = validAbilities.filter(ability => ability.type.canUse(this));

	// Finding a valid target:
	// Note: storing target in case getTarget uses rnd as in the case of projectiles:
	// No possible target will simply return null i.e. will not pass the filter
	validAbilities = validAbilities.filter(function (ability) {	
		ability.target = ability.type.getTarget(this);
		
		// Special test when targeting the player to make sure he is actually visible:
		if (ability.target && gs.vectorEqual(ability.target, gs.pc.tileIndex) && !gs.getTile(this.tileIndex).visible) {
			return false;
		}
		
		return ability.target;
	}, this);

	validAbilities = validAbilities.filter(ability => !ability.type.shouldUseOn || ability.type.shouldUseOn(this, ability.target));
	return validAbilities;
	
};


// GET_WANDER_INDEX:
// ************************************************************************************************
NPC.prototype.getWanderIndex = function () {
	var toTileIndex = {x: this.tileIndex.x + this.wanderVector.x,
					   y: this.tileIndex.y + this.wanderVector.y};

	if (this.canMoveTo(toTileIndex) && gs.isIndexSafe(toTileIndex)) {
		// Changing direction:
		if (util.frac() < 0.05) {
			this.wanderVector = this.newWanderVector();
		}
		
		return toTileIndex;
	}
	// Hit a wall:
	else {
		this.wanderVector = this.newWanderVector();
	}
	
	return null;
};

// NEW_WANDER_VECTOR:
// ************************************************************************************************
NPC.prototype.newWanderVector = function () {
	var vec = {};

	// Move to player:
	if (util.frac() < 0.10) {
		if (this.tileIndex.x < gs.pc.tileIndex.x) {
			vec.x = 1;
		} else if (this.tileIndex.x > gs.pc.tileIndex.x) {
			vec.x = -1;
		} else {
			vec.x = 0;
		}

		if (this.tileIndex.y < gs.pc.tileIndex.y) {
			vec.y = 1;
		} else if (this.tileIndex.y > gs.pc.tileIndex.y) {
			vec.y = -1;
		} else {
			vec.y = 0;
		}

		// Random move:
	} else {
		vec = {x: util.randInt(-1, 1), y: util.randInt(-1, 1)};
	}
	return vec;
};

// GET_MOVE_TOWARDS_INDEX:
// Returns the tileIndex that will move the NPC closest towards targetTileIndex
// ************************************************************************************************
NPC.prototype.getMoveTowardsIndex = function (targetTileIndex) {
	var path;

	if (this.tileIndex.x !== targetTileIndex.x || this.tileIndex.y !== targetTileIndex.y) {
		path = gs.findPath(this.tileIndex, targetTileIndex, {
			allowDiagonal: this.movementSpeed !== 0,
			avoidTraps: false,
			exploredOnly: false,
			passDoors: true,
			canWalkFunc: this.canMoveTo.bind(this),
			maxDepth: 100
		});
		
		// A* Path:
		if (path && path.length > 0 && path.length < 20 && this.canMoveTo(path[path.length - 1])) {
			return path[path.length - 1];
		}
		// Niave Path:
		else {
			// Right:
			if (this.tileIndex.x < targetTileIndex.x && this.canMoveTo(this.tileIndex.x + 1, this.tileIndex.y)) {
				return {x: this.tileIndex.x + 1, y: this.tileIndex.y};
			}
			// Left:
			else if (this.tileIndex.x > targetTileIndex.x && this.canMoveTo(this.tileIndex.x - 1, this.tileIndex.y)) {
				return {x: this.tileIndex.x - 1, y: this.tileIndex.y};
			}
			// Up:
			else if (this.tileIndex.y > targetTileIndex.y && this.canMoveTo(this.tileIndex.x, this.tileIndex.y - 1)) {
				return {x: this.tileIndex.x, y: this.tileIndex.y - 1};
			}
			// Down:
			else if (this.tileIndex.y < targetTileIndex.y && this.canMoveTo(this.tileIndex.x, this.tileIndex.y + 1)) {
				return {x: this.tileIndex.x, y: this.tileIndex.y + 1};
			}
		}
	}
	
	return null;
};

// GET_MOVE_AWAY_INDEX:
// Get an index which will move this character away from hostileCharacter
// ************************************************************************************************
NPC.prototype.getMoveAwayIndex = function (hostileCharacter) {
	var indexList;
	
	indexList = gs.getIndexInRadius(this.tileIndex, 1);
	indexList = indexList.filter(index => this.canMoveTo(index));
	
	// No tiles to go to:
	if (indexList.length === 0) {
		return null;
	}
	
	// Find the tile thats furthest from the player:
	indexList.sort((a, b) => gs.distance(hostileCharacter.tileIndex, b) - gs.distance(hostileCharacter.tileIndex, a));
	
	if (gs.distance(hostileCharacter.tileIndex, indexList[0]) > gs.distance(hostileCharacter.tileIndex, this.tileIndex)) {
		return indexList[0];
	} 
	else {
		return null;
	}
};

// GET_RANDOM_MOVE_INDEX:
// ************************************************************************************************
NPC.prototype.getRandomMoveIndex = function () {
	var indexList;
	
	indexList = gs.getIndexListAdjacent(this.tileIndex);
	indexList = indexList.filter(index => this.canMoveTo(index));
	
	return indexList.length > 0 ? util.randElem(indexList) : null;
};

// GET_NEAREST_ATTACK_INDEX:
// ************************************************************************************************
NPC.prototype.getNearestAttackIndex = function (nearestHostile) {
	var indexList, pred;
	
	pred = function (tileIndex) {
		return this.canMoveTo(tileIndex);
	}.bind(this);
	
	indexList = gs.getIndexInFlood(this.tileIndex, pred, 3);
	indexList = indexList.filter(index => gs.isRayPassable(index, nearestHostile.tileIndex));
	indexList.sort((a, b) => gs.distance(this.tileIndex, a) - gs.distance(this.tileIndex, b));
	
	return indexList.length > 0 ? indexList[0] : null;
};


// SHOULD_START_RUNNING:
// ************************************************************************************************
NPC.prototype.shouldStartRunning = function () {
	return this.currentHp > 0 
		&& this.currentHp <= Math.round(this.maxHp * 0.25) 
		&& util.frac() <= 0.25 
		&& !this.statusEffects.has('Berserk') 
		&& !this.type.neverRun;
};/*global Phaser, game, gs, localStorage, util*/
/*global levelController, Item, CharacterInventory, help*/
/*global console, isNaN, TILE_SIZE*/
/*global ItemSlot, ItemSlotList, Abilities, Character*/
/*global MAX_LEVEL, FOOD_TIME, INVENTORY_SIZE, EXTENDED_WAIT_TURNS, FONT_NAME, SKILL_NAMES*/
/*global MIN_MOVE_TIME, MOVE_TIME, SKILL_POINTS_PER_LEVEL*/
/*global HP_PER_SKILL, MP_PER_SKILL, STEALTH_PER_SKILL, MAX_SKILL, COLD_TIME, MAX_COLD_LEVEL, FREEZING_DAMAGE*/
/*global PLAYER_FRAMES, TALENT_POINT_LEVELS, RAGE_DECREASE_TURNS, CONFUSION_RANDOM_MOVE_PERCENT*/
/*global FACTION, MAX_ABILITIES, MAX_PLAYER_SLEEP_TIME*/
/*global INVENTORY_WIDTH, INVENTORY_HEIGHT, CHARACTER_SIZE*/
/*global WEAPON_HOT_BAR_WIDTH, WEAPON_HOT_BAR_HEIGHT, ZONE_FADE_TIME*/
/*jshint white: true, laxbreak: true, esversion: 6, loopfunc: true*/
'use strict';

// CREATE_PLAYER_CHARACTER:
// ************************************************************************************************
gs.createPlayerCharacter = function () {
	this.pc = new PlayerCharacter();
	this.characterList.push(this.pc);
};

// CONSTRUCTOR:
// ************************************************************************************************
function PlayerCharacter() {
	this.type = {
		name: 'Player',
		niceName: 'Player',
		frame: 656,
		movementSpeed: 1,
		protection: 0,
		resistance: {
			Fire: 0,
			Cold: 0,
			Toxic: 0,
			Shock: 0
		},
		bloodTypeName: 'Blood',
		damageShield: 0,
		evasion: 1,
		reflection: 0,
		size: CHARACTER_SIZE.MEDIUM,
		effectImmune: []
	};
	
	this.createSharedProperties();
	this.name = 'Player';
	this.isExploring = false;
	this.characterClass = null;
	this.numDeaths = 0;
	this.fastMove = false;
	this.faction = FACTION.PLAYER;
	this.previousTileIndex = null;
	this.summonIDList = [];
	this.keyHoldTime = 0;
	this.attackDelay = 0; // Use this in order to stop double speed strafe attacks
	
	this.id = gs.nextCharacterID;
	gs.nextCharacterID += 1;
	
	// Exp:
	this.exp = gs.expPerLevel[1]; // Due to skills, level 1 actually requires 20 exp
	this.level = 1;

	// Talents:
	this.talentPoints = 0;
	this.talents = [];
	this.availableTalents = [];
	
	// Skill:
	this.skillPoints = 0;
	
	// Religion:
	this.religion = null;
	
	// Rage:
	this.rageTimer = 0;
	this.rage = 0;
	
	// Sleep:
	this.sleepTime = 0;

	// Permanent Bonuses:
	this.permanentHpBonus = 0;
	this.permanentMpBonus = 0;
	
	// Inventory:
	this.inventory = new CharacterInventory(this);

	// Timers:
	this.starveTimer = 0;
	this.foodTimer = 0;
	this.foodTextTimer = 0;
	this.coldTimer = 0;
	this.regenTimer = 0;
	
	// Event Queue:
	this.eventTimer = 0;
	this.eventQueue = [];
	
	// Cold Level: 0=Normal, 1=Cold, 2=Freezing (take damage)
	this.coldLevel = 0;

	// Click Queue:
	this.actionQueue = [];

	// Update stats before game begins:
	this.updateStats();
	this.currentHp = this.maxHp;
	this.currentFood = this.maxFood;
	this.poisonDamage = 0;
}
PlayerCharacter.prototype = new Character();

// ON_ADD_ITEM:
// ************************************************************************************************
PlayerCharacter.prototype.onAddItem = function (item) {
	// Popup Text:
	if (gs.turn > 0 && !gs.inArray(item.name, ['HealingShroom', 'EnergyShroom'])) {
		this.queuePopUpText(item.toShortDesc(), '#ffffff');
	}
	
	gs.HUD.refresh();
};

// DROP_ITEM:
// Drops an item (from the cursor).
// This function does not actually remove the item from the inventory but rather places it below the players feet or as close as possible
// ************************************************************************************************
PlayerCharacter.prototype.dropItem = function (item) {
	var indexList, floorItem;
	
	indexList = gs.getIndexInFlood(this.tileIndex, gs.isStaticPassable.bind(gs), 10);
	indexList = indexList.filter(index => !gs.getItem(index));
	
	floorItem = gs.createFloorItem(indexList[0], item);
	floorItem.wasDropped = true;
};

// CAN_DROP_ITEM:
// ************************************************************************************************
PlayerCharacter.prototype.canDropItem = function () {
	var indexList;
	
	indexList = gs.getIndexInFlood(this.tileIndex, gs.isStaticPassable.bind(gs), 10);
	indexList = indexList.filter(index => !gs.getItem(index));
	
	return indexList.length > 0;
};

// UPDATE_TURN
// ************************************************************************************************
PlayerCharacter.prototype.updateTurn = function () {
	// Eat food:
	if (this.race.name !== 'Mummy') {
		if (this.foodTimer >= FOOD_TIME) {
			this.foodTimer = 0;
			// Eat food (don't die):  
			if (this.currentFood > 0) {
				this.currentFood -= 1;
			}
		} else {
			this.foodTimer += 1;
		}

		// Starving:
		this.starveTimer += 1;
		if (this.currentFood === 0 && this.starveTimer >= 3) {
			this.starveTimer = 0;
			this.takeDamage(1, 'None', {neverCrit: true});
		}

		// Show hunger messages:
		if (this.currentFood <= 3 && this.foodTextTimer >= 10) {
			this.foodTextTimer = 0;
			this.popUpText('HUNGRY',  '#ff0000');
		} 
		else if (this.currentFood <= 1 && this.foodTextTimer >= 10) {
			this.popUpText('VERY HUNGRY', '#ff0000');
			this.foodTextTimer = 0;
		} 
		else if (this.foodTextTimer < 10) {
			this.foodTextTimer += 1;
		}
	}
	
	// Sleep:
	if (this.isAsleep) {
		this.popUpText('Sleeping', '#ffffff');
		this.sleepTime += 1;
		
		if (this.sleepTime > MAX_PLAYER_SLEEP_TIME) {
			this.sleepTime = 0;
			this.isAsleep = false;
		}
	}
	
	// Cold:
	if (gs.zoneType().isCold) {
		this.coldTimer += 1;
		if (this.coldTimer > COLD_TIME) {
			this.coldTimer = 0;
			if (this.coldLevel < MAX_COLD_LEVEL) {
				this.coldLevel += 1;
			} 
			else {
				this.takeDamage(FREEZING_DAMAGE, 'Cold', {killer: 'Freezing', neverCrit: true});
			}
		}
	} 
	else {
		this.coldLevel = 0;
	}
	
	// Religion:
	if (this.religion && gs.religionTypes[this.religion].onTurn) {
		gs.religionTypes[this.religion].onTurn(this);
	}

	// Rage:
	if (this.hasRage && this.rage > 0) {
		this.rageTimer += 1;
		if (this.rageTimer >= RAGE_DECREASE_TURNS) {
			this.rage -= 1;
			this.rageTimer = 0;
		}
	} 
	else {
		this.rageTimer = 0;
	}
	
	// Charging charms:
	this.inventory.onUpdateTurn();
	
	if (!gs.help.rest && this.currentHp < this.maxHp / 2 && gs.numVisibleNPCs() === 0) {
		help.restDialog();
	}
	
	this.updateTurnBase();
	this.updateStats();
};

// IS_READY_FOR_INPUT:
// ************************************************************************************************
PlayerCharacter.prototype.isReadyForInput = function () {
	return gs.activeCharacter === this
		&& gs.projectileList.length === 0
		&& !this.isMultiMoving
		&& this.currentHp > 0;
};

// IS_SQUEEZE_MOVE:
// Returns true when the player is slow, the tileIndex is diagonally adjacent, and moving there would require a 'squeeze' move
// ************************************************************************************************
PlayerCharacter.prototype.isSqueezeMove = function (tileIndex) {
	var isDiagonal;
	
	isDiagonal = function (dx, dy) {
		return this.tileIndex.x === tileIndex.x - dx 
			&& this.tileIndex.y === tileIndex.y - dy 
			&& !gs.isStaticPassable(tileIndex.x - dx, tileIndex.y) 
			&& !gs.isStaticPassable(tileIndex.x, tileIndex.y - dy);
	}.bind(this);
	
	return this.movementSpeed === 0
		&& this.canMoveTo(tileIndex)
		&& (isDiagonal(-1, -1) || isDiagonal(-1, 1) || isDiagonal(1, -1) || isDiagonal(1, 1));
};

// CLICK_TILE_INDEX:
// ************************************************************************************************
PlayerCharacter.prototype.clickTileIndex = function (tileIndex, exploredOnly, fastMove = false, rightClick = false) {
	var path, i;

    // Skip if its not the players turn:
    if (gs.activeCharacter !== this || gs.projectileList.length > 0 || this.isMultiMoving) {
        return;
    }
	
	// Skip if tileIndex is out of bounds:
	if (!gs.isInBounds(tileIndex)) {
		return;
	}
	
	this.fastMove = fastMove;
	this.actionQueue = [];
	this.isExploring = false;
	this.attackOnEnterTile = false;
	
	// Confusion:
	if (!gs.vectorEqual(tileIndex, this.tileIndex) && this.isConfused ) {
		if (util.frac() <= CONFUSION_RANDOM_MOVE_PERCENT) {
			tileIndex = this.getConfusedClickTileIndex();
		}
		gs.hasNPCActed = true;
	}
	
	// Right click:
	if (rightClick) {
		if (this.inventory.getQuickWeapon() && this.canAttack(tileIndex, this.inventory.getQuickWeapon())) {
			this.quickWeaponAttack(tileIndex);
		}
	}
	// Use Ability:
	else if (gs.state === 'USE_ABILITY_STATE' && this.canZap(tileIndex)) {
		this.zap(tileIndex);
		gs.keyBoardMode = false;
	}
	// Waiting:
	else if (gs.getTile(tileIndex) && gs.getChar(tileIndex) === this && gs.state === 'GAME_STATE') {
		// Picking up item:
		if (gs.getItem(tileIndex) && this.inventory.canAddItem(gs.getItem(tileIndex).item)) {
			this.pickUpItem(gs.getItem(tileIndex));
		}
		// Waiting:
		else {
			this.waitClicked();
		}
		gs.keyBoardMode = false;	
	}
	// Attacking with range (out of range):
	else if (this.weaponSkill() === 'Range' && this.isVisibleHostileAt(tileIndex) && gs.distance(this.tileIndex, tileIndex) > this.weaponRange()) {
		this.popUpText('Out of Range', '#ff0000');
	}
	// Attacking with Range (out of mana):
	else if (this.weaponSkill() === 'Range' && this.isVisibleHostileAt(tileIndex) && this.inventory.getWeapon().type.mpCost && this.currentMp < this.inventory.getWeapon().type.mpCost) {
		this.popUpText('Out of mana', '#ff0000');
	}
	// Attacking with range (too close):
	else if (this.weaponSkill() === 'Range' && this.isVisibleHostileAt(tileIndex) && gs.distance(this.tileIndex, tileIndex) < this.weaponMinRange()) {
		this.popUpText('Too Close', '#ff0000');
	}
	// Attacking with Range (line blocked):
	else if (this.weaponSkill() === 'Range' && this.isVisibleHostileAt(tileIndex) && !this.canAttack(tileIndex)) {
		this.popUpText('No clear line', '#ff0000');
	}
	// Squeeze Move:
	else if (gs.state === 'GAME_STATE' && this.isSqueezeMove(tileIndex)) {
		this.moveTo(tileIndex, 200);
		this.popUpText('Squeeze', '#ffffff');
	}
	// Stop Slow characters from accidently diagonally moving:
	else if (gs.state === 'GAME_STATE'
			 && this.movementSpeed === 0
			 && gs.distance(this.tileIndex, tileIndex) > 1
			 && gs.sqDistance(this.tileIndex, tileIndex) === 1
			 && gs.numVisibleNPCs() > 0
			 && this.canMoveTo(tileIndex)) {
		return;	
	}
	// Else we push a list of clicks ending in the index:
	else if (gs.state === 'GAME_STATE') {
		path = this.getPathTo(tileIndex, exploredOnly);
		if (path && path.length > 0) {
			for (i = 0; i < path.length; i += 1) {
				this.actionQueue[i] = {type: 'CLICK', tileIndex: path[i], shift: gs.keys.shift.isDown || this.isConfused};
			}
			gs.keyBoardMode = false;
		}
		// Attacking: (takes care of no path to target ex. ice, pit):
		else if (this.canAttack(tileIndex)) {
			this.actionQueue[0] = {type: 'CLICK', tileIndex: tileIndex};
			gs.keyBoardMode = false;
		}
	}
};

// 	QUICK_WEAPON_ATTACK:
// ************************************************************************************************
PlayerCharacter.prototype.quickWeaponAttack = function (tileIndex) {
	this.attack(tileIndex, true, this.inventory.getQuickWeapon());
	gs.keyBoardMode = false;
	this.inventory.quickWeaponEquipped = true;
	this.updateStats();
};

// IS_VISIBLE_HOSTILE_AT:
// ************************************************************************************************
PlayerCharacter.prototype.isVisibleHostileAt = function (tileIndex) {
	var char = gs.getChar(tileIndex);
	return char && char !== this && this.canSeeCharacter(char) && char.isAlive && char.faction === FACTION.HOSTILE;
};

// WEAPON_SKILL:
// ************************************************************************************************
PlayerCharacter.prototype.weaponSkill = function (weapon) {
	weapon = weapon || this.inventory.getWeapon();
	return weapon.type.effect.skill;
};

// GET_CONFUSED_CLICK_TILE_INDEX:
// Used when the player is confused
// ************************************************************************************************
PlayerCharacter.prototype.getConfusedClickTileIndex = function () {
	var indexList = gs.getIndexInBox(this.tileIndex.x - 1, this.tileIndex.y - 1, this.tileIndex.x + 2, this.tileIndex.y + 2);
	indexList = indexList.filter(index => !gs.vectorEqual(index, this.tileIndex));
	indexList = indexList.filter(index => gs.isPassable(index) || this.canAttack(index));
	return util.randElem(indexList);
};

// GET_PATH_TO:
// ************************************************************************************************
PlayerCharacter.prototype.getPathTo = function (tileIndex, exploredOnly) {
	return gs.findPath(this.tileIndex, tileIndex, {
		allowDiagonal: this.movementSpeed > 0,
		avoidTraps: gs.isIndexSafe(this.tileIndex, this),
		exploredOnly: exploredOnly,
		passDoors: true,
		canWalkFunc: this.canWalk.bind(this),
		maxDepth: 1000,
		character: this
	});
};

// CAN_WALK:
// ************************************************************************************************
PlayerCharacter.prototype.canWalk = function (tileIndex) {
	if (gs.getTile(tileIndex).type.isPit && !this.isFlying) {
		return false;
	}
	
	return true;
};

// CHOOSE_ACTION
// ************************************************************************************************
PlayerCharacter.prototype.chooseAction = function () {
	var path, tileIndex, click;

	// Frozen or trapped skips turn:
	if (this.isStunned || this.isAsleep) {
		gs.pauseTime = 30;
		this.endTurn(100);
		return;
	}
	
	// Exploration:
	// Grabbing new unexplored tile indices and 'clicking' on them:
	if (this.isExploring && this.body.state === 'WAITING' && this.actionQueue.length === 0) {
		this.startExploring();
	}
	
	this.keyBoardControls();

	// Process click queue:
	if (this.body.state === 'WAITING' && this.actionQueue.length > 0) {
		// If its possible to complete the click queue ahead of schedule:
		if (this.tryToCompleteactionQueue()) {
			this.actionQueue = [];
			return;
		}

		// Get the next action the player has queued:
		click = this.actionQueue.pop();

		// Waiting action:
		if (click.type === 'WAIT') {
			this.endTurn(100);
			return;
		}

		// Click tile Index action:
		tileIndex = click.tileIndex;

		// Attacking:
		if (!click.shift && this.canAttack(tileIndex)) {
			this.attack(tileIndex);
		}
		// Doors:
		else if (gs.getObj(tileIndex, obj => obj.isDoor()) && this.canInteract(tileIndex)) {
			this.interact(tileIndex);
			if (this.actionQueue.length > 0) {
				path = this.getPathTo(this.actionQueue[0].tileIndex, false);
				if (path && path.length > 0) {
					for (let i = 0; i < path.length; i += 1) {
						this.actionQueue[i] = {type: 'CLICK', tileIndex: path[i]};
					}
				}
			}
		}
		// Items:
		else if (this.canReachItem(tileIndex)) {
			this.tryToPickUpItem(tileIndex);
		}
		// Interact:
		else if (this.canInteract(tileIndex)) {
			this.interact(tileIndex);
		}
		// Dangerous Terrain:
		else if (this.canMoveTo(tileIndex) && gs.isIndexSafe(this.tileIndex, this) && !gs.isIndexSafe(tileIndex, this) && !click.shift) {
			this.stopExploring();
			
			if (!gs.help.unsafeMove) {
				help.unsafeMoveDialog();
			}
			else {	
				this.popUpText('Dangerous Terrain', '#ffffff');
			}
		}
		// Charmed moving:
		else if (this.cantMoveFromCharm(tileIndex)) {
			this.popUpText('Cant run!', '#ffffff');
		}
		// Pit:
		else if (this.canJumpInPit(tileIndex)) {
			this.jumpInPit(tileIndex);
		}
		// Dialog:
		else if (this.canTalk(tileIndex)) {
			this.talk(tileIndex);
		}
		
		// Moving:
		else if (this.canMoveTo(tileIndex)) {
			this.moveTo(tileIndex);
		}
	}
};

// CANT_MOVE_FROM_CHARM:
// ************************************************************************************************
PlayerCharacter.prototype.cantMoveFromCharm = function (tileIndex) {
	var npc;
	
	if (this.statusEffects.has('NPCCharm') && !this.isMultiMoving) {
		npc = gs.getCharWithID(this.statusEffects.get('NPCCharm').npcId);

		if (gs.distance(tileIndex, npc.tileIndex) > gs.distance(this.tileIndex, npc.tileIndex) + 0.5) {
			return true;
		}
	}
	
	return false;
};

// KEYBOARD_CONTROLS:
// ************************************************************************************************
PlayerCharacter.prototype.keyBoardControls = function () {
	if (this.keyHoldTime !== 0 || gs.state !== 'GAME_STATE') {
		this.keyHoldTime -= 1;
		return;
	}
	
	if (gs.keys.numPad1.isDown || gs.keys.end.isDown) {
		this.clickTileIndex({x: this.tileIndex.x - 1, y: this.tileIndex.y + 1}, false, true);
		this.keyHoldTime = 10;
	}
	else if (gs.keys.numPad2.isDown || gs.keys.down.isDown) {
		this.clickTileIndex({x: this.tileIndex.x, y: this.tileIndex.y + 1}, false, true);
		this.keyHoldTime = 10;
	}
	else if (gs.keys.numPad3.isDown || gs.keys.pageDown.isDown) {
		this.clickTileIndex({x: this.tileIndex.x + 1, y: this.tileIndex.y + 1}, false, true);
		this.keyHoldTime = 10;
	}
	else if (gs.keys.numPad4.isDown || gs.keys.left.isDown) {
		this.clickTileIndex({x: this.tileIndex.x - 1, y: this.tileIndex.y}, false, true);
		this.keyHoldTime = 10;
	}
	else if (gs.keys.numPad6.isDown || gs.keys.right.isDown) {
		this.clickTileIndex({x: this.tileIndex.x + 1, y: this.tileIndex.y}, false, true);
		this.keyHoldTime = 10;
	}
	else if (gs.keys.numPad7.isDown || gs.keys.home.isDown) {
		this.clickTileIndex({x: this.tileIndex.x - 1, y: this.tileIndex.y - 1}, false, true);
		this.keyHoldTime = 10;
	}
	else if (gs.keys.numPad8.isDown || gs.keys.up.isDown) {
		this.clickTileIndex({x: this.tileIndex.x, y: this.tileIndex.y - 1}, false, true);
		this.keyHoldTime = 10;
	}
	else if (gs.keys.numPad9.isDown || gs.keys.pageUp.isDown) {
		this.clickTileIndex({x: this.tileIndex.x + 1, y: this.tileIndex.y - 1}, false, true);
		this.keyHoldTime = 10;
	}
};

// TRY_TO_COMPLETE_CLICK_QUEUE:
// ************************************************************************************************
PlayerCharacter.prototype.tryToCompleteactionQueue = function () {
	if (this.actionQueue[0].type === 'WAIT') {
		return false;
	}

	var tileIndex = this.actionQueue[0].tileIndex;

	// Attacking:
	if (this.canAttack(tileIndex) && !this.actionQueue[0].shift) {
		this.attack(tileIndex);
		return true;
	}

	return false;
};

// FALL_DOWN_PIT:
// ************************************************************************************************
PlayerCharacter.prototype.fallDownPit = function () {
	if (gs.nextLevel()) {
		gs.descendLevel();
		gs.pc.randomTeleport();
		gs.pc.popUpText('Fell down pit!', '#ffffff');
		gs.createParticlePoof(gs.pc.tileIndex, 'WHITE');
	}
	else {
		gs.pc.death(null, {killer: 'Pit'});
	}
	
};

// ON_ENTER_TILE:
// Called once the character has actually finished moving and entered the tile
// Note that his tileIndex is already correct as it was set when beginning the move
// ************************************************************************************************
PlayerCharacter.prototype.onEnterTile = function () {
	this.onEnterTileBase();

	if (this.attackOnEnterTile) {
		this.attackOnEnterTile = false;
		this.moveAttack(this.prevTileIndex, this.tileIndex);
	}
	
	// Pick Up Items:
	if (gs.getItem(this.tileIndex) && !this.isMultiMoving && !gs.getItem(this.tileIndex).wasDropped) {
		if (this.inventory.canAddItem(gs.getItem(this.tileIndex).item)) {
			this.pickUpItem(gs.getItem(this.tileIndex));
		}
		else {
			this.stopExploring();
			this.popUpText('Inventory Full', '#ffffff');
			gs.getItem(this.tileIndex).wasDropped = true;
		}
	}
	
	// Trigger Groups:
	if (gs.getTile(this.tileIndex).triggerGroup) {
		levelController.onTriggerGroup(gs.getTile(this.tileIndex).triggerGroup);
	}

	// Calc LoS:
	gs.calculateLoS();
	
	// Drop Walls:
	for (let i = 0; i < gs.dropWallList.length; i += 1) {
		if (gs.dropWallList[i].filter(index => gs.getTile(index).visible && gs.distance(this.tileIndex, index) <= 4).length === gs.dropWallList[i].length) {
			gs.explodeWall(gs.dropWallList[i]);
			gs.removeFromArray(gs.dropWallList[i], gs.dropWallList);
			break;
		}
	}
	
	// Interact with objects:
	if (this.canInteract(this.tileIndex)) {
		this.interact(this.tileIndex);
	}
	
	if (!gs.help.stairs && gs.getObj(this.tileIndex, 'DownStairs')) {
		help.stairsDialog();
	}
};

// CAN_REACH_ITEM:
// Seperate from walking over a tile and picking up an item
// ************************************************************************************************
PlayerCharacter.prototype.canReachItem = function (tileIndex) {
	return gs.getItem(tileIndex) 
		&& !gs.isPassable(tileIndex) 
		&& gs.distance(tileIndex, this.tileIndex) <= 1.5 
		&& !this.isMultiMoving;
};

// TRY_TO_PICK_UP_ITEM:
// ************************************************************************************************
PlayerCharacter.prototype.tryToPickUpItem = function (tileIndex) {
	if (this.inventory.canAddItem(gs.getItem(tileIndex).item)) {
		this.pickUpItem(gs.getItem(tileIndex));
	}
	else {
		this.popUpText('Inventory Full', '#ffffff');
		this.stopExploring();
		gs.getItem(tileIndex).wasDropped = true;
	}
};

// PICK_UP_ITEM:
// ************************************************************************************************
PlayerCharacter.prototype.pickUpItem = function (floorItem) {
	var item = floorItem.item;
	if (item.type.name === 'GoldCoin') {
		item.amount = Math.ceil(item.amount * this.goldMod);	
	}
	
	this.inventory.addItem(item);
	
	if (!floorItem.wasDropped && item.type.name !== 'GobletOfYendor') {
		this.gainExperience(gs.dangerLevel());
	}
	
	this.actionQueue = [];
	
	if (item.getSound()) {
		gs.playSound(item.getSound(), gs.pc.tileIndex);
	}
	
	gs.destroyFloorItem(floorItem);
	
	this.stopExploring();
	
	if (item.type.name === 'GoldCoin') {
		gs.createParticlePoof(floorItem.tileIndex, 'YELLOW', 10);	
	}
	
	if (gs.inArray(item.type.slot, ['shield', 'ring', 'body', 'feet', 'hands', 'head'])) {
		help.itemDialog();
	}
	if (item.type.slot === 'book') {
		help.bookDialog();
	}
	
	// Test victory condition:
	if (item.type.name === 'GobletOfYendor') {
		gs.playSound(gs.sounds.levelUp, gs.pc.tileIndex);
		gs.openVictoryMenu();
	}
	
	gs.HUD.miniMap.refresh();
};

// CAN_SWAP_WITH:
// Returns true if there is an ally at the tileIndex, and that ally can swap places with the player.
// Takes into account swimming creatures that cannot leave lava or water
// ************************************************************************************************
PlayerCharacter.prototype.canSwapWith = function (tileIndex) {
	return gs.isStaticPassable(tileIndex)
		&& gs.getChar(tileIndex)
		&& gs.getChar(tileIndex).faction === FACTION.PLAYER
		&& !gs.getChar(tileIndex).isImmobile
		&& !gs.getChar(tileIndex).isStunned
		&& gs.getChar(tileIndex).canMoveToTile(this.tileIndex);
};

// CAN_MOVE_TO:
// ************************************************************************************************
PlayerCharacter.prototype.canMoveTo = function (tileIndex) {
	if (this.isImmobile) {
		return false;
	}
	
	if (this.cantMoveFromCharm(tileIndex)) {
		return false;
	}
	
	if (gs.getTile(tileIndex).type.isPit && !this.isFlying) {
		return false;
	}
	
	return gs.isPassable(tileIndex) || this.canSwapWith(tileIndex);
};

// CAN_JUMP_IN_PIT:
// ************************************************************************************************
PlayerCharacter.prototype.canJumpInPit = function (tileIndex) {
	return gs.getTile(tileIndex).type.isPit && !this.isFlying;
};

// JUMP_IN_PIT:
// Called when the player intentionally clicks a pit
// ************************************************************************************************
PlayerCharacter.prototype.jumpInPit = function (tileIndex) {
	var pitFunc, dialog;
	
	pitFunc = function () {
		this.body.moveToTileIndex(tileIndex);
	}.bind(this);
	
	// Setup Dialog:
	dialog = [{}];
	dialog[0].text = 'Really jump into the pit?';
	dialog[0].responses = [
		{text: 'Yes', nextLine: 'exit', func: pitFunc},
		{text: 'No', nextLine: 'exit'},
	];
	
	gs.dialogMenu.open(dialog);
};

// MOVE_TO:
// ************************************************************************************************
PlayerCharacter.prototype.moveTo = function (tileIndex, moveTime) {	
	// Halt exploration:
	if (this.isExploring && !gs.isIndexSafe(tileIndex, this)) {
		this.stopExploring();
		return;
	}
		
	// Swap places:
	if (this.canSwapWith(tileIndex)) {
		gs.getChar(tileIndex).body.moveToTileIndex(this.tileIndex);
	}
		
	// Move Attack:
	this.attackOnEnterTile = false;
	this.prevTileIndex = {x: this.tileIndex.x, y: this.tileIndex.y};
	if (this.hasTalent('StrafeAttack') && !this.isMultiMoving) {
		this.attackOnEnterTile = true;
	}
		
	this.body.moveToTileIndex(tileIndex);
		
	if (!this.isMultiMoving || this.actionQueue.length === 0) {
		this.endTurn(moveTime || this.moveTime);
	}
};

// CAN_TALK:
// ************************************************************************************************
PlayerCharacter.prototype.canTalk = function (tileIndex) {
	var character = gs.getChar(tileIndex);
	return character 
		&& character.faction === FACTION.NEUTRAL
		&& gs.dialog[character.type.name]
		&& gs.distance(this.tileIndex, character.tileIndex) <= 1.5;
};

// TALK
// ************************************************************************************************
PlayerCharacter.prototype.talk = function (tileIndex) {
	gs.dialogNPC = gs.getChar(tileIndex);
	gs.dialogMenu.open();
};

// CAN_ATTACK:
// ************************************************************************************************
PlayerCharacter.prototype.canAttack = function (tileIndex, weapon) {
	var tile = gs.getTile(tileIndex),
		char = gs.getChar(tileIndex),
		canAttackChar,
		canShootTrap;
	
	weapon = weapon || this.inventory.getWeapon();
	
	// Out of mana:
	if (weapon.type.mpCost && this.currentMp < weapon.type.mpCost) {
		return false;
	}
	
	canAttackChar = char && 
					char.isAlive && 
					this.canSeeCharacter(char) && 
					(char.faction === FACTION.HOSTILE || char.faction === FACTION.DESTRUCTABLE) &&
					gs.distance(this.tileIndex, tileIndex) > this.weaponMinRange(weapon);
	
	canShootTrap = weapon.type.range > 1.5 && gs.canShootTrap(tileIndex) && tile.visible;
	
	return gs.isInBounds(tileIndex)
		&& (canAttackChar || canShootTrap)
		&& gs.distance(this.tileIndex, tileIndex) <= this.weaponRange(weapon)
		&& this.isAttackPassable(tileIndex, weapon);
};

// IS_ATTACK_PASSABLE:
// Stops us from having to do raycasts until last moment
// ************************************************************************************************
PlayerCharacter.prototype.isAttackPassable = function (targetTileIndex, weapon) {
	weapon = weapon || this.inventory.getWeapon();
	
	// Perfect Aim:
	if (this.hasTalent('PerfectAim') && weapon.type.effect === gs.weaponEffects.SingleProjectile) {
		return gs.isRayStaticPassable(this.tileIndex, targetTileIndex);
	}
	// Pole Arm:
	else if (weapon.type.effect === gs.weaponEffects.PoleArm) {
		return gs.isRayStaticPassable(this.tileIndex, targetTileIndex);
	}
	else {
		return gs.isRayPassable(this.tileIndex, targetTileIndex);
	}
};

// ATTACK:
// ************************************************************************************************
PlayerCharacter.prototype.attack = function (tileIndex, endTurn = true, weapon = null) {
	weapon = weapon || this.inventory.getWeapon();
	
	// Attacking character (takes priority):
	if (gs.getChar(tileIndex)) {
		weapon.type.effect.effect(tileIndex, weapon);
	}
	// Attacking trap w/ range:
	else if (this.weaponSkill(weapon) === 'Range' && gs.canShootTrap(tileIndex)) {
		weapon.type.effect.effect(tileIndex, weapon);
	}
	// Attacking trap w/ melee:
	else if (this.weaponSkill(weapon) === 'Melee' && gs.canShootTrap(tileIndex)) {
		this.body.faceTileIndex(tileIndex);
		this.body.bounceTowards(tileIndex);
		gs.getObj(tileIndex).stepOn(null);
	}
	else {
		throw 'Cannot attack tileIndex';
	}
	
	// Consuming mana from weapon (generally used for staves)
	if (weapon.type.mpCost && !gs.debugProperties.disableMana) {
		this.currentMp -= 1;
	}
	
	// Facing the target:
	this.body.faceTileIndex(tileIndex);

	// End Turn:
	if (endTurn) {
		this.endTurn(100);
	}
};

// AUTO_ATTACK:
// ************************************************************************************************
PlayerCharacter.prototype.autoAttack = function (rightClick = false) {
	var nearestNPC;
	
	if (gs.activeCharacter !== this || gs.projectileList.length > 0) {
		return;
	}
	
	nearestNPC = gs.getNearestVisibleNPC();
	
	if (nearestNPC) {
		gs.hasNPCActed = true;
		this.clickTileIndex(nearestNPC.tileIndex, true, true, rightClick);
	}
};

// MOVE_ATTACK:
// ************************************************************************************************
PlayerCharacter.prototype.moveAttack = function (prevTileIndex, toTileIndex) {
	var list;
	
	if (this.attackDelay > 0) {
		return;
	}
	
	list = this.getAttackableNPCs();
	
	// Only move attacking visible and hostile npcs:
	list = list.filter(npc => this.isHostileToMe(npc) && this.canSeeCharacter(npc) && npc.isAgroed); 
	
	// Never attack reflective enemies:
	if (this.weaponSkill() === 'Range') {
		list = list.filter(npc => npc.reflection === 0);
	}
	
	// Only npcs that we are not moving away from:
	list = list.filter(npc => gs.sqDistance(npc.tileIndex, prevTileIndex) - gs.sqDistance(npc.tileIndex, toTileIndex) >= 0);
	
	// Targeting the nearest enemy:
	list.sort((a, b) => gs.distance(prevTileIndex, a.tileIndex) - gs.distance(prevTileIndex, b.tileIndex));
		
	if (list.length > 0) {
		gs.hasNPCActed = true;
		this.attack(list[0].tileIndex, false);
		this.attackDelay = 100;
	}
};

// GET_ATTACKABLE_NPCS:
// Return a list of attackable npcs
// ************************************************************************************************
PlayerCharacter.prototype.getAttackableNPCs = function () {	
	return gs.getAllNPCs().filter(npc => gs.pc.canAttack(npc.tileIndex));
};

// CANNOT_USE_ABILITY:
// Returns a string (true) as to why player cannot use ability
// Returns false otherwise
// ************************************************************************************************
PlayerCharacter.prototype.cannotUseAbility = function (abilityIndex) {
	var ability = this.abilities.list[abilityIndex];

	// Confused:
	if (this.isConfused) {
		return 'Confused!';
	}
	
	// Cooldown not done:
	if (ability.coolDown > 0) {
		return 'Not Ready';
	}
	
	// Sustained abilities:
	if (ability.type.isSustained) {
		// Can always turn an ability off:
		if (ability.isOn) {
			return false;
		}
		// Not enough max mana:
		else if (ability.type.isSustained && !ability.isOn && this.maxMp < this.manaCost(ability.type)) {
			return 'Out of Mana';
		}
	} 
	// Mana no enough:
	else if (this.currentMp < this.manaCost(ability.type) && !gs.debugProperties.disableMana) {
		return 'Out of Mana';
	}
	
	
	// Hit Points not enough:
	if (this.currentHp <= ability.type.hitPointCost) {
		return 'Out of Health';
	}
	
	// Basic canUse requirement not met:
	if (!ability.type.canUse(this)) {
		return 'Cannot use';
	}
	
	// Charm has no charge:
	if (ability.type.itemType && this.inventory.getCharm().charges === 0) {
		return 'No charge';
	}
	
	return false;
};

// CLICK_ABILITY:
// ************************************************************************************************
PlayerCharacter.prototype.clickAbility = function (abilityIndex) {
	if (gs.activeCharacter !== this || !this.isReadyForInput() || !this.abilities.abilityInSlot(abilityIndex)) {
		return;
	}

	if (gs.state === 'USE_ABILITY_STATE') {
		gs.pc.cancelUseAbility();
		return;		
	}

	if (gs.state !== 'GAME_STATE') {
		return;
	}
	
	if (this.cannotUseAbility(abilityIndex)) {
		this.popUpText(this.cannotUseAbility(abilityIndex), '#ffffff');
		return;
	}
	
	// Set selectedAbility and selectedItem:
	this.selectedAbility = this.abilities.list[abilityIndex];

	// Turn off a sustained ability:
	if (this.selectedAbility.isOn) {
		this.selectedAbility.isOn = false;
		this.updateStats();
		this.popUpText(gs.capitalSplit(this.selectedAbility.type.name) + ' off', '#ffffff');
		this.endTurn(100);
	}
	// Turn on sustained ability:
	else if (this.selectedAbility.type.isSustained) {
		this.selectedAbility.isOn = true;
		this.popUpText(gs.capitalSplit(this.selectedAbility.type.name) + ' on', '#ffffff');
		this.updateStats();
		this.endTurn(100);
	}
	// Use Immediately:
	else if (this.selectedAbility.type.useImmediately) {
		this.zap();
		gs.keyBoardMode = false;
	} 
	// Switching to ability targeting state:
	else {
		gs.state = 'USE_ABILITY_STATE';
		
		gs.playSound(gs.sounds.spell, gs.pc.tileIndex);

		// Popup Text:
		this.popUpText(gs.capitalSplit(this.selectedAbility.type.name), '#ffffff');

		// Particle Generator:
		if (this.particleGenerator) {
			this.particleGenerator.isAlive = false;
		}

		if (this.selectedAbility.type.particleColor) {
			this.particleGenerator = gs.createCastingParticle(this.tileIndex, this.selectedAbility.type.particleColor);
		}
	}
};

// IS_ABILITY_ON:
// Is the sustained ability turned on?
// ************************************************************************************************
PlayerCharacter.prototype.isAbilityOn = function (abilityName) {
	var isOn = false;
	
	this.abilities.abilityList.forEach(function (ability) {
		if (ability.type.name === abilityName && ability.isOn) {
			isOn = true;
		}
	}, this);
	
	return isOn;
};

// CAN_ZAP:
// ************************************************************************************************
PlayerCharacter.prototype.canZap = function (tileIndex) {
	return gs.state === 'USE_ABILITY_STATE'
		&& gs.isInBounds(gs.cursorTileIndex)
		&& this.selectedAbility.type.canUse(this)
		&& this.selectedAbility.type.canUseOn(this, tileIndex);
};

// CAN_CONSERVE_MANA:
// ************************************************************************************************
PlayerCharacter.prototype.canConserveMana = function (abilityType) {
	return abilityType.magicType
		&& !abilityType.isSustained
		&& !abilityType.isSummon;
};

// MANA_COST:
// ************************************************************************************************
PlayerCharacter.prototype.manaCost = function (abilityType) {
	if (this.canConserveMana(abilityType) && this.manaConservation[abilityType.magicType]) {
		return abilityType.mana - this.manaConservation[abilityType.magicType];
	}
	else {
		return abilityType.mana;
	}
};

// ZAP:
// ************************************************************************************************
PlayerCharacter.prototype.zap = function (tileIndex) {
	var abilityType = this.selectedAbility.type;
	
	if (!abilityType.useImmediately && abilityType.range && gs.distance(this.tileIndex, tileIndex) > abilityType.range) {
		this.popUpText('Out of Range', '#ff0000');
		gs.state = gs.state === 'USE_ABILITY_STATE' ? 'GAME_STATE' : gs.state;
	} 
	else {
		// Use Ability:
		abilityType.useOn(this, tileIndex);

		// End Turn:
		gs.state = gs.state === 'USE_ABILITY_STATE' ? 'GAME_STATE' : gs.state;
		
		// Particles:
		if (abilityType.particleColor && !abilityType.noParticlePoof) {
			gs.createParticlePoof(this.tileIndex, abilityType.particleColor);
		}
		
		if (!abilityType.dontEndTurn) {
			this.endTurn(100);
		}
		
		// Set cooldown:
		if (abilityType.coolDown && !gs.debugProperties.disableMana) {
			this.selectedAbility.coolDown = abilityType.coolDown;
		}
		
		// Use Mana:
		if (abilityType.mana && !gs.debugProperties.disableMana) {
			if (game.rnd.frac() <= this.saveManaChance) {
				this.popUpText('Saved Mana', '#ffffff');
			} 
			else {
				this.currentMp -= this.manaCost(abilityType);
			}
		}
		
		// Use Hit Points:
		if (abilityType.hitPointCost) {
			this.takeDamage(abilityType.hitPointCost, 'None', {killer: this, neverCrit: true});
		}
		
		// Consumables (wands and scrolls):
		if (this.selectedItem) {
			// Charged wands:
			if (this.selectedItem.type.stats && this.selectedItem.type.stats.maxCharges) {
				this.selectedItem.charges -= 1;
				
				// Destroying wand:
				if (this.selectedItem.charges === 0) {
					this.inventory.removeItem(this.selectedItem);
				}
			}
			
			// Scrolls:
			if (!abilityType.itemType.stats || !abilityType.itemType.stats.maxCharges) {
				this.inventory.removeItem(this.selectedItem);
			}
		}
		// Charm:
		else if (abilityType.itemType && abilityType.itemType.slot === 'charm') {
			this.inventory.getCharm().charges -= 1;
		}
	}

	if (this.particleGenerator) {
		this.particleGenerator.isAlive = false;
	}

	this.selectedItem = null;
};



// CAN_INTERACT:
// ************************************************************************************************
PlayerCharacter.prototype.canInteract = function (tileIndex) {
	return gs.isInBounds(tileIndex)
		&& gs.getObj(tileIndex, obj => obj.canInteract(this));
};

// INTERACT:
// ************************************************************************************************
PlayerCharacter.prototype.interact = function (tileIndex) {
	// Adding a test so that the player does not end his turn when zoning:
	if (gs.getObj(tileIndex, obj => obj.isZoneLine || obj.type.name === 'Portal')) {
		gs.getObj(tileIndex).interact(this);
		
	} 
	else {
		gs.getObj(tileIndex).interact(this);

		// End Turn:
		this.endTurn(100);
	}
};

// USE_ZONE_LINE:
// ************************************************************************************************
PlayerCharacter.prototype.useZoneLine = function () {
	var func, zoneLine;
	
	if (gs.activeCharacter !== this || gs.state !== 'GAME_STATE' || game.camera.onFadeComplete.getNumListeners() > 0) {
		return;
	}
	
	zoneLine = gs.getObj(this.tileIndex);
	
	// Sealed zone line:
	if (zoneLine.isSealed) {
		this.popUpText('Sealed', '#ffffff');
		return;
	}
	
	func = function () {
		gs.zoneTo(zoneLine);
		game.camera.flash('#ffffff', ZONE_FADE_TIME * 2);
		game.camera.onFlashComplete.addOnce(function () {
			if (gs.state === 'ZONING_STATE') {	
				gs.setState('GAME_STATE');
			}
		}, this);
	};

	game.camera.fade('#000000', ZONE_FADE_TIME);
	game.camera.onFadeComplete.addOnce(func, this);
	gs.setState('ZONING_STATE');
};

// WEAPON_SLOT_CLICKED:
// ************************************************************************************************
PlayerCharacter.prototype.weaponSlotClicked = function (slot) {
	if (gs.activeCharacter !== this || !this.isReadyForInput()) {
		return;
	}
	
	if (slot.hasItem()) {
		this.inventory.lastWeaponIndex = this.inventory.weaponIndex;
		this.inventory.weaponIndex = slot.index;
		gs.playSound(this.inventory.getWeapon().getSound(), this.tileIndex);
		
		this.updateStats();
		this.onEquipItem(this.inventory.getWeapon());
		
		if (gs.state === 'CHARACTER_MENU_STATE') {
			gs.characterMenu.refresh();
		}
		else {
			this.popUpText(gs.capitalSplit(this.inventory.getWeapon().type.name), '#ffffff');
		}
	}
};

// ON_EQUIP_ITEM:
// ************************************************************************************************
PlayerCharacter.prototype.onEquipItem = function (item) {
	
	
	if (item.type.slot === 'charm' && item.type.useEffect) {
		this.addAbility(item.type.useEffect);
		item.charges = 0;
		item.chargeTimer = 0;
		
		if (gs.debugProperties.disableMana) {
			item.charges = 1;
		}
	}
	
	this.statusEffects.onChangeEquipment();
	this.updateTerrainEffects();
};

// ON_UNEQUIP_ITEM:
// ************************************************************************************************
PlayerCharacter.prototype.onUnequipItem = function (item) {
	
	
	if (item.type.slot === 'charm' && item.type.useEffect) {
		this.removeAbility(item.type.useEffect);
		item.charges = 0;
		item.chargeTimer = 0;
	}
	
	this.statusEffects.onChangeEquipment();
	this.updateTerrainEffects();
};

// CONSUMABLE_SLOT_CLICKED:
// ************************************************************************************************
PlayerCharacter.prototype.consumableSlotClicked = function (slot) {
	var itemType = slot.item.type;
	
	if (gs.activeCharacter !== this || !this.isReadyForInput()) {
		return;
	}
	
	// Block mummy eating:
	if (this.race.name === 'Mummy' && itemType.edible) {
		this.popUpText('Cannot Eat', '#ffffff');	
		return;
	}
	
	// Cancel use ability:
	if (gs.state === 'USE_ABILITY_STATE') {
		gs.pc.cancelUseAbility();
		return;		
	}
	
	// Sound:
	if (itemType.sound) {
		gs.playSound(itemType.sound, this.tileIndex);
	} 
	else {
		gs.playSound(gs.sounds.potion, this.tileIndex); 
	}
		
	// Effect happens immediately:
	if (itemType.useEffect && itemType.useEffect.useImmediately) {
		itemType.useEffect.useOn(this, null, slot.item);
		
		this.endTurn(100);
	}
	// Status Effect:
	else if (itemType.statusEffectName) {
		this.statusEffects.add(itemType.statusEffectName);
		this.endTurn(100);
	}
	// Ability:
	else {
		this.selectedAbility = {type: itemType.useEffect};
		this.selectedItem = slot.item;

		gs.state = 'USE_ABILITY_STATE';

		gs.playSound(gs.sounds.spell, gs.pc.tileIndex);
		
		// Popup Text:
		this.popUpText(gs.capitalSplit(this.selectedAbility.type.name), '#ffffff');


		// Particle Generator:
		if (this.particleGenerator) {
			this.particleGenerator.isAlive = false;
		}

		if (this.selectedAbility.type.particleColor) {
			this.particleGenerator = gs.createCastingParticle(this.tileIndex, this.selectedAbility.type.particleColor);
		}
	}
	
	// Use charges:
	if (slot.item.charges && itemType.useEffect && itemType.useEffect.useImmediately) {
		slot.item.charges -= 1;
			
		// Wands:
		if (slot.item.charges === 0) {
			slot.removeItem(1);
		}
	}
	// Remove consumable (not charges)
	// Testing for USE_ABILITY_STATE so that targetable scrolls can be canceled
	else if (!slot.item.charges && slot.item.type.name !== 'ScrollOfEnchantment' && slot.item.type.name !== 'ScrollOfAcquirement' && gs.state !== 'USE_ABILITY_STATE') {
		slot.removeItem(1);
	}
	
	// Update stats:
	this.updateStats();
};

// CANCEL_USE_ABILITY:
// ************************************************************************************************
PlayerCharacter.prototype.cancelUseAbility = function () {
	gs.state = 'GAME_STATE';
	this.selectedScroll = null;
	this.selectedAbility = null;
	this.selectedItem = null;
	
	gs.playSound(gs.sounds.scroll, this.tileIndex);

	if (this.particleGenerator) {
		this.particleGenerator.isAlive = false;
	}
};

// WAIT_CLICKED:
// ************************************************************************************************
PlayerCharacter.prototype.waitClicked = function () {
	if (gs.activeCharacter !== this) {
		return;
	}
	
	// Rest:
	if (gs.keys.shift.isDown) {
		if (gs.numVisibleNPCs() === 0) {
			this.rest();
		}
		else {
			this.popUpText('Nearby Hostile!', '#ff0000');
		}
	}
	// Wait:
	else {
		this.actionQueue = [{type: 'WAIT'}];
		this.popUpText('WAIT', '#ffffff');
	}
};

// REST:
// Rest until either HP or EP is full (whichever takes less time)
// ************************************************************************************************
PlayerCharacter.prototype.rest = function () {
	var hpTime, epTime, min;
	
	// Rest until recovery:
	if (this.currentHp < this.maxHp || this.currentMp < this.maxMp) {
		hpTime = this.hpRegenTime * (this.maxHp - this.currentHp);
		epTime = this.mpRegenTime * (this.maxMp - this.currentMp);
	
		if (this.currentHp === this.maxHp) {
			min = epTime;
		}
		else if (this.currentMp === this.maxMp) {
			min = hpTime;
		}
		else {
			min = Math.min(hpTime, epTime);
		}
	}
	// Rest 10 turns:
	else {
		min = 10;
	}
	
		
	this.actionQueue = [];
	for (let i = 0; i < min; i += 1) {
		this.actionQueue.push({type: 'WAIT'});
	}
	
	this.popUpText('REST ' + min, '#ffffff');
};

// GAIN_EXPERIENCE:
// ************************************************************************************************
PlayerCharacter.prototype.gainExperience = function (amount) {
	if (!this.isAlive) {
		return;
	}
	
	// Apply exp modifiers:
	amount = Math.floor(amount * this.expMod);

	if (isNaN(amount)) {
		throw 'gainExperience NaN';
	}

	// Increase experience:
	if (this.level < MAX_LEVEL) {
		this.exp += amount;
	}

	// Check for level up:
	while (this.exp >= gs.expPerLevel[this.level + 1]) {
		this.gainLevel();
	}
};

// LOSE_EXP:
// ************************************************************************************************
PlayerCharacter.prototype.loseExp = function (amount) {
	if (this.exp - amount < gs.expPerLevel[this.level]) {
		this.exp = gs.expPerLevel[this.level];
	} else {
		this.exp -= amount;
	}
};

// GO_TO_SLEEP:
// ************************************************************************************************
PlayerCharacter.prototype.goToSleep = function () {};

// GAIN_LEVEL:
// ************************************************************************************************
PlayerCharacter.prototype.gainLevel = function () {
	if (!this.isAlive) {
		return;
	}
	
	// Sound:
	gs.playSound(gs.sounds.levelUp, this.tileIndex);

	this.level += 1;
	
	help.levelUpDialog();

	// Attributes:
	if (this.level % 3 === 0) {
		gs.openAttributeGainMenu();
	}
	// Talent Points:
	else {
		this.talentPoints += 1;
	}

	// Talent and Skill Points:
	this.skillPoints += SKILL_POINTS_PER_LEVEL;
	
	this.updateStats();

	
	// Restore HP and EP to full:
	this.currentHp = this.maxHp;
	this.currentMp = this.maxMp;
	this.resetAllCoolDowns();
	
	
	// Pop Up Text:
	this.queuePopUpText('LEVEL UP',  '#ffff00');
	
	// Effect:
	gs.createEXPEffect(this.tileIndex);
	
	gs.logExperienceLevel();
	
	gs.kongSubmit('MaxXL', this.level);
};

// CAN_GAIN_SKILL:
// ************************************************************************************************
PlayerCharacter.prototype.canGainSkill = function (skillName) {
	return this.skillPoints > 0 && this.skills[skillName] < MAX_SKILL;
};

// GAIN_SKILL:
// ************************************************************************************************
PlayerCharacter.prototype.gainSkill = function (skillName) {
	if (this.canGainSkill(skillName)) {
		this.skillPoints -= 1;
		this.skills[skillName] += 1;
		this.updateStats();
		
		if (skillName === 'Fortitude') {
			this.currentHp += HP_PER_SKILL;
		}
		else if (skillName === 'Focus') {
			this.currentMp += MP_PER_SKILL;
		}
		
		this.capStats();
	}
};

// GET_RANDOM_SKILL_NAME:
// Returns the name of a random, upgradable skill
// ************************************************************************************************
PlayerCharacter.prototype.getRandomSkillName = function () {
	let list = SKILL_NAMES.filter(skillName => this.skills[skillName] < MAX_SKILL);
	return list.length > 0 ? util.randElem(list) : null;
};

// AGRO_PLAYER:
// Called when a character is confused so must handle for player
// ************************************************************************************************
PlayerCharacter.prototype.agroPlayer = function () {};

// ON_TAKE_DAMAGE:
// ************************************************************************************************
PlayerCharacter.prototype.onTakeDamage = function () {
	gs.hasNPCActed = true;
	
	if (this.currentHp < this.maxHp * 0.25) {
		gs.logCriticalMoment();
	}
	
	if (this.isAsleep) {
		this.isAsleep = false;
	}
};

// DEATH:
// ************************************************************************************************
PlayerCharacter.prototype.death = function (damageType, flags) {
	// Avoid killing the player twice in a single turn:
	if (!this.isAlive) {
		return;
	}
	
	// Burning self to death:
	if (damageType === 'Fire' && flags.killer === this) {
		gs.deathText = 'was burned to death';
	} 
	// Fire Shroom:
	else if (flags.killer === 'FireShroom') {
		gs.deathText = 'was burned to death by a fire shroom';
	}
	//Fire Glyph:
	else if (flags.killer === 'FireGlyph') {
		gs.deathText = 'was burned to death by an exploding fire glyph';
	}
	// Spike Trap:
	else if (flags.killer === 'SpikeTrap') {
		gs.deathText = 'was impaled by spikes';
	}
	// Bear Trap:
	else if (flags.killer === 'BearTrap') {
		gs.deathText = 'was killed by a bear trap';
	}
	// Killed Self:
	else if (flags.killer === 'Lava') {
		gs.deathText = 'was burned to death in a pool of lava';
	}
	// Gas:
	else if (flags.killer === 'Gas') {
		gs.deathText = 'suffocated to death in toxic gas';	
	} 
	// Killed self:
	else if (flags.killer === this) {
		gs.deathText = 'killed himself';
	}
	// Unique Killer:
	else if (flags.killer && flags.killer.type && flags.killer.type.isUnique) {
		gs.deathText = 'was killed by ' + flags.killer.type.niceName;
	}
	// Killer:
	else if (flags.killer && flags.killer.type) {
		gs.deathText = 'was killed by a ' + flags.killer.type.niceName;
	}
	// Pit:
	else if (flags.killer && flags.killer === 'Pit') {
		gs.deathText = 'fell to his death.';
	}
	// Generic:
	else {
		gs.deathText = 'was killed';
	}

	this.isAlive = false;
	this.currentHp = 0;
	this.poisonDamage = 0;
	
	this.updateUIFrame();
	
	// Life Saving:
	if (this.hasLifeSaving) {
		gs.openLifeSavingMenu();
	}
	// Actual death (clear save):
	else {
		if (!gs.debugProperties.allowRespawn) {
			gs.logGameRecord(gs.deathText, false);
			gs.clearGameData();
		}
		
		gs.openDeathMenu();
	}
};

// GAIN_RAGE:
// ************************************************************************************************
PlayerCharacter.prototype.gainRage = function (amount) {
	if (this.hasRage && this.rage < this.maxRage) {
		this.rage += amount;
		this.rageTimer = 0;
	}
	
	// Reduce Cooldowns:
	this.abilities.reduceCoolDowns(this.rage);
};

// GAIN_FOOD:
// ************************************************************************************************
PlayerCharacter.prototype.gainFood = function (amount) {
	this.currentFood += 1;
	this.currentFood = Math.min(this.maxFood, this.currentFood);
};

// ON_KILL:
// ************************************************************************************************
PlayerCharacter.prototype.onKill = function (character) {};

// EXP_PERCENT:
// ************************************************************************************************
PlayerCharacter.prototype.expPercent = function () {
	var expToLevel = this.exp - gs.expPerLevel[this.level],
		totalExpToLevel = gs.expPerLevel[this.level + 1] - gs.expPerLevel[this.level];
	return Math.floor(expToLevel / totalExpToLevel * 100);

};

// START_EXPLORING:
// ************************************************************************************************
PlayerCharacter.prototype.startExploring = function () {
	var tileIndex;

	if (gs.activeCharacter !== this || gs.state !== 'GAME_STATE') {
		return;
	}
	
	if (gs.numVisibleNPCs() === 0) {
		tileIndex = gs.findUnexploredTileIndex(this.tileIndex);
		if (tileIndex) {
			this.clickTileIndex(tileIndex, false, true);
			this.isExploring = true;
		} 
		else if (gs.unexploredTilesRemaining()) {
			tileIndex = gs.findUnexploredTileIndex(this.tileIndex, true);
			if (tileIndex) {
				this.clickTileIndex(tileIndex, false, true);
				this.isExploring = true;
			} 
			else {
				this.popUpText('Partially Explored', '#ffffff');
				this.stopExploring();
			}
		}
		else {
			this.popUpText('Exploration Complete', '#ffffff');
			this.stopExploring();
		}
	} 
	else {
		this.popUpText('Nearby Hostile!', '#ff0000');
		this.stopExploring();
	}
};

// STOP_EXPLORING:
// ************************************************************************************************
PlayerCharacter.prototype.stopExploring = function () {
	this.isExploring = false;
	this.fastMove = false;
	this.actionQueue = [];
	
	// Just in case something calls us while we're multimoving:
	this.statusEffects.remove('Sprint');
	this.statusEffects.remove('Charge');
};



// ADD_ABILITY:
// ************************************************************************************************
PlayerCharacter.prototype.addAbility = function (ability) {
	var abilitySlot;
	
	// Add ability to abilities:
	abilitySlot = this.abilities.addAbility(ability);
			
	// Add ability to UI:
	gs.HUD.abilityBar.addAbility(abilitySlot);
};

// REMOVE_ABILITY:
// ************************************************************************************************
PlayerCharacter.prototype.removeAbility = function (ability) {
	var abilitySlot;
	
	abilitySlot = this.abilities.removeAbility(ability);
	
	gs.HUD.abilityBar.removeAbility(abilitySlot);
};

// GET_UNAVAILABLE_TALENT:
// Returns a talent that the player does not currenctly have
// Used from book shelves
// ************************************************************************************************
PlayerCharacter.prototype.getUnavailableTalent = function () {
	var list = gs.talentList.slice(0);
	
	list = list.filter(talent => !this.hasTalent(talent.name));
	list = list.filter(talent => !gs.inArray(talent.name, this.availableTalents));
	list = list.filter(talent => !talent.neverDrop);
	
	return list.length > 0 ? util.randElem(list) : null;
};

// CAN_LEARN_TALENT:
// Can the player learn the next level of the talent
// ************************************************************************************************
PlayerCharacter.prototype.canLearnTalent = function (talentName) {
	var talentType = gs.talents[talentName],
		level;
	
	if (!talentType) throw talentName + ' is not a valid talent name';

	// Set the next level:
	if (this.hasTalent(talentName)) {
		level = this.getTalent(talentName).level + 1;
	}
	else {
		level = 1;
	}
	
	// Does the talent have a next level:
	if (level > talentType.level.length) {
		return false;
	}

	if (this.talentPoints <= 0) {
		return false;
	}
	
	if (this.level < talentType.level[level - 1]) {
		return false;
	}

	return true;
};

// LEARN_TALENT:
// ************************************************************************************************
PlayerCharacter.prototype.learnTalent = function (talentName, level) {
	var talentType = gs.talents[talentName];
	
	if (gs.inArray(talentName, this.availableTalents)) {
		gs.removeFromArray(talentName, this.availableTalents);
	}
	
	// Set the next level:
	if (!level) {
		if (this.hasTalent(talentName)) {
			level = this.getTalent(talentName).level + 1;
		}
		else {
			level = 1;
		}
	}
	
	// Learning a talent for the first time:
	if (!this.hasTalent(talentName)) {
		// Adding the associated ability:
		if (talentType.ability) {
			this.addAbility(talentType.ability);
		}
		
		this.talents.push({
			type: talentType,
			level: level
		});
	}
	// Upgrading an existing talent:
	else {
		this.getTalent(talentName).level = level;
	}
		
	this.talentPoints -= 1;

	this.updateStats();
	
	if (talentType.onLearn) {
		talentType.onLearn(this);
	}
};

// ADD_AVAILABLE_TALENTS:
// ************************************************************************************************
PlayerCharacter.prototype.addAvailableTalents = function (list) {
	list.forEach(function (talentName) {
		if (!gs.inArray(talentName, this.availableTalents) && !this.hasTalent(talentName)) {
			
			if (!gs.talents.hasOwnProperty(talentName)) {
				throw 'addAvailableTalents() - not a valid talentName: ' + talentName;
			}
			
			this.availableTalents.push(talentName);
		}
	}, this);
	
	// Sort the list by level:
	this.availableTalents.sort((a, b) => gs.talents[a].level[0] - gs.talents[b].level[0]);
};

// ADD_BOOK_TALENTS:
// ************************************************************************************************
PlayerCharacter.prototype.addBookTalents = function (book) {
	this.addAvailableTalents(book.talents);
};

// GET_TALENT:
// ************************************************************************************************
PlayerCharacter.prototype.getTalent = function (talentName) {
	return this.talents.find(talent => talent.type.name === talentName);
};

// GET_TALENT_LEVEL:
// ************************************************************************************************
PlayerCharacter.prototype.getTalentLevel = function (talentName) {
	if (this.getTalent(talentName)) {
		return this.getTalent(talentName).level;
	}
	else {
		return 0;
	}
};

// HAS_TALENT:
// Returns true if the player has learned the talent
// ************************************************************************************************
PlayerCharacter.prototype.hasTalent = function (talentName) {
	return Boolean(this.getTalent(talentName));
};

// HAS_AVAILABLE_TALENT:
// returns true if the player has learned the talent or has it available
// ************************************************************************************************
PlayerCharacter.prototype.hasAvailableTalent = function (talentName) {
	return this.hasTalent(talentName) || Boolean(this.availableTalents.find(name => name === talentName));
};
// SET_RELIGION:
// ************************************************************************************************
PlayerCharacter.prototype.setReligion = function (religionName) {
	if (!gs.religionTypes[religionName]) {
		throw 'Invalid religionName: ' + religionName;
	}

	this.religion = religionName;
	
	if (gs.religionTypes[this.religion].onSet) {
		gs.religionTypes[this.religion].onSet(this);
	}
};

// RANDOM_TELEPORT:
// Use this function to randomly teleport the player to a random open tileIndex in the level
// ************************************************************************************************
PlayerCharacter.prototype.randomTeleport = function () {
	this.teleportTo(gs.getOpenIndexInLevel());
};

// TELEPORT_TO:
// Use this function to teleport the player to a specified tileIndex
// ************************************************************************************************
PlayerCharacter.prototype.teleportTo = function (tileIndex) {
	this.stopExploring();
	
	this.body.snapToTileIndex(tileIndex);
	
	game.camera.focusOnXY(this.body.position.x + 104, this.body.position.y);
	gs.calculateLoS(true);
	
	gs.HUD.miniMap.refresh();
	
	this.statusEffects.onTeleport();
};

// GET_ACTIVE_SUMMON_LIST:
// Returns a list of characters that were summoned by the player and are present on the current level
// ************************************************************************************************
PlayerCharacter.prototype.getActiveSummonList = function () {
	return this.summonIDList.filter(id => gs.getCharWithID(id)).map(id => gs.getCharWithID(id));
};

// CORRODE_WEAPON:
// Will corrode the players weapon (subtract 1 mod)
// ************************************************************************************************
PlayerCharacter.prototype.corrodeWeapon = function () {
	if (this.inventory.getWeapon().type.name !== 'Fists' && this.inventory.getWeapon().type.name !== 'Staff' && this.inventory.getWeapon().mod > 0) {
		this.inventory.getWeapon().mod -= 1;
		this.queuePopUpText('Corroded ' + gs.capitalSplit(this.inventory.getWeapon().type.name), '#ffffff');
	}
};



// CREATE_PLAYER_TYPE:
// ************************************************************************************************
gs.createPlayerType = function () {
	var delta, i;

	// this.expPerLevel = [0, 0, 20];
	this.expPerLevel = [0, 0, 15];
	for (i = 3; i <= MAX_LEVEL; i += 1) {
		//this.expPerLevel[i] = this.expPerLevel[i - 1] + i * i * 3;
		if (i < 10) {
			this.expPerLevel[i] = this.expPerLevel[i - 1] + (i - 1) * (20 + i);
		}
		else {
			this.expPerLevel[i] = this.expPerLevel[i - 1] + (i - 1) * (20 + i * 2);
		}	
	}
};

// END_TURN:
// ************************************************************************************************
PlayerCharacter.prototype.endTurn = function (waitTime) {
	this.statusEffects.onEndTurn();
	this.waitTime = waitTime;
	this.attackDelay = Math.max(0, this.attackDelay - waitTime);
	gs.endTurn();
};

// SAVE:
// ************************************************************************************************
PlayerCharacter.prototype.save = function () {
	var data = {}, i;

	// Location:
	data.isDailyChallenge = gs.isDailyChallenge || false;
	data.seed = gs.seed;
	data.zoneName = gs.zoneName;
	data.zoneLevel = gs.zoneLevel;
	data.tileIndex = {x: this.tileIndex.x, y: this.tileIndex.y};
	data.branches = gs.branches;
	data.remainingAltars = gs.remainingAltars;
	data.previouslySpawnedUniques = gs.previouslySpawnedUniques;
	data.levelFeatures = gs.levelFeatures;
	data.nextCharacterID = gs.nextCharacterID;
	data.eventLog = gs.eventLog;
	data.nextCrystalChestGroupId = gs.nextCrystalChestGroupId;
	data.crystalChestGroupIsOpen = gs.crystalChestGroupIsOpen;
	data.previouslySpawnedFeatures = gs.previouslySpawnedFeatures;
	data.previouslySpawnedStaticLevels = gs.previouslySpawnedStaticLevels;
	
	// Merchant Inventory:
	data.merchantInventory = gs.merchantInventory.toData();
	
	// Current Stats:
	data.currentHp = this.currentHp;
	data.currentMp = this.currentMp;
	data.currentFood = this.currentFood;
	data.baseStrength = this.baseStrength;
	data.baseIntelligence = this.baseIntelligence;
	data.baseDexterity = this.baseDexterity;
	data.permanentHpBonus = this.permanentHpBonus;
	data.permanentMpBonus = this.permanentMpBonus;
	data.rage = this.rage;
	data.summonIDList = this.summonIDList;
	data.poisonDamage = this.poisonDamage;
	
	// Level and Exp:
	data.exp = this.exp;
	data.level = this.level;
	
	
	data.savedTime = gs.gameTime();
	
	// Race, Class, and Religion:
	data.characterClass = this.characterClass;
	data.race = this.race.name;
	data.religion = this.religion;

	
	// Inventory:
	data.inventory = this.inventory.toData();
	
	// Abilities:
	data.abilities = this.abilities.toData();
	
	// Ability Bar:
	data.abilityBar = gs.HUD.abilityBar.toData();
	
	// Skills:
	data.skillPoints = this.skillPoints;
	data.skills = this.skills;
	
	// Talents:
	data.talentPoints = this.talentPoints;
	data.talentList = [];
	for (let i = 0; i < this.talents.length; i += 1) {
		data.talentList.push({
			name: this.talents[i].type.name,
			level: this.talents[i].level
		});
	}
	data.availableTalents = this.availableTalents;


	
	
	// Status Effects:
	data.statusEffects = this.statusEffects.toData();
	
	localStorage.setItem('PlayerData', JSON.stringify(data));
	
	gs.help.soundOn = gs.soundOn;
	gs.help.musicOn = gs.musicOn;
	localStorage.setItem('Help', JSON.stringify(gs.help));
};

// LOAD:
// ************************************************************************************************
PlayerCharacter.prototype.load = function () {
	var data = JSON.parse(localStorage.getItem('PlayerData'));

	gs.isDailyChallenge = data.isDailyChallenge || false;
	gs.seed = data.seed;
	gs.zoneName = null; // Need to add this to not save shit from the main menu level
	gs.changeLevel(data.zoneName, data.zoneLevel);
	gs.branches = data.branches;
	gs.previouslySpawnedUniques = data.previouslySpawnedUniques;
	gs.savedTime = data.savedTime;
	gs.levelFeatures = data.levelFeatures;
	gs.nextCharacterID = data.nextCharacterID;
	gs.eventLog = data.eventLog;
	gs.nextCrystalChestGroupId = data.nextCrystalChestGroupId;
	gs.crystalChestGroupIsOpen = data.crystalChestGroupIsOpen;
	gs.previouslySpawnedFeatures = data.previouslySpawnedFeatures;
	gs.previouslySpawnedStaticLevels = data.previouslySpawnedStaticLevels;
	
	// Current Stats:
	this.currentHp = data.currentHp;
	this.currentMp = data.currentMp;
	this.currentFood = data.currentFood;
	this.baseStrength = data.baseStrength;
	this.baseIntelligence = data.baseIntelligence;
	this.baseDexterity = data.baseDexterity;
	this.permanentHpBonus = data.permanentHpBonus;
	this.permanentMpBonus = data.permanentMpBonus;
	this.summonIDList = data.summonIDList;
	this.poisonDamage = data.poisonDamage || 0;
	
	// Class and Race:
	this.characterClass = data.characterClass;
	this.race = gs.playerRaces[data.race];
	
	
	// Level and Exp:
	this.exp = data.exp;
	this.level = data.level;
	
	
	// Skills:
	this.skillPoints = data.skillPoints;
	this.skills = data.skills;
	
	// Religion:
	this.religion = data.religion;
	gs.remainingAltars = data.remainingAltars;
	
	// Rage:
	this.rage = data.rage || 0;
	
	// Merchent Inventory:
	gs.merchantInventory.loadData(data.merchantInventory);

	// Talents:
	this.talentPoints = data.talentPoints;
	for (let i = 0; i < data.talentList.length; i += 1) {
		this.talents.push({
			type: gs.talents[data.talentList[i].name],
			level: data.talentList[i].level
		});
	}
	this.availableTalents = data.availableTalents;

	// Inventory:
	this.inventory.loadData(data.inventory);
	
	// Abilities:
	this.abilities.loadData(data.abilities);
	
	// Ability Bar:
	gs.HUD.abilityBar.loadData(data.abilityBar);

	// Load Status Effects:
	this.statusEffects.loadData(data.statusEffects);
	
	this.sprite.frame = PLAYER_FRAMES[this.characterClass];
	this.type.frame = PLAYER_FRAMES[this.characterClass];
	this.updateStats();
	
	this.body.snapToTileIndex(data.tileIndex);
};

// GET_NEAREST_VISIBLE_NPC:
// ************************************************************************************************
gs.getNearestVisibleNPC = function () {
	var list = gs.getAllNPCs().filter(npc => npc.faction === FACTION.HOSTILE && gs.pc.canSeeCharacter(npc));
	list.sort((a, b) => gs.distance(gs.pc.tileIndex, a.tileIndex) - gs.distance(gs.pc.tileIndex, b.tileIndex));
	return list.length > 0 ? list[0] : null;
};/*global gs, game, console*/
/*global SCREEN_HEIGHT, HUD_START_X*/
/*jshint esversion: 6, laxbreak: true*/
'use strict';

// TOGGLE_KEY_BOARD_MOVE:
// ************************************************************************************************
gs.toggleKeyBoardMode = function (b) {
	if (b) {
		var nearestNPC = this.getNearestVisibleNPC();

		this.keyBoardMode = true;

		if (nearestNPC) {
			this.cursorTileIndex.x = nearestNPC.tileIndex.x;
			this.cursorTileIndex.y = nearestNPC.tileIndex.y;
		} 
		else {
			this.cursorTileIndex.x = this.pc.tileIndex.x;
			this.cursorTileIndex.y = this.pc.tileIndex.y;
		}
	} 
	else {
		this.keyBoardMode = false;
	}
};

// ON_NUM_PAD_DOWN:
// Moves the character or moves the cursor when in keyBoardMode
// ************************************************************************************************
gs.onNumPadDown = function (vector) {
	this.lastInputType = 'KEYBOARD';
	gs.pc.keyHoldTime = 20;
	
	// Moving Cursor:
	if (this.keyBoardMode) {
		this.cursorTileIndex.x += vector.x;
		this.cursorTileIndex.y += vector.y;
	} 
	/*
	// Multi stepping:
	else if (gs.state === 'GAME_STATE' && gs.keys.shift.isDown) {
		this.onMultiMove(vector);
	}
	*/
	// Single stepping:
	else if (gs.state === 'GAME_STATE') {
		gs.pc.stopExploring();
		gs.pc.clickTileIndex({x: gs.pc.tileIndex.x + vector.x, y: gs.pc.tileIndex.y + vector.y}, false, true);
	}
};

// ON_MULTI_MOVE:
// Return a tileIndex in the direction of vector from the player character.
// Try to move 10 total tiles
// Stop before dangerous terrain or when the 3x3 surroundings change i.e ends of halls, corners etc.
// ************************************************************************************************
gs.onMultiMove = function (vector) {
	var nextTileIndex,
		tileIndex = null;
	
	for (let i = 1; i < 10; i += 1) {
		nextTileIndex = {x: gs.pc.tileIndex.x + vector.x * i, y: gs.pc.tileIndex.y + vector.y * i};
		
		// Break conditions:
		if (!gs.isPassable(nextTileIndex)
		   || !gs.isIndexSafe(nextTileIndex)) {
			break;
		}
		
		tileIndex = {x: gs.pc.tileIndex.x + vector.x * i, y: gs.pc.tileIndex.y + vector.y * i};
	}
	
	if (tileIndex) {
		gs.pc.clickTileIndex(tileIndex, false, true);
	}
};

// ON_NUM_KEY_DOWN:
// Quick selects abilities
// ************************************************************************************************
gs.onNumKeyDown = function (index) {
	if (gs.pc.isReadyForInput()) {	
		

		gs.HUD.abilityBar.slotClicked(gs.HUD.abilityBar.abilitySlots[index]);
		
		if (this.lastInputType === 'KEYBOARD' && gs.state === 'USE_ABILITY_STATE') {
			this.toggleKeyBoardMode(true);
		}
	}
};

// ON_ENTER:
// Used to confirm actions in keyboard mode, confirm dialog, or wait/rest
// ************************************************************************************************
gs.onEnter = function () {
	if (gs.pc.isReadyForInput()) {
		if (this.keyBoardMode) {
			gs.pc.clickTileIndex(this.cursorTileIndex);
		}
		else if (gs.state === 'GAME_STATE') {
			gs.pc.stopExploring();
			gs.pc.clickTileIndex(gs.pc.tileIndex);
		} 
		else if (gs.state === 'DIALOG_MENU_STATE') {
			gs.dialogMenu.buttonClicked({index: 0});	
		}
	}
};

// ON_CLICK:
// ************************************************************************************************
gs.onClick = function () {
	// Clicking a tile:
	if (gs.isPointerInWorld() && (gs.state === 'GAME_STATE' || gs.state === 'USE_ABILITY_STATE')) {
		gs.pc.clickTileIndex(gs.pointerTileIndex(), false, false);
	} 
	// Clicking the mini-map:
	else if (gs.HUD.miniMap.isPointerOver() && gs.state === 'GAME_STATE' && gs.isInBounds(gs.HUD.miniMap.indexUnderPointer()) && gs.getTile(gs.HUD.miniMap.indexUnderPointer()).explored) {
		gs.pc.clickTileIndex(gs.HUD.miniMap.indexUnderPointer(), true, true);
	}
};

// ON_RIGHT_CLICK:
// ************************************************************************************************
gs.onRightClick = function () {
	if (gs.isPointerInWorld() && (gs.state === 'GAME_STATE')) {
		gs.pc.clickTileIndex(gs.pointerTileIndex(), false, false, true);
	} 
};


// ON_ESCAPE:
// ************************************************************************************************
gs.onEscape = function () {
	if (gs.pc.isReadyForInput()) {
		if (gs.keyBoardMode) {
			this.toggleKeyBoardMode(false);
		}
		
		if (gs.state === 'HELP_MENU_STATE') {
			gs.helpMenu.close();
		}

		if (gs.state === 'USE_ABILITY_STATE') {
			gs.pc.cancelUseAbility();
		}

		if (gs.state === 'CHARACTER_MENU_STATE') {
			gs.characterMenu.close();
		}

		if (gs.state === 'OPTIONS_MENU_STATE') {
			gs.optionsMenu.close();
		}

		if (gs.state === 'ENCHANTMENT_MENU_STATE') {
			gs.enchantmentMenu.close();
		}

		if (gs.state === 'ACQUIREMENT_MENU_STATE') {
			gs.acquirementMenu.close();
		}
		
		if (gs.state === 'TRANSFERANCE_MENU_STATE') {
			gs.transferanceMenu.close();
		}
		
		if (gs.state === 'SHOP_MENU_STATE') {
			gs.shopMenu.close();
		}

		gs.pc.stopExploring();
	}
	// Closing character menu from the death state
	else if (!gs.pc.isAlive && gs.state === 'CHARACTER_MENU_STATE') {
		gs.characterMenu.close();
	}
};

// ON_EXPLORE_CLICKED:
// ************************************************************************************************
gs.onExploreClicked = function () {
	if (gs.state === 'GAME_STATE' && gs.pc.isReadyForInput()) {
		if (gs.pc.isExploring) {
			gs.pc.stopExploring();
		}
		else {
			gs.pc.startExploring();
		}
		
	}
};

// ON_SWAP_WEAPON_CLICKED:
// ************************************************************************************************
gs.onSwapWeaponClicked = function () {
	if (gs.pc.isReadyForInput()) {
		gs.pc.inventory.swapWeapon();
	}
};

// ON_OPEN_CHARACTER_MENU:
// ************************************************************************************************
gs.onCharacterMenuClicked = function () {
	
	if (gs.state === 'GAME_STATE' && gs.pc.isReadyForInput()) {
		gs.characterMenu.open();
	} 
	else if (gs.state === 'CHARACTER_MENU_STATE') {
		gs.characterMenu.close();
	}
};

// ON_DOWN_STAIRS_KEY:
// ************************************************************************************************
gs.onDownStairsKey = function () {
	var obj = gs.findObj(obj => obj.type === gs.objectTypes.DownStairs);

	// Use down stairs:
	if (gs.getObj(gs.pc.tileIndex, 'DownStairs')) {
		gs.pc.useZoneLine();
	}
	// Warp to stairs:
	else if (gs.debugProperties.warpStairs && obj) {
		gs.pc.body.snapToTileIndex(obj.tileIndex);
	}
	// Goto down stairs:
	else if (obj && gs.getTile(obj.tileIndex).explored) {
		gs.pc.clickTileIndex(obj.tileIndex, true, true);
	}
};

// ON_UP_STAIRS_KEY:
// ************************************************************************************************
gs.onUpStairsKey = function () {
	var obj = gs.findObj(obj => obj.type === gs.objectTypes.UpStairs);

	// Use up stairs:
	if (gs.getObj(gs.pc.tileIndex, 'UpStairs')) {
		gs.pc.useZoneLine();
	}
	// Warp to stairs:
	else if (gs.debugProperties.warpStairs && obj) {
		gs.pc.body.snapToTileIndex(obj.tileIndex);
	}
	// Goto up stairs:
	else if (obj && gs.getTile(obj.tileIndex).explored) {
		gs.pc.clickTileIndex(obj.tileIndex, true, true);
	}
};

// ON_STAIRS_KEY:
// ************************************************************************************************
gs.onStairsKey = function () {
	if (gs.getObj(gs.pc.tileIndex, ['UpStairs', 'DownStairs'])) {
		gs.pc.useZoneLine();
	}
};

// CREATE_PLAYER_CHARACTER_INPUT:
// ************************************************************************************************
gs.createPlayerCharacterInput = function () {
	// Clicking pointer:
	game.input.activePointer.leftButton.onDown.add(this.onClick, this);
	game.input.activePointer.rightButton.onDown.add(this.onRightClick, this);


	//game.input.activePointer.rightButton

	// Moving Pointer:
	game.input.addMoveCallback(function () {
		this.lastInputType = 'MOUSE';
	}, this);

	// E Key (Auto Explore):
	this.keys.e.onDown.add(this.onExploreClicked, this);

	// Space Key (Wait Turn):
	this.keys.space.onDown.add(this.onEnter, this);
	this.keys.enter.onDown.add(this.onEnter, this);
	this.keys.numPad5.onDown.add(this.onEnter, this);
	
	// Auto Attack:
	this.keys.tab.onDown.add(function () {
		gs.pc.autoAttack();
	}, this);
	this.keys.q.onDown.add(function () {
		gs.pc.autoAttack(true);
	}, this);
	
	// ESC Key (cancel casting)
	this.keys.esc.onDown.add(this.onEscape, this);
	
	// W Key (Swap Weapons):
	this.keys.w.onDown.add(this.onSwapWeaponClicked, this);

	// A Key (Keyboard Mode):
	this.keys.a.onDown.add(function () {
		this.toggleKeyBoardMode(true);
	}, this);

	// T Key (open talent menu):
	this.keys.t.onDown.add(this.onCharacterMenuClicked, this);
	this.keys.c.onDown.add(this.onCharacterMenuClicked, this);
	this.keys.i.onDown.add(this.onCharacterMenuClicked, this);
	
	// > Key (Goto Down Stairs):
	this.keys.period.onDown.add(this.onDownStairsKey, this);
	
	// < Key (Goto Up Stairs):
	this.keys.comma.onDown.add(this.onUpStairsKey, this);

	// s Key (use stairs):
	this.keys.s.onDown.add(this.onStairsKey, this);
	
	// NUM_PAD_KEYS:
	this.keys.numPad1.onDown.add(this.onNumPadDown.bind(this, {x: -1, y: 1}));
	this.keys.numPad2.onDown.add(this.onNumPadDown.bind(this, {x: 0, y: 1}));
	this.keys.numPad3.onDown.add(this.onNumPadDown.bind(this, {x: 1, y: 1}));
	this.keys.numPad4.onDown.add(this.onNumPadDown.bind(this, {x: -1, y: 0}));	
	this.keys.numPad6.onDown.add(this.onNumPadDown.bind(this, {x: 1, y: 0}));
	this.keys.numPad7.onDown.add(this.onNumPadDown.bind(this, {x: -1, y: -1}));
	this.keys.numPad8.onDown.add(this.onNumPadDown.bind(this, {x: 0, y: -1}));
	this.keys.numPad9.onDown.add(this.onNumPadDown.bind(this, {x: 1, y: -1}));
	
	this.keys.end.onDown.add(this.onNumPadDown.bind(this, {x: -1, y: 1}));
	this.keys.down.onDown.add(this.onNumPadDown.bind(this, {x: 0, y: 1}));
	this.keys.pageDown.onDown.add(this.onNumPadDown.bind(this, {x: 1, y: 1}));
	this.keys.left.onDown.add(this.onNumPadDown.bind(this, {x: -1, y: 0}));	
	this.keys.right.onDown.add(this.onNumPadDown.bind(this, {x: 1, y: 0}));
	this.keys.home.onDown.add(this.onNumPadDown.bind(this, {x: -1, y: -1}));
	this.keys.up.onDown.add(this.onNumPadDown.bind(this, {x: 0, y: -1}));
	this.keys.pageUp.onDown.add(this.onNumPadDown.bind(this, {x: 1, y: -1}));

	// NUM_KEYS:
	this.keys.num1.onDown.add(this.onNumKeyDown.bind(gs, 0), this);
	this.keys.num2.onDown.add(this.onNumKeyDown.bind(gs, 1), this);
	this.keys.num3.onDown.add(this.onNumKeyDown.bind(gs, 2), this);
	this.keys.num4.onDown.add(this.onNumKeyDown.bind(gs, 3), this);
	this.keys.num5.onDown.add(this.onNumKeyDown.bind(gs, 4), this);
	this.keys.num6.onDown.add(this.onNumKeyDown.bind(gs, 5), this);
	this.keys.num7.onDown.add(this.onNumKeyDown.bind(gs, 6), this);
	this.keys.num8.onDown.add(this.onNumKeyDown.bind(gs, 7), this);
};

// POINTER_TILE_INDEX:
// ************************************************************************************************
gs.pointerTileIndex = function () {
	return this.toTileIndex({x: game.input.activePointer.x + game.camera.x, y: game.input.activePointer.y + game.camera.y});
};

// IS POINTER IN WORLD:
// ********************************************************************************************
gs.isPointerInWorld = function () {
	return game.input.activePointer.x < HUD_START_X
		&& game.input.activePointer.x > 4
		&& game.input.activePointer.y < SCREEN_HEIGHT - 4
		&& game.input.activePointer.y > 4
		&& gs.isInBounds(gs.pointerTileIndex());
};/*global gs, PlayerCharacter*/
/*global Item*/
/*global PLAYER_FRAMES*/
'use strict';
// SET_CLASS:
// ************************************************************************************************
PlayerCharacter.prototype.setClass = function (className) {
	var key;
	this.characterClass = className;
	
	// Starting Food:
	if (this.race.name !== 'Mummy') {
		this.inventory.addItem(Item.createItem('Meat'));
		
		if (gs.inArray(className, ['Necromancer', 'Enchanter', 'FireMage', 'IceMage', 'StormMage'])) {
			this.inventory.addItem(Item.createItem('PotionOfEnergy'));
		}
	}
	
	// WARRIOR:
	if (className === 'Warrior') {
		// Equipment:
		this.inventory.addItem(Item.createItem('ShortSword'));
		this.inventory.addItem(Item.createItem('Dart', {amount: 10}));
		this.inventory.equipmentSlot('shield').addItem(Item.createItem('WoodenShield'));
		
		// Talents:
		this.learnTalent('ShieldsUp');
		this.addAvailableTalents([
			'ShieldsUp', 'PowerStrike', 'Fortitude', 'WeaponMastery',		
			'ShieldWall', 'Deflect', 'Charge',
		]);
		
	}
	// BARBARIAN:
	else if (className === 'Barbarian') {
		// Equipment:
		this.inventory.addItem(Item.createItem('HandAxe'));
		this.inventory.addItem(Item.createItem('Dart', {amount: 10}));
		
		// Talents:
		this.learnTalent('PowerStrike');
		this.addAvailableTalents([
			'PowerStrike', 'Sprint', 'BloodLust', 'WeaponMastery',
			'Charge', 'StrafeAttack',	
		]);
	}
	// RANGER:
	else if (className === 'Ranger') {
		// Equipment:
		this.inventory.addItem(Item.createItem('ShortBow'));
		
		// Talents:
		this.learnTalent('PowerShot');
		this.addAvailableTalents([
			'PowerShot', 'Sprint', 'Evasive', 'RangeMastery',
			'TunnelShot', 'PerfectAim', 'StrafeAttack'
		]);
	}
	// ROGUE:
	else if (className === 'Rogue') {
		// Equipment:
		this.inventory.addItem(Item.createItem('ShortSword'));
		this.inventory.addItem(Item.createItem('Dart', {amount: 20}));
		
		// Talents:
		this.learnTalent('SleepingDart');
		this.addAvailableTalents([
			'SleepingDart', 'Sprint', 'Evasive', 'StealthMastery',
			'DungeonSense', 'NimbleFingers', 'SmokeBomb'
		]);
		
	}
	// FIRE_MAGE:
	else if (className === 'FireMage') {
		// Equipment:
		this.inventory.addItem(Item.createItem('StaffOfFire'));
		
		// Talents:
		this.learnTalent('FireBall');
		this.addAvailableTalents([
			'FireBall', 'FireAttunement', 'FireMastery', 'Focus',
			'BurstOfFlame', 'FlamingHands', 'FireBolt'
		]);
	}
	// ICE_MAGE:
	else if (className === 'IceMage') {
		// Equipment:
		this.inventory.addItem(Item.createItem('StaffOfIce'));
		
		// Talents:
		this.learnTalent('ConeOfCold');
		this.addAvailableTalents([
			'ConeOfCold', 'ColdAttunement', 'ColdMastery', 'Focus',
			'FreezingCloud', 'Freeze', 'IceArmor'
		]);
	}
	// STORM_MAGE:
	else if (className === 'StormMage') {
		// Equipment:
		this.inventory.addItem(Item.createItem('StaffOfStorms'));
		
		// Talents:
		this.learnTalent('LightningBolt');
		this.addAvailableTalents([
			'LightningBolt', 'StormAttunement',	'StormMastery', 'Focus',
			'ThunderClap', 'Shock', 'Levitation'
		]);
	}
	// NECROMANCER:
	else if (className === 'Necromancer') {
		// Equipment:
		this.inventory.addItem(Item.createItem('StaffOfPoison'));
		
		// Talents:
		this.learnTalent('LifeSpike');
		this.addAvailableTalents([
			'LifeSpike', 'ToxicAttunement',	'ToxicMastery', 'Focus',
			'InfectiousDisease', 'SummonSkeleton', 'Cannibalise'
		]);
	}
	// ENCHANTER:
	else if (className === 'Enchanter') {
		// Equipment:
		this.inventory.addItem(Item.createItem('StaffOfMagicMissiles'));
		
		// Talents:
		this.learnTalent('Confusion');
		this.addAvailableTalents([
			'Confusion', 'Fear', 'MagicMastery', 'Focus',
			'Charm', 'Mesmerize', 'Swiftness',
		]);
	} 
	else {
		throw 'Invalid className';
	}	
	
	this.inventory.lastWeaponIndex = 1;
	this.inventory.weaponIndex = 0;
	
	

	this.updateStats();
	this.talentPoints = 0;
	this.currentHp = this.maxHp;
	this.currentMp = this.maxMp;
	this.sprite.frame = PLAYER_FRAMES[className];
	this.type.frame = PLAYER_FRAMES[className];
};

gs.createPlayerClasses = function () {
	this.classEffects = {};
	
	// FIRE_MAGE:
	this.classEffects.FireMage = function (character) {
		character.intelligence += 3;
	};
	
	// STORM_MAGE:
	this.classEffects.StormMage = function (character) {
		character.intelligence += 3;
	};
	
	// NECROMANCER:
	this.classEffects.Necromancer = function (character) {
		character.intelligence += 3;
	};
	
	// ICE_MAGE:
	this.classEffects.IceMage = function (character) {
		character.intelligence += 3;
	};
	
	// ENCHANTER:
	this.classEffects.Enchanter = function (character) {
		character.intelligence += 3;
	};
	
	// WARRIOR:
	this.classEffects.Warrior = function (character) {
		character.strength += 3;
	};
	
	// BARBARIAN:
	this.classEffects.Barbarian = function (character) {
		character.strength += 3;
		character.hasRage += 1;
	};
	
	// RANGER:
	this.classEffects.Ranger = function (character) {
		character.dexterity += 3;
	};
	
	// ROGUE:
	this.classEffects.Rogue = function (character) {
		character.dexterity += 3;
	};
};
/*global game, gs, console*/
'use strict';

gs.createPlayerRaces = function () {
	this.playerRaces = {};
	
	// HUMAN:
	this.playerRaces.Human = {};
	this.playerRaces.Human.effect = function (character) {
		
	};
	this.playerRaces.Human.desc = function () {
		var str = 'Human\n';
		str += 'Medium Size\n';
		return str;
	};
	
	// OGRE:
	this.playerRaces.Ogre = {};
	this.playerRaces.Ogre.effect = function (character) {
		character.strength += 3;
		character.intelligence -= 3;
		
		character.bonusMovementSpeed -= 1;
		character.size += 1;
	};
	this.playerRaces.Ogre.desc = function () {
		var str = 'Ogre\n';
		str += 'Large Size\n';
		str += '+3 Strength\n';
		str += '-3 Intelligence\n';
		str += 'Slow Movement speed\n';
		
		return str;
	};
	
	// TROLL:
	this.playerRaces.Troll = {};
	this.playerRaces.Troll.effect = function (character) {
		character.bonusHpRegenTime += 5;
		character.intelligence -= 3;
		character.resistance.Fire -= 1;
	};
	this.playerRaces.Troll.desc = function () {
		var str = 'Troll\n';
		str += 'Medium Size\n';
		str += '-3 Intelligence\n';
		str += '-50% Fire Resistance\n';
		str += 'Double regen speed\n';
		return str;
	};
	
	// MUMMY:
	this.playerRaces.Mummy = {};
	this.playerRaces.Mummy.effect = function (character) {
		character.resistance.Fire -= 1;
		character.resistance.Toxic += 1;
	};
	this.playerRaces.Mummy.desc = function () {
		var str = 'Mummy\n';
		str += 'Medium Size\n';
		str += 'No hunger\n';
		str += '-50% Fire Resistance\n';
		str += '+50% Toxic Resistance\n';
		str += 'Cannot consume potions or food\n';
		return str;
	};
	
	// ELF:
	this.playerRaces.Elf = {};
	this.playerRaces.Elf.effect = function (character) {
		character.dexterity += 3;
		character.strength -= 3;
	};
	this.playerRaces.Elf.desc = function () {
		var str = 'Elf\n';
		str += 'Medium Size\n';
		str += '+3 Dexterity\n';
		str += '-3 Strength\n';
		str += 'No min range for bows\n';
		return str;
	};
	
	// GNOME:
	this.playerRaces.Gnome = {};
	this.playerRaces.Gnome.effect = function (character) {
		character.intelligence += 3;
		character.strength -= 3;
		character.size -= 1;
	};
	this.playerRaces.Gnome.desc = function () {
		var str = 'Gnome\n';
		str += 'Small Size\n';
		str += '+3 Intelligence\n';
		str += '-3 Strength\n';
		return str;
	};
	
	this.playerRaceList = [];
	this.forEachType(this.playerRaces, function (playerRace) {
		this.playerRaceList.push(playerRace);
	}, this);
	
	this.nameTypes(this.playerRaces);
};/*global gs, console*/
/*global ItemSlot, ItemSlotList, Item, PlayerCharacter*/
/*global ASSERT_EQUAL, ASSERT_THROW*/
/*global EQUIPMENT_SLOT_NAMES*/
/*global CHARACTER_SIZE*/
/*global INVENTORY_WIDTH, INVENTORY_HEIGHT*/
/*global WEAPON_HOT_BAR_WIDTH, WEAPON_HOT_BAR_HEIGHT*/
/*global CONSUMABLE_HOT_BAR_WIDTH, CONSUMABLE_HOT_BAR_HEIGHT*/
/*jshint laxbreak: true, esversion: 6*/
'use strict';

// CHARACTER_INVENTORY:
// ************************************************************************************************
function CharacterInventory (character) {	
	this.character = character;
	
	// Item Slot Lists:
	this.inventory = new ItemSlotList(INVENTORY_WIDTH * INVENTORY_HEIGHT);
	this.weaponHotBar = new ItemSlotList(WEAPON_HOT_BAR_WIDTH * WEAPON_HOT_BAR_HEIGHT - 1, 'weapon');
	this.consumableHotBar = new ItemSlotList(CONSUMABLE_HOT_BAR_WIDTH * CONSUMABLE_HOT_BAR_HEIGHT, 'consumable');
	this.equipment = new ItemSlotList(EQUIPMENT_SLOT_NAMES.length);
	this.quickWeaponSlot = new ItemSlot(null, 'weapon');
	
	// Set this to true to temporarily equip the quick weapon for a single turn to handle player stats
	this.quickWeaponEquipped = false;
	
	// Setting itemSlotTypes:
	EQUIPMENT_SLOT_NAMES.forEach(function (name, index) {
		this.equipment.itemSlots[index].itemTypeSlot = name;
	}, this);
	
	// Misc:
	this.gold = 0;
	this.keys = 0;
	this.weaponIndex = -1;
	this.lastWeaponIndex = -1;
	
	// Default Weapon:
	this.fists = Item.createItem('Fists');
	
	// Flaming Hands:
	this.flamingHands = Item.createItem('FlamingHands');
}

// EQUIPMENT_SLOT:
// Easy access to equipment slots by name
// ************************************************************************************************
CharacterInventory.prototype.equipmentSlot = function (slotName) {
	ASSERT_EQUAL(EQUIPMENT_SLOT_NAMES.indexOf(slotName) > -1, true, 'Invalid slotName: ' + slotName);
	
	return this.equipment.itemSlots[EQUIPMENT_SLOT_NAMES.indexOf(slotName)];
};

// TO_DATA:
// ************************************************************************************************
CharacterInventory.prototype.toData = function () {
	var data = {};
	
	// Save ItemSlotLists:
	data.inventory = this.inventory.toData();
	data.weaponHotBar = this.weaponHotBar.toData();
	data.consumableHotBar = this.consumableHotBar.toData();
	data.equipment = this.equipment.toData();
	data.quickWeaponSlot = this.quickWeaponSlot.toData();
	
	// Misc:
	data.weaponIndex = this.weaponIndex;
	data.lastWeaponIndex = this.lastWeaponIndex;
	data.gold = this.gold;
	data.keys = this.keys;
	
	return data;
};

// LOAD_DATA:
// ************************************************************************************************
CharacterInventory.prototype.loadData = function (data) {	
	// Load ItemSlotLists:
	this.inventory.loadData(data.inventory);
	this.weaponHotBar.loadData(data.weaponHotBar);
	this.consumableHotBar.loadData(data.consumableHotBar);
	this.equipment.loadData(data.equipment);
	this.quickWeaponSlot.loadData(data.quickWeaponSlot);
	
	
	// Load Misc:
	this.gold = data.gold;
	this.keys = data.keys;
	this.weaponIndex = data.weaponIndex;
	this.lastWeaponIndex = data.lastWeaponIndex;
};

// CAN_ADD_ITEM:
// ************************************************************************************************
CharacterInventory.prototype.canAddItem = function (item) {
	ASSERT_EQUAL(Item.isItem(item), true, 'Invalid item: ' + item);
	
	if (item.type.name === 'GoldCoin' || item.type.name === 'Key' || item.type.name === 'GobletOfYendor') {
		return true;
	}
	else if (this.consumableHotBar.canAddItem(item)) {
		return true;
	}
	else if (this.weaponHotBar.canAddItem(item)) {
		return true;
	}
	else if (this.inventory.canAddItem(item)) {
		return true;
	}
	
	return false;
};


// ADD_ITEM:
// ************************************************************************************************
CharacterInventory.prototype.addItem = function (item) {	
	// Add Gold:
	if (item.type.name === 'GoldCoin') {
		this.gold += item.amount;
	}
	// Add Key:
	else if (item.type.name === 'Key') {
		this.keys += 1;
	}
	// Add Book Talents:
	else if (item.type.slot === 'book') {
		this.character.addBookTalents(item);
	}
	// First try to stack on consumable:
	else if (this.consumableHotBar.canStackItem(item)) {
		this.consumableHotBar.addItem(item);
	}
	// First try to stack on weapons:
	else if (this.weaponHotBar.canStackItem(item)) {
		this.weaponHotBar.addItem(item);
	}
	// First try to stack on inventory:
	else if (this.inventory.canStackItem(item)) {
		this.inventory.addItem(item);
	}
	// Add item to consumable hotbar:
	else if (this.consumableHotBar.canAddItem(item)) {
		this.consumableHotBar.addItem(item);
	}
	// Add item to weapon hotbar:
	else if (this.weaponHotBar.canAddItem(item)) {
		this.weaponHotBar.addItem(item);
	}
	// Adding to inventory:
	else if (this.inventory.canAddItem(item)) {
		this.inventory.addItem(item);
	}
	// Can't add item:
	else {
		this.character.dropItem(item);
	}
		
	this.character.onAddItem(item);
};

// REMOVE_ITEM:
// ************************************************************************************************
CharacterInventory.prototype.removeItem = function (item, amount) {
	ASSERT_EQUAL(Item.isItem(item), true, 'Invalid item: ' + item);
	
	// Try to remove from weaponHotBar:
	if (this.weaponHotBar.containsItem(item)) {
		this.weaponHotBar.removeItem(item, amount);
	}
	// Try to remove from consumableHotBar:
	else if (this.consumableHotBar.containsItem(item)) {
		this.consumableHotBar.removeItem(item, amount);
	}
	// Try to remove from inventory:
	else if (this.inventory.containsItem(item)) {
		this.inventory.removeItem(item, amount);
	}
	// Try to remove from equipment:
	else if (this.equipment.containsItem(item)) {
		this.equipment.removeItem(item, amount);
		this.character.onUnequipItem(item);
	}
	// Try to remove from quick slot
	else if (this.quickWeaponSlot.item === item) {
		this.quickWeaponSlot.removeItem(amount);
	}
	else {
		throw 'Failed to remove item: ' + item;
	}
	
	this.character.updateStats();
};


// ALL_FULL_ITEM_SLOTS:
// Used when we need to create a list of all the players slots for stuff like merchant, enchantment, transferance menus.
// ************************************************************************************************
CharacterInventory.prototype.allFullItemSlots = function () {
	var list = [];
	
	list = list.concat(this.equipment.allFullItemSlots());
	list = list.concat(this.consumableHotBar.allFullItemSlots());
	list = list.concat(this.weaponHotBar.allFullItemSlots());
	list = list.concat(this.inventory.allFullItemSlots());
	
	if (this.quickWeaponSlot.hasItem()) {
		list.push(this.quickWeaponSlot);
	}
	
	return list;
};

// HIGHEST_MOD:
// Returns the highest mod of the itemType in the inventory or 0 if no item
// ************************************************************************************************
CharacterInventory.prototype.highestMod = function (itemType) {
	var itemList;
	itemList = this.allFullItemSlots().map(slot => slot.item);
	itemList = itemList.filter(item => item.type === itemType);
	itemList.sort((a, b) => b.mod - a.mod);
	return itemList.length > 0 ? itemList[0].mod : 0;
};

// ITEM_OF_TYPE:
// Returns the item in the players inventory of the specified type
// ************************************************************************************************
CharacterInventory.prototype.itemOfType = function (type) {
	if (this.weaponHotBar.itemOfType(type)) {
		return this.weaponHotBar.itemOfType(type);
	}
	else if (this.consumableHotBar.itemOfType(type)) {
		return this.consumableHotBar.itemOfType(type);
	}
	else if (this.inventory.itemOfType(type)) {
		return this.inventory.itemOfType(type);
	}
	else if (this.equipment.itemOfType(type)) {
		return this.equipment.itemOfType(type);
	}
	else {
		return null;
	}
};

// COUNT_ITEM_OF_TYPE:
// ************************************************************************************************
CharacterInventory.prototype.countItemOfType = function (type) {
	var item = this.itemOfType(type);
	
	if (item) {
		return item.amount;
	}
	else {
		return 0;
	}
};

// GET_WEAPON:
// ************************************************************************************************
CharacterInventory.prototype.getWeapon = function () {
	if (this.quickWeaponEquipped) {
		if (this.quickWeaponSlot.item) {
			return this.quickWeaponSlot.item;
		}
		else {
			return this.fists;
		}
	}
	else if (this.character.statusEffects.has('FlamingHands')) {
		return this.flamingHands;
	}
	else if (this.weaponIndex === -1) {
		return this.fists;
	} 
	else if (this.weaponHotBar.itemAtIndex(this.weaponIndex) === null) {
		return this.fists;
	} 
	else {
		return this.weaponHotBar.itemAtIndex(this.weaponIndex);
	}
};

// GET_QUICK_WEAPON:
// ************************************************************************************************
CharacterInventory.prototype.getQuickWeapon = function () {
	return this.quickWeaponSlot.item;
};

// GET_CHARM:
// ************************************************************************************************
CharacterInventory.prototype.getCharm = function () {
	return this.equipmentSlot('charm').item;
};

// SWAP_WEAPON:
// ************************************************************************************************
CharacterInventory.prototype.swapWeapon = function () {
	// No last weapon:
	if (this.lastWeaponIndex === -1) {
		return;
	}

	// Still don't have weapon:
	if (!this.weaponHotBar.itemAtIndex(this.lastWeaponIndex)) {
		return;
	}

	gs.pc.weaponSlotClicked(this.weaponHotBar.itemSlots[this.lastWeaponIndex]);
};

// ON_UPDATE_TURN:
// ************************************************************************************************
CharacterInventory.prototype.onUpdateTurn = function () {
	if (this.equipmentSlot('charm').hasItem()) {
		this.equipmentSlot('charm').item.onUpdateTurn();
	}
};

// ON_UPDATE_STATS:
// ************************************************************************************************
CharacterInventory.prototype.onUpdateStats = function () {
	this.equipmentList().forEach(function(item) {
		item.applyEquipmentStats(this.character);
	}, this);
};

// EQUIPMENT_LIST:
// Return a list of all the items the character is currently wearing
// Returns a list of 'Items'
// ************************************************************************************************
CharacterInventory.prototype.equipmentList = function () {
	var list = [];
	
	this.equipment.forEachItem(function (item) {
		if (item.type.slot !== 'shield') {
			list.push(item);
		}
		// Only add shield if the player can wield it i.e. not wielding a two-hander
		else if (this.canWieldShield()) {
			list.push(item);
		}
		
	}, this);

	// Adding weapon:
	list.push(this.getWeapon());
	
	return list;
};

// CAN_WIELD_SHIELD:
// Determines if the player can validly equip an item in the shield slot.
// ************************************************************************************************
CharacterInventory.prototype.canWieldShield = function () {
	return this.getWeapon().type.hands === 1 || this.character.size === CHARACTER_SIZE.LARGE;
};

// HAS_SHIELD_EQUIPPED:
// Used for determining if the character can use shield abilities.
// Note that this will return false for items like orbs of power even though they fit in the shield slot
// ************************************************************************************************
CharacterInventory.prototype.hasShieldEquipped = function () {
	return this.equipmentSlot('shield').hasItem()
		&& this.equipmentSlot('shield').item.type.stats.protection > 0
		&& this.canWieldShield();
};

// UNIT_TESTS:
// ************************************************************************************************
CharacterInventory.UnitTests = function () {
	var pc = new PlayerCharacter(),
		inventory = pc.inventory,
		data;
	
	// EQUIPMENT_SLOT:
	// ********************************************************************************************
	EQUIPMENT_SLOT_NAMES.forEach(function (name) {
		ASSERT_EQUAL(inventory.equipmentSlot(name).isEmpty(), true, 'Test Failed');
	}, this);
	
	ASSERT_THROW(inventory.equipmentSlot.bind(inventory, 'foobar'), 'Test Failed');
	
	// CAN_ADD_ITEM:
	// ********************************************************************************************
	ASSERT_THROW(inventory.canAddItem.bind(inventory, 'foobar'));
	
	ASSERT_EQUAL(inventory.canAddItem(Item.createItem('GoldCoin')), true, 'Always add gold');
	ASSERT_EQUAL(inventory.canAddItem(Item.createItem('Key')), true, 'Always add keys');
	ASSERT_EQUAL(inventory.canAddItem(Item.createItem('GobletOfYendor')), true, 'Always add goblet');
	ASSERT_EQUAL(inventory.canAddItem(Item.createItem('PotionOfHealing')), true, 'Can add to consumable bar');
	ASSERT_EQUAL(inventory.canAddItem(Item.createItem('LongSword')), true, 'Can add to weapon bar');
	
	// Fill the weapon bar:
	while (inventory.weaponHotBar.canAddItem(Item.createItem('LongSword'))) {
		inventory.addItem(Item.createItem('LongSword'));
	}
	ASSERT_EQUAL(inventory.weaponHotBar.canAddItem(Item.createItem('LongSword')), false, 'Weapon hotbar should be full now');
	ASSERT_EQUAL(inventory.canAddItem(Item.createItem('LongSword')), true, 'Should add to general inventory even when full');
	
	// Fill the general inventory:
	while (inventory.inventory.canAddItem(Item.createItem('LongSword'))) {
		inventory.addItem(Item.createItem('LongSword'));
	}
	ASSERT_EQUAL(inventory.canAddItem(Item.createItem('LongSword')), false, 'Inventory should now be full');
	
	// ADD_ITEM:
	// ********************************************************************************************
	pc = new PlayerCharacter();
	inventory = pc.inventory;
	
	inventory.addItem(Item.createItem('GoldCoin', {amount: 10}));
	ASSERT_EQUAL(inventory.gold, 10, 'Adding gold item');
	
	inventory.addItem(Item.createItem('Key'));
	ASSERT_EQUAL(inventory.keys, 1, 'Adding key item');
	
	let numTalents = pc.availableTalents.length;
	inventory.addItem(Item.createItem('TomeOfInferno'));
	ASSERT_EQUAL(pc.availableTalents.length > numTalents, true, 'Successfully added talents');
	
	// Add to consumable bar:
	inventory.addItem(Item.createItem('PotionOfHealing'));
	ASSERT_EQUAL(inventory.consumableHotBar.countItemOfType(gs.itemTypes.PotionOfHealing), 1);
	
	// Stack on consumable bar:
	inventory.addItem(Item.createItem('PotionOfHealing'));
	ASSERT_EQUAL(inventory.consumableHotBar.countItemOfType(gs.itemTypes.PotionOfHealing), 2);
	
	// Add to weapon bar:
	inventory.addItem(Item.createItem('Dart', {amount: 1}));
	ASSERT_EQUAL(inventory.weaponHotBar.countItemOfType(gs.itemTypes.Dart), 1);
	
	// Stack on weapon bar:
	inventory.addItem(Item.createItem('Dart', {amount: 1}));
	ASSERT_EQUAL(inventory.weaponHotBar.countItemOfType(gs.itemTypes.Dart), 2);
	
	// Add to main inventory:
	inventory.inventory.addItem(Item.createItem('Javelin', {amount: 1}));
	ASSERT_EQUAL(inventory.inventory.countItemOfType(gs.itemTypes.Javelin), 1);
	
	// Stack on main inventory:
	inventory.addItem(Item.createItem('Javelin', {amount: 1}));
	ASSERT_EQUAL(inventory.inventory.countItemOfType(gs.itemTypes.Javelin), 2);
	
	// Make sure it wasn't added to weapons:
	ASSERT_EQUAL(inventory.weaponHotBar.countItemOfType(gs.itemTypes.Javelin), 0);
	
	// ADD / REMOVE EVERY ITEM:
	// ********************************************************************************************
	pc = new PlayerCharacter();
	inventory = pc.inventory;
	
	// Attempt to add and remove every item in the game:
	for (let key in gs.itemTypes) {
		if (gs.itemTypes.hasOwnProperty(key)) {
			let item = Item.createItem(key);
			inventory.addItem(item);
			
			if (inventory.itemOfType(item.type)) {
				inventory.removeItem(item);
			}
		}
	}
};
/*global game, gs, Phaser, console, util*/
/*global GOOD_DROP_TABLE_LIST*/
/*jslint white: true */
'use strict';

// CREATE_UNIQUE_NPC_TYPES:
// ************************************************************************************************
gs.createUniqueNPCTypes = function () {
	this.dialog = {};
	this.dialogInit = {};
	this.npcInventories = {};
	this.dialogFuncs = {};


	// DEFAULT:
	this.dialog.Default = [
		{text: 'No Dialog',
		 responses: [{text: '[Done]', nextLine: 'exit'}]
		}
	];

	// MERCHANT:
	this.dialog.Merchant = [
		{text: "Greetings brave adventurer and welcome to my humble shop! Can I interest you in some items?",
		 responses: [
			 {text: "[View Items]", nextLine: 'barter'},
			 {text: "[Done]", nextLine: 'exit'}
		 ]
		}
	];
	
	// SKILL_TRAINER:
	this.dialog.SkillTrainer = [
		{text: "Hello brave adventurer. I can provide you with additional skill points for 25 gold each.",
		 responses: [
			 {text: 'Ok',
			  prereq: function () {
				  return gs.pc.inventory.gold >= 25;
			  },
			  func: function () {gs.pc.skillPoints += 1; gs.pc.inventory.gold -= 25;},
			  nextLine: 'exit'
			 },
			 {text: 'No thanks', 
			  nextLine: 'exit'
			 }
		 ]
		}
	];
	
	// TALENT_TRAINER:
	this.dialog.TalentTrainer = [
		{text: "Hello brave adventurer. I can provide you with additional talent points for 100 gold each.",
		 responses: [
			 {text: 'Ok',
			  prereq: function () {
				  return gs.pc.inventory.gold >= 100;
			  },
			  func: function () {
				  gs.pc.talentPoints += 1;
				  gs.pc.inventory.gold -= 100;
			  },
			  nextLine: 'exit'},
			 {text: 'No thanks', nextLine: 'exit'}
		 ]
		}
	];
	
	// PRIEST:
	this.dialog.Priest = [{text: "Hello brave adventurer. For a small donation of 10 gold I can fully restore your health and mana and provide you with a powerful blessing.",
								 responses: [{text: 'Ok',
											  prereq: function () {return gs.pc.inventory.gold >= 10;},
											  func: function () {
												  gs.pc.cure();
												  gs.pc.mentalCure();
												  gs.pc.healHp(gs.pc.maxHp);
												  gs.pc.gainMp(gs.pc.maxMp);
												  gs.pc.statusEffects.add('Bless');
												  gs.pc.inventory.gold -= 10;
											  },
											  nextLine: 'exit'},
											 {text: 'No thanks', nextLine: 'exit'}
											 ]
								}
							   ];
    
	// GUARDED_CONTAINER:
	this.dialog.GuardedContainer = [
		{text: 'Are you sure you want to open this container?',
		 responses: [
			 {text: 'Yes', nextLine: 'exit', func: function () {gs.openingContainer.openContainer(); }},
			 {text: 'No', nextLine: 'exit'}
		 ]
		}
	];

    //Cow:	
    this.dialog.Cow = [{text: 'Moo',
									 responses: [{text: 'Okay', nextLine: 'exit'},
												]
									}
								   ];
        
    //Chicken:	
    this.dialog.Chicken = [{text: 'Cluck Cluck',
									 responses: [{text: 'Okay', nextLine: 'exit'},
												]
									}
								   ];
    
    //Pig:	
    this.dialog.Pig = [{text: 'Oink Oink',
									 responses: [{text: 'Okay', nextLine: 'exit'},
												]
									}
								   ];
    
    //Sheep:	
    this.dialog.Sheep = [{text: 'Baa',
									 responses: [{text: 'Okay', nextLine: 'exit'},
												]
									}
								   ];
	// GUARDED_DOOR:
	this.dialog.GuardedDoor = [{text: 'This door is covered in warning glyphs. Really open it?',
								responses: [{text: 'Yes', nextLine: 'exit', func: function () {gs.openingDoor.openDoor(); }},
											{text: 'No', nextLine: 'exit'}
										   ]
							   }
							  ];
	
	// CRYSTAL_CHEST:
	this.dialog.CrystalChest = [
		{text: 'Opening this chest will permanently seal nearby crystal chests.',
		 responses: [
			 {text: 'Open chest.',
			  nextLine: 'exit',
			  func: function () {
				  gs.crystalChestGroupIsOpen[gs.openingContainer.groupId] = true;
				  gs.pc.inventory.addItem(gs.openingContainer.item);
				  gs.openingContainer.item = null;
				  gs.openingContainer.setIsFull(false);
				  gs.HUD.miniMap.refresh();
			  }
			 },
			 {text: 'Nevermind.',
			  nextLine: 'exit'
			 }
		 ]
		}
	];
	
	// SEALED_CRYSTAL_CHEST:
	this.dialog.SealedCrystalChest = [
		{text: 'This chest has been permanently sealed.',
		 responses: [
			 {text: 'Ok.', nextLine: 'exit'}
		 ]
		}
	];
	
	// LOCKED_DOOR:
	this.dialog.LockedDoor = [
		{text: 'This door is locked, would you like to use a key to open it?',
		 responses: [
			 {text: 'Yes', 
			  nextLine: 'exit',
			  prereq: function () {return gs.pc.inventory.keys > 0;},
			  func: function () {gs.pc.inventory.keys -= 1; gs.openingDoor.openDoor();}
			 },
			 {text: 'No', nextLine: 'exit'}
		 ]
		}
	];
	
	// PERMA_LOCKED_DOOR:
	this.dialog.PermaLockedDoor = [
		{text: 'The gate has closed and you can see no way of opening it.',
		 responses: [{text: 'Ok', nextLine: 'exit'}]
		}
	];
	
	// SWITCH_GATE:
	this.dialog.SwitchGate = [
		{text: 'This gate is sealed shut. There must be a switch somewhere on the level that opens it.',
		 responses: [{text: 'Ok', nextLine: 'exit'}]
		}
	];
	
	// TIMED_TREASURE_ROOM:
	this.dialog.TimedTreasureRoom = [
		{text: 'You hear the sound of a gate slowly grinding shut somewhere on this level.',
		 responses: [{text: 'Ok', nextLine: 'exit'}]
		}
	];
	
	// BRANCH_HELP:
	this.dialog.BranchHelp = [
		{text: 'You have entered an optional side branch of the dungeon. You can return to the previous level at any time in order to continue your quest.',
		 responses: [{text: 'Ok', nextLine: 'exit'}]
		}
	];
	
	// SLAVE:
	this.dialog.Slave = [{text: '[PLACEHOLDER] Thank you for saving me!',
						  responses: [{text: "You're welcome!", nextLine: 'exit'}
									 ],
						  func: function () {
							  gs.dialogNPC.destroy();
						  }
						 }
						];
};/*global gs, game, console*/
/*global PlayerCharacter, Character, NPC*/
/*global PLAYER_INITIAL_HP, PLAYER_INITIAL_MP, PLAYER_INITIAL_MAX_FOOD*/
/*global PLAYER_HP_PER_LEVEL, PLAYER_MP_PER_LEVEL*/
/*global RANGE_MULTIPLIER_PER_SKILL, SPELL_MULTIPLIER_PER_SKILL, STEALTH_PER_SKILL*/
/*global SAVE_AMMO_PER_SKILL, HP_PER_SKILL, MP_PER_SKILL*/
/*global HP_REGEN_TIME, MP_REGEN_TIME, CRITICAL_PERCENT, MAX_RAGE, RAGE_DECREASE_TURNS*/
/*global MAX_DEFENSE, CHARACTER_SIZE, CRIT_MULTIPLIER*/
/*global MOVE_TIME, RAGE_POINT_PERCENT*/
/*global MAX_EVASION_PERCENT, EVASION_PERCENT_PER_POINT*/
/*global CRIT_PERCENT_PER_STEALTH*/
/*global RESISTANCE_MULTIPLIER*/
/*global MAX_REFLECTION_PERCENT, REFLECTION_PERCENT_PER_POINT*/
/*jshint esversion: 6*/
'use strict';



// UPDATE_STATS_BASE:
// ************************************************************************************************
Character.prototype.updateStatsBase = function () {
	var key;
	
	// Zero Out Bonus Stats:
	this.bonusMaxHp = 0;
	this.bonusMaxMp = 0;
	this.bonusMaxFood = 0;
	this.bonusExpMod = 0;
	this.bonusGoldMod = 0;
	this.bonusDamageShield = 0;
	this.bonusMeleeRange = 0;
	this.bonusProjectileRange = 0;
	this.bonusMovementSpeed = 0;
	this.bonusSaveAmmoChance = 0;
	this.bonusSaveManaChance = 0;
	this.bonusReflection = 0;
	this.bonusEvasion = 0;
	this.bonusHpRegenTime = 0;
	this.bonusMpRegenTime = 0;
	this.maxHpModifier = 0;
	this.meleeLifeTap = 0;
	this.critMultiplier = CRIT_MULTIPLIER;
	
	// Flaggy type stuff:
	// Using integers in the case that multiple effects want to set this same flag (they can all just increment by 1);
	// Also because equipment works by adding to the stat (an integer)
	this.isFlying = 0;
	this.isTelepathic = 0;
	this.hasLifeSaving = 0;
	this.hasInferno = 0;
	this.hasThunder = 0;
	this.hasRage = 0;
	this.isConfused = 0;
	this.isSlowProjectile = this.type.isSlowProjectile;
	
	// Mostly status effects:
	this.isMultiMoving = 0;
	this.alwaysCrit = 0;
	this.alwaysProjectileCrit = 0;
	this.knockBackOnHit = 0;
	this.isWet = 0;
	this.isFlammable = 0;
	this.isUnstable = 0;
	this.isStunned = 0;
	this.isMarked = 0;
	this.isImmobile = 0;
	this.hasKeenHearing = 0;
	
	if (this.type.cantMove) {
		this.isImmobile = 1;
	}
	
	// Size:
	this.size = this.type.size;
	
	// Weapons:
	this.meleePower = 0;
	this.rangePower = 0;
	this.maxRage = MAX_RAGE;
	
	// Stealth:
	this.stealth = 0;
	this.stealthModifier = 0;
	
	// Spells:
	this.firePower = 0;
	this.coldPower = 0;
	this.toxicPower = 0;
	this.stormPower = 0;
	this.spellPower = 0;
	this.spellPowerModifier = 0;
	this.manaConservation = {Fire: 0, Cold: 0, Toxic: 0, Storm: 0};
	
	// Resistance:
	this.protection = this.type.protection;
	this.resistance.Fire = this.type.resistance.Fire;
	this.resistance.Cold = this.type.resistance.Cold;
	this.resistance.Shock = this.type.resistance.Shock;
	this.resistance.Toxic = this.type.resistance.Toxic;
	this.blockChance = 0;
	this.parryChance = 0;
	
	// Attributes:
	this.strength = this.baseStrength;
	this.dexterity = this.baseDexterity;
	this.intelligence = this.baseIntelligence;
	
	// Class:
	if (this.characterClass && gs.classEffects[this.characterClass]) {
		gs.classEffects[this.characterClass](this);
	}
	
	// Race:
	if (this.race) {
		this.race.effect(this);
	}
	
	// Equipment:
	if (this.inventory) {
		this.inventory.onUpdateStats();
	}
	
	// NPC Class:
	if (this.npcClassType && this.npcClassType.effect) {
		this.npcClassType.effect(this);
	}
	
	// Status Effects:
	this.statusEffects.onUpdateStats();
	
	
	// Talents:
	if (this.talents) {
		this.talents.forEach(function (talent) {
			if (talent.type.effect) {
				talent.type.effect(this);
			}
		}, this);
	}
	
	// Sustained Abilities:
	this.abilities.list.forEach(function (ability) {
		if (ability && ability.isOn) {		
			if (ability.type.sustainedEffect) {
				ability.type.sustainedEffect(this);
			}
			this.bonusMaxMp -= ability.type.mana;
		}
	}, this);
	
	// Sustained Summons:
	this.getActiveSummonList().forEach(function (char) {
		if (char.type.sustainedMpCost) {
			this.bonusMaxMp -= char.type.sustainedMpCost;
		}
	}, this);
	
	// Religion:
	if (this.religion && gs.religionTypes[this.religion].effect) {
		gs.religionTypes[this.religion].effect(this);
	}
	
	// Spell Power:
	this.spellPower += (this.intelligence - 10);
	this.spellPower += this.skills.SpellCasting;
	
	// Magic Power:
	this.firePower += this.spellPower;
	this.coldPower += this.spellPower;
	this.stormPower += this.spellPower;
	this.toxicPower += this.spellPower;
	
	// Magic Modifier (penalty):
	this.firePower = Math.floor(this.firePower + this.firePower * this.spellPowerModifier);
	this.coldPower = Math.floor(this.coldPower + this.coldPower * this.spellPowerModifier);
	this.stormPower = Math.floor(this.stormPower + this.stormPower * this.spellPowerModifier);
	this.toxicPower = Math.floor(this.toxicPower + this.toxicPower * this.spellPowerModifier);
	this.spellPower = Math.floor(this.spellPower + this.spellPower * this.spellPowerModifier);
	
	// Magic Damage Multipliers:
	this.fireDamageMultiplier =		1.0 + this.firePower * 0.05;
	this.coldDamageMultiplier =		1.0 + this.coldPower * 0.05;
	this.shockDamageMultiplier =	1.0 + this.stormPower * 0.05;
	this.toxicDamageMultiplier = 	1.0 + this.toxicPower * 0.05;
	this.spellDamageMultiplier =	1.0 + this.spellPower * 0.05;
	
	// Melee damage multiplier:
	this.meleePower += (this.strength - 10);
	this.meleePower += this.skills.Melee;
	
	// Rage damage multiplier:
	if (this.hasRage && this.rage > 0) {
		this.meleePower += this.rage;
	}
	
	this.meleeDamageMultiplier = 1.0 + this.meleePower * 0.05;
	
	// Range damage multiplier:
	this.rangePower += (this.dexterity - 10);
	this.rangePower += this.skills.Range;
	this.rangeDamageMultiplier = 1.0 + this.rangePower * 0.05;
	
	
	// Evasion:
	this.evasion = this.type.evasion;
	this.evasion += this.bonusEvasion;
	this.evasion += Math.floor( (this.dexterity - 10) / 2);
	
	// Stealth:
	this.stealth += (this.dexterity - 10);
	this.stealth += this.skills.Stealth;
	this.stealth = Math.floor(this.stealth + this.stealth * this.stealthModifier);
	
	// Adrenaline:
	if (this.hasTalent('Adrenaline') && this.currentHp <= this.maxHp / 3) {
		this.bonusSaveManaChance += 0.5;
	}
	
	// Other Stats:
	this.damageShield = this.type.damageShield + this.bonusDamageShield;
	this.saveAmmoChance = this.bonusSaveAmmoChance;
	this.saveManaChance = this.bonusSaveManaChance;
	this.reflection = this.type.reflection + this.bonusReflection;
	
	// Crit Multiplier:
	this.critMultiplier += this.stealth * CRIT_PERCENT_PER_STEALTH;
	
	
	if (this.type.isFlying) {
		this.isFlying += 1;
	}
	
	// Movement:
	this.movementSpeed = Math.max(0, Math.min(2, this.type.movementSpeed + this.bonusMovementSpeed));
	this.moveTime = MOVE_TIME[this.movementSpeed];
};

// UPDATE_STATS
// ************************************************************************************************
NPC.prototype.updateStats = function () {
	this.updateStatsBase();
	
	if (this.type.hitPointType) {
		this.maxHp = gs.npcMaxHp(this.level, this.type.hitPointType);
	}
	else {
		this.maxHp = this.type.maxHp;
	}
	
	this.maxHp += this.bonusMaxHp;
	
	this.hpRegenTime = Math.round(HP_REGEN_TIME / this.maxHp);
	this.mpRegenTime = Math.round(MP_REGEN_TIME / this.maxMp);
};

// PLAYER_UPDATE_STATS:
// ************************************************************************************************
PlayerCharacter.prototype.updateStats = function () {
	this.updateStatsBase();
	
	// Initial:
	this.maxHp = PLAYER_INITIAL_HP[this.characterClass];
	this.maxMp = PLAYER_INITIAL_MP[this.characterClass];
	
	// Level Contribution:
	this.maxHp += (this.level - 1) * PLAYER_HP_PER_LEVEL[this.characterClass];
	this.maxMp += (this.level - 1) * PLAYER_MP_PER_LEVEL[this.characterClass];
	
	// Additional Bonuses:
	this.maxHp += this.bonusMaxHp;
	this.maxMp += this.bonusMaxMp;
	
	// Attribute Bonus:
	this.maxHp += (this.strength - 10) * 2;
	this.maxMp += (this.intelligence - 10);
	
	// Skill Bonus:
	this.maxHp += this.skills.Fortitude * 2;
	this.maxMp += this.skills.Focus;
	
	// Permanent Bonus:
	this.maxHp += this.permanentHpBonus;
	this.maxMp += this.permanentMpBonus;
	
	// Modifier:
	this.maxHp += this.maxHp * this.maxHpModifier;
	
	// Round:
	this.maxHp = Math.round(this.maxHp);
	this.maxMp = Math.round(this.maxMp);
	
	// Barbarian (no mana):
	if (this.characterClass === 'Barbarian') {
		this.maxMp = 0;
	}
	
	this.maxFood = PLAYER_INITIAL_MAX_FOOD + this.bonusMaxFood;
	this.expMod = 1 + this.bonusExpMod;
	this.goldMod = 1 + this.bonusGoldMod;
	
	// Shield Wall:
	if (this.hasTalent('ShieldWall') && this.inventory.hasShieldEquipped()) {
		gs.getIndexListAdjacent(this.tileIndex).forEach(function (tileIndex) {
			if (!gs.isStaticPassable(tileIndex)) {
				this.protection += 1;
			}
		}, this);
	}
	
	// Make sure to remove sustained effects if player does not have enough mana:
	while (this.maxMp < 0 && this.abilities.list.find(ability => ability && ability.isOn)) {
		let ability = this.abilities.list.find(ability => ability && ability.isOn);
		ability.isOn = false;
		this.maxMp += ability.type.mana;
	}
	
	
	// Cap Stats:
	this.capStats();
	
	// In case player removes a flying item while over a pit:
	// Note: must check if there is even a tile there in the case that the player is updating his stats before map is created
	if (gs.getTile(this.tileIndex) && gs.getTile(this.tileIndex).type.isPit && !this.isFlying) {
		if (gs.state === 'CHARACTER_MENU_STATE') {
			gs.characterMenu.close();
		}
		this.fallDownPit();
	}
	
	this.hpRegenTime = 10 - this.bonusHpRegenTime;
	this.mpRegenTime = 15 - this.bonusMpRegenTime;
};


// CAP_STATS:
// ************************************************************************************************
Character.prototype.capStats = function () {
	this.maxHp = Math.max(0, this.maxHp);
	this.maxMp = Math.max(0, this.maxMp);
	
	this.currentFood = Math.min(this.currentFood, this.maxFood);
	this.currentHp = Math.min(this.currentHp, this.maxHp);
	this.currentMp = Math.min(this.currentMp, this.maxMp);
	
	// Resistance Cap:
	this.resistance.Shock = Math.min(this.resistance.Shock, 3);
	this.resistance.Fire = Math.min(this.resistance.Fire, 3);
	this.resistance.Cold = Math.min(this.resistance.Cold, 3);
	this.resistance.Toxic = Math.min(this.resistance.Toxic, 3);
	
	this.hpRegenTime = Math.max(this.hpRegenTime, 1);
	this.mpRegenTime = Math.max(this.mpRegenTime, 1);
	
	this.size = Math.max(CHARACTER_SIZE.SMALL, Math.min(CHARACTER_SIZE.LARGE, this.size));
};

// WEAPON_DAMAGE:
// ************************************************************************************************
PlayerCharacter.prototype.weaponDamage = function (weapon) {
	var damage;
	
	weapon = weapon || this.inventory.getWeapon();
	
	damage = weapon.getModdedStat('damage');
	
	// Magic Staff:
	if (weapon.type.effect === gs.weaponEffects.MagicStaff) {
		if (gs.projectileTypes[weapon.type.projectileName].damageType === 'Fire') {
			damage *= this.fireDamageMultiplier;
		}
		else if (gs.projectileTypes[weapon.type.projectileName].damageType === 'Cold') {
			damage *= this.coldDamageMultiplier;
		}
		else if (gs.projectileTypes[weapon.type.projectileName].damageType === 'Toxic') {
			damage *= this.toxicDamageMultiplier;
		}
		else if (gs.projectileTypes[weapon.type.projectileName].damageType === 'Shock') {
			damage *= this.shockDamageMultiplier;
		}
		else if (gs.projectileTypes[weapon.type.projectileName].damageType === 'Physical') {
			damage *= this.spellDamageMultiplier;
		}
	}
	// Melee Weapon:
	else if (weapon.type.effect.skill === 'Melee') {
		damage *= this.meleeDamageMultiplier;
	}
	// Range Weapon:
	else if (weapon.type.effect.skill === 'Range') {
		damage *= this.rangeDamageMultiplier;
	}
	
	damage = Math.round(damage);
	
	return damage;
};

// WEAPON_RANGE:
// ************************************************************************************************
PlayerCharacter.prototype.weaponRange = function (weapon) {
	var range;
	
	weapon = weapon || this.inventory.getWeapon();
	
	// Melee:
	if (weapon.type.effect.skill === 'Melee') {
		range = weapon.type.range + this.bonusMeleeRange;
	}
	// Range:
	else if (weapon.type.effect.skill === 'Range') {
		range = weapon.type.range + this.bonusProjectileRange;
	}
	
	return range;
};

// WEAPON_MIN_RANGE:
// ************************************************************************************************
PlayerCharacter.prototype.weaponMinRange = function (weapon) {
	weapon = weapon || this.inventory.getWeapon();
	
	// Elves have no minRange:
	if (this.race.name === 'Elf') {
		return 0;
	}
	else {
		return weapon.type.minRange;
	}
};

// DODGE_PERCENT:
// ************************************************************************************************
Character.prototype.dodgePercent = function () {
	return Math.min(MAX_EVASION_PERCENT, this.evasion * EVASION_PERCENT_PER_POINT);
};

// REFLECT_PERCENT:
// ************************************************************************************************
Character.prototype.reflectPercent = function () {
	return Math.min(MAX_REFLECTION_PERCENT, this.reflection * REFLECTION_PERCENT_PER_POINT);
};

// GET_STAT_DESC:
// ************************************************************************************************
PlayerCharacter.prototype.getStatDesc = function (tag) {
	var str = '';
	
	if (tag === 'Strength') {
		str += 'Strength:\n';
		str += 'Each point of strength over 10 gives +2 HP and +1 Melee Power.';
	}
	else if (tag === 'Dexterity') {
		str += 'Dexterity:\n';
		str += 'Each point of dexterity over 10 gives +1 Stealth and +1 Range Power.\n';
		str += 'You will also gain +1 Evasion for every 2 points of dexterity.';
	}
	else if (tag === 'Intelligence') {
		str += 'Intelligence:\n';
		str += 'Each point of intelligence over 10 gives +1 MP and +1 Spell Power.';
	}
	else if (tag === 'Protection') {
		str += 'Protection:\n';
		
		if (this.protection > 0) {
			str += 'Your armor will reduce physical damage by 0 - ' + this.protection + ' points every time you are hit by a physical attack.';
		}
		else {
			str += 'Your armor will reduce physical damage by 0 points every time you are hit by a physical attack.';
		}
	}
	else if (tag === 'Evasion') {
		str += 'Evasion:\n';
		str += 'Each point of evasion gives you a ' + gs.toPercentStr(EVASION_PERCENT_PER_POINT) + ' chance to dodge melee and projectile attacks';
		str += ' up to a max of ' + gs.toPercentStr(MAX_EVASION_PERCENT) + '\n';
		str += 'Your evasion is giving you a ' + gs.toPercentStr(this.dodgePercent()) + ' chance to dodge.';
	}
	else if (tag === 'Reflection') {
		str += 'Reflection:\n';
		str += 'Each point of reflection gives you a ' + gs.toPercentStr(REFLECTION_PERCENT_PER_POINT) + ' chance to reflect projectile attacks';
		str += ' up to a max of ' + gs.toPercentStr(MAX_REFLECTION_PERCENT) + '\n';
		str += 'Your reflection is giving you a ' + gs.toPercentStr(this.reflectPercent()) + ' chance to reflect.';
	}
	else if (tag === 'Stealth') {
		str += 'Stealth:\n';
		str += 'Decreases the chance that unaware monsters will spot you. ';
		str += 'Each point of stealth will increase the damage of all critical hits by ' + gs.toPercentStr(CRIT_PERCENT_PER_STEALTH) + '.';
	}
	else if (tag === 'FireResistance') {
		str += 'Fire Resistance:\n';
		str += 'Gives you a chance to resist ' + gs.toPercentStr(RESISTANCE_MULTIPLIER[this.resistance.Fire] / 2) + ' of all fire damage.';
	}
	else if (tag === 'ColdResistance') {
		str += 'Cold Resistance:\n';
		str += 'Gives you a chance to resist ' + gs.toPercentStr(RESISTANCE_MULTIPLIER[this.resistance.Cold] / 2) + ' of all cold damage.';
	}
	else if (tag === 'ShockResistance') {
		str += 'Shock Resistance:\n';
		str += 'Gives you a chance to resist ' + gs.toPercentStr(RESISTANCE_MULTIPLIER[this.resistance.Shock] / 2) + ' of all shock damage.';
	}
	else if (tag === 'ToxicResistance') {
		str += 'Toxic Resistance:\n';
		str += 'Gives you a chance to resist ' + gs.toPercentStr(RESISTANCE_MULTIPLIER[this.resistance.Toxic] / 2) + ' of all toxic damage.';
	}
	else if (tag === 'MeleePower') {
		str += 'Melee Power:\n';
		str += 'Each point of melee power increases your melee damage by 5%.\n';
		str += 'Your melee power is giving you a +' + gs.toPercentStr(this.meleeDamageMultiplier - 1) + ' modifier to melee damage.';
		
	}
	else if (tag === 'RangePower') {
		str += 'Range Power:\n';
		str += 'Each point of range power increases your range damage by 5% with bows, slings and thrown weapons.\n';
		str += 'Your range power is giving you a +' + gs.toPercentStr(this.rangeDamageMultiplier - 1) + ' modifier to range damage.';
		
	}
	else if (tag === 'SpellPower') {
		str += 'Spell Power:\n';
		str += 'Each point of spell power increases the damage, duration etc. of all spells by 5%.\n';
		str += 'Your spell power is giving you a +' + gs.toPercentStr(this.spellDamageMultiplier - 1) + ' modifier to all spells.';
	}
	else if (tag === 'FirePower') {
		str += 'Fire Power:\n';
		str += 'Each point of fire power increases the damage, duration etc. of all fire spells by 5%.\n';
		str += 'Your fire power is giving you a +' + gs.toPercentStr(this.fireDamageMultiplier - 1) + ' modifier to all fire spells.';
	}
	else if (tag === 'ColdPower') {
		str += 'Cold Power:\n';
		str += 'Each point of cold power increases the damage, duration etc. of all cold spells by 5%.\n';
		str += 'Your cold power is giving you a +' + gs.toPercentStr(this.coldDamageMultiplier - 1) + ' modifier to all cold spells.';
	}
	else if (tag === 'StormPower') {
		str += 'Storm Power:\n';
		str += 'Each point of storm power increases the damage, duration etc. of all storm spells by 5%.\n';
		str += 'Your storm power is giving you a +' + gs.toPercentStr(this.shockDamageMultiplier - 1) + ' modifier to all storm spells.';
	}
	else if (tag === 'ToxicPower') {
		str += 'Toxic Power:\n';
		str += 'Each point of toxic power increases the damage, duration etc. of all toxic spells by 5%.\n';
		str += 'Your toxic power is giving you a +' + gs.toPercentStr(this.toxicDamageMultiplier - 1) + ' modifier to all toxic spells.';
	}
	
	return str;
};/*global gs, util*/
/*global TIME_SCALAR, TILE_SIZE*/
/*global KNOCK_BACK_SPEED, FAST_MOVEMENT_SPEED, MOVEMENT_SPEED*/
/*global CHARACTER_SIZE*/
/*jshint esversion: 6*/
'use strict';

var pcx, pcy;

// CHARACTER_BODY:
// ************************************************************************************************
function CharacterBody (character) {
	this.character = character;
	
	this.state = 'WAITING';
	this.tileIndex = {x: 0, y:  0};
	this.position = {x: 0, y: 0};
	this.offset = {x: 0, y: 0};
	this.walkBounce = 'UP';
	this.facing = 'RIGHT';
	this.isKnockBack = false;
	
	// Make sure to give player an initial tileIndex:
	this.character.tileIndex = {x: 0, y: 0};
}

// MOVE_TO_TILE_INDEX:
// Will perform a tween setting this.state to 'MOVING'
// ************************************************************************************************
CharacterBody.prototype.moveToTileIndex = function (tileIndex) {
	// Set facing:
	if (!this.isKnockBack) {
		if (tileIndex.x < this.tileIndex.x) {
        	this.facing = 'LEFT';
		} else if (tileIndex.x > this.tileIndex.x) {
			this.facing = 'RIGHT';
		}
	}
	
	
	this.setTileIndex(tileIndex);
	this.state = 'MOVING';
};

// SNAP_TO_TILE_INDEX:
// Will instantly snap position
// ************************************************************************************************
CharacterBody.prototype.snapToTileIndex = function (tileIndex) {
	this.setTileIndex(tileIndex);
	this.position.x = this.destinationPos().x;
    this.position.y = this.destinationPos().y;
	this.finishTween();
};

// SET_TILE_INDEX:
// ************************************************************************************************
CharacterBody.prototype.setTileIndex = function (tileIndex) {
	// Remove from previous tile:
	if (gs.getTile(this.tileIndex) && gs.getTile(this.tileIndex).character === this.character) {
		gs.getTile(this.tileIndex).character = null;
	}
	
	// Set new tileIndex:
    this.tileIndex.x = tileIndex.x;
    this.tileIndex.y = tileIndex.y;
	
	// Update characters tileIndex
	this.character.tileIndex.x = tileIndex.x;
	this.character.tileIndex.y = tileIndex.y;
	
	// Update global pc tileIndex (easy access when debugging):
	if (this.character === gs.pc) {
		pcx = this.tileIndex.x;
		pcy = this.tileIndex.y;
	}
	
	// Enter new tile:
	gs.getTile(this.tileIndex).character = this.character;
};

// ON_UPDATE_FRAME:
// ************************************************************************************************
CharacterBody.prototype.onUpdateFrame = function () {
	this.tweenPosition();
	this.handleKnockBack();
	this.updateFrameWalkBounce();
	
	// End turn if the sprite has arived at its destination:
	if (this.state === 'MOVING' && this.isAtDestination()) {
        this.finishTween();
    }
};

// FINISH_TWEEN:
// ************************************************************************************************
CharacterBody.prototype.finishTween = function () {
	this.state = 'WAITING';
	this.isKnockBack = false;
		
	this.character.onEnterTile();

	if (this.character.type.name === 'Penguin') {
		this.character.sprite.frame = this.character.type.frame; // resetting penguin slide
	}
};

// UPDATE_FRAME_WALK_BOUNCE:
// ************************************************************************************************
CharacterBody.prototype.updateFrameWalkBounce = function () {
	// Walk bounce:
	if (this.state === 'MOVING') {
		if (this.walkBounce === 'UP') {
			this.offset.y -= 0.4 * TIME_SCALAR;
			if (this.offset.y <= -3) {
				this.walkBounce = 'DOWN';
			}
		} 
		else if (this.walkBounce === 'DOWN') {
			this.offset.y += 0.4 * TIME_SCALAR;
			if (this.offset.y >= 0) {
				this.walkBounce = 'UP';
			}
		}
	} 
	else {
		this.offset.y *= 0.75 / TIME_SCALAR;
		this.offset.x *= 0.75 / TIME_SCALAR;
	}
};

// IS_AT_DESTINATION:
// ************************************************************************************************
CharacterBody.prototype.isAtDestination = function () {	
	return gs.distance(this.position, this.destinationPos()) <= this.tweenSpeed();
};

// DESTINATION_POS:
// ************************************************************************************************
CharacterBody.prototype.destinationPos = function () {
	return util.toPosition(this.tileIndex);
};

// HANDLE_KNOCK_BACK:
// ************************************************************************************************
CharacterBody.prototype.handleKnockBack = function () {
	let tempTileIndex = gs.toTileIndex(this.position);
	
	// Handling knock back through traps:
	// Notice that we only handle the case in which the player is passing through a tile
	// The case in which the player has arived at the tile can be handled by standard method
	if (this.isKnockBack && !gs.vectorEqual(tempTileIndex, this.tileIndex)) {
		let obj = gs.getObj(tempTileIndex, obj => obj.type.activate);
		if (obj) {
			// We temporarily place the character on the tileIndex in order to trigger the trap
			gs.getTile(tempTileIndex).character = this.character;
			obj.stepOn(this.character);
			gs.getTile(tempTileIndex).character = null;
			
			// If the trap has immobalised the character he needs to halt movement:
			// This will stop his knockback completely
			if (this.character.isImmobile && this.character.isAlive) {
				this.snapToTileIndex(tempTileIndex);
			}
		}
	}
};

// TWEEN_POSITION:
// ************************************************************************************************
CharacterBody.prototype.tweenPosition = function () {
	var speed = this.tweenSpeed(),
		destination = this.destinationPos();
    
	// Tween position X:
    if (this.position.x < destination.x - speed) {
        this.position.x += speed;
    } 
	else if (this.position.x > destination.x + speed) {
        this.position.x -= speed;
    } 
	else {
		this.position.x = destination.x;
	}
    
    // Tween position Y:
    if (this.position.y < destination.y - speed) {
        this.position.y += speed;
    } 
	else if (this.position.y > destination.y + speed) {
        this.position.y -= speed;
    } 
	else {
		this.position.y = destination.y;
	}
};

// TWEEN_SPEED:
// ************************************************************************************************
CharacterBody.prototype.tweenSpeed = function () {
	if (this.isKnockBack) {
		return KNOCK_BACK_SPEED;
	}
	else if (gs.pc && gs.pc.fastMove) {
		return FAST_MOVEMENT_SPEED;
	}
	else {
		return MOVEMENT_SPEED;
	}
};

// APPLY_KNOCK_BACK:
// ************************************************************************************************
CharacterBody.prototype.applyKnockBack = function (normalVec, numTiles) {
	var toTileIndex;
	
	// Immobile enemies (nests, statues, etc.) can never be knocked back:
	if (this.character.type.cantMove || this.character.isImmobile) {
		return;
	}
	
	// Size multiplier:
	if (this.character.size === CHARACTER_SIZE.SMALL) {
		numTiles = numTiles * 2;
	}
	else if (this.character.size === CHARACTER_SIZE.LARGE) {
		numTiles = Math.floor(numTiles / 2);
	}
	
    toTileIndex = this.getKnockBackIndex(normalVec, numTiles);
    
	if (!gs.vectorEqual(toTileIndex, this.tileIndex)) {
		this.isKnockBack = true;
		
		if (this.character !== gs.pc) {
			this.character.waitTime = 100;
		}
		
		this.moveToTileIndex(toTileIndex);
	}
};

// GET_KNOCK_BACK_INDEX:
// ************************************************************************************************
CharacterBody.prototype.getKnockBackIndex = function (normalVec, numTiles) {
	var startPosition = util.toPosition(this.tileIndex),
        currentPosition = {x: startPosition.x, y: startPosition.y},
		nextPosition,
        step = 4,
        currentDistance = 0,
		newTileIndex = this.tileIndex;
	
	for (currentDistance = 0; currentDistance <= numTiles * TILE_SIZE; currentDistance += step) {
		nextPosition = {x: startPosition.x + normalVec.x * currentDistance, y: startPosition.y + normalVec.y * currentDistance};
		
		if (!gs.vectorEqual(gs.toTileIndex(nextPosition), this.tileIndex) && !gs.isPassable(gs.toTileIndex(nextPosition))) {
			break;
		}
        currentPosition = nextPosition;
    }
	
	return gs.toTileIndex(currentPosition);
};

// FACE_TILE_INDEX:
// Used when attacking to face the direction of attack
// ************************************************************************************************
CharacterBody.prototype.faceTileIndex = function (tileIndex) {
	if (this.character.type.rotateAim) {
		return;
	}
	
	// Face target:
    if (tileIndex.x >= this.tileIndex.x) {
        this.facing = 'RIGHT';
    } else {
        this.facing = 'LEFT';
    }
};

// BOUNCE_TOWARDS:
// Used during attacks to give a bit of animation
// ************************************************************************************************
CharacterBody.prototype.bounceTowards = function (tileIndex) {
	var normal;
	
	if (gs.vectorEqual(tileIndex, this.tileIndex)) {
		normal = {x: 0, y: 0};
	}
	else {
		normal = gs.getNormal(this.tileIndex, tileIndex);
	}
	
	this.offset.x = normal.x * 10;
	this.offset.y = normal.y * 10;
};/*global Phaser, game, gs, console, TILE_SIZE, HELL_FIRE_DAMAGE*/
/*global GREEN_TARGET_BOX_FRAME, RED_SELECT_BOX_FRAME, PURPLE_SELECT_BOX_FRAME*/
/*global MAX_ABILITIES, ITEM_ABILITY_MULTIPLIER_PER_LEVEL*/
/*jshint laxbreak: true, esversion: 6, loopfunc: true*/
'use strict';

// CONSTRUCTOR:
// Abilities is an object that can be added to characters to grant them abilities
// ************************************************************************************************
function Abilities() {
	this.list = [];
	this.clearAbilities();
}

// GET_ABILITY:
// Returns the ability if it exists or null
// ************************************************************************************************
Abilities.prototype.getAbility = function (abilityTypeName) {
	return this.list.find(ability => ability && ability.type.name === abilityTypeName);
};

// UPDATE_TURN:
// Ticks cooldowns:
// ************************************************************************************************
Abilities.prototype.updateTurn = function () {
	for (let i = 0; i < MAX_ABILITIES; i += 1) {
		if (this.list[i] && this.list[i].coolDown > 0) {
			this.list[i].coolDown -= 1;
		}
	}
};

// REDUCE_COOL_DOWNS:
// Ticks cooldowns:
// ************************************************************************************************
Abilities.prototype.reduceCoolDowns = function (amount) {
	for (let i = 0; i < MAX_ABILITIES; i += 1) {
		if (this.list[i] && this.list[i].coolDown > 0) {
			this.list[i].coolDown -= amount;
			
			this.list[i].coolDown = Math.max(0, this.list[i].coolDown);
		}
	}
};

// RESET_ALL_COOLDOWNS:
// ************************************************************************************************
Abilities.prototype.resetAllCoolDowns = function () {
	for (let i = 0; i < MAX_ABILITIES; i += 1) {
		if (this.list[i]) {
			this.list[i].coolDown = 0;
		}
	}
};

// HAS_COOL_DOWN:
Abilities.prototype.hasCoolDown = function () {
	for (let i = 0; i < MAX_ABILITIES; i += 1) {
		if (this.list[i] && this.list[i].coolDown > 0) {
			return true;
		}
	}
	return false;
};

// ABILITY_IN_SLOT:
// Returns the ability in the slot or null if no ability
// ************************************************************************************************
Abilities.prototype.abilityInSlot = function (slot) {
	return this.list[slot];
};

// CLEAR_ABILITIES:
// ************************************************************************************************
Abilities.prototype.clearAbilities = function () {
	for (let i = 0; i < MAX_ABILITIES; i += 1) {
		this.list[i] = null;
	}
};

// ADD_ABILITY:
// Returns the slot
// ************************************************************************************************
Abilities.prototype.addAbility = function (type) {
	for (let i = 0; i < MAX_ABILITIES; i += 1) {
		if (this.list[i] === null) {
			this.list[i] = {
				type: type, 
				coolDown: 0,
				isOn: false
			};
			return i;
		}
	}
	
	throw 'Max abilities exceeded: have not implemented checks for this yes';
};

// REMOVE_ABILITY:
// Returns the slot
// ************************************************************************************************
Abilities.prototype.removeAbility = function (type) {
	for (let i = 0; i < MAX_ABILITIES; i += 1) {
		if (this.list[i].type === type) {
			this.list[i] = null;
			return i;
		}
	}
	
	throw 'Could not remove ability...';
};

// TO_DATA:
// ************************************************************************************************
Abilities.prototype.toData = function () {
	var data = [];
	
	for (let i = 0; i < MAX_ABILITIES; i += 1) {
		if (this.list[i]) {
			data[i] = {
				typeName: this.list[i].type.name,
				coolDown: this.list[i].coolDown,
				isOn: this.list[i].isOn
			};
		}
		else {
			data[i] = null;
		}
	}
	
	return data;
};

// LOAD_DATA:
// ************************************************************************************************
Abilities.prototype.loadData = function (data) {
	for (let i = 0; i < MAX_ABILITIES; i += 1) {
		if (data[i]) {
			this.list[i] = {
				type: gs.abilityTypes[data[i].typeName], 
				coolDown: data[i].coolDown,
				isOn: data[i].isOn
			};
		}
		else {
			this.list[i] = null;
		}
	}
};

// CREATE_NPC_ABILITY_TYPE:
// Used by NPCs to create unique abilityTypes giving them each their own unique abilities
// ************************************************************************************************
gs.createNPCAbilityType = function (npcType, abilityTypeName, abilityStats) {
	var abilityType, key;
	
	if (!this.abilityTypes[abilityTypeName]) {
		throw 'createNPCAbilityType - undefined abilityType: ' + abilityTypeName;
	}
	
	// abilityType is now a copy of the abilityType specified in the template:
	abilityType = Object.create(this.abilityTypes[abilityTypeName]);
	
	// We now grab whatever additional properties we need:
	for (key in abilityStats) {
		if (abilityStats.hasOwnProperty(key)) {
			
			if (key === 'range') {
				var range = abilityStats.range;
				abilityType.range = function () {
					return range;
				};
			}
			else {
				abilityType[key] = abilityStats[key];
			}
		}
	}
	
	// Attributes:
	if (abilityType.attributes) {
		let attributes = Object.create(abilityType.attributes);
		
		// Damage (scaled by level):
		if (attributes.damage) {
			let damage = Object.create(attributes.damage);
			
			// Damage Type i.e. LOW, MEDIUM, HIGH etc.
			if (abilityStats && abilityStats.damageType) {
				
				
				damage.damageType = abilityStats.damageType;
				
				damage.value = function (character) {
					return gs.npcDamage(character.level, this.damageType);
				};
			}
			// Setting damage directly:
			else if (abilityStats && abilityStats.baseDamage) {
				damage.value = function (character) {
					return abilityStats.baseDamage;
				};
			}
			// No Damage:
			else {
				damage.value = function (character) {
					return 0;
				};
			}
			
			attributes.damage = damage;
		}
		
		// Duration (defaults to min):
		if (attributes.duration) {
			let duration = Object.create(attributes.duration);
			duration.value = function (character) {
				return this.base[1];
			};
			attributes.duration = duration;
		}
		
		abilityType.attributes = attributes;
	}

	
	return abilityType;
};


// CREATE_ITEM_ABILITY_TYPE:
// ************************************************************************************************
gs.createItemAbilityType = function (itemType) {
	var abilityType;
	
	if (!this.abilityTypes[itemType.useEffect]) throw 'undefined abilityType: ' + itemType.useEffect;
	
	// abilityType is now a copy of the abilityType specified in the template:
	abilityType = Object.create(this.abilityTypes[itemType.useEffect]);
	
	abilityType.frame = itemType.f;
	abilityType.mana = 0;
	abilityType.name = itemType.name;
	abilityType.niceName = itemType.niceName;
	abilityType.itemType = itemType;
	
	// Attributes:
	if (abilityType.attributes) {
		let attributes = Object.create(abilityType.attributes);
		
		// Damage (scaled by level):
		if (attributes.damage) {
			let damage = Object.create(attributes.damage);
			
			damage.value = function (character) {
				return Math.ceil(this.base[1] + this.base[1] * (character.level - 1) * ITEM_ABILITY_MULTIPLIER_PER_LEVEL);
			};
			
			attributes.damage = damage;
		}

		// Duration (scaled by level):
		if (attributes.duration) {
			let duration = Object.create(attributes.duration);
			
			duration.value = function (character) {
				return Math.ceil(this.base[1] + this.base[1] * (character.level - 1) * ITEM_ABILITY_MULTIPLIER_PER_LEVEL);
			};
			
			attributes.duration = duration;
		}

		// Aoe Range (set to max):
		if (attributes.aoeRange) {
			let aoeRange = Object.create(attributes.aoeRange);
			
			aoeRange.value = function (character) {
				return this.base[this.base.length - 1];
			};
			
			attributes.aoeRange = aoeRange;
		}
		
		abilityType.attributes = attributes;
	}
	
	
	
	
	// If New ability (i.e. charm) need to add it to list:
	if (!gs.abilityTypes.hasOwnProperty(abilityType.name)) {
		gs.abilityTypes[abilityType.name] = abilityType;
	}
	
	return abilityType;
};


// ABILITY_DESC:
// ************************************************************************************************
gs.abilityDesc = function (ability, item) {
	var str = '', charm;
	
	// Need to know if the desc is refering to an ability, on the abilityBar that is generated by a charm.
	// If this is so, then we get a reference to the actual charm item that is generating the ability.
	if (ability.type.itemType && ability.type.itemType.slot === 'charm' && !item) {
		charm = gs.pc.inventory.getCharm();
	}
	
	// Ability Name:
	if (!item) {
		// Name of Charm:
		if (charm) {
			str += charm.toShortDesc() + '\n';
		}
		else {	
			str += ability.type.niceName + '\n';
		}
	}
	
	// Sustained:
	if (ability.type.isSustained) {
		str += 'Sustained Effect' + '\n';
	}
	
	// Mana:
	if (ability.type.mana) {
		str += 'Mana: ' + gs.pc.manaCost(ability.type) + '\n';
	}
	
	// Hit Points:
	if (ability.type.hitPointCost) {
		str += 'Hit Points: ' + ability.type.hitPointCost + '\n';
	}
	
	// Cool Down:
	if (ability.type.coolDown) {
		str += 'Cool Down: ' + ability.type.coolDown + '\n';
	}
	
	// Charges on Charm:
	if (charm) {
		str += 'Charges: ' + charm.charges + '/' + charm.getModdedStat('maxCharges');
		
		// Showing recharge:
		if (charm.charges < charm.getModdedStat('maxCharges')) {
			str += ' [' + charm.chargeTimer + '/' + charm.type.chargeTime + ']\n';
		}
		else {
			str += '\n';
		}
	}
	
	// Attributes:
	if (ability.type.attributes) {
		this.forEachType(ability.type.attributes, function (attribute) {
			str += gs.capitalSplit(attribute.name) + ': ';

			// Wands and Charm attributes (just show the final modified stat):
			if (item || charm) {
				str += attribute.value(gs.pc) + '\n';
			}
			// Modified attribute:
			else if (attribute.base[gs.pc.getTalentLevel(ability.type.name)] !== attribute.value(gs.pc)) {
				str += attribute.base[gs.pc.getTalentLevel(ability.type.name)] + ' [' + attribute.value(gs.pc) + ']\n';
			}
			// Unmodified attribute:
			else {
				str += attribute.base[gs.pc.getTalentLevel(ability.type.name)] +'\n';
			}
		}, this);
	}
	
	// Ability Desc:
	if (typeof ability.type.desc === 'function') {
		str += ability.type.desc();
	}
	else {	
		str += ability.type.desc;
	}
	
	return str;
};

// CREATE_ABILITY_TYPES:
// ********************************************************************************************
gs.createAbilityTypes = function () {
	this.abilityTypes = {};
	
	this.createAbilityHelpers();
	this.createPlayerAbilityTypes();
	this.createNPCAbilityTypes();
	this.createNPCOnDeathTypes();
	
	this.setAbilityStats();
};
/*global gs, game, util, console*/
/*global Item*/
/*global RED_SELECT_BOX_FRAME, PURPLE_SELECT_BOX_FRAME, PURPLE_BOX_FRAME*/
/*global LOS_DISTANCE, TILE_SIZE, FACTION, ABILITY_RANGE, HELL_FIRE_DAMAGE*/
/*jshint esversion: 6, laxbreak: true, loopfunc: true*/
'use strict';

// CREATE_PLAYER_ABILITY_TYPES:
// ************************************************************************************************
gs.createPlayerAbilityTypes = function () {
	// ********************************************************************************************
	// ARMOR_ABILITIES:
	// ********************************************************************************************
	// SHIELDS_UP:
	// ********************************************************************************************
	this.abilityTypes.ShieldsUp = {};
	this.abilityTypes.ShieldsUp.useImmediately = true;
	this.abilityTypes.ShieldsUp.showTarget = this.abilityShowTarget.SelfTarget;
	this.abilityTypes.ShieldsUp.canUse = this.abilityCanUse.Shield;
	this.abilityTypes.ShieldsUp.useOn = function (actingCharacter) {
		actingCharacter.statusEffects.add('ShieldsUp');
	};
	
	// DEFLECT:
	// ********************************************************************************************
	this.abilityTypes.Deflect = {};
	this.abilityTypes.Deflect.useImmediately = true;
	this.abilityTypes.Deflect.showTarget = this.abilityShowTarget.SelfTarget;
	this.abilityTypes.Deflect.canUse = this.abilityCanUse.Shield;
	this.abilityTypes.Deflect.useOn = function (actingCharacter) {
		var duration;
		
		// Attributes:
		duration = this.attributes.duration.value(actingCharacter);
		
		actingCharacter.statusEffects.add('Deflect', {duration: duration});
	};
	
	
	// ********************************************************************************************
	// MELEE_ABILITIES:
	// ********************************************************************************************
	// POWER_STRIKE:
	// Deals a critical hit and knocks the target back two tiles
	// ********************************************************************************************
	this.abilityTypes.PowerStrike = {};
	this.abilityTypes.PowerStrike.range = this.abilityRange.Weapon;
	this.abilityTypes.PowerStrike.showTarget = this.abilityShowTarget.SingleTarget;
	this.abilityTypes.PowerStrike.canUseOn = this.abilityCanUseOn.SingleCharacterRay;
	this.abilityTypes.PowerStrike.canUse = this.abilityCanUse.MeleeWeapon;
	this.abilityTypes.PowerStrike.useOn = function (actingChar, targetTileIndex) {
		var flags, damage;
		
		// Attributes:
		damage = Math.ceil(actingChar.weaponDamage() * this.attributes.damageMultiplier.value(actingChar));
		
		// Flags:
		flags = {
			isSpecialAttack: true,
			effectFunc: function (targetChar) {
				targetChar.body.applyKnockBack(gs.getNormal(actingChar.tileIndex, targetTileIndex), 2);
			}
		};
		
		// Melee Attack:
		gs.meleeAttack(actingChar, targetTileIndex, damage, flags);
		
		// Shake Screen:
		game.camera.shake(0.010, 100);
	};

	
	// CHARGE:
	// Sprints towards a target and deals a critical hit + knockback
	// ********************************************************************************************
	this.abilityTypes.Charge = {};
	this.abilityTypes.Charge.dontEndTurn = true;
	this.abilityTypes.Charge.range = LOS_DISTANCE;
	this.abilityTypes.Charge.showTarget = this.abilityShowTarget.Path;
	this.abilityTypes.Charge.canUse = function (actingCharacter) {
		return gs.abilityCanUse.MeleeWeapon.call(this, actingCharacter)
			&& !actingCharacter.isImmobile;
	};
	
	this.abilityTypes.Charge.canUseOn = function (actingChar, targetTileIndex) {
		var path = actingChar.getPathTo(targetTileIndex, true);
		
		return gs.abilityCanUseOn.SingleCharacterSmite.call(this, actingChar, targetTileIndex)
			&& gs.getChar(targetTileIndex).faction !== FACTION.NEUTRAL
			&& gs.getChar(targetTileIndex).faction !== FACTION.PLAYER
			&& !actingChar.cantMoveFromCharm(targetTileIndex)
			&& path
			&& path.length > 0
			&& path.length <= this.attributes.maxPath.value(actingChar) + 1;
	};
	this.abilityTypes.Charge.useOn = function (actingCharacter, targetTileIndex) {
		var path = actingCharacter.getPathTo(targetTileIndex, true);

		for (let i = 0; i < path.length; i += 1) {
			actingCharacter.actionQueue[i] = {type: 'CLICK', tileIndex: path[i]};
		}
		
		actingCharacter.statusEffects.remove('Slow');
		actingCharacter.statusEffects.add('Charge');
		gs.keyBoardMode = false;
	};

	
	// BERSERK:
	// Doubles the characters damage and movement speed
	// ********************************************************************************************
	this.abilityTypes.Berserk = {};
	this.abilityTypes.Berserk.useImmediately = true;
	this.abilityTypes.Berserk.showTarget = this.abilityShowTarget.SelfTarget;
	this.abilityTypes.Berserk.getTarget = this.abilityGetTarget.Self;
	this.abilityTypes.Berserk.shouldUseOn = function (actingCharacter) {
		return actingCharacter.currentHp <= actingCharacter.maxHp / 2
			&& !actingCharacter.statusEffects.has('Berserk')
			&& game.rnd.frac() <= 0.5;
	};
	this.abilityTypes.Berserk.useOn = function (actingCharacter) {
		var duration;
		
		// Attributes:
		duration = this.attributes.duration.value(actingCharacter);
		
		// Status Effect:
		actingCharacter.statusEffects.add('Berserk', {duration: duration});
	};
	
	
	
	// ********************************************************************************************
	// RANGE_ABILITIES:
	// ********************************************************************************************
	// POWER_SHOT:
	// Fires a single projectile from the players weapon which crit hits and deals knock back
	// ********************************************************************************************
	this.abilityTypes.PowerShot = {};
	this.abilityTypes.PowerShot.range = this.abilityRange.Weapon;
	this.abilityTypes.PowerShot.showTarget = this.abilityShowTarget.SingleTarget;
	this.abilityTypes.PowerShot.canUseOn = this.abilityCanUseOn.SingleCharacterRay;
	this.abilityTypes.PowerShot.canUse = this.abilityCanUse.RangeWeapon;
	this.abilityTypes.PowerShot.useOn = function (actingCharacter, targetTileIndex) {
		var proj, flags, damage;
		
		// Attributes:
		damage = Math.ceil(actingCharacter.weaponDamage() * this.attributes.damageMultiplier.value(actingCharacter));
		
		// Projectile Flags:
		flags = {
			knockBack: 2,
			isSpecialAttack: true
		};
		
		// Create Projectile:
		proj = actingCharacter.inventory.getWeapon().type.effect.effect(targetTileIndex, actingCharacter.inventory.getWeapon(), flags);
		proj.damage = damage;
	};

	
	// TUNNEL_SHOT:
	// Fires a single projectile from the players weapon which passes through targets crit hitting all of them
	// ********************************************************************************************
	this.abilityTypes.TunnelShot = {};
	this.abilityTypes.TunnelShot.range = this.abilityRange.Weapon;
	this.abilityTypes.TunnelShot.showTarget = this.abilityShowTarget.SingleTarget;
	this.abilityTypes.TunnelShot.canUseOn = this.abilityCanUseOn.SingleCharacterSmite;
	this.abilityTypes.TunnelShot.canUse = this.abilityCanUse.RangeWeapon;
	this.abilityTypes.TunnelShot.useOn = function (actingCharacter, targetTileIndex) {
		var flags, proj, damage;
		
		// Attributes:
		damage = Math.ceil(actingCharacter.weaponDamage() * this.attributes.damageMultiplier.value(actingCharacter));
		
		// Projectile Flags:
		flags = {
			isTunnelShot: true,
			isSpecialAttack: true,
		};
		
		proj = actingCharacter.inventory.getWeapon().type.effect.effect(targetTileIndex, actingCharacter.inventory.getWeapon(), flags);
		proj.damage = damage;
	};
	
	// DEAD_EYE:
	// ********************************************************************************************
	this.abilityTypes.DeadEye = {};
	this.abilityTypes.DeadEye.useImmediately = true;
	this.abilityTypes.DeadEye.showTarget = this.abilityShowTarget.SelfTarget;
	this.abilityTypes.DeadEye.useOn = function (actingCharacter) {
		var duration;
		
		// Attributes:
		duration = this.attributes.duration.value(actingCharacter);
		
		// Status Effect:
		actingCharacter.statusEffects.add('DeadEye', {duration: duration});
	};
	
	// ********************************************************************************************
	// STEALTH_ABILITIES:
	// ********************************************************************************************
	// SLEEPING_DART:
	// ************************************************************************************************
	this.abilityTypes.SleepingDart = {};
	this.abilityTypes.SleepingDart.range = ABILITY_RANGE;
	this.abilityTypes.SleepingDart.showTarget = this.abilityShowTarget.SingleTarget;
	this.abilityTypes.SleepingDart.canUseOn = this.abilityCanUseOn.SingleCharacterRay;
	this.abilityTypes.SleepingDart.useOn = function (actingCharacter, targetTileIndex) {
		var flags;
		
		flags = {
			duration: this.attributes.duration.value(actingCharacter)
		};
		
		// Create projectile:
		gs.createProjectile(actingCharacter, targetTileIndex, 'SleepingDart', 0, flags);
		
		// Play sound:
		gs.playSound(gs.sounds.throw, actingCharacter.tileIndex);
		
		// Bounce and Face:
		actingCharacter.body.faceTileIndex(targetTileIndex);
		actingCharacter.body.bounceTowards(targetTileIndex);
	}; 
	
	// SMOKE_BOMB:
	// ************************************************************************************************
	this.abilityTypes.SmokeBomb = {};
	//this.abilityTypes.SmokeBomb.dontEndTurn = true;
	this.abilityTypes.SmokeBomb.range = ABILITY_RANGE;
	this.abilityTypes.SmokeBomb.showTarget = this.abilityShowTarget.SingleTarget;
	this.abilityTypes.SmokeBomb.canUseOn = function (actingCharacter, targetTileIndex) {
		return gs.abilityCanUseOn.SingleTileRay.call(this, actingCharacter, targetTileIndex)
			|| gs.vectorEqual(targetTileIndex, actingCharacter.tileIndex);
	};
	this.abilityTypes.SmokeBomb.useOn = function (actingCharacter, targetTileIndex) {
		var flags;
		
		flags = {
			duration: this.attributes.duration.value(actingCharacter)
		};
		
		// Create projectile:
		if (gs.vectorEqual(actingCharacter.tileIndex, targetTileIndex)) {
			gs.projectileEffects.SmokeBomb(gs.getTile(targetTileIndex), {flags: flags});
		}
		else {
			gs.createProjectile(actingCharacter, targetTileIndex, 'SmokeBomb', 0, flags);
			
			// Bounce and Face:
			actingCharacter.body.faceTileIndex(targetTileIndex);
			actingCharacter.body.bounceTowards(targetTileIndex);
		}
		
		// Play sound:
		gs.playSound(gs.sounds.throw, actingCharacter.tileIndex);
	}; 
	
	// NIMBLE_FINGERS:
	// ************************************************************************************************
	gs.isTrap = function (obj) {
		return obj.type.name === 'FireShroom'
			|| obj.type.name === 'BearTrap'
			|| obj.type.name === 'FirePot'
			|| obj.type.name === 'GasPot';
	};
	
	this.abilityTypes.NimbleFingers = {};
	this.abilityTypes.NimbleFingers.range = 1.5;
	this.abilityTypes.NimbleFingers.showTarget = this.abilityShowTarget.SingleTarget;
	this.abilityTypes.NimbleFingers.canUseOn = function (actingCharacter, targetTileIndex) {
		return gs.distance(actingCharacter.tileIndex, targetTileIndex) < this.range()
			&& (gs.getObj(targetTileIndex, obj => gs.isTrap(obj))
				|| gs.getChar(targetTileIndex) && gs.isTrap(gs.getChar(targetTileIndex)));
	};
	this.abilityTypes.NimbleFingers.canUse = function (actingCharacter) {
		var count = 0;
		
		count += actingCharacter.inventory.countItemOfType(gs.itemTypes.FireShroom);
		count += actingCharacter.inventory.countItemOfType(gs.itemTypes.BearTrap);
		count += actingCharacter.inventory.countItemOfType(gs.itemTypes.FirePot);
		count += actingCharacter.inventory.countItemOfType(gs.itemTypes.GasPot);
		
		return count < this.attributes.numTraps.value(actingCharacter);
	};
	this.abilityTypes.NimbleFingers.useOn = function (actingCharacter, targetTileIndex) {
		// Char:
		if (gs.getChar(targetTileIndex) && gs.isTrap(gs.getChar(targetTileIndex))) {
			
			gs.pc.inventory.addItem(Item.createItem(gs.getChar(targetTileIndex).type.name));
			gs.getChar(targetTileIndex).destroy();
		}
		// Object:
		else {
			gs.pc.inventory.addItem(Item.createItem(gs.getObj(targetTileIndex).type.name));
			
			gs.destroyObject(gs.getObj(targetTileIndex));
		}
	};
	
	// PLACE_TRAP:
	// ************************************************************************************************
	this.abilityTypes.PlaceTrap = {};
	this.abilityTypes.PlaceTrap.range = 1.5;
	this.abilityTypes.PlaceTrap.showTarget = this.abilityShowTarget.SingleTarget;
	this.abilityTypes.PlaceTrap.canUseOn = function (actingCharacter, targetTileIndex) {
		return gs.distance(actingCharacter.tileIndex, targetTileIndex) < this.range()
			&& !gs.getObj(targetTileIndex) 
			&& gs.isPassable(targetTileIndex)
			&& !gs.getTile(targetTileIndex).type.isPit;
	};
	this.abilityTypes.PlaceTrap.useOn = function (actingCharacter, targetTileIndex) {
		// Char:
		if (gs.inArray(gs.pc.selectedItem.type.name, ['FireShroom', 'BearTrap'])) {
			gs.createObject(targetTileIndex, gs.pc.selectedItem.type.name);
		}
		// Object:
		else if (gs.inArray(gs.pc.selectedItem.type.name, ['FirePot', 'GasPot'])) {
			gs.createNPC(targetTileIndex, gs.pc.selectedItem.type.name);
		}
	};
	
	// SNEAK:
	// ************************************************************************************************
	this.abilityTypes.Sneak = {};
	this.abilityTypes.Sneak.useImmediately = true;
	this.abilityTypes.Sneak.showTarget = this.abilityShowTarget.SelfTarget;
	this.abilityTypes.Sneak.useOn = function (actingCharacter) {
		actingCharacter.statusEffects.add('Sneak', {duration: 21});
	};

	// EVADE:
	// ************************************************************************************************
	this.abilityTypes.Evade = {};
	this.abilityTypes.Evade.useImmediately = true;
	this.abilityTypes.Evade.showTarget = this.abilityShowTarget.SelfTarget;
	this.abilityTypes.Evade.useOn = function (actingCharacter) {
		for (let i = 0; i < gs.characterList.length; i += 1) {
			if (gs.characterList[i].isAgroed) {
				gs.characterList[i].isAgroed = false;
			}
		}
		gs.createParticlePoof(actingCharacter.tileIndex, 'SMOKE');
		actingCharacter.statusEffects.add('Sneak', {duration: 11});
	};
	
	// ********************************************************************************************
	// FIRE_MAGIC_ABILITIES:
	// ********************************************************************************************
	// FIRE_BALL:
	// ********************************************************************************************
	this.abilityTypes.FireBall = {};
	this.abilityTypes.FireBall.magicType = 'Fire';
	this.abilityTypes.FireBall.range = 5.5;
	this.abilityTypes.FireBall.aoeRange = 1.0;
	this.abilityTypes.FireBall.noParticlePoof = true;
	this.abilityTypes.FireBall.showTarget = this.abilityShowTarget.TBAoE;
	this.abilityTypes.FireBall.canUseOn = this.abilityCanUseOn.SingleTileRay;
	this.abilityTypes.FireBall.useOn = function (actingCharacter, targetTileIndex) {
		var damage;
		
		// Attributes:
		damage = this.attributes.damage.value(actingCharacter);
		
		// Create projectile:
		gs.createProjectile(actingCharacter, targetTileIndex, 'FireBall', damage, {killer: actingCharacter});
	
		// Bounce and Face:
		actingCharacter.body.faceTileIndex(targetTileIndex);
		actingCharacter.body.bounceTowards(targetTileIndex);
		
		// Effect:
		gs.createMagicShootEffect(actingCharacter, targetTileIndex, 'FireShoot');
		
		// Play sound:
		gs.playSound(gs.sounds.throw, actingCharacter.tileIndex);
	};

	
	// FIRE_ATTUNEMENT:
	// ********************************************************************************************
	this.abilityTypes.FireAttunement = {};
	this.abilityTypes.FireAttunement.useImmediately = true;
	this.abilityTypes.FireAttunement.showTarget = this.abilityShowTarget.SelfTarget;
	this.abilityTypes.FireAttunement.useOn = function (actingCharacter) {
		var firePower, duration;
		
		// Attributes:
		firePower = this.attributes.firePower.value(actingCharacter);
		duration = this.attributes.duration.value(actingCharacter);
		
		// Status Effect:
		actingCharacter.statusEffects.add('FireAttunement', {firePower: firePower, duration: duration});
		
		// Particles:
		gs.createFireEffect(actingCharacter.tileIndex);
		
		// Play Sound:
		gs.playSound(gs.sounds.cure, actingCharacter.tileIndex);
	};
	
	// FLAMING_HANDS:
	// ********************************************************************************************
	this.abilityTypes.FlamingHands = {};
	this.abilityTypes.FlamingHands.magicType = 'Fire';
	this.abilityTypes.FlamingHands.useImmediately = true;
	this.abilityTypes.FlamingHands.showTarget = this.abilityShowTarget.SelfTarget;
	this.abilityTypes.FlamingHands.useOn = function (actingCharacter) {
		var duration;
		
		// Attributes:
		duration = this.attributes.duration.value(actingCharacter);
		
		// Status Effect:
		actingCharacter.statusEffects.add('FlamingHands', {duration: duration});
		
		// Particles:
		gs.createFireEffect(actingCharacter.tileIndex);
		
		// Play Sound:
		gs.playSound(gs.sounds.cure, actingCharacter.tileIndex);
	};
	
	// FIRE_BOLT:
	// ********************************************************************************************
	this.abilityTypes.FireBolt = {};
	this.abilityTypes.FireBolt.magicType = 'Fire';
	this.abilityTypes.FireBolt.range = 5.5;
	this.abilityTypes.FireBolt.showTarget = this.abilityShowTarget.Bolt;
	this.abilityTypes.FireBolt.canUseOn = this.abilityCanUseOn.Bolt;
	this.abilityTypes.FireBolt.getTarget = this.abilityGetTarget.Bolt;
	this.abilityTypes.FireBolt.useOn = function (actingCharacter, targetTileIndex) {
		var indexList, damage;
		
		// Attributes:
		damage = this.attributes.damage.value(actingCharacter);
		
		indexList = gs.getIndexInBRay(actingCharacter.tileIndex, targetTileIndex);
		
		indexList.forEach(function (tileIndex) {
			gs.createFire(tileIndex, damage, {killer: actingCharacter});
		}, this);
	
		// Bounce and Face:
		actingCharacter.body.faceTileIndex(targetTileIndex);
		actingCharacter.body.bounceTowards(targetTileIndex);
	};
	
	// BURST_OF_FLAME:
	// ********************************************************************************************
	this.abilityTypes.BurstOfFlame = {};
	this.abilityTypes.BurstOfFlame.magicType = 'Fire';
	this.abilityTypes.BurstOfFlame.range = ABILITY_RANGE;
	this.abilityTypes.BurstOfFlame.aoeRange = 3;
	this.abilityTypes.BurstOfFlame.showTarget = this.abilityShowTarget.BurstOfFlame;
	this.abilityTypes.BurstOfFlame.canUseOn = function (actingCharacter, targetTileIndex) {
		return gs.getTile(targetTileIndex).visible
			&& gs.distance(actingCharacter.tileIndex, targetTileIndex) <= this.range(actingCharacter)
			&& (gs.isPassable(targetTileIndex) || gs.getChar(targetTileIndex) || gs.getObj(targetTileIndex, obj => obj.type.canBurstOfFlame));
	};
	this.abilityTypes.BurstOfFlame.useOn = function (actingCharacter, targetTileIndex) {
		var damage, objName;
		
		// Attributes:
		damage = this.attributes.damage.value(actingCharacter);
		
		// Used on flaming object:
		if (gs.getObj(targetTileIndex, obj => obj.type.canBurstOfFlame)) {
			this.getIndexList(actingCharacter, targetTileIndex).forEach(function (tileIndex) {
				gs.createFire(tileIndex, damage, {killer: actingCharacter});
			}, this);
			
			// Must check for obj (in case a shroom was destroyed by the fire):
			if (gs.getObj(targetTileIndex)) {
				objName = gs.getObj(targetTileIndex).type.name;
				gs.destroyObject(gs.getObj(targetTileIndex));
				
				if (objName === 'Brazer') {
					gs.createObject(targetTileIndex, 'UnlitBrazer');
				}
			}
			
		}
		// Used on ground or enemy:
		else {
			gs.createFire(targetTileIndex, damage, {killer: actingCharacter});
		}
	};
	this.abilityTypes.BurstOfFlame.getIndexList = function (actingCharacter, targetTileIndex) {
		var indexList = gs.getIndexInRadius(targetTileIndex, this.aoeRange(actingCharacter));
		indexList = indexList.filter(index => gs.isStaticPassable(index));
		indexList = indexList.filter(index => gs.isRayStaticPassable(index, targetTileIndex));
		
		// Used on flaming objects on walls will only spread downwards:
		if (!gs.getTile(targetTileIndex).type.passable) {
			indexList = indexList.filter(index => index.y > targetTileIndex.y);
		}
		return indexList;
	};
	
	// INFERNO_ORB:
	// ********************************************************************************************
	this.abilityTypes.InfernoOrb = {};
	this.abilityTypes.InfernoOrb.magicType = 'Fire';
	this.abilityTypes.InfernoOrb.range = LOS_DISTANCE;
	this.abilityTypes.InfernoOrb.showTarget = this.abilityShowTarget.Bolt;
	this.abilityTypes.InfernoOrb.canUseOn = this.abilityCanUseOn.Bolt;
	this.abilityTypes.InfernoOrb.useOn = function (actingChar, targetTileIndex) {
		var orb, indexList, damage;
		
		// Attributes:
		damage = this.attributes.damage.value(actingChar);
		
		indexList = gs.getIndexInBRay(actingChar.tileIndex, targetTileIndex);
		
		// Create Orb:
		orb = gs.createNPC(indexList[0], 'InfernoOrb', {burstDamage: damage});
		orb.waitTime = 100;
		
		// Setup orbs actionQueue:
		orb.actionQueue = [];
		for (let i = 1; i < indexList.length; i += 1) {
			orb.actionQueue.unshift({type: 'MOVE', tileIndex: indexList[i]});
		}
		orb.actionQueue.unshift({tileIndex: targetTileIndex, type: 'DEATH'});

		
	};
	

	
	// ********************************************************************************************
	// STORM_MAGIC_ABILITIES:
	// ********************************************************************************************	
	// LIGHTNING_BOLT:
	// ********************************************************************************************
	this.abilityTypes.LightningBolt = {};
	this.abilityTypes.LightningBolt.magicType = 'Storm';
	this.abilityTypes.LightningBolt.range = 5.5;
	this.abilityTypes.LightningBolt.showTarget = this.abilityShowTarget.Bolt;
	this.abilityTypes.LightningBolt.canUseOn = this.abilityCanUseOn.Bolt;
	this.abilityTypes.LightningBolt.getTarget = this.abilityGetTarget.Bolt;
	this.abilityTypes.LightningBolt.useOn = function (actingCharacter, targetTileIndex) {
		var indexList, damage;
		
		// Attributes:
		damage = this.attributes.damage.value(actingCharacter);
		
		indexList = gs.getIndexInBRay(actingCharacter.tileIndex, targetTileIndex);
		
		indexList.forEach(function (tileIndex) {
			gs.createShock(tileIndex, damage, {killer: actingCharacter});
		}, this);
	
		// Bounce and Face:
		actingCharacter.body.faceTileIndex(targetTileIndex);
		actingCharacter.body.bounceTowards(targetTileIndex);
		
		// Camera Effects:
		game.camera.shake(0.010, 100);
		game.camera.flash(0xffffff, 50);
		
		// Sound:
		gs.playSound(gs.sounds.bolt, actingCharacter.tileIndex);
	};

	// STORM_ATTUNEMENT:
	// ********************************************************************************************
	this.abilityTypes.StormAttunement = {};
	this.abilityTypes.StormAttunement.useImmediately = true;
	this.abilityTypes.StormAttunement.showTarget = this.abilityShowTarget.SelfTarget;
	this.abilityTypes.StormAttunement.useOn = function (actingCharacter) {
		var duration, stormPower;
		
		// Attributes:
		stormPower = this.attributes.stormPower.value(actingCharacter);
		duration = this.attributes.duration.value(actingCharacter);
		
		// Status Effect:
		actingCharacter.statusEffects.add('StormAttunement', {stormPower: stormPower, duration: duration});
		
		// Particles:
		gs.createParticlePoof(actingCharacter.tileIndex, 'BLUE');
		
		// Play Sound:
		gs.playSound(gs.sounds.cure, actingCharacter.tileIndex);
	};
	
	// SHOCK:
	// ********************************************************************************************
	this.abilityTypes.Shock = {};
	this.abilityTypes.Shock.magicType = 'Storm';
	this.abilityTypes.Shock.range = 5.5;
	this.abilityTypes.Shock.showTarget = this.abilityShowTarget.SingleTarget;
	this.abilityTypes.Shock.canUseOn = this.abilityCanUseOn.SingleCharacterSmite;
	this.abilityTypes.Shock.useOn = function (actingCharacter, targetTileIndex) {
		var indexList, pred, damage;
		
		// Attributes:
		damage = this.attributes.damage.value(actingCharacter);
		
		pred = function (tileIndex) {
			return gs.getChar(tileIndex) && gs.getChar(tileIndex) !== gs.pc;
		};
		
		indexList = gs.getIndexInFlood(targetTileIndex, pred, 3);
		
		indexList.forEach(function (tileIndex) {
			gs.createShock(tileIndex, damage, {killer: actingCharacter});
		}, this);
	
		
		// Camera Effects:
		game.camera.shake(0.010, 100);
		game.camera.flash(0xffffff, 50);
		
		// Sound:
		gs.playSound(gs.sounds.bolt, actingCharacter.tileIndex);
		
	};

	// THUNDER_CLAP:
	// ********************************************************************************************
	this.abilityTypes.ThunderClap = {};
	this.abilityTypes.ThunderClap.magicType = 'Storm';
	this.abilityTypes.ThunderClap.useImmediately = true;
	this.abilityTypes.ThunderClap.aoeRange = 3;
	this.abilityTypes.ThunderClap.showTarget = this.abilityShowTarget.PBAoE;
	this.abilityTypes.ThunderClap.canUseOn = this.abilityCanUseOn.SingleTileSmite;
	this.abilityTypes.ThunderClap.useOn = function (actingChar, targetTileIndex) {
		var indexList, stunTurns;
		
		// Attributes:
		stunTurns = this.attributes.stunTurns.value(actingChar);
		
		indexList = gs.getIndexInRadius(actingChar.tileIndex, this.aoeRange(actingChar));
		indexList = indexList.filter(index => this.canUseOn(actingChar, index));
		indexList = indexList.filter(index => gs.getChar(index));
		
		indexList.forEach(function (tileIndex) {
			gs.getChar(tileIndex).statusEffects.add('Stunned', {duration: stunTurns + 1});
			gs.createParticlePoof(tileIndex, 'WHITE');
		}, this);
		
		// Camera Effects:
		game.camera.shake(0.010, 100);
		game.camera.flash(0xffffff, 300);
		
		// Sound:
		gs.playSound(gs.sounds.bolt, actingChar.tileIndex);
	};
	
	// LEVITATION:
	// ********************************************************************************************
	this.abilityTypes.Levitation = {};
	this.abilityTypes.Levitation.magicType = 'Storm';
	this.abilityTypes.Levitation.useImmediately = true;
	this.abilityTypes.Levitation.isSustained = true;
	this.abilityTypes.Levitation.showTarget = this.abilityShowTarget.SelfTarget;
	this.abilityTypes.Levitation.canUseOn = null;
	this.abilityTypes.Levitation.sustainedEffect = function (character) {
		character.isFlying += 1;
	};
	
	// STATIC_DISCHARGE:
	// ********************************************************************************************
	this.abilityTypes.StaticDischarge = {};
	this.abilityTypes.StaticDischarge.magicType = 'Storm';
	this.abilityTypes.StaticDischarge.useImmediately = true;
	this.abilityTypes.StaticDischarge.aoeRange = 3.0;
	this.abilityTypes.StaticDischarge.canUseOn = this.abilityCanUseOn.SingleTileSmite;
	this.abilityTypes.StaticDischarge.showTarget = this.abilityShowTarget.PBAoE;
	this.abilityTypes.StaticDischarge.useOn = function (actingChar) {
		var indexList, damage;
		
		// Attributes:
		damage = this.attributes.damage.value(actingChar);
		
		indexList = gs.getIndexInRadius(actingChar.tileIndex, this.aoeRange(actingChar));
		indexList = indexList.filter(index => this.canUseOn(actingChar, index));
		
		indexList.forEach(function (tileIndex) {
			gs.createShock(tileIndex, damage, {killer: actingChar});
		}, this);
		
		// Camera Effects:
		game.camera.shake(0.010, 100);
		game.camera.flash(0xffffff, 59);
		
		// Sound:
		gs.playSound(gs.sounds.bolt, actingChar.tileIndex);
		
	};
	
	
	// ********************************************************************************************
	// NECROMANCER_ABILITIES:
	// ********************************************************************************************
	// LIFE_SPIKE:
	this.abilityTypes.LifeSpike = {};
	this.abilityTypes.LifeSpike.magicType = 'Toxic';
	this.abilityTypes.LifeSpike.range = ABILITY_RANGE;
	this.abilityTypes.LifeSpike.getTarget = this.abilityGetTarget.SingleTarget;
	this.abilityTypes.LifeSpike.showTarget = this.abilityShowTarget.SingleTarget;
	this.abilityTypes.LifeSpike.canUseOn = this.abilityCanUseOn.SingleCharacterRay;
	this.abilityTypes.LifeSpike.useOn = function (actingCharacter, targetTileIndex) {
		var damage, duration;
		
		// Attributes:
		damage = this.attributes.damage.value(actingCharacter);
		duration = this.attributes.duration.value(actingCharacter);
		
		// Create Projectile:
		gs.createProjectile(actingCharacter, targetTileIndex, 'LifeSpike', damage, {killer: actingCharacter, duration: duration});
		
		// Bounce and Face:
		actingCharacter.body.faceTileIndex(targetTileIndex);
		actingCharacter.body.bounceTowards(targetTileIndex);
		
		// Effect:
		gs.createMagicShootEffect(actingCharacter, targetTileIndex, 'ToxicShoot');
		
		
		// Play Sound:
		gs.playSound(gs.sounds.throw, actingCharacter.tileIndex);
	};

	
	// TOXIC_ATTUNEMENT:
	// ********************************************************************************************
	this.abilityTypes.ToxicAttunement = {};
	this.abilityTypes.ToxicAttunement.magicType = 'Toxic';
	this.abilityTypes.ToxicAttunement.useImmediately = true;
	this.abilityTypes.ToxicAttunement.showTarget = this.abilityShowTarget.SelfTarget;
	this.abilityTypes.ToxicAttunement.useOn = function (actingCharacter) {
		var toxicPower, duration;
		
		// Attributes:
		toxicPower = this.attributes.toxicPower.value(actingCharacter);
		duration = this.attributes.duration.value(actingCharacter);
		
		// Status Effect:
		actingCharacter.statusEffects.add('ToxicAttunement', {toxicPower: toxicPower, duration: duration});
		
		// Particles:
		gs.createParticlePoof(actingCharacter.tileIndex, 'PURPLE');
		
		// Play Sound:
		gs.playSound(gs.sounds.cure, actingCharacter.tileIndex);
	};
	
	// SUMMON_SKELETON:
	// ********************************************************************************************
	this.abilityTypes.SummonSkeleton = {};
	this.abilityTypes.SummonSkeleton.magicType = 'Toxic';
	this.abilityTypes.SummonSkeleton.isSummon = true;
	this.abilityTypes.SummonSkeleton.useImmediately = true;
	this.abilityTypes.SummonSkeleton.showTarget = this.abilityShowTarget.SelfTarget;
	this.abilityTypes.SummonSkeleton.getIndexList = function (actingCharacter) {
		var indexList;
		
		indexList = gs.getIndexInRadius(actingCharacter.tileIndex, 1.5);
		indexList = indexList.filter(index => gs.isPassable(index));
		indexList = indexList.filter(index => gs.isIndexSafe(index));
		indexList = indexList.filter(index => !gs.getTile(index).type.isPit);
		return indexList;
	};
	
	this.abilityTypes.SummonSkeleton.canUse = function (actingCharacter) {
		return this.getIndexList(actingCharacter).length > 0;	
	};
	this.abilityTypes.SummonSkeleton.useOn = function (actingCharacter) {
		var indexList, num, skeletonLevel;
		
		// Attributes:
		skeletonLevel = this.attributes.skeletonLevel.value(actingCharacter);
		
		// Get valid tileIndex:
		indexList = this.getIndexList(actingCharacter);
		
		gs.createSummonEffect(indexList[0], function () {
			let npc = gs.createNPC(indexList[0], 'Skeleton', {level: skeletonLevel});
			npc.faction = FACTION.PLAYER;
			npc.popUpText('Summoned', '#ffffff');
			npc.isAgroed = true;
			actingCharacter.summonIDList.push(npc.id);
			npc.summonerID = actingCharacter.id;
			npc.summonDuration = -1; // No duration
		}, this);

		
		// Sound:
		gs.playSound(gs.sounds.cure, actingCharacter.tileIndex);
	};
	
	// INFECTIOUS_DISEASE:
	// ************************************************************************************************
	this.abilityTypes.InfectiousDisease = {};
	this.abilityTypes.InfectiousDisease.magicType = 'Toxic';
	this.abilityTypes.InfectiousDisease.range = 5.0;
	this.abilityTypes.InfectiousDisease.showTarget = this.abilityShowTarget.SingleTarget;
	this.abilityTypes.InfectiousDisease.canUseOn = this.abilityCanUseOn.SingleCharacterRay;
	this.abilityTypes.InfectiousDisease.useOn = function (actingCharacter, targetTileIndex) {
		var damage, duration;
		
		// Attributes:
		damage = this.attributes.damage.value(actingCharacter);
		duration = this.attributes.duration.value(actingCharacter);
		
		gs.getChar(targetTileIndex).statusEffects.add('InfectiousDisease', {damage: damage, duration: duration});
		
	};

	
	// CANNIBALISE:
	// ************************************************************************************************
	this.abilityTypes.Cannibalise = {};
	this.abilityTypes.Cannibalise.useImmediately = true;
	this.abilityTypes.Cannibalise.showTarget = this.abilityShowTarget.SelfTarget;
	this.abilityTypes.Cannibalise.useOn = function (actingCharacter) {
		actingCharacter.gainMp(6);
		gs.createParticlePoof(actingCharacter.tileIndex, 'PURPLE');
	};
	
	// POISON_CLOUD:
	// ********************************************************************************************
	this.abilityTypes.PoisonCloud = {};
	this.abilityTypes.PoisonCloud.magicType = 'Toxic';
	this.abilityTypes.PoisonCloud.range = ABILITY_RANGE;
	this.abilityTypes.PoisonCloud.showTarget = this.abilityShowTarget.SingleTarget;
	this.abilityTypes.PoisonCloud.canUseOn = this.abilityCanUseOn.SingleTileRay;
	this.abilityTypes.PoisonCloud.useOn = function (actingCharacter, targetTileIndex) {
		var damage;
		
		// Attributes:
		damage = this.attributes.damage.value(actingCharacter);
		
		// Create Projectile:
		gs.createProjectile(actingCharacter, targetTileIndex, 'PlayerGasBall', damage, {killer: actingCharacter});
	
		// Play Sound:
		gs.playSound(gs.sounds.throw, actingCharacter.tileIndex);
	};

	
	// ********************************************************************************************
	// ICE_MAGIC_ABILITIES:
	// ********************************************************************************************
	
	// CONE_OF_COLD:
	// ********************************************************************************************
	this.abilityTypes.ConeOfCold = {};
	this.abilityTypes.ConeOfCold.magicType = 'Cold';
	this.abilityTypes.ConeOfCold.range = ABILITY_RANGE;
	this.abilityTypes.ConeOfCold.aoeRange = 3;
	this.abilityTypes.ConeOfCold.showTarget = this.abilityShowTarget.Fan;
	this.abilityTypes.ConeOfCold.canUseOn = function () {return true;};
	this.abilityTypes.ConeOfCold.useOn = function (actingCharacter, targetTileIndex) {
		var indexList, delta, charList = [], damage;
		
		// Attributes:
		damage = this.attributes.damage.value(actingCharacter);
		
		delta = gs.get8WayVector(actingCharacter.tileIndex, targetTileIndex);
		
		// Handle all tiles:
		indexList = gs.getIndexInFan(actingCharacter.tileIndex, this.aoeRange(actingCharacter), delta);
		indexList.forEach(function (tileIndex) {
			if (!gs.isRayClear(actingCharacter.tileIndex, tileIndex)) {
				return;
			}
			
			if (gs.getChar(tileIndex)) {
				charList.push(gs.getChar(tileIndex));
			}
			
			// Random Ice:
			if (!gs.getObj(tileIndex) && gs.getTile(tileIndex).type.name === 'Water') {
				gs.createObject(tileIndex, 'Ice');
			}
		}, this);
		
		// Sort to handle furthest characters first:
		charList.sort((a, b) => gs.distance(actingCharacter.tileIndex, b.tileIndex) - gs.distance(actingCharacter.tileIndex, a.tileIndex));
		
		// Handle all characters:
		charList.forEach(function (char) {
			var distance;
			
			if (gs.distance(char.tileIndex, actingCharacter.tileIndex) < 1.5) {
				distance = 2;
			}
			else {
				distance = 1;
			}
			gs.createParticleBurst(char.sprite.position, delta, 'WHITE');
			char.body.applyKnockBack(delta, distance);
			char.takeDamage(damage, 'Cold', {killer: actingCharacter});
		}, this);
		
		// Bounce and Face:
		actingCharacter.body.faceTileIndex(targetTileIndex);
		actingCharacter.body.bounceTowards(targetTileIndex);
		
		gs.createParticleBurst(actingCharacter.sprite.position, delta, 'WHITE');
		
	};

	
	// COLD_ATTUNEMENT:
	// ********************************************************************************************
	this.abilityTypes.ColdAttunement = {};
	this.abilityTypes.ColdAttunement.magicType = 'Cold';
	this.abilityTypes.ColdAttunement.useImmediately = true;
	this.abilityTypes.ColdAttunement.showTarget = this.abilityShowTarget.SelfTarget;
	this.abilityTypes.ColdAttunement.useOn = function (actingCharacter) {
		var coldPower, duration;
		
		// Attributes:
		coldPower = this.attributes.coldPower.value(actingCharacter);
		duration = this.attributes.duration.value(actingCharacter);
		
		// Status Effect:
		actingCharacter.statusEffects.add('ColdAttunement', {coldPower: coldPower, duration: duration});
		
		// Particles:
		gs.createIceEffect(actingCharacter.tileIndex);
		
		// Play Sound:
		gs.playSound(gs.sounds.cure, actingCharacter.tileIndex);
	};
	
	// FREEZING_CLOUD:
	// ********************************************************************************************
	this.abilityTypes.FreezingCloud = {};
	this.abilityTypes.FreezingCloud.magicType = 'Cold';
	this.abilityTypes.FreezingCloud.range = 4.0;
	this.abilityTypes.FreezingCloud.aoeRange = 1.5;
	this.abilityTypes.FreezingCloud.showTarget = this.abilityShowTarget.TBAoE;
	this.abilityTypes.FreezingCloud.canUseOn = this.abilityCanUseOn.SingleTileSmite;
	this.abilityTypes.FreezingCloud.useOn = function (actingCharacter, targetTileIndex) {
		var indexList, damage, duration;
		
		// Attributes:
		damage = this.attributes.damage.value(actingCharacter);
		duration = this.attributes.duration.value(actingCharacter);
		
		indexList = gs.getIndexInRadius(targetTileIndex, this.aoeRange(actingCharacter));
		
		indexList.forEach(function (tileIndex) {
			if (gs.isStaticPassable(tileIndex) && !gs.getCloud(tileIndex)) {
				gs.createCloud(tileIndex, 'FreezingCloud', damage, duration);
			}
		}, this);
	};
	
	
	// FREEZE:
	// ********************************************************************************************
	this.abilityTypes.Freeze = {};
	this.abilityTypes.Freeze.magicType = 'Cold';
	this.abilityTypes.Freeze.range = 4.0;
	this.abilityTypes.Freeze.showTarget = this.abilityShowTarget.SingleTarget;
	this.abilityTypes.Freeze.canUseOn = function (actingCharacter, targetTileIndex) {
		return gs.abilityCanUseOn.SingleTileSmite.call(this, actingCharacter, targetTileIndex)
			&& !gs.getCloud(targetTileIndex);
	};
	this.abilityTypes.Freeze.useOn = function (actingCharacter, targetTileIndex) {
		var duration;
		
		// Attributes:
		duration = this.attributes.duration.value(actingCharacter);
		
		gs.createParticlePoof(targetTileIndex, 'WHITE');
		gs.createIce(targetTileIndex, duration);
	};
	
	// ICE_ARMOR:
	// ********************************************************************************************
	this.abilityTypes.IceArmor = {};
	this.abilityTypes.IceArmor.magicType = 'Cold';
	this.abilityTypes.IceArmor.useImmediately = true;
	this.abilityTypes.IceArmor.isSustained = true;
	this.abilityTypes.IceArmor.showTarget = this.abilityShowTarget.SelfTarget;
	this.abilityTypes.IceArmor.canUseOn = null;
	this.abilityTypes.IceArmor.sustainedEffect = function (character) {
		character.protection += 5;
	};
	
	// FLASH_FREEZE:
	// ********************************************************************************************
	this.abilityTypes.FlashFreeze = {};
	this.abilityTypes.FlashFreeze.magicType = 'Cold';
	this.abilityTypes.FlashFreeze.useImmediately = true;
	this.abilityTypes.FlashFreeze.range = LOS_DISTANCE;
	this.abilityTypes.FlashFreeze.showTarget = this.abilityShowTarget.LoS;
	this.abilityTypes.FlashFreeze.canUseOn = this.abilityCanUseOn.SingleCharacterSmite;
	this.abilityTypes.FlashFreeze.useOn = function (actingCharacter, targetTileIndex) {
		var duration;
		
		// Attributes:
		duration = this.attributes.duration.value(actingCharacter);
		
		gs.characterList.forEach(function (character) {
			if (gs.getTile(character.tileIndex).visible && character.isAlive && character.faction === FACTION.HOSTILE) {
				gs.createParticlePoof(character.tileIndex, 'WHITE');
				gs.createIce(character.tileIndex, duration);
			}	
		}, this);
		
		// Camera Effects:
		game.camera.shake(0.010, 100);
		game.camera.flash(0xffffff, 300);
	};
	
	// ********************************************************************************************
	// ENCHANTER_ABILITIES:
	// ********************************************************************************************
	// CONFUSION:
	// ********************************************************************************************
	this.abilityTypes.Confusion = {};
	this.abilityTypes.Confusion.range = 5.5;
	this.abilityTypes.Confusion.showTarget = this.abilityShowTarget.TBAoE;
	this.abilityTypes.Confusion.canUseOn = this.abilityCanUseOn.SingleTileSmite;
	this.abilityTypes.Confusion.useOn = function (actingCharacter, targetTileIndex) {
		var indexList, duration;
		
		// Attributes:
		duration = this.attributes.duration.value(actingCharacter);
		
		// Targets:
		indexList = gs.getIndexInRadius(targetTileIndex, this.aoeRange(actingCharacter));
		indexList = indexList.filter(index => gs.getChar(index) && !gs.getChar(index).type.isMindless);
		
		// Effect:
		indexList.forEach(function (tileIndex) {
			gs.getChar(tileIndex).agroPlayer();
			gs.getChar(tileIndex).statusEffects.add('Confusion', {duration: duration});
			gs.createParticlePoof(gs.pc.tileIndex, 'PURPLE'); 
		}, this);
		
		// Sound:
		gs.playSound(gs.sounds.cure, actingCharacter.tileIndex);
	};
	this.abilityTypes.Confusion.aoeRange = function (actingChar) {
		return this.attributes.aoeRange.value(actingChar);
	};
	
	// FEAR:
	// ********************************************************************************************
	this.abilityTypes.Fear = {};
	this.abilityTypes.Fear.useImmediately = true;
	this.abilityTypes.Fear.showTarget = this.abilityShowTarget.PBAoE;
	this.abilityTypes.Fear.canUseOn = this.abilityCanUseOn.SingleTileSmite;
	this.abilityTypes.Fear.useOn = function (actingChar, targetTileIndex) {
		var indexList, duration;
		
		// Attributes:
		duration = this.attributes.duration.value(actingChar);
		
		// Targets:
		indexList = gs.getIndexInRadius(actingChar.tileIndex, this.aoeRange(actingChar));
		indexList = indexList.filter(index => this.canUseOn(actingChar, index));
		indexList = indexList.filter(index => gs.getChar(index) && actingChar.isHostileToMe(gs.getChar(index)));
		
		// Effect:
		indexList.forEach(function (tileIndex) {
			if (gs.getChar(tileIndex).type.neverRun) {
				gs.getChar(tileIndex).popUpText('Immune', '#ffffff');
			}
			else {
				gs.createParticlePoof(tileIndex, 'PURPLE');
				gs.getChar(tileIndex).agroPlayer();
				gs.getChar(tileIndex).statusEffects.add('Feared', {duration: duration});
			}
			
		}, this);
		
		// Caster particles and text:
		gs.pc.popUpText('Fear!', '#ffffff');
		gs.createParticlePoof(actingChar.tileIndex, 'PURPLE');
	};
	this.abilityTypes.Fear.aoeRange = function (actingChar) {
		return this.attributes.aoeRange.value(actingChar);
	};

	
	// CHARM:
	// ********************************************************************************************
	this.abilityTypes.Charm = {};
	this.abilityTypes.Charm.range = 5.5;
	this.abilityTypes.Charm.showTarget = this.abilityShowTarget.SingleTarget;
	this.abilityTypes.Charm.canUseOn = function (actingCharacter, targetTileIndex) {
		return gs.abilityCanUseOn.SingleCharacterSmite.call(this, actingCharacter, targetTileIndex)
			&& !gs.getChar(targetTileIndex).type.cantMove
			&& !gs.getChar(targetTileIndex).type.isMindless
			&& gs.getChar(targetTileIndex).faction !== actingCharacter.faction;
	};
	this.abilityTypes.Charm.useOn = function (actingCharacter, targetTileIndex) {
		var char, duration;
		
		// Attributes:
		duration = this.attributes.duration.value(actingCharacter);
		
		// Effect:
		char = gs.getChar(targetTileIndex);
		char.agroPlayer();
		char.faction = FACTION.PLAYER;
		char.statusEffects.add('Charm', {duration: duration});
		
		// Pop Up:
		char.popUpText('Charmed!', '#ffffff');
		
		// Particles:
		gs.createParticlePoof(targetTileIndex, 'PURPLE'); 
		
		// Sound:
		gs.playSound(gs.sounds.cure, actingCharacter.tileIndex);
	};

	
	// MESMERIZE:
	// ********************************************************************************************
	this.abilityTypes.Mesmerize = {};
	this.abilityTypes.Mesmerize.range = 5.5;
	this.abilityTypes.Mesmerize.aoeRange = 1.5;
	this.abilityTypes.Mesmerize.showTarget = this.abilityShowTarget.TBAoE;
	this.abilityTypes.Mesmerize.canUseOn = this.abilityCanUseOn.SingleTileSmite;
	this.abilityTypes.Mesmerize.useOn = function (actingCharacter, targetTileIndex) {
		var indexList, duration;
		
		// Attributes:
		duration = this.attributes.duration.value(actingCharacter);
		
		// Targets:
		indexList = gs.getIndexInRadius(targetTileIndex, this.aoeRange(actingCharacter));
		indexList = indexList.filter(index => gs.getChar(index) && !gs.getChar(index).type.isMindless);
		
		// Effect:
		indexList.forEach(function (tileIndex) {
			gs.getChar(tileIndex).agroPlayer();
			gs.getChar(tileIndex).goToSleep();
			gs.getChar(tileIndex).statusEffects.add('DeepSleep', {duration: duration});
			gs.createParticlePoof(tileIndex, 'MEZ', 10); 
		}, this);
		
		
		// Sound:
		gs.playSound(gs.sounds.cure, actingCharacter.tileIndex);
	};

	this.abilityTypes.Swiftness = {};
	this.abilityTypes.Swiftness.useImmediately = true;
	this.abilityTypes.Swiftness.isSustained = true;
	this.abilityTypes.Swiftness.showTarget = this.abilityShowTarget.SelfTarget;
	this.abilityTypes.Swiftness.canUseOn = null;
	this.abilityTypes.Swiftness.sustainedEffect = function (character) {
		character.bonusMovementSpeed += 1;
	};
	
	// ********************************************************************************************
	// MISC_ABILITIES:
	// Many of these are attached to charms, wands or scrolls:
	// ********************************************************************************************
	// SCROLL_OF_FEAR:
	// ********************************************************************************************
	this.abilityTypes.ScrollOfFear = {};
	this.abilityTypes.ScrollOfFear.useImmediately = true;
	this.abilityTypes.ScrollOfFear.range = LOS_DISTANCE;
	this.abilityTypes.ScrollOfFear.showTarget = this.abilityShowTarget.LoS;
	this.abilityTypes.ScrollOfFear.useOn = function (actingChar, targetTileIndex) {
	
		gs.characterList.forEach(function (character) {
			if (gs.getTile(character.tileIndex).visible && character.isAlive && character.faction === FACTION.HOSTILE) {
				if (character.type.neverRun) {
					character.popUpText('Immune', '#ffffff');
				}
				else {
					gs.createParticlePoof(character.tileIndex, 'PURPLE');
					character.agroPlayer();
					character.statusEffects.add('Feared', {duration: 20});
				}
			}	
		}, this);
		
		// Caster particles and text:
		gs.pc.popUpText('Fear!', '#ffffff');
		gs.createParticlePoof(actingChar.tileIndex, 'PURPLE');
	};
	this.abilityTypes.Fear.aoeRange = function (actingChar) {
		return this.attributes.aoeRange.value(actingChar);
	};
	// HELL_FIRE:
	// ********************************************************************************************
	this.abilityTypes.HellFire = {};
	this.abilityTypes.HellFire.range = LOS_DISTANCE;
	this.abilityTypes.HellFire.showTarget = this.abilityShowTarget.LoS;
	this.abilityTypes.HellFire.useImmediately = true;
	this.abilityTypes.HellFire.useOn = function (actingChar, targetTileIndex) {
		var damage;
		
		// Attributes:
		damage = this.attributes.damage.value(actingChar);
		
		gs.characterList.forEach(function (character) {
			if (gs.getTile(character.tileIndex).visible && character.isAlive && character.faction === FACTION.HOSTILE) {
				gs.createFire(character.tileIndex, damage, {killer:gs.pc});
			}	
		}, this);
		
		game.camera.shake(0.02, 300);
		game.camera.flash(0xff0000, 20);
		gs.playSound(gs.sounds.explosion, gs.pc.tileIndex);
	};
	
	// BLINK:
	// ********************************************************************************************
	this.abilityTypes.Blink = {};
	this.abilityTypes.Blink.range = LOS_DISTANCE;
	this.abilityTypes.Blink.showTarget = this.abilityShowTarget.SingleTarget;
	this.abilityTypes.Blink.canUseOn = function (actingChar, targetTileIndex) {
		return gs.abilityCanUseOn.SingleTileSmite.call(this, actingChar, targetTileIndex)
			&& gs.isPassable(targetTileIndex);
	};
	this.abilityTypes.Blink.useOn = function (actingChar, targetTileIndex) {
		gs.createParticlePoof(actingChar.tileIndex, 'PURPLE');
		gs.playSound(gs.sounds.teleport, gs.pc.tileIndex);
		actingChar.teleportTo(targetTileIndex);
		gs.createParticlePoof(actingChar.tileIndex, 'PURPLE');
	};
	
	// HEALING:
	// ********************************************************************************************
	this.abilityTypes.Healing = {};
	this.abilityTypes.Healing.useImmediately = true;
	this.abilityTypes.Healing.showTarget = this.abilityShowTarget.SelfTarget;
	this.abilityTypes.Healing.useOn = function (actingCharacter) {
		gs.pc.cure();
		
		gs.pc.healHp(gs.pc.maxHp);
		
		// Sound:
		gs.playSound(gs.sounds.cure, gs.pc.tileIndex);
	
		// Effect:
		gs.createHealingEffect(gs.pc.tileIndex);
		
	};
	this.abilityTypes.Healing.desc = "Completely restores your HP and cures physical effects.";
	
	// ENERGY:
	// ********************************************************************************************
	this.abilityTypes.Energy = {};
	this.abilityTypes.Energy.useImmediately = true;
	this.abilityTypes.Energy.showTarget = this.abilityShowTarget.SelfTarget;
	this.abilityTypes.Energy.useOn = function (actingCharacter) {
		gs.pc.mentalCure();
		
		gs.pc.gainMp(gs.pc.maxMp);
		gs.pc.resetAllCoolDowns();
		
		// Sound:
		gs.playSound(gs.sounds.cure, this.tileIndex);
		
		// Effect:
		gs.createManaEffect(gs.pc.tileIndex);
	};
	this.abilityTypes.Energy.desc = "Completely restores your MP and cures mental effects.";
	
	
	
	// DOMINATION:
	// ********************************************************************************************
	this.abilityTypes.Domination = {};
	this.abilityTypes.Domination.range = 5.5;
	this.abilityTypes.Domination.showTarget = this.abilityShowTarget.SingleTarget;
	this.abilityTypes.Domination.canUseOn = function (actingCharacter, targetTileIndex) {
		return gs.abilityCanUseOn.SingleCharacterSmite.call(this, actingCharacter, targetTileIndex)
			&& !gs.getChar(targetTileIndex).type.cantMove
			&& !gs.getChar(targetTileIndex).type.isMindless;
	};
	this.abilityTypes.Domination.useOn = function (actingCharacter, targetTileIndex) {
		var char;
		
		char = gs.getChar(targetTileIndex);
		char.faction = FACTION.PLAYER;
		char.isAsleep = false;
		
		// Pop Up:
		char.popUpText('Charmed!', '#ffffff');
		
		// Particles:
		gs.createParticlePoof(targetTileIndex, 'PURPLE'); 
	};
	
	// SPRINT:
	// Sprints towards a target and deals a critical hit + knockback
	// ********************************************************************************************
	this.abilityTypes.Sprint = {};
	this.abilityTypes.Sprint.dontEndTurn = true;
	this.abilityTypes.Sprint.range = LOS_DISTANCE;
	this.abilityTypes.Sprint.showTarget = this.abilityShowTarget.Path;
	this.abilityTypes.Sprint.canUse = function (actingCharacter) {
		return !actingCharacter.isImmobile;
	};
	
	this.abilityTypes.Sprint.canUseOn = function (actingChar, targetTileIndex) {
		var path = actingChar.getPathTo(targetTileIndex, true);
		return gs.isPassable(targetTileIndex)
			&& !actingChar.cantMoveFromCharm(targetTileIndex)
			&& path
			&& path.length > 0
			&& path.length <= this.attributes.maxPath.value(actingChar);
	};
	this.abilityTypes.Sprint.useOn = function (actingCharacter, targetTileIndex) {
		var path = actingCharacter.getPathTo(targetTileIndex, true);
		
		for (let i = 0; i < path.length; i += 1) {
			actingCharacter.actionQueue[i] = {type: 'CLICK', tileIndex: path[i], shift: true};
		}
		
		actingCharacter.statusEffects.remove('Slow');
		actingCharacter.statusEffects.add('Sprint', {tileIndex: {x: targetTileIndex.x, y: targetTileIndex.y}});
		gs.keyBoardMode = false;
	};
	
	
	// SUMMON_BLADES:
	// ********************************************************************************************
	this.abilityTypes.SummonBlades = {};
	this.abilityTypes.SummonBlades.useImmediately = true;
	this.abilityTypes.SummonBlades.showTarget = this.abilityShowTarget.SelfTarget;
	this.abilityTypes.SummonBlades.canUse = function (actingCharacter) {
		return gs.getIndexInRadius(actingCharacter.tileIndex, 1.5).filter(index => gs.isPassable(index)).length > 0;	
	};
	this.abilityTypes.SummonBlades.useOn = function (actingCharacter) {
		var indexList, npc, num, level;
		
		// Get valid tileIndex:
		indexList = gs.getIndexInRadius(actingCharacter.tileIndex, 1.5);
		indexList = indexList.filter(index => gs.isPassable(index));
		indexList = indexList.filter(index => gs.isIndexSafe(index));
		
		// Scale base on player level:
		if (actingCharacter.level >= 12) {
			num = 8;
			level = 8;
		}
		else if (actingCharacter.level >= 6) {
			num = 6;
			level = 6;
		}
		else {
			num = 4;
			level = 4;
		}
		
		
		for (let i = 0; i < Math.min(num, indexList.length); i += 1) {
			gs.createSummonEffect(indexList[i], function () {
				let npc = gs.createNPC(indexList[i], 'SpectralBlade', {summonerID: actingCharacter.id, level: level});
				npc.faction = FACTION.PLAYER;
				actingCharacter.summonIDList.push(npc.id);
				npc.summonerID = actingCharacter.id;
				npc.isAgroed = true;
				npc.popUpText('Summoned', '#ffffff');
			}, this);
		}
		
		// Sound:
		gs.playSound(gs.sounds.cure, actingCharacter.tileIndex);
	};
};

// SET_ABILITY_STATS:
// ************************************************************************************************
gs.setAbilityStats = function () {
	// MANA:
	// ********************************************************************************************
	// Fire Magic:
	this.abilityTypes.FireBall.mana = 3;
	this.abilityTypes.BurstOfFlame.mana = 4;
	this.abilityTypes.FireBolt.mana = 4;
	this.abilityTypes.FlamingHands.mana = 4;
	this.abilityTypes.InfernoOrb.mana = 5;
	
	// Storm Magic:
	this.abilityTypes.LightningBolt.mana = 3;
	this.abilityTypes.ThunderClap.mana = 4;
	this.abilityTypes.Shock.mana = 4;
	this.abilityTypes.Levitation.mana = 6;
	this.abilityTypes.StaticDischarge.mana = 5;
	
	// Necromancer Magic:
	this.abilityTypes.LifeSpike.mana = 3;
	this.abilityTypes.Cannibalise.mana = 0;
	this.abilityTypes.Cannibalise.hitPointCost = 8;
	this.abilityTypes.InfectiousDisease.mana = 4;
	this.abilityTypes.SummonSkeleton.mana = 3;
	this.abilityTypes.PoisonCloud.mana = 5;
	
	// Cold Magic:
	this.abilityTypes.ConeOfCold.mana = 3;
	this.abilityTypes.FreezingCloud.mana = 4;
	this.abilityTypes.Freeze.mana = 4;
	this.abilityTypes.IceArmor.mana = 6;
	this.abilityTypes.FlashFreeze.mana = 5;
	
	// Enchantment Magic:
	this.abilityTypes.Confusion.mana = 3;
	this.abilityTypes.Fear.mana = 3;
	this.abilityTypes.Charm.mana = 4;
	this.abilityTypes.Mesmerize.mana = 4;
	this.abilityTypes.Swiftness.mana = 6;
	
	
	// COOL_DOWNS:
	// ********************************************************************************************
	// Fire Magic:
	this.abilityTypes.FireAttunement.coolDown = 250;
	
	// Storm Magic:
	this.abilityTypes.StormAttunement.coolDown = 250;
	
	// Necromancy:
	this.abilityTypes.ToxicAttunement.coolDown = 250;
	
	// Ice Magic:
	this.abilityTypes.ColdAttunement.coolDown = 250;
	
	// Armor:
	this.abilityTypes.ShieldsUp.coolDown = 10;
	this.abilityTypes.Deflect.coolDown = 20;
	
	// Melee:
	this.abilityTypes.PowerStrike.coolDown = 10;
	this.abilityTypes.Charge.coolDown = 20;
	this.abilityTypes.Berserk.coolDown = 250;
	
	// Range:
	this.abilityTypes.PowerShot.coolDown = 10;
	this.abilityTypes.TunnelShot.coolDown = 20;
	this.abilityTypes.DeadEye.coolDown = 250;
	
	// Stealth:
	this.abilityTypes.SleepingDart.coolDown = 10;
	this.abilityTypes.SmokeBomb.coolDown = 20;
	this.abilityTypes.Sneak.coolDown = 20;
	this.abilityTypes.Evade.coolDown = 100;
	
	// Athletics:
	this.abilityTypes.Sprint.coolDown = 20;
	
	// NECROMANCY_ATTRIBUTES:
	// ********************************************************************************************
	this.abilityTypes.LifeSpike.attributes = {
		damage: 			{base: [null, 4, 6, 7], modifier: 'toxicDamageMultiplier'},
		duration: 			{base: [null, 5, 5, 5], modifier: 'toxicDamageMultiplier'},
	};
	this.abilityTypes.InfectiousDisease.attributes = {
		damage:				{base: [null, 3, 5, 6], modifier: 'toxicDamageMultiplier'},
		duration:			{base: [null, 15, 15, 15], modifier: 'toxicDamageMultiplier'},
	};
	this.abilityTypes.PoisonCloud.attributes = {
		damage:				{base: [null, 6, 8, 9], modifier: 'toxicDamageMultiplier'},
	};
	this.abilityTypes.ToxicAttunement.attributes = {
		toxicPower:			{base: [null, 10, 14, 16], modifier: null},
		duration:			{base: [null, 10, 10, 10], modifier: null},
	};
	this.abilityTypes.SummonSkeleton.attributes = {
		skeletonLevel:		{base: [null, 6, 10, 12], modifier: null},
	};
	
	// FIRE_MAGIC_ATTRIBUTES:
	// ********************************************************************************************
	this.abilityTypes.FireBall.attributes = {
		damage:				{base: [null, 14, 18, 20], modifier: 'fireDamageMultiplier'},
	};
	this.abilityTypes.BurstOfFlame.attributes = {
		damage:				{base: [null, 22, 28, 32], modifier: 'fireDamageMultiplier'},
	};
	this.abilityTypes.FireBolt.attributes = {
		damage:				{base: [null, 16, 20, 22], modifier: 'fireDamageMultiplier'},
	};
	this.abilityTypes.InfernoOrb.attributes = {
		damage:				{base: [null, 26, 34, 40], modifier: 'fireDamageMultiplier'},
	};
	this.abilityTypes.FireAttunement.attributes = {
		firePower:			{base: [null, 10, 14, 16], modifier: null},
		duration:			{base: [null, 10, 10, 10], modifier: null},
	};
	this.abilityTypes.FlamingHands.attributes = {
		damage:				{base: [null, 5, 5, 5], modifier: 'fireDamageMultiplier'},
		duration:			{base: [null, 10, 15, 20], modifier: 'fireDamageMultiplier'},
	};
	
	// STORM_MAGIC_ATTRIBUTES:
	// ********************************************************************************************
	this.abilityTypes.LightningBolt.attributes = {
		damage:				{base: [null, 14, 18, 20], modifier: 'shockDamageMultiplier'}
	};
	this.abilityTypes.Shock.attributes = {
		damage:				{base: [null, 18, 22, 24], modifier: 'shockDamageMultiplier'}
	};
	this.abilityTypes.ThunderClap.attributes = {
		stunTurns:			{base: [null, 3, 5, 6], nodifier: null}
	};
	this.abilityTypes.StaticDischarge.attributes = {
		damage:				{base: [null, 22, 30, 36], modifier: 'shockDamageMultiplier'}
	};	
	this.abilityTypes.StormAttunement.attributes = {
		stormPower:			{base: [null, 10, 14, 16], modifier: null},
		duration:			{base: [null, 10, 10, 10], modifier: null},
	};
	
	// MELEE_ATTRIBUTES:
	// ********************************************************************************************
	this.abilityTypes.PowerStrike.attributes = {
		damageMultiplier:	{base: [null, 2.0, 2.2, 2.4], modifier: null}
	};
	this.abilityTypes.Charge.attributes = {
		maxPath:			{base: [null, 4, 5, 6], modifier: null}
	};
	this.abilityTypes.Berserk.attributes = {
		duration:			{base: [null, 12, 16, 20], modifier: null}
	};
	
	// RANGE_ATTRIBUTES:
	// ********************************************************************************************
	this.abilityTypes.PowerShot.attributes = {
		damageMultiplier:	{base: [null, 2.0, 2.2, 2.4], modifier: null}
	};
	this.abilityTypes.TunnelShot.attributes = {
		damageMultiplier:	{base: [null, 2.0, 2.2, 2.4], modifier: null}
	};
	this.abilityTypes.DeadEye.attributes = {
		duration:			{base: [null, 12, 16, 20], modifier: null}
	};
	
	// DEFENSE_ATTRIBUTES:
	// ********************************************************************************************
	this.abilityTypes.Deflect.attributes = {
		duration:			{base: [null, 8, 10, 12], modifier: null}
	};
	
	// COLD_MAGIC_ATTRIBUTES:
	// ********************************************************************************************
	this.abilityTypes.ConeOfCold.attributes = {
		damage:				{base: [null, 10, 14, 16], modifier: 'coldDamageMultiplier'}
	};
	this.abilityTypes.FreezingCloud.attributes = {
		damage:				{base: [null, 3, 5, 6], modifier: 'coldDamageMultiplier'},
		duration:			{base: [null, 10, 10, 10], modifier: 'coldDamageMultiplier'}
	};
	this.abilityTypes.Freeze.attributes = {
		duration:			{base: [null, 8, 12, 14], modifier: 'coldDamageMultiplier'}
	};
	this.abilityTypes.ColdAttunement.attributes = {
		coldPower:			{base: [null, 10, 14, 16], modifier: null},
		duration:			{base: [null, 10, 10, 10], modifier: null},
	};
	this.abilityTypes.FlashFreeze.attributes = {
		duration:			{base: [null, 5, 7, 8]},
	};
	
	// ENCHANTMENT_MAGIC_ATTRIBUTES:
	// ********************************************************************************************
	this.abilityTypes.Confusion.attributes = {
		duration:			{base: [null, 10, 14, 16], modifier: 'spellDamageMultiplier'},
		aoeRange:			{base: [null, 0, 1, 1.5], modifier: null},
	};
	this.abilityTypes.Fear.attributes = {
		duration:			{base: [null, 6, 8, 10], modifier: 'spellDamageMultiplier'},
		aoeRange:			{base: [null, 1.5, 2.0, 2.5], modifier: null}
	};
	this.abilityTypes.Charm.attributes = {
		duration:			{base: [null, 20, 28, 34], modifier: 'spellDamageMultiplier'},
	};
	this.abilityTypes.Mesmerize.attributes = {
		duration:			{base: [null, 5, 7, 8], modifier: 'spellDamageMultiplier'},
	};

	// ATHLETICS_ATTRIBUTES:
	// ********************************************************************************************
	this.abilityTypes.Sprint.attributes = {
		maxPath:			{base: [null, 5, 6, 7], modifier: null}
	};
	

	// STEALTH_ATTRIBUTES:
	// ********************************************************************************************
	this.abilityTypes.SleepingDart.attributes = {
		duration:			{base: [null, 5, 7, 8], modifier: null}
	};
	this.abilityTypes.SmokeBomb.attributes = {
		duration:			{base: [null, 5, 8, 10], modifier: null}
	};
	this.abilityTypes.NimbleFingers.attributes = {
		numTraps:			{base: [null, 3, 5, 7], modifier: null}
	};
	
	// MISC_ATTRIBUTES:
	this.abilityTypes.HellFire.attributes = {
		damage:				{base: [null, HELL_FIRE_DAMAGE], modifier: null}	
	};
	
	
	// Create Attribute Value funcs:
	this.forEachType(this.abilityTypes, function (talentType) {
		if (talentType.attributes) {			
			for (let key in talentType.attributes) {
				if (talentType.attributes.hasOwnProperty(key)) {
					let attribute = talentType.attributes[key];
					
					attribute.name = key;
					
					// Value Func:
					if (attribute.base) {
						attribute.value = function (actingCharacter) {
						
							if (this.modifier) {
								return Math.ceil(this.base[actingCharacter.getTalentLevel(talentType.name)] * actingCharacter[this.modifier]);
							}
							else {
								return this.base[actingCharacter.getTalentLevel(talentType.name)];
							}
						};
					}
					
				}
				
			}
		}
	}, this);
	
	
	// PARTICLE:
	// ********************************************************************************************
	// Fire Magic:
	this.abilityTypes.FireBall.particleColor = 'RED';
	this.abilityTypes.BurstOfFlame.particleColor = 'RED';
	this.abilityTypes.InfernoOrb.particleColor = 'RED';
	this.abilityTypes.FireBolt.particleColor = 'RED';
	
	// Storm Magic:
	this.abilityTypes.LightningBolt.particleColor = 'BLUE';
	this.abilityTypes.Shock.particleColor = 'BLUE';
	this.abilityTypes.ThunderClap.particleColor = 'BLUE';
	this.abilityTypes.StaticDischarge.particleColor = 'BLUE';
	
	// Necromancy:
	this.abilityTypes.LifeSpike.particleColor = 'PURPLE';
	this.abilityTypes.Cannibalise.particleColor = 'PURPLE';
	this.abilityTypes.PoisonCloud.particleColor = 'PURPLE';
	this.abilityTypes.InfectiousDisease.particleColor = 'PURPLE';
	
	// Cold:
	this.abilityTypes.ConeOfCold.particleColor = 'WHITE';
	this.abilityTypes.FreezingCloud.particleColor = 'WHITE';
	this.abilityTypes.Freeze.particleColor = 'WHITE';
	this.abilityTypes.FlashFreeze.particleColor = 'WHITE';
	
	// Enchantment:
	this.abilityTypes.Confusion.particleColor = 'PURPLE';
	this.abilityTypes.Charm.particleColor = 'PURPLE';
	this.abilityTypes.Mesmerize.particleColor = 'PURPLE';
	this.abilityTypes.Fear.particleColor = 'PURPLE';
	
	// IMAGE_INDEX:
	// ********************************************************************************************
	// Armor and Shields:
	this.abilityTypes.ShieldsUp.frame = 1488;
	this.abilityTypes.Deflect.frame = 1489;
	
	// Fire Magic:
	this.abilityTypes.FireBall.frame = 1376;
	this.abilityTypes.FireAttunement.frame = 1377;
	this.abilityTypes.BurstOfFlame.frame = 1378;
	this.abilityTypes.InfernoOrb.frame = 1379;
	this.abilityTypes.FlamingHands.frame = 1380;
	this.abilityTypes.FireBolt.frame = 1381;

	// Storm Magic:
	this.abilityTypes.LightningBolt.frame = 1392;
	this.abilityTypes.StormAttunement.frame = 1393;
	this.abilityTypes.Shock.frame = 1395;
	this.abilityTypes.ThunderClap.frame = 1394;
	this.abilityTypes.StaticDischarge.frame = 1395;
	this.abilityTypes.Levitation.frame = 1396;
	

	// Necromancy:
	this.abilityTypes.LifeSpike.frame = 1424;
	this.abilityTypes.ToxicAttunement.frame = 1425;
	this.abilityTypes.SummonSkeleton.frame = 1426;
	this.abilityTypes.Cannibalise.frame = 1427;
	this.abilityTypes.PoisonCloud.frame = 1428;
	this.abilityTypes.InfectiousDisease.frame = 1429;
	
	// Cold Magic:
	this.abilityTypes.ConeOfCold.frame = 1408;
	this.abilityTypes.FreezingCloud.frame = 1409;
	this.abilityTypes.ColdAttunement.frame = 1410;
	this.abilityTypes.Freeze.frame = 1411;
	this.abilityTypes.FlashFreeze.frame = 1412;
	this.abilityTypes.IceArmor.frame = 1413;
	
	// Enchantment:
	this.abilityTypes.Confusion.frame = 1520;
	this.abilityTypes.Charm.frame = 1521;
	this.abilityTypes.Mesmerize.frame = 1522;
	this.abilityTypes.Fear.frame = 1523;
	this.abilityTypes.Swiftness.frame = 1524;
	
	// Melee:
	this.abilityTypes.PowerStrike.frame = 1440;
	this.abilityTypes.Charge.frame = 1441;
	this.abilityTypes.Berserk.frame = 1442;
	
	// Range:
	this.abilityTypes.PowerShot.frame = 1456;
	this.abilityTypes.TunnelShot.frame = 1458;
	this.abilityTypes.DeadEye.frame = 1459;
	
	// Stealth:
	//this.abilityTypes.Sneak.frame = 1472;
	this.abilityTypes.SleepingDart.frame = 1472;
	this.abilityTypes.SmokeBomb.frame = 1473;
	this.abilityTypes.NimbleFingers.frame = 1474;
	this.abilityTypes.Evade.frame = 1475;
	
	// Athletics:
	this.abilityTypes.Sprint.frame = 1504;

	
};

// SET_ABILITY_TYPE_DEFAULTS:
// ************************************************************************************************
gs.setAbilityTypeDefaults = function () {
	var trueFunc = function () {return true;},
		rangeFunc = function () {return ABILITY_RANGE;};
	
	
	this.nameTypes(this.abilityTypes);
	this.forEachType(this.abilityTypes, function (abilityType) {

		// RANGE:
		// ****************************************************************************************
		
		// Converting numbers to range() func:
		if (typeof abilityType.range === 'number') {
			var range = abilityType.range;
			abilityType.range = function (actingChar) {
				return range;
			};
		}
		// Default to max range:
		else if (!abilityType.range){
			abilityType.range = rangeFunc;
		}
		
		// Converting aoeRange numbers to func:
		if (typeof abilityType.aoeRange === 'number') {
			var aoeRange = abilityType.aoeRange;
			abilityType.aoeRange = function (actingChar) {
				return aoeRange;
			};
		}
		
	
		abilityType.canUse = abilityType.canUse || trueFunc;
		abilityType.mana = abilityType.mana || 0;
		abilityType.coolDown = abilityType.coolDown || 0;
		abilityType.hitPointCost = abilityType.hitPointCost || 0;
		
		// Desc:
		if (gs.talents[abilityType.name] && gs.talents[abilityType.name].desc) {
			abilityType.desc = gs.talents[abilityType.name].desc;
		}
		else if (!abilityType.desc) {
			abilityType.desc = '';
		}
	}, this);
};/*global gs, game, util, console*/
/*global LOS_DISTANCE, ABILITY_RANGE, FACTION*/
/*global SPIDER_EGG_HATCH_TURNS*/
/*global FIRE_POT_MIN_DAMAGE, FIRE_POT_MAX_DAMAGE*/
/*global GAS_POT_MIN_DAMAGE, GAS_POT_MAX_DAMAGE*/
/*jshint esversion: 6, laxbreak: true*/
'use strict';

// CREATE_NPC_ABILITY_TYPES:
// ********************************************************************************************
gs.createNPCAbilityTypes = function () {
	// MELEE_ATTACK:
	// Used by NPCs to give them melee attacks
	// Note that player melee attacks are handled by weaponEffectTypes
	// ****************************************************************************************
	this.abilityTypes.MeleeAttack = {};
	this.abilityTypes.MeleeAttack.attributes = {damage: {}};
	this.abilityTypes.MeleeAttack.onHitFunc = null;
	this.abilityTypes.MeleeAttack.range = 1.5;
	this.abilityTypes.MeleeAttack.canUseOn = this.abilityCanUseOn.SingleTileRay;
	this.abilityTypes.MeleeAttack.getTarget = this.abilityGetTarget.SingleTarget;
	this.abilityTypes.MeleeAttack.useOn = function (character, targetTileIndex) {
		var damage, onHitFunc = null;
		
		// Attributes:
		damage = this.attributes.damage.value(character);
		
		if (this.onHitFunc) {
			onHitFunc = this.onHitFunc.bind(this);
		}
		
		// Melee Attack:
		gs.meleeAttack(character, targetTileIndex, damage, {effectFunc: onHitFunc});
		
		// Play Sound:
		gs.playSound(gs.sounds.melee, character.tileIndex);
	};
	
	// VAMPIRE_ATTACK:
	// Used by NPCs to give them a vampire attack which heals and raises their max hp
	// ****************************************************************************************
	this.abilityTypes.VampireAttack = Object.create(this.abilityTypes.MeleeAttack);
	this.abilityTypes.VampireAttack.onHitFunc = function (defender, attacker, damage) {
		attacker.healHp(Math.ceil(damage / 2));
	};
	
	// EXP_DRAIN_ATTACK:
	// Used by NPCs to give them a exp draining melee attacks
	// Note that player melee attacks are handled by weaponEffectTypes
	// ****************************************************************************************
	this.abilityTypes.EXPDrainAttack = Object.create(this.abilityTypes.MeleeAttack);
	this.abilityTypes.EXPDrainAttack.onHitFunc = function (defender, attacker, damage) {
		defender.loseExp(5);
	};
	
	
	// MANA_DRAIN_ATTACK:
	// Used by NPCs to give them a mana draining melee attacks
	// Note that player melee attacks are handled by weaponEffectTypes
	// ****************************************************************************************
	this.abilityTypes.ManaDrainAttack = Object.create(this.abilityTypes.MeleeAttack);
	this.abilityTypes.ManaDrainAttack.onHitFunc = function (defender, attacker, damage) {
		defender.loseMp(5);
		defender.queuePopUpText('Mana Drain!', '#ffffff');
	};
	
	
	// POISON_ATTACK:
	// ********************************************************************************************
	this.abilityTypes.PoisonAttack = Object.create(this.abilityTypes.MeleeAttack);
	this.abilityTypes.PoisonAttack.onHitFunc = function (defender, attacker, damage) {
		var poisonDamage;
		
		poisonDamage = this.attributes.damage.value(attacker) * 2;
		
		if (util.frac() < 0.25) {
			defender.addPoisonDamage(poisonDamage);
		}
	};
	
	
	// DRAINING_ATTACK:
	// ********************************************************************************************
	this.abilityTypes.DrainingAttack = Object.create(this.abilityTypes.MeleeAttack);
	this.abilityTypes.DrainingAttack.onHitFunc = function (defender, attacker, damage) {
		if (util.frac() < 0.25) {
			defender.statusEffects.add('Draining');
		}	
	};
	
	// TRAMPLE_ATTACK:
	// ********************************************************************************************
	this.abilityTypes.TrampleAttack = Object.create(this.abilityTypes.MeleeAttack);
	this.abilityTypes.TrampleAttack.canUse = function (actingChar) {
		return !actingChar.isImmobile;
	};
	this.abilityTypes.TrampleAttack.useOn = function (character, targetTileIndex) {
		var onHit, damage;
		
		damage = this.attributes.damage.value(character);
		
		onHit = function (targetChar) {
			character.popUpText('Trample!', '#ffffff');
		}.bind(this);
		
		// Melee Attack:
		gs.meleeAttack(character, targetTileIndex, damage, {effectFunc: onHit, knockBack: 1});
		
		if (gs.isPassable(targetTileIndex)) {
			character.moveTo(targetTileIndex);
		}
		
		// Play Sound:
		gs.playSound(gs.sounds.melee, character.tileIndex);	
	};
	
	// PROJECTILE_ATTACK:
	// Used by NPCs to give them projectile attacks
	// Note that player projectile attacks are handled by weaponEffectTypes
	// ********************************************************************************************
	this.abilityTypes.ProjectileAttack = {};
	this.abilityTypes.ProjectileAttack.attributes = {damage: {}};
	this.abilityTypes.ProjectileAttack.canUseOn = this.abilityCanUseOn.NPCProjectileAttack;
	this.abilityTypes.ProjectileAttack.range = 5.0;
	this.abilityTypes.ProjectileAttack.sound = gs.sounds.throw;
	this.abilityTypes.ProjectileAttack.getTarget = this.abilityGetTarget.SingleTarget;
	this.abilityTypes.ProjectileAttack.useOn = function (character, targetTileIndex) {
		var damage;
		
		damage = this.attributes.damage.value(character);
		
		// Create Projectile:
		gs.createProjectile(character, targetTileIndex, this.projectileTypeName, damage, {killer: character});
		
		// Character bounce and face:
		character.body.faceTileIndex(targetTileIndex);
		character.body.bounceTowards(targetTileIndex);
		
		// Effect:
		if (this.shootEffect) {
			gs.createMagicShootEffect(character, targetTileIndex, this.shootEffect);
		}
		
		// Play Sound:
		gs.playSound(this.sound, character.tileIndex);
	};
	
	// PROJECTILE_KITE:
	// Used by NPCs to give them projectile attacks
	// The NPC will take a step away from their target while firing if possible
	// ********************************************************************************************
	this.abilityTypes.ProjectileKite = {};
	this.abilityTypes.ProjectileKite.attributes = {damage: {}};
	this.abilityTypes.ProjectileKite.canUseOn = this.abilityCanUseOn.NPCProjectileAttack;
	this.abilityTypes.ProjectileKite.range = 5.0;
	this.abilityTypes.ProjectileKite.sound = gs.sounds.throw;
	this.abilityTypes.ProjectileKite.getTarget = this.abilityGetTarget.SingleTarget;
	this.abilityTypes.ProjectileKite.useOn = function (actingChar, targetTileIndex) {
		var tileIndex;
		
		gs.abilityTypes.ProjectileAttack.useOn.call(this, actingChar, targetTileIndex);
		
		if (gs.getChar(targetTileIndex)) {	
			tileIndex = actingChar.getMoveAwayIndex(gs.getChar(targetTileIndex));
			if (tileIndex) {
				actingChar.moveTo(tileIndex);
			}
		}
	};
	
	// HIDE_IN_SHELL:
	// ********************************************************************************************
	this.abilityTypes.HideInShell = {};
	this.abilityTypes.HideInShell.range = 1.5;
	this.abilityTypes.HideInShell.canUseOn = this.abilityCanUseOn.SingleCharacterRay;
	this.abilityTypes.HideInShell.canUse = function (actingChar) {
		return !actingChar.statusEffects.has('HideInShell');
	};
	this.abilityTypes.HideInShell.getTarget = this.abilityGetTarget.SingleTarget;
	this.abilityTypes.HideInShell.useOn = function (character, targetTileIndex) {
		character.statusEffects.add('HideInShell');
	};
	
	// SUICIDE:
	// Used by NPCs which kill themselves when in range
	// Note that the actual effects upon death are handled by onNPCDeath
	// ********************************************************************************************
	this.abilityTypes.Suicide = {};
	this.abilityTypes.Suicide.range = 1.5;
	this.abilityTypes.Suicide.canUseOn = this.abilityCanUseOn.SingleCharacterRay;
	this.abilityTypes.Suicide.getTarget = this.abilityGetTarget.SingleTarget;
	this.abilityTypes.Suicide.useOn = function (character, targetTileIndex) {
		character.death();
	};
	
	// SPAWN_NPC:
	// Used by NPC spawners
	// ********************************************************************************************
	this.abilityTypes.SpawnNPC = {};
	this.abilityTypes.SpawnNPC.attributes = {damage: {}};
	this.abilityTypes.SpawnNPC.range = LOS_DISTANCE;
	this.abilityTypes.SpawnNPC.mana = 1;
	this.abilityTypes.SpawnNPC.numSpawned = 1;
	this.abilityTypes.SpawnNPC.getTarget = this.abilityGetTarget.SingleTarget;
	this.abilityTypes.SpawnNPC.getSpawnIndex = function (actingChar, targetTileIndex) {
		var indexList;
		
		indexList = gs.getIndexInRadius(actingChar.tileIndex, 1.5);
		indexList = indexList.filter(index => gs.isPassable(index));
		indexList = indexList.filter(index => gs.isIndexSafe(index));
		indexList = indexList.filter(index => !gs.getTile(index).type.isPit);
		
		// Sort by nearest to target:
		indexList.sort((a, b) => gs.distance(targetTileIndex, a) - gs.distance(targetTileIndex, b));
		return indexList.length > 0 ? indexList[0] : null;
	};
	this.abilityTypes.SpawnNPC.canUseOn = function (actingChar, targetTileIndex) {
    	return gs.distance(actingChar.tileIndex, targetTileIndex) <= this.range()
			&& this.getSpawnIndex(actingChar, targetTileIndex);
	};
	this.abilityTypes.SpawnNPC.useOn = function (actingChar, targetTileIndex) {
		var tileIndex, npc, flags = {};
		
		for (let i = 0; i < this.numSpawned; i += 1) {
			tileIndex = this.getSpawnIndex(actingChar, targetTileIndex);
			if (tileIndex) {
				if (this.npcTypeName === 'FireBall') {
					flags.burstDamage = this.attributes.damage.value(actingChar);
				}
				
				npc = gs.createNPC(tileIndex, this.npcTypeName, flags);
				npc.spotAgroPlayer();
				npc.waitTime = 100;
				npc.faction = actingChar.faction;
				gs.playSound(gs.sounds.spell, actingChar.tileIndex);
				gs.createParticlePoof(tileIndex, 'WHITE');
			}
		}
		
		// Destroy spawner type NPCs (immobile) that are out of mana:
		if (actingChar.type.cantMove && actingChar.currentMp === 1) {
			actingChar.death();
		}
	};
	
	// SPIDER_WEB
	// ********************************************************************************************
	this.abilityTypes.SpiderWeb = {};
	this.abilityTypes.SpiderWeb.range = 2;
	this.abilityTypes.SpiderWeb.shouldUseOn = function (character, targetTileIndex) {
		return game.rnd.frac() < 0.5;
	};
	this.abilityTypes.SpiderWeb.getTarget = this.abilityGetTarget.SingleTarget;
	this.abilityTypes.SpiderWeb.canUseOn = function (character, targetTileIndex) {
		return gs.abilityCanUseOn.SingleCharacterRay.call(this, character, targetTileIndex)
			&& !gs.getChar(targetTileIndex).isImmobile;
	};
	this.abilityTypes.SpiderWeb.useOn = function (character, targetTileIndex) {
		gs.createProjectile(character, targetTileIndex, 'SpiderWeb');
		
		// Character bounce and face:
		character.body.faceTileIndex(targetTileIndex);
		character.body.bounceTowards(targetTileIndex);
	};
	
	// THROW_NET:
	// ********************************************************************************************
	this.abilityTypes.ThrowNet = {};
	this.abilityTypes.ThrowNet.range = 4;
	this.abilityTypes.ThrowNet.getTarget = this.abilityGetTarget.SingleTarget;
	this.abilityTypes.ThrowNet.canUseOn = this.abilityTypes.SpiderWeb.canUseOn;
	this.abilityTypes.ThrowNet.useOn = function (character, targetTileIndex) {
		gs.createProjectile(character, targetTileIndex, 'ThrowingNet');
	};

	// CONSTRICT:
	// ********************************************************************************************
	this.abilityTypes.Constrict = {};
	this.abilityTypes.Constrict.range = 1.5;
	this.abilityTypes.Constrict.getTarget = this.abilityGetTarget.SingleTarget;
	this.abilityTypes.Constrict.canUseOn = this.abilityCanUseOn.SingleTileRay;
	this.abilityTypes.Constrict.canUse = function (actingChar) {
		return !actingChar.statusEffects.has('Constricting');
	};
	this.abilityTypes.Constrict.useOn = function (character, targetTileIndex) {
		var targetChar = gs.getChar(targetTileIndex);
		
		if (targetChar) {
			targetChar.statusEffects.add('Constricted', {duration: 5, constrictingCharId: character.id});
			character.statusEffects.add('Constricting' , {duration: 5, targetCharId: targetChar.id});
		}
		
		character.body.faceTileIndex(targetTileIndex);
		character.body.bounceTowards(targetTileIndex);
	};

	// REVIVE_SKELETON:
	// ****************************************************************************************
	this.abilityTypes.ReviveSkeleton = {};
	this.abilityTypes.ReviveSkeleton.range = LOS_DISTANCE;
	this.abilityTypes.ReviveSkeleton.aoeRange = 5;
	this.abilityTypes.ReviveSkeleton.canUse = function (actingChar) {
		// Charmed NPCs should never revive skeletons:
		return actingChar.faction === FACTION.HOSTILE;
	};
	this.abilityTypes.ReviveSkeleton.canUseOn = function (actingChar, targetTileIndex) {
		return gs.abilityCanUseOn.SingleTileSmite.call(this, actingChar, targetTileIndex) 
			&& gs.getObj(targetTileIndex, 'SkeletonCorpse') 
			&& gs.isPassable(targetTileIndex);
	};
	this.abilityTypes.ReviveSkeleton.getTarget = function (actingChar) {
		var indexList = gs.getIndexInRadius(actingChar.tileIndex, this.aoeRange(actingChar));
		
		indexList = indexList.filter(index => this.canUseOn(actingChar, index));
		
		return indexList.length > 0 ? indexList[0] : null;
	};
	this.abilityTypes.ReviveSkeleton.useOn = function (character, targetTileIndex) {
		var object = gs.getObj(targetTileIndex),
			npc;
		
		// Revive Skeleton:
		npc = gs.createNPC(object.tileIndex, object.npcTypeName || 'SkeletonWarrior');
		npc.popUpText('Revived', '#ffffff');
		gs.createParticlePoof(object.tileIndex, 'PURPLE');
		gs.destroyObject(object);
		
		// Caster:
		gs.createParticlePoof(character.tileIndex, 'PURPLE');
		character.popUpText('Revive Skeleton', '#ffffff');
	};
	

	// SUMMON_ICE_BOMB:
	// ****************************************************************************************
	this.abilityTypes.SummonIceBomb = {};
	this.abilityTypes.SummonIceBomb.attributes = {damage: {}};
	this.abilityTypes.SummonIceBomb.range = ABILITY_RANGE;
	this.abilityTypes.SummonIceBomb.aoeRange = 1.5; // Used by getTarget.TBAoE to select tiles adjacent to hostiles
	this.abilityTypes.SummonIceBomb.getTarget = this.abilityGetTarget.TBAoE;
	this.abilityTypes.SummonIceBomb.canUseOn = function (actingChar, targetTileIndex) {
		return gs.abilityCanUseOn.SingleTileSmite.call(this, actingChar, targetTileIndex)
			&& !gs.getObj(targetTileIndex)
			&& !gs.getTile(targetTileIndex).type.isPit
			&& gs.isPassable(targetTileIndex);
	};
	this.abilityTypes.SummonIceBomb.useOn = function (character, targetTileIndex) {
		var object;
		
		// Character:
		character.popUpText('Summon Ice Bomb', '#ffffff');
		gs.createParticlePoof(character.tileIndex, 'WHITE');
		
		// Bomb:
		gs.createSummonEffect(targetTileIndex, function () {
			object = gs.createObject(targetTileIndex, 'IceBomb');
			object.damage = this.attributes.damage.value(character);
		}, this);
		
		// Sound:
		gs.playSound(gs.sounds.cure, character.tileIndex);
	};
	
	// THROW_BOMB:
	// ****************************************************************************************
	this.abilityTypes.ThrowBomb = {};
	this.abilityTypes.ThrowBomb.attributes = {damage: {}};
	this.abilityTypes.ThrowBomb.range = LOS_DISTANCE;
	this.abilityTypes.ThrowBomb.aoeRange = 1.0; // Used by getTarget.TBAoE to select tiles adjacent to hostiles
	this.abilityTypes.ThrowBomb.getTarget = this.abilityGetTarget.TBAoE;
	this.abilityTypes.ThrowBomb.canUseOn = function (actingChar, targetTileIndex) {
		return gs.abilityCanUseOn.SingleTileSmite.call(this, actingChar, targetTileIndex)
			&& !gs.getObj(targetTileIndex)
			&& !gs.getTile(targetTileIndex).type.isPit
			&& gs.isPassable(targetTileIndex);
	};
	this.abilityTypes.ThrowBomb.useOn = function (character, targetTileIndex) {
		var damage;
		
		damage = this.attributes.damage.value(character);
		
		gs.createProjectile(character, targetTileIndex, 'Bomb', damage, {killer: character});
		
		// Character bounce and face:
		character.body.faceTileIndex(targetTileIndex);
		character.body.bounceTowards(targetTileIndex);
	};
	
	// NPC_POISON_CLOUD:
	// ****************************************************************************************
	this.abilityTypes.NPCPoisonCloud = {};
	this.abilityTypes.NPCPoisonCloud.attributes = {damage: {}};
	this.abilityTypes.NPCPoisonCloud.range = ABILITY_RANGE;
	this.abilityTypes.NPCPoisonCloud.aoeRange = 1.5; // Used by getTarget.TBAoE to select tiles adjacent to hostiles
	this.abilityTypes.NPCPoisonCloud.getTarget = this.abilityGetTarget.TBAoE;
	this.abilityTypes.NPCPoisonCloud.canUseOn = this.abilityCanUseOn.SingleTileSmite;
	this.abilityTypes.NPCPoisonCloud.useOn = function (character, targetTileIndex) {
		var damage, position;
		
		damage = this.attributes.damage.value(character);
		
		// Caster:
		character.popUpText('Poison Cloud', '#ffffff');
		gs.createParticlePoof(character.tileIndex, 'PURPLE');
		
		// Cloud:
		gs.createCloud(targetTileIndex, 'PoisonGas', damage, 15);
		gs.createParticlePoof(targetTileIndex, 'PURPLE');
		
		// Sound:
		gs.playSound(gs.sounds.fire, targetTileIndex);
	};
	
	// SUMMON_MONSTERS:
	// Summons a group of monsters in a radius around the caster.
	// These monsters are flagged as summoned and have a reference to the summoner.
	// If the summoner is killed then the monsters poof automatically.
	// Note: never save summoned creatures when zoning
	// ********************************************************************************************
	this.abilityTypes.SummonMonsters = {};
	this.abilityTypes.SummonMonsters.range = LOS_DISTANCE;
	this.abilityTypes.SummonMonsters.num = 4;
	this.abilityTypes.SummonMonsters.getTarget = this.abilityGetTarget.SingleTarget;
	this.abilityTypes.SummonMonsters.canUseOn = function (actingChar, targetTileIndex) {
		var indexList;
		
		// Find adjacent indices in which to summon:
		indexList = gs.getIndexInRadius(actingChar.tileIndex, 2);
		indexList = indexList.filter(index => gs.isPassable(index));
		indexList = indexList.filter(index => gs.isRayPassable(actingChar.tileIndex, index));
		
		return indexList.length > 0
			&& gs.distance(actingChar.tileIndex, targetTileIndex) <= this.range()
			&& gs.isRayClear(actingChar.tileIndex, targetTileIndex);	
	};
	this.abilityTypes.SummonMonsters.useOn = function (actingChar, targetTileIndex) {
		var indexList;
		
		// Find adjacent indices in which to summon:
		indexList = gs.getIndexInRadius(actingChar.tileIndex, 2);
		indexList = indexList.filter(index => gs.isPassable(index));
		indexList = indexList.filter(index => gs.isRayPassable(actingChar.tileIndex, index));
		
		// Sort by nearest to target:
		indexList.sort((a, b) => gs.distance(targetTileIndex, a) - gs.distance(targetTileIndex, b));
		indexList = indexList.slice(0, this.num);
		
		// Spawn summoned npcs:
		indexList.forEach(function (index) {
			gs.createSummonEffect(index, function () {
				var npc = gs.createNPC(index, this.npcTypeName, {summonerID: actingChar.id});
				npc.waitTime = 100;
				npc.isAgroed = true;
				npc.faction = actingChar.faction;
				actingChar.summonIDList.push(npc.id);
				npc.popUpText('Summoned', '#ffffff');
			}, this);
		}, this);
		
		// Sound:
		gs.playSound(gs.sounds.cure, actingChar.tileIndex);
	};
	

	// WATCH_PLAYER:
	// ********************************************************************************************
	this.abilityTypes.WatchPlayer = {};
	this.abilityTypes.WatchPlayer.range = LOS_DISTANCE;
	this.abilityTypes.WatchPlayer.canUseOn = this.abilityCanUseOn.SingleCharacterSmite;
	this.abilityTypes.WatchPlayer.getTarget = this.abilityGetTarget.SingleTarget;
	this.abilityTypes.WatchPlayer.useOn = function (character, targetTileIndex) {
		gs.pc.statusEffects.add('Marked');
	};
	
	// WALL_OF_FIRE:
	// The NPC summons a 1x3 flaming clouds behind the player
	// ********************************************************************************************
	this.abilityTypes.WallOfFire = {};
	this.abilityTypes.WallOfFire.attributes = {damage: {}};
	this.abilityTypes.WallOfFire.range = ABILITY_RANGE;
	this.abilityTypes.WallOfFire.getTarget = this.abilityGetTarget.SingleTarget;
	this.abilityTypes.WallOfFire.getIndexList = function (character, targetTileIndex) {
		var indexList;
		
		indexList = gs.getIndexListAdjacent(targetTileIndex);
		indexList = indexList.filter(index => gs.isStaticPassable(index) && !gs.getCloud(index));
		indexList = indexList.filter(index => gs.distance(index, character.tileIndex) > gs.distance(targetTileIndex, character.tileIndex));
		
		return indexList;
	};
	this.abilityTypes.WallOfFire.canUseOn = function (character, targetTileIndex) {
		return gs.abilityCanUseOn.SingleCharacterSmite.call(this, character, targetTileIndex)
			&& this.getIndexList(character, targetTileIndex).length > 0;
	};
	this.abilityTypes.WallOfFire.useOn = function (character, targetTileIndex) {
		var indexList, damage;
		
		// Attributes:
		damage = this.attributes.damage.value(character);
		
		// Caster:
		character.popUpText('Wall Of Fire', '#ffffff');
		gs.createParticlePoof(character.tileIndex, 'RED');
		
		// Targets:
		indexList = this.getIndexList(character, targetTileIndex);
		
		// Create Clouds:
		indexList.forEach(function (tileIndex) {
			gs.createParticlePoof(tileIndex, 'RED');
			gs.createCloud(tileIndex, 'FlamingCloud', damage, 10);			  
		}, this);
		
		// Sound:
		gs.playSound(gs.sounds.cure, character.tileIndex);
	};
	
	// WALL_OF_POISON_GAS:
	// The NPC summons a 1x3 flaming clouds behind the player
	// ********************************************************************************************
	this.abilityTypes.WallOfPoisonGas = {};
	this.abilityTypes.WallOfPoisonGas.attributes = {damage: {}};
	this.abilityTypes.WallOfPoisonGas.range = ABILITY_RANGE;
	this.abilityTypes.WallOfPoisonGas.getTarget = this.abilityGetTarget.SingleTarget;
	this.abilityTypes.WallOfPoisonGas.getIndexList = function (character, targetTileIndex) {
		var indexList;
		
		indexList = gs.getIndexListAdjacent(targetTileIndex);
		indexList = indexList.filter(index => gs.isStaticPassable(index) && !gs.getCloud(index));
		indexList = indexList.filter(index => gs.distance(index, character.tileIndex) > gs.distance(targetTileIndex, character.tileIndex));
		
		return indexList;
	};
	this.abilityTypes.WallOfPoisonGas.canUseOn = function (character, targetTileIndex) {
		return gs.abilityCanUseOn.SingleCharacterSmite.call(this, character, targetTileIndex)
			&& this.getIndexList(character, targetTileIndex).length > 0;
	};
	this.abilityTypes.WallOfPoisonGas.useOn = function (character, targetTileIndex) {
		var indexList, damage;
		
		// Attributes:
		damage = this.attributes.damage.value(character);
		
		// Caster:
		gs.createParticlePoof(character.tileIndex, 'PURPLE');
		
		// Targets:
		indexList = this.getIndexList(character, targetTileIndex);
		
		// Create Clouds:
		indexList.forEach(function (tileIndex) {
			gs.createParticlePoof(tileIndex, 'PURPLE');
			gs.createCloud(tileIndex, 'PoisonCloud', damage, 10);			  
		}, this);
		
		// Sound:
		gs.playSound(gs.sounds.cure, character.tileIndex);
	};
	
	
	// HEAL:
	// ********************************************************************************************
	this.abilityTypes.Heal = {};
	this.abilityTypes.Heal.range = LOS_DISTANCE;
	this.abilityTypes.Heal.healPercent = 0.25;
	this.abilityTypes.Heal.getTarget = this.abilityGetTarget.SingleAlly;
	this.abilityTypes.Heal.canUseOn = function (actingCharacter, targetTileIndex) {
		return gs.abilityCanUseOn.SingleCharacterSmite.call(this, actingCharacter, targetTileIndex)
			&& gs.getChar(targetTileIndex).currentHp < gs.getChar(targetTileIndex).maxHp
			&& !gs.getChar(targetTileIndex).type.noRegen;
	};
	this.abilityTypes.Heal.useOn = function (actingCharacter, targetTileIndex) {
		var npc = gs.getChar(targetTileIndex);

		// Caster:
		actingCharacter.popUpText('Casting Heal', '#ffffff');
		gs.createParticlePoof(actingCharacter.tileIndex, 'GREEN');
		
		
		// Target Char:
		npc.healHp(Math.round(npc.maxHp * this.healPercent));
		npc.popUpText('Healed!', '#ffffff');
		gs.createHealingEffect(npc.tileIndex);
		gs.playSound(gs.sounds.cure, npc.tileIndex);
		
	};
	
	// HASTE:
	// ********************************************************************************************
	this.abilityTypes.Haste = {};
	this.abilityTypes.Haste.range = LOS_DISTANCE;
	this.abilityTypes.Haste.getTarget = this.abilityGetTarget.SingleAlly;
	this.abilityTypes.Haste.canUseOn = function (actingCharacter, targetTileIndex) {
		return gs.abilityCanUseOn.SingleCharacterSmite.call(this, actingCharacter, targetTileIndex)
			&& !gs.getChar(targetTileIndex).statusEffects.has('Haste')
			&& !gs.getChar(targetTileIndex).type.cantMove;
	};
	this.abilityTypes.Haste.canUse = function (actingCharacter) {
		if (actingCharacter.faction === FACTION.HOSTILE) {
			return true;
		}
		// Player allies should only cast haste on the player when there are hostiles agroed
		else {
			return gs.agroedHostileList().length > 0;
		}
	};
	this.abilityTypes.Haste.useOn = function (actingCharacter, targetTileIndex) {
		var npc = gs.getChar(targetTileIndex);
		
		npc.statusEffects.add('Haste');
		
		// Pop Up Text:
		actingCharacter.popUpText('Casting Haste', '#ffffff');
		
		// Particles:
		gs.createYellowMagicEffect(npc.tileIndex);
		
		gs.createParticlePoof(actingCharacter.tileIndex, 'PURPLE');
	};
	
	// SMITE:
	// ********************************************************************************************
	this.abilityTypes.Smite = {};
	this.abilityTypes.Smite.attributes = {damage: {}};
	this.abilityTypes.Smite.canUseOn = this.abilityCanUseOn.SingleCharacterSmite;
	this.abilityTypes.Smite.range = ABILITY_RANGE;
	this.abilityTypes.Smite.getTarget = this.abilityGetTarget.SingleTarget;
	this.abilityTypes.Smite.useOn = function (actingChar, targetTileIndex) {
		var damage;
		
		// Attributes:
		damage = this.attributes.damage.value(actingChar);
		
		// Status Effect:
		actingChar.statusEffects.add('CastingSmite', {damage: damage, tileIndex: {x: targetTileIndex.x, y: targetTileIndex.y}});
		
		// Set Facing:
		actingChar.body.faceTileIndex(targetTileIndex);
	};
	
	
	
	// SLOW_CHARGE:
	// ********************************************************************************************
	this.abilityTypes.SlowCharge = {};
	this.abilityTypes.SlowCharge.attributes = {damage: {}};
	this.abilityTypes.SlowCharge.range = LOS_DISTANCE;
	this.abilityTypes.SlowCharge.canUseOn = this.abilityCanUseOn.SingleCharacterStraightRay;
	this.abilityTypes.SlowCharge.shouldUseOn = function (actingCharacter, targetTileIndex) {
		return gs.distance(actingCharacter.tileIndex, targetTileIndex) >= 4;
	};
	this.abilityTypes.SlowCharge.getTarget = this.abilityGetTarget.SingleTarget;
	this.abilityTypes.SlowCharge.useOn = function (actingChar, targetTileIndex) {
		var delta, damage;
		
		// Attributes:
		damage = this.attributes.damage.value(actingChar);
		
		delta = gs.get8WayVector(actingChar.tileIndex, targetTileIndex);
		
		// Status Effect:
		actingChar.moveDelta = {x: delta.x, y: delta.y};
		actingChar.statusEffects.add('SlowCharge', {damage: damage});
	};
	
	// ORB_OF_FIRE:
	// ********************************************************************************************
	this.abilityTypes.OrbOfFire = {};
	this.abilityTypes.OrbOfFire.attributes = {damage: {}};
	this.abilityTypes.OrbOfFire.range = LOS_DISTANCE;
	this.abilityTypes.OrbOfFire.getTarget = this.abilityGetTarget.SingleTarget;
	this.abilityTypes.OrbOfFire.canUseOn = function (actingCharacter, targetTileIndex) {
		var delta = gs.get8WayVector(actingCharacter.tileIndex, targetTileIndex);
		
		
		return gs.isPassable(actingCharacter.tileIndex.x + delta.x, actingCharacter.tileIndex.y + delta.y)
			&& gs.distance(actingCharacter.tileIndex, targetTileIndex) <= this.range()
			&& gs.isStraight(actingCharacter.tileIndex, targetTileIndex)
			&& gs.isRayPassable(actingCharacter.tileIndex, targetTileIndex);
	};
	this.abilityTypes.OrbOfFire.useOn = function (actingCharacter, targetTileIndex) {
		var delta, proj, damage;
		
		// Attributes:
		damage = this.attributes.damage.value(actingCharacter);
		
		// Direction:
		delta = gs.get8WayVector(actingCharacter.tileIndex, targetTileIndex);
		
		// Projectile:
		proj = gs.createNPC({x: actingCharacter.tileIndex.x + delta.x, y: actingCharacter.tileIndex.y + delta.y}, 'OrbOfFire', {burstDamage: damage});
		proj.moveDelta = {x: delta.x, y: delta.y};
		proj.waitTime = 100;
		proj.isAgroed = true;
		
		// Caster:
		actingCharacter.popUpText('Orb of Fire', '#ffffff');
		gs.createParticlePoof(actingCharacter.tileIndex, 'RED');
		
		// Character bounce and face:
		actingCharacter.body.faceTileIndex(targetTileIndex);
		actingCharacter.body.bounceTowards(targetTileIndex);
	};
	
	
	// SLIDE:
	// ********************************************************************************************
	this.abilityTypes.Slide = {};
	this.abilityTypes.Slide.range = LOS_DISTANCE;
	this.abilityTypes.Slide.getTarget = this.abilityGetTarget.SingleTarget;
	this.abilityTypes.Slide.canUseOn = function (actingCharacter, targetTileIndex) {
		var toTileIndex = actingCharacter.body.getKnockBackIndex(gs.getNormal(targetTileIndex, actingCharacter.tileIndex), 4);
		return gs.distance(actingCharacter.tileIndex, targetTileIndex) <= 2
			&& gs.distance(actingCharacter.tileIndex, toTileIndex) > 1.5;
	};
	this.abilityTypes.Slide.useOn = function (actingCharacter, targetTileIndex) {
		var toTileIndex = actingCharacter.body.getKnockBackIndex(gs.getNormal(targetTileIndex, actingCharacter.tileIndex), 4);
		
		actingCharacter.popUpText('Slide!', '#ffffff');
		actingCharacter.body.moveToTileIndex(toTileIndex);
		actingCharacter.sprite.frame = actingCharacter.sprite.frame + 1;
	};
	
	// SEAL_DOORS:
	// ********************************************************************************************
	this.abilityTypes.SealDoors = {};
	this.abilityTypes.SealDoors.getTarget = this.abilityGetTarget.SingleTarget;
	this.abilityTypes.SealDoors.range = ABILITY_RANGE;
	this.abilityTypes.SealDoors.getTargetList = function (actingChar) {
		var indexList;
		
		indexList = gs.getIndexInRadius(actingChar.tileIndex, this.range());
		indexList = indexList.filter(index => gs.getObj(index, obj => obj.type.name === 'Door' || obj.isZoneLine()));
		indexList = indexList.filter(index => gs.getObj(index, obj => obj.isZoneLine()) || !gs.getChar(index));
		indexList = indexList.filter(index => gs.isRayClear(actingChar.tileIndex, index));
		
		return indexList;
	};
	this.abilityTypes.SealDoors.canUseOn = function (actingChar, targetTileIndex) {
		return this.getTargetList(actingChar).length > 0;
	};
	
	this.abilityTypes.SealDoors.useOn = function (actingChar, targetTileIndex) {
		var indexList = this.getTargetList(actingChar);
		
		gs.createParticlePoof(actingChar.tileIndex, 'PURPLE');
		
		actingChar.statusEffects.add('SealDoors', {indexList: indexList});
		
		indexList.forEach(function (tileIndex) {	
			gs.createParticlePoof(tileIndex, 'PURPLE');
			gs.createDamageText(util.toPosition(tileIndex).x, util.toPosition(tileIndex).y - 12, 'Sealed', '#ffffff');
		}, this);
	};
	
	// FLAMING_CLOUD_BOLT:
	// ********************************************************************************************
	this.abilityTypes.FlamingCloudBolt = {};
	this.abilityTypes.FlamingCloudBolt.attributes = {damage: {}};
	this.abilityTypes.FlamingCloudBolt.range = 5.5;
	this.abilityTypes.FlamingCloudBolt.showTarget = this.abilityShowTarget.Bolt;
	this.abilityTypes.FlamingCloudBolt.canUseOn = this.abilityCanUseOn.Bolt;
	this.abilityTypes.FlamingCloudBolt.getTarget = this.abilityGetTarget.SingleTarget;
	this.abilityTypes.FlamingCloudBolt.useOn = function (actingChar, targetTileIndex) {
		var indexList, damage;
		
		// Attributes:
		damage = this.attributes.damage.value(actingChar);
		
		// Targets:
		indexList = gs.getIndexInBRay(actingChar.tileIndex, targetTileIndex);
		
		// Effect (using events):
		indexList.forEach(function (tileIndex) {
			var event;
			
			// Create event:
			event = {delay: 5};
			event.effect = function () {
				if (!gs.getCloud(tileIndex)) {
					gs.createCloud(tileIndex, 'FlamingCloud', damage, 10);
					gs.playSound(gs.sounds.fire, tileIndex);
				}
			}.bind(this);
			
			// Push event:
			actingChar.addEvent(event);
		}, this);
		
		// Character bounce and face:
		actingChar.body.faceTileIndex(targetTileIndex);
		actingChar.body.bounceTowards(targetTileIndex);
	};
	
	// POISON_CLOUD_BOLT:
	// ********************************************************************************************
	this.abilityTypes.PoisonCloudBolt = {};
	this.abilityTypes.PoisonCloudBolt.attributes = {damage: {}};
	this.abilityTypes.PoisonCloudBolt.range = 5.5;
	this.abilityTypes.PoisonCloudBolt.showTarget = this.abilityShowTarget.Bolt;
	this.abilityTypes.PoisonCloudBolt.canUseOn = this.abilityCanUseOn.Bolt;
	this.abilityTypes.PoisonCloudBolt.getTarget = this.abilityGetTarget.SingleTarget;
	this.abilityTypes.PoisonCloudBolt.useOn = function (actingChar, targetTileIndex) {
		var indexList, damage;
		
		// Attributes:
		damage = this.attributes.damage.value(actingChar);
		
		// Targets:
		indexList = gs.getIndexInBRay(actingChar.tileIndex, targetTileIndex);
		
		// Effect (using events):
		indexList.forEach(function (tileIndex) {
			var event;
			
			// Create event:
			event = {delay: 5};
			event.effect = function () {
				if (!gs.getCloud(tileIndex)) {
					gs.createCloud(tileIndex, 'PoisonCloud', damage, 10);
				}
			}.bind(this);
			
			// Push event:
			actingChar.addEvent(event);
		}, this);
	};
	
	// NPC_CHARM:
	// ********************************************************************************************
	this.abilityTypes.NPCCharm = {};
	this.abilityTypes.NPCCharm.range = ABILITY_RANGE;
	this.abilityTypes.NPCCharm.canUseOn = this.abilityCanUseOn.SingleCharacterSmite;
	this.abilityTypes.NPCCharm.getTarget = this.abilityGetTarget.SingleTarget;
	this.abilityTypes.NPCCharm.useOn = function (character, targetTileIndex) {
		gs.pc.statusEffects.add('NPCCharm', {npcId: character.id});
	};
	
	// NPC_CONFUSION:
	// ********************************************************************************************
	this.abilityTypes.NPCConfusion = {};
	this.abilityTypes.NPCConfusion.range = ABILITY_RANGE;
	this.abilityTypes.NPCConfusion.canUseOn = this.abilityCanUseOn.SingleCharacterSmite;
	this.abilityTypes.NPCConfusion.getTarget = this.abilityGetTarget.SingleTarget;
	this.abilityTypes.NPCConfusion.useOn = function (character, targetTileIndex) {
		gs.pc.statusEffects.add('Confusion');
	};
	
	// BUFFET:
	// ********************************************************************************************
	this.abilityTypes.Buffet = {};
	this.abilityTypes.Buffet.range = 3.0;
	this.abilityTypes.Buffet.aoeRange = 3.0;
	this.abilityTypes.Buffet.canUseOn = this.abilityCanUseOn.SingleCharacterRay;
	this.abilityTypes.Buffet.getTarget = this.abilityGetTarget.SingleTarget;
	this.abilityTypes.Buffet.useOn = function (actingCharacter, targetTileIndex) {
		var indexList;
		
		indexList = gs.getIndexInRadius(actingCharacter.tileIndex, this.aoeRange(actingCharacter));
		
		indexList.forEach(function (tileIndex) {
			var char = gs.getChar(tileIndex);
			
			if (char && char !== actingCharacter && gs.isRayPassable(actingCharacter.tileIndex, tileIndex)) {
				char.body.applyKnockBack(gs.getNormal(actingCharacter.tileIndex, tileIndex), 3);
				gs.createParticleBurst(char.sprite.position, gs.getNormal(actingCharacter.tileIndex, char.tileIndex), 'WHITE');
			}
		}, this);
		
		actingCharacter.popUpText('Buffet!', '#ffffff');
	};
	
	// FIRE_STORM:
	// ********************************************************************************************
	this.abilityTypes.FireStorm = {};
	this.abilityTypes.FireStorm.attributes = {damage: {}};
	this.abilityTypes.FireStorm.range = ABILITY_RANGE;
	this.abilityTypes.FireStorm.getTarget = this.abilityGetTarget.SingleTarget;
	this.abilityTypes.FireStorm.canUseOn = function (actingCharacter, targetTileIndex) {
		var delta = gs.get8WayVector(actingCharacter.tileIndex, targetTileIndex);
		return gs.isPassable(actingCharacter.tileIndex.x + delta.x, actingCharacter.tileIndex.y + delta.y)
			&& gs.distance(actingCharacter.tileIndex, targetTileIndex) <= this.range()
			&& gs.isStraight(actingCharacter.tileIndex, targetTileIndex);
	};
	this.abilityTypes.FireStorm.useOn = function (actingChar, targetTileIndex) {
		var delta, proj, damage;
		
		// Attributes:
		damage = this.attributes.damage.value(actingChar);
		
		// Direction:
		delta = gs.get8WayVector(actingChar.tileIndex, targetTileIndex);
		
		// Status Effect:
		actingChar.statusEffects.add('CastingFireStorm', {
			damage: damage,
			tileIndex: {x: actingChar.tileIndex.x + delta.x, y: actingChar.tileIndex.y + delta.y},
			delta: {x: delta.x, y: delta.y}
		});
		
		// Set Facing:
		actingChar.body.faceTileIndex(targetTileIndex);
	};
	
	
	

	
    // ********************************************************************************************
    // UPDATE_TURN:
    // Special functionality that NPCs call every turn to update themselves.
    // ********************************************************************************************
	this.npcUpdateTurn = {};

	// PLANT_SPITTER_SPROUT:
	// ********************************************************************************************
	this.npcUpdateTurn.PlantSpitterSprout = function () {
		if (this.growTime === undefined) {
			this.growTime = 10;
		} else if (this.growTime > 0) {
			this.growTime -= 1;
		} else {
			this.destroy();
			gs.createNPC(this.tileIndex, 'PlantSpitter');
		}
	};

	// PLANT_SPITTER:
	// ********************************************************************************************
	this.npcUpdateTurn.PlantSpitter = function () {
		if (this.growTime === undefined) {
			this.growTime = 10;
		} else if (this.growTime > 0) {
			this.growTime -= 1;
		} else {
			this.destroy();
			gs.createNPC(this.tileIndex, 'MaturePlantSpitter');
		}
	};
	
	// FIRE_BALL:
	// ********************************************************************************************
	this.npcUpdateTurn.FireBall = function () {
		this.currentHp -= 1;
		if (this.currentHp <= 0) {
			this.death();
		}
	};
	
	// SPIDER_EGG:
	// ********************************************************************************************
	this.npcUpdateTurn.SpiderEgg = function () {
		var npc;
		
		if (this.timeToHatch < SPIDER_EGG_HATCH_TURNS) {
			this.timeToHatch += 1;
		} 
		else {
			this.death();
			npc = gs.createNPC(this.tileIndex, 'Spider');
			npc.isAgroed = true;
		}
	};
	

	// REGENERATE:
	// ********************************************************************************************
	this.npcUpdateTurn.Regenerate = function () {
		this.healHp(Math.ceil(this.maxHp * 0.05));
	};
	
	// ********************************************************************************************
    // ON_HIT:
    // Special functionality that NPCs call when they are hit.
    // ********************************************************************************************
	this.npcOnHit = {};
	
	// SLIME_SPLIT:
	// ********************************************************************************************
	this.npcOnHit.SlimeSplit = function (character) {
		var newNpc;

		if (gs.getPassableAdjacentIndex(character.tileIndex) && character.currentHp > 1 && character.sprite.frame < character.type.frame + 3) {
			newNpc = gs.createNPC(gs.getPassableAdjacentIndex(character.tileIndex), 'Slime');

			// First Split:
			if (character.sprite.frame === character.type.frame) {
				newNpc.sprite.frame = character.type.frame + 1;
				character.sprite.frame = character.type.frame + 1;
			}
			// Second Split:
			else if (character.sprite.frame === character.type.frame + 1) {
				newNpc.sprite.frame = character.type.frame + 2;
				character.sprite.frame = character.type.frame + 2;

			} 
			// Third Split:
			else {
				newNpc.sprite.frame = character.type.frame + 3;
				character.sprite.frame = character.type.frame + 3;
			}

			newNpc.currentHp = Math.floor(character.currentHp / 2);
			character.currentHp = Math.floor(character.currentHp / 2);
		}
	};
	
	this.npcOnHit.BaseBlink = function (character, preBlinkFunc = null) {
		var indexList;
		
		if (character.isImmobile || character.isStunned) {
			return;
		}
		
		// Finding a valid destination:
		indexList = gs.getIndexInRadius(character.tileIndex, LOS_DISTANCE);
		indexList = indexList.filter(index => gs.getTile(index).visible);
		indexList = indexList.filter(index => gs.isPassable(index) && character.canMoveTo(index));
		
		if (indexList.length > 0) {
			if (preBlinkFunc) {
				preBlinkFunc.call(this, character);
			}
			
			gs.createParticlePoof(character.tileIndex, 'PURPLE');
			character.popUpText('Blink', '#ffffff');
			gs.playSound(gs.sounds.teleport, character.tileIndex);
			
			character.body.snapToTileIndex(util.randElem(indexList));
			
			gs.createParticlePoof(character.tileIndex, 'PURPLE');
			character.popUpText('Blink', '#ffffff');
			
			character.waitTime = 100;
		}
	};
	
	// BLINK_FROG:
	// ********************************************************************************************
	this.npcOnHit.BlinkFrog = function (character) {
		if (game.rnd.frac() < 0.75) {
			gs.npcOnHit.BaseBlink(character);
		}
	};
	
	// IMP_BLINK:
	// ********************************************************************************************
	this.npcOnHit.ImpBlink = function (character) {
		if (game.rnd.frac() < 0.50) {
			gs.npcOnHit.BaseBlink(character);
		}
	};
	
	// FIRE_BLINK:
	// ********************************************************************************************
	this.npcOnHit.FireBlink = function (character) {
		if (game.rnd.frac() < 0.75) {
			gs.npcOnHit.BaseBlink(character, function (char) {
				if (!gs.getCloud(char.tileIndex)) {
					gs.createCloud(char.tileIndex, 'FlamingCloud', gs.npcDamage(char.level, 'MLOW'), 10);
				}
			});
		}
	};
};

// CREATE_NPC_ABILITY_TYPES:
// Special functionality that NPCs call when they die.
// ********************************************************************************************
gs.createNPCOnDeathTypes = function () {
	
	// EXPLODE:
	// ****************************************************************************************
	this.abilityTypes.Explode = {};
	this.abilityTypes.Explode.attributes = {damage: {}};
	this.abilityTypes.Explode.use = function (actingChar) {
		var damage = actingChar.burstDamage || this.attributes.damage.value(actingChar);
		
		gs.createExplosion(actingChar.tileIndex, 1.5, damage, {killer: actingChar});
	};
	
	// BIG_EXPLODE:
	// ****************************************************************************************
	this.abilityTypes.BigExplode = {};
	this.abilityTypes.BigExplode.attributes = {damage: {}};
	this.abilityTypes.BigExplode.use = function (actingChar) {
		var damage = actingChar.burstDamage || this.attributes.damage.value(actingChar);
		
		gs.createExplosion(actingChar.tileIndex, 2, damage, {killer: actingChar});
	};
	
	// EXPLODE_CROSS:
	// ****************************************************************************************
	this.abilityTypes.FirePotExplode = {};
	this.abilityTypes.FirePotExplode.use = function (actingChar) {		
		gs.createExplosionCross(actingChar.tileIndex, 3, gs.getScaledTrapDamage(FIRE_POT_MIN_DAMAGE, FIRE_POT_MAX_DAMAGE), {killer: actingChar});
	};
	
	// BREAK_GAS_POT:
	// ****************************************************************************************
	this.abilityTypes.BreakGasPot = {};
	this.abilityTypes.BreakGasPot.use = function (actingChar) {
		gs.createCloud(actingChar.tileIndex, 'PoisonGas', gs.getScaledTrapDamage(GAS_POT_MIN_DAMAGE, GAS_POT_MAX_DAMAGE), 15);
	};
	
	// BLOAT:
	// ****************************************************************************************
	this.abilityTypes.Bloat = {};
	this.abilityTypes.Bloat.attributes = {damage: {}};
	this.abilityTypes.Bloat.use = function (actingChar) {
		var damage = actingChar.burstDamage || this.attributes.damage.value(actingChar);
		
		//gs.createExplosion(actingChar.tileIndex, 1, damage, {killer: actingChar});
		gs.createCloud(actingChar.tileIndex, 'PoisonGas', damage, 15);
	};
	
	// SKELETON_CORPSE:
	// ****************************************************************************************
	this.abilityTypes.SkeletonCorpse = {};
	this.abilityTypes.SkeletonCorpse.use = function (actingChar) {
		var obj;
		if (!gs.getObj(actingChar.tileIndex)) {
			obj = gs.createObject(actingChar.tileIndex, 'SkeletonCorpse');
			obj.npcTypeName = actingChar.type.name;
		}
	};
};/*global gs, game*/
/*global TILE_SIZE*/
/*global GREEN_TARGET_BOX_FRAME, PURPLE_SELECT_BOX_FRAME, RED_SELECT_BOX_FRAME*/
/*global GREEN_BOX_FRAME, PURPLE_BOX_FRAME, RED_BOX_FRAME*/
/*global FACTION*/
/*jshint laxbreak: true, esversion: 6*/
'use strict';

// CREATE_ABILITY_HELPERS:
// ************************************************************************************************
gs.createAbilityHelpers = function () {
	this.createAbilityRange();
	this.createAbilityShowTarget();
	this.createAbilityCanUse();
	this.createAbilityCanUseOn();
	this.createAbilityGetTarget();
};

// CREATE_ABILITY_RANGE:
// ************************************************************************************************
gs.createAbilityRange = function () {
	this.abilityRange = {};
	
	// WEAPON:
	// Use the range of the characters currently equipped weapon
	// ********************************************************************************************
	this.abilityRange.Weapon = function () {
		return gs.pc.weaponRange();
	};
};

// CREATE_ABILITY_SHOW_TARGET:
// ************************************************************************************************
gs.createAbilityShowTarget = function () {
	this.abilityShowTarget = {};
	
	// SELF_TARGET:
	// ********************************************************************************************
	gs.abilityShowTarget.SelfTarget = function (targetTileIndex) {
		gs.targetSprites[0].x = gs.pc.tileIndex.x * TILE_SIZE;
		gs.targetSprites[0].y = gs.pc.tileIndex.y * TILE_SIZE;
		gs.targetSprites[0].visible = true;
		gs.targetSprites[0].frame = GREEN_TARGET_BOX_FRAME;
	};

	// SINGLE_TARGET:
	// ********************************************************************************************
	gs.abilityShowTarget.SingleTarget = function (targetTileIndex) {
		// Valid Target:
		if (this.canUseOn(gs.pc, targetTileIndex)) {
			gs.targetSprites[0].x = targetTileIndex.x * TILE_SIZE;
			gs.targetSprites[0].y = targetTileIndex.y * TILE_SIZE;
			gs.targetSprites[0].visible = true;
			gs.targetSprites[0].frame = PURPLE_SELECT_BOX_FRAME;
		}
		// Invalid Target:
		else {
			gs.targetSprites[0].x = targetTileIndex.x * TILE_SIZE;
			gs.targetSprites[0].y = targetTileIndex.y * TILE_SIZE;
			gs.targetSprites[0].visible = true;
			gs.targetSprites[0].frame = RED_SELECT_BOX_FRAME;
			gs.showTargetLine(targetTileIndex);
		}
	};
	
	// PATH:
	// ********************************************************************************************
	gs.abilityShowTarget.Path = function (targetTileIndex) {
		var path;
		
		if (this.canUseOn(gs.pc, targetTileIndex)) {
			path = gs.pc.getPathTo(targetTileIndex, true);
		
			if (path && path.length > 0) {
				let i = 0;
				path.forEach(function (tileIndex) {
					gs.targetSprites[i].x = tileIndex.x * TILE_SIZE;
					gs.targetSprites[i].y = tileIndex.y * TILE_SIZE;
					gs.targetSprites[i].visible = true;
					gs.targetSprites[i].frame = PURPLE_BOX_FRAME;
					i += 1;
				}, this);
				
				gs.targetSprites[0].frame = PURPLE_SELECT_BOX_FRAME;
			}
		}
		else {
			gs.targetSprites[0].x = targetTileIndex.x * TILE_SIZE;
			gs.targetSprites[0].y = targetTileIndex.y * TILE_SIZE;
			gs.targetSprites[0].visible = true;
			gs.targetSprites[0].frame = RED_SELECT_BOX_FRAME;
		}
	};
	
	// TARGET_BASED_AOE:
	// ********************************************************************************************
	gs.abilityShowTarget.TBAoE = function (targetTileIndex) {
		var indexList, i = 0;
		
		// Valid Target:
		if (this.canUseOn(gs.pc, targetTileIndex)) {
			indexList = gs.getIndexInRadius(targetTileIndex, this.aoeRange(gs.pc));
			indexList = indexList.filter(index => gs.isStaticPassable(index));
			
			indexList.forEach(function (index) {
				gs.targetSprites[i].x = index.x * TILE_SIZE;
				gs.targetSprites[i].y = index.y * TILE_SIZE;
				gs.targetSprites[i].visible = true;
				if (gs.vectorEqual(targetTileIndex, index)) {
					gs.targetSprites[i].frame = PURPLE_SELECT_BOX_FRAME;
				}
				else {
					gs.targetSprites[i].frame = PURPLE_BOX_FRAME;
				}
				i += 1;
			}, this);
		}
		// Invalid Target:
		else {
			gs.targetSprites[0].x = targetTileIndex.x * TILE_SIZE;
			gs.targetSprites[0].y = targetTileIndex.y * TILE_SIZE;
			gs.targetSprites[0].visible = true;
			gs.targetSprites[0].frame = RED_SELECT_BOX_FRAME;
			gs.showTargetLine(targetTileIndex);
		}
	};
	
	// BOLT:
	// ********************************************************************************************
	gs.abilityShowTarget.Bolt = function (targetTileIndex) {
		var indexList, i = 0, frame, endFrame;
		
		// Valid Target:
		if (this.canUseOn(gs.pc, targetTileIndex)) {
			frame = PURPLE_BOX_FRAME;
			endFrame = PURPLE_SELECT_BOX_FRAME;
		}
		// Invalid Target:
		else {
			frame = RED_BOX_FRAME;
			endFrame = RED_SELECT_BOX_FRAME;
		}
			
		indexList = gs.getIndexInBRay(gs.pc.tileIndex, targetTileIndex);

		indexList.forEach(function (index) {
			gs.targetSprites[i].x = index.x * TILE_SIZE;
			gs.targetSprites[i].y = index.y * TILE_SIZE;
			gs.targetSprites[i].visible = true;
			gs.targetSprites[i].frame = gs.vectorEqual(targetTileIndex, index) ? endFrame : frame;
			i += 1;
		}, this);

	};

	// POINT_BLANK_AOE:
	// ********************************************************************************************
	gs.abilityShowTarget.PBAoE = function (targetTileIndex) {
		var indexList = gs.getIndexInRadius(gs.pc.tileIndex, this.aoeRange(gs.pc)),
			i = 0;
		
		indexList.forEach(function (index) {
			if (this.canUseOn(gs.pc, index)) {
				gs.targetSprites[i].x = index.x * TILE_SIZE;
				gs.targetSprites[i].y = index.y * TILE_SIZE;
				gs.targetSprites[i].visible = true;
				gs.targetSprites[i].frame = gs.getChar(index) ? PURPLE_SELECT_BOX_FRAME : PURPLE_BOX_FRAME;
				i += 1;
			}
		}, this);
	};
	
	// LINE_OF_SIGHT:
	// ********************************************************************************************
	gs.abilityShowTarget.LoS = function () {
		var i = 0;
		
		gs.characterList.forEach(function (character) {
			if (gs.getTile(character.tileIndex).visible && character.isAlive && character.faction === FACTION.HOSTILE) {
				gs.targetSprites[i].x = character.tileIndex.x * TILE_SIZE;
				gs.targetSprites[i].y = character.tileIndex.y * TILE_SIZE;
				gs.targetSprites[i].visible = true;
				gs.targetSprites[i].frame = PURPLE_SELECT_BOX_FRAME;
				i += 1;
			}	
		}, this);
	};

	// BOX:
	// ********************************************************************************************
	gs.abilityShowTarget.Box = function (targetTileIndex, width, height) {
		var indexList = gs.getIndexInBox(targetTileIndex.x, targetTileIndex.y, targetTileIndex.x + width, targetTileIndex.y + height),
			i = 0;

		indexList.forEach(function (index) {
			if (gs.isPassable(index) || gs.getChar(index)) {
				gs.targetSprites[i].x = index.x * TILE_SIZE;
				gs.targetSprites[i].y = index.y * TILE_SIZE;
				gs.targetSprites[i].visible = true;
				gs.targetSprites[i].frame = PURPLE_SELECT_BOX_FRAME;
				i += 1;
			}
		}, this);
	};
	

	
	// BURST_OF_FLAME:
	// ********************************************************************************************
	this.abilityShowTarget.BurstOfFlame = function (targetTileIndex) {
		var indexList;
		
		if (this.canUseOn(gs.pc, targetTileIndex)) {
			// Burst Target:
			if (gs.getObj(targetTileIndex, obj => obj.type.canBurstOfFlame)) {
				var i = 0;

				this.getIndexList(gs.pc, targetTileIndex).forEach(function (tileIndex) {
					gs.targetSprites[i].x = tileIndex.x * TILE_SIZE;
					gs.targetSprites[i].y = tileIndex.y * TILE_SIZE;
					gs.targetSprites[i].visible = true;
					gs.targetSprites[i].frame = PURPLE_BOX_FRAME;
					i += 1;
				}, this);

				gs.targetSprites[i].x = targetTileIndex.x * TILE_SIZE;
				gs.targetSprites[i].y = targetTileIndex.y * TILE_SIZE;
				gs.targetSprites[i].visible = true;
				gs.targetSprites[i].frame = PURPLE_SELECT_BOX_FRAME;
			}
			// Single target:
			else {
				gs.abilityShowTarget.SingleTarget.call(this, targetTileIndex);
			}
		}
		else {
			gs.targetSprites[0].x = targetTileIndex.x * TILE_SIZE;
			gs.targetSprites[0].y = targetTileIndex.y * TILE_SIZE;
			gs.targetSprites[0].visible = true;
			gs.targetSprites[0].frame = RED_SELECT_BOX_FRAME;
			gs.showTargetLine(targetTileIndex);
		}
	};
	
	// FAN:
	// ********************************************************************************************
	this.abilityShowTarget.Fan = function (targetTileIndex) {
		var delta,
			indexList,
			i = 0;
		
		delta = gs.get8WayVector(gs.pc.tileIndex, targetTileIndex);
		indexList = gs.getIndexInFan(gs.pc.tileIndex, this.aoeRange(gs.pc), delta);
		
		indexList.forEach(function (index) {
			if (!gs.isRayClear(gs.pc.tileIndex, index) || !gs.isStaticPassable(index)) {
				return;
			}
			
			gs.targetSprites[i].x = index.x * TILE_SIZE;
			gs.targetSprites[i].y = index.y * TILE_SIZE;
			gs.targetSprites[i].visible = true;
			gs.targetSprites[i].frame = PURPLE_BOX_FRAME;
			
			if (gs.distance(index, gs.pc.tileIndex) < 1.5) {
				gs.targetSprites[i].frame = PURPLE_SELECT_BOX_FRAME;
			}
			i += 1;
		}, this);
	};
};

// CREATE_ABILITY_CAN_USE:
// ************************************************************************************************
gs.createAbilityCanUse = function () {
	this.abilityCanUse = {};
	
	// SHIELD:
	// ********************************************************************************************
	this.abilityCanUse.Shield = function (actingCharacter) {
		return actingCharacter.inventory.hasShieldEquipped();
	};
	
	// MELEE_WEAPON:
	// ********************************************************************************************
	this.abilityCanUse.MeleeWeapon = function (actingCharacter) {
		return actingCharacter.inventory.getWeapon().type.effect.skill === 'Melee';
	};
	
	// RANGE_WEAPON:
	// ********************************************************************************************
	this.abilityCanUse.RangeWeapon = function (actingCharacter) {
		return actingCharacter.inventory.getWeapon().type.effect.skill === 'Range'
			&& actingCharacter.inventory.getWeapon().type.effect === gs.weaponEffects.SingleProjectile;
	};
};

// CREATE_ABILITY_CAN_USE_ON:
// ************************************************************************************************
gs.createAbilityCanUseOn = function () {
	this.abilityCanUseOn = {};
	// SINGLE_CHARACTER_STRAIGHT_RAY:
	// ********************************************************************************************
	this.abilityCanUseOn.SingleCharacterStraightRay = function (actingChar, targetTileIndex) {		
		return gs.getChar(targetTileIndex)
			&& gs.isInBounds(targetTileIndex)
			&& gs.distance(actingChar.tileIndex, targetTileIndex) <= this.range(actingChar)
			&& gs.isRayPassable(actingChar.tileIndex, targetTileIndex)
			&& gs.isStraight(actingChar.tileIndex, targetTileIndex)
			&& actingChar.isHostileToMe(gs.getChar(targetTileIndex));
			
	};
	
	// NPC_PROJECTILE_ATTACK:
	// Used by NPC projectile attacks to give them a chance of shooting their friends
	// ********************************************************************************************
	this.abilityCanUseOn.NPCProjectileAttack = function (actingChar, targetTileIndex) {
		var lineClear = true, normal;
		
		// If the ray is not passable (character or level):
		if (!gs.isRayPassable(actingChar.tileIndex, targetTileIndex)) {
			lineClear = false;
			
			// 25% chance to shoot through a friendly as long as not adjacent
			normal = gs.get8WayVector(actingChar.tileIndex, targetTileIndex);
			if (!gs.getChar(actingChar.tileIndex.x + normal.x, actingChar.tileIndex.y) && gs.isRayShootable(actingChar.tileIndex, targetTileIndex) && game.rnd.frac() < 0.25) {
				lineClear = true;
			}
		}
		
		return lineClear
			&& gs.isRayClear(actingChar.tileIndex, targetTileIndex)
			&& gs.distance(actingChar.tileIndex, targetTileIndex) <= this.range(actingChar);
	};
	
	// SINGLE_CHARACTER_RAY:
	// Must have a clear (passable) ray to the targetTileIndex
	// targetTileIndex must contain a hostile character
	// ********************************************************************************************
	this.abilityCanUseOn.SingleCharacterRay = function (actingChar, targetTileIndex) {
		return gs.isInBounds(targetTileIndex)
			&& gs.getChar(targetTileIndex)
			&& gs.distance(actingChar.tileIndex, targetTileIndex) <= this.range(actingChar)
			&& gs.isRayPassable(actingChar.tileIndex, targetTileIndex)
			&& gs.getChar(targetTileIndex) !== actingChar;
	};
	
	// SINGLE_CHARACTER_SMITE:
	// Must have clear (visible) ray to the targetTileIndex
	// targetTileIndex must contain a hostile character
	// ********************************************************************************************
	this.abilityCanUseOn.SingleCharacterSmite = function (actingChar, targetTileIndex) {		
		return gs.isInBounds(targetTileIndex)
			&& gs.getChar(targetTileIndex)
			&& gs.distance(actingChar.tileIndex, targetTileIndex) <= this.range(actingChar)
			&& gs.isRayClear(actingChar.tileIndex, targetTileIndex)
			&& gs.getChar(targetTileIndex) !== actingChar;
	};
	
	// SINGLE_TILE_RAY:
	// Must have a clear (passable) ray to the targetTileIndex
	// targetTileIndex can contain a hostile character or it can be passable (staticPassable)
	// ********************************************************************************************
	this.abilityCanUseOn.SingleTileRay = function (actingChar, targetTileIndex) {		
		return gs.isInBounds(targetTileIndex)
			&& gs.distance(actingChar.tileIndex, targetTileIndex) <= this.range(actingChar)
			&& gs.isRayPassable(actingChar.tileIndex, targetTileIndex)
			&& gs.isStaticPassable(targetTileIndex)
			&& gs.getChar(targetTileIndex) !== actingChar;
	};
	
	// SINGLE_TILE_SMITE:
	// Must have a clear (visible) ray to the targetTileIndex
	// targetTileIndex can contain a hostile character or it can be passable (staticPassable)
	// ********************************************************************************************
	this.abilityCanUseOn.SingleTileSmite = function (actingChar, targetTileIndex) {		
		return gs.isInBounds(targetTileIndex)
			&& gs.distance(actingChar.tileIndex, targetTileIndex) <= this.range(actingChar)
			&& gs.isRayClear(actingChar.tileIndex, targetTileIndex)
			&& gs.isStaticPassable(targetTileIndex)
			&& gs.getChar(targetTileIndex) !== actingChar;
	};
	
	// BOLT:
	// Must have a static passable BRay to the targetTileIndex
	// ********************************************************************************************
	this.abilityCanUseOn.Bolt = function (actingChar, targetTileIndex) {
		return gs.isInBounds(targetTileIndex)
			&& !gs.vectorEqual(actingChar.tileIndex, targetTileIndex)
			&& gs.distance(actingChar.tileIndex, targetTileIndex) <= this.range(actingChar)
			&& gs.isBRay(actingChar.tileIndex, targetTileIndex, gs.isStaticPassable);
	};

};

// CREATE_ABILITY_GET_TARGET:
// ************************************************************************************************
gs.createAbilityGetTarget = function () {
	this.abilityGetTarget = {};
	
	// SELF:
	// ********************************************************************************************
	this.abilityGetTarget.Self = function (actingChar) {
		return actingChar;
	};
	
	// SINGLE_TARGET:
	// ********************************************************************************************
	this.abilityGetTarget.SingleTarget = function (actingChar) {
		var indexList;
		
		// All targetable indices:
		indexList = gs.getIndexInRadius(actingChar.tileIndex, this.range(actingChar));
		
		// Only valid indices:
		indexList = indexList.filter(index => gs.getChar(index) && actingChar.isHostileToMe(gs.getChar(index)));
		indexList = indexList.filter(index => this.canUseOn(actingChar, index));
		
		// Sort by distance:
		indexList.sort((a, b) => gs.distance(actingChar.tileIndex, a) - gs.distance(actingChar.tileIndex, b));
		
		return indexList.length > 0 ? indexList[0] : null;
	};
	
	// SINGLE_ALLY:
	// ********************************************************************************************
	this.abilityGetTarget.SingleAlly = function (actingChar) {
		var indexList;
		
		// All targetable indices:
		indexList = gs.getIndexInRadius(actingChar.tileIndex, this.range(actingChar));
		
		// Only valid indices:
		indexList = indexList.filter(index => gs.getChar(index) && !actingChar.isHostileToMe(gs.getChar(index)));
		indexList = indexList.filter(index => this.canUseOn(actingChar, index));
		
		// Sort by distance:
		indexList.sort((a, b) => gs.distance(actingChar.tileIndex, a) - gs.distance(actingChar.tileIndex, b));
		
		return indexList.length > 0 ? indexList[0] : null;
	};
	
	// BOLT:
	// ********************************************************************************************
	this.abilityGetTarget.Bolt = function (actingChar) {
		var indexList,
			potentialTargetList = [];
		
		// All targetable indices:
		indexList = gs.getIndexInRadius(actingChar.tileIndex, this.range(actingChar));
		
		// Only valid indices:
		indexList = indexList.filter(index => this.canUseOn(actingChar, index));
		
		// Count number of hostile and friendly characters in each ray:
		indexList.forEach(function (index) {
			var list;
			
			list = gs.getIndexInBRay(actingChar.tileIndex, index);
			list = list.filter(index => gs.getChar(index) && actingChar.canSeeCharacter(gs.getChar(index)));
			
			potentialTargetList.push({
				tileIndex: index, 
				hostileCount: list.reduce((sum, idx) => sum + (actingChar.isHostileToMe(gs.getChar(idx)) ? 1 : 0), 0),
				allyCount: list.reduce((sum, idx) => sum + (actingChar.faction === gs.getChar(idx).faction ? 1 : 0), 0)
			});
		}, this);
		
		
		// Only consider targets with more hostiles than allies:
		potentialTargetList = potentialTargetList.filter(target => target.hostileCount > target.allyCount);
		
		// Sort by hostile count:
		potentialTargetList.sort((a, b) => b.hostileCount - a.hostileCount);
		
		return potentialTargetList.length > 0 ? potentialTargetList[0].tileIndex : null;
	};
	
	// TARGET_BASED_AOE:
	// More hostiles than allies in AoE
	// ********************************************************************************************
	this.abilityGetTarget.TBAoE = function (actingChar) {
		var indexList, potentialTargetList = [];
		
		// All targetable indices:
		indexList = gs.getIndexInRadius(actingChar.tileIndex, this.range(actingChar));
		indexList = indexList.filter(index => this.canUseOn(actingChar, index));
		
		// Count number of hostile and friendly characters in AoE
		indexList.forEach(function (index) {
			var list;
			
			list = gs.getIndexInRadius(index, this.aoeRange(actingChar));
			list = list.filter(index => gs.getChar(index) && actingChar.canSeeCharacter(gs.getChar(index)));
			
			potentialTargetList.push({
				tileIndex: index, 
				hostileCount: list.reduce((sum, idx) => sum + (actingChar.isHostileToMe(gs.getChar(idx)) ? 1 : 0), 0),
				allyCount: list.reduce((sum, idx) => sum + (actingChar.faction === gs.getChar(idx).faction ? 1 : 0), 0)
			});
		}, this);
		
		// Only consider targets with more hostiles than allies:
		potentialTargetList = potentialTargetList.filter(target => target.hostileCount > target.allyCount);
		
		// Sort by distance:
		potentialTargetList.sort((a, b) => gs.distance(actingChar.tileIndex, a.tileIndex) - gs.distance(actingChar.tileIndex, b.tileIndex));
		
		return potentialTargetList.length > 0 ? potentialTargetList[0].tileIndex : null;
	};
	
	// POINT_BLANK_AOE:
	// Returns actingChar.tileIndex if more hostiles than allies in AoE
	// Otherwise returns null.
	// In this way NPCs know if its a good idea to use the ability i.e. they won't use it if it returns null
	// ********************************************************************************************
	this.abilityGetTarget.PBAoE = function (actingChar) {
		var indexList, hostileCount, allyCount;
		
		// Get all index around actingChar:
		indexList = gs.getIndexInRadius(actingChar.tileIndex, this.aoeRange(actingChar));
		
		// Make sure its visible:
		indexList = indexList.filter(index => this.canUseOn(actingChar, index));
		
		// Count the effected hostiles and allies:
		hostileCount = indexList.reduce((sum, idx) => sum + (actingChar.isHostileToMe(gs.getChar(idx)) ? 1 : 0), 0);
		allyCount = indexList.reduce((sum, idx) => sum + (actingChar.faction === gs.getChar(idx).faction ? 1 : 0), 0);
			
		return hostileCount > allyCount ? actingChar.tileIndex : null;
	};
	
	// FLOOD:
	// More hostiles than allies in flood.
	// ********************************************************************************************
	this.abilityGetTarget.Flood = function (actingChar) {
		var indexList, potentialTargetList = [], pred;
			
		pred = function (tileIndex) {
			return gs.isStaticPassable(tileIndex) && !gs.getCloud(tileIndex);
		};
		
		// All targetable indices:
		indexList = gs.getIndexInRadius(actingChar.tileIndex, this.range(actingChar));
		
		// Only valid indices:
		indexList = indexList.filter(index => this.canUseOn(actingChar, index));
		
		// Count number of hostile and friendly characters in AoE
		indexList.forEach(function (index) {
			var list;
			
			list = gs.getIndexInFlood(index, pred, this.floodDepth);
			list = list.filter(index => gs.getChar(index));
			
			potentialTargetList.push({
				tileIndex: index, 
				hostileCount: list.reduce((sum, idx) => sum + (actingChar.isHostileToMe(gs.getChar(idx)) ? 1 : 0), 0),
				allyCount: list.reduce((sum, idx) => sum + (actingChar.faction === gs.getChar(idx).faction ? 1 : 0), 0)
			});
		}, this);
		
		// Only consider targets with more hostiles than allies:
		potentialTargetList = potentialTargetList.filter(target => target.hostileCount > target.allyCount);
		
		// Sort by distance:
		potentialTargetList.sort((a, b) => gs.distance(actingChar.tileIndex, a.tileIndex) - gs.distance(actingChar.tileIndex, b.tileIndex));
		
		return potentialTargetList.length > 0 ? potentialTargetList[0].tileIndex : null;
	};
	
};

/*
	// FAN:
	// ********************************************************************************************
	gs.abilityShowTarget.Fan.getIndexList = function (actingCharacter, targetTileIndex) {
		var direction, indexList = [], func, haltCondition;
		
		haltCondition = function (index) {
			return !gs.isPassable(index) && !gs.getChar(index);
		};
		
		func = function (dir, fanRange) {
			gs.getIndexInRay(actingCharacter.tileIndex,
							 {x: actingCharacter.tileIndex.x + dir.x * fanRange, y: actingCharacter.tileIndex.y + dir.y * fanRange},
							 haltCondition).forEach(function (index) {
				if (!indexList.find(i => gs.vectorEqual(i, index))) {
					indexList.push(index);
				}
			});
		};
		
		// Decide which of the 4 cardinal directions the ability will be used
		direction = gs.getCardinalVector(actingCharacter.tileIndex, targetTileIndex);
		
		// Cast 3 rays and collect the tiles that are acceptable
		if (direction) {
			func(direction, 3);
			func({x: direction.x + gs.getOrthoVector(direction).x, y: direction.y + gs.getOrthoVector(direction).y}, 2);
			func({x: direction.x - gs.getOrthoVector(direction).x, y: direction.y - gs.getOrthoVector(direction).y}, 2);
			
			
			return indexList;
		}
		else {
			return null;
		}
	};
	
	gs.abilityShowTarget.Fan = function (targetTileIndex) {
		var indexList = gs.abilityShowTarget.Fan.getIndexList(gs.pc, targetTileIndex),
			i = 0;
		
		gs.targetSprites.forEach(function (targetSprite) {
			targetSprite.visible = false;
		});
		
		indexList.forEach(function (index) {
			gs.targetSprites[i].x = index.x * TILE_SIZE;
			gs.targetSprites[i].y = index.y * TILE_SIZE;
			gs.targetSprites[i].visible = true;
			gs.targetSprites[i].frame = PURPLE_SELECT_BOX_FRAME;
			i += 1;
		}, this);
	};
	*/
/*global game, gs*/
/*global TALENTS_PER_BOOK, MAX_RAGE, RAGE_DECREASE_TURNS*/
/*jshint esversion: 6*/
'use strict';


// CREATE_TALENTS:
// ************************************************************************************************
gs.createTalents = function () {
	this.talents = {};
	
	this.createTalentEffects();

	// NECROMANCY:
	// ********************************************************************************************
	// Active:
	this.talents.LifeSpike = 			{skillName: 'Necromancy', 	level: [1, 5, 9]};
	this.talents.ToxicAttunement = 		{skillName: 'Necromancy',	level: [1, 5, 9]};
	this.talents.SummonSkeleton =		{skillName: 'Necromancy',	level: [4, 8, 12]};
	this.talents.InfectiousDisease =	{skillName: 'Necromancy',	level: [4, 8, 12]};
	this.talents.Cannibalise = 			{skillName: 'Necromancy',	level: [8]};
	this.talents.PoisonCloud = 			{skillName: 'Necromancy',	level: [8, 12, 16]};
	
	// Passive:
	this.talents.ToxicMastery =			{skillName: 'Necromancy',	level: [1, 5, 9], bonus: [4, 3, 2]};
	
	// FIRE_MAGIC:
	// ********************************************************************************************
	// Active:
	this.talents.FireBall = 			{skillName: 'FireMagic',	level: [1, 5, 9]};
	this.talents.FireAttunement = 		{skillName: 'FireMagic',	level: [1, 5, 9]};
	this.talents.FlamingHands =			{skillName: 'FireMagic',	level: [4, 8, 12]};
	this.talents.BurstOfFlame = 		{skillName: 'FireMagic',	level: [4, 8, 12]};
	this.talents.FireBolt =				{skillName: 'FireMagic',	level: [4, 8, 12]};
	this.talents.InfernoOrb = 			{skillName: 'FireMagic',	level: [8, 12, 16]};
	
	// Passive:
	this.talents.FireMastery =			{skillName: 'FireMagic',	level: [1, 5, 9], bonus: [4, 3, 2]};
	
	
	// STORM_MAGIC:
	// ********************************************************************************************
	// TIER_I
	this.talents.LightningBolt = 		{skillName: 'StormMagic',	level: [1, 5, 9]};
	this.talents.StormAttunement = 		{skillName: 'StormMagic',	level: [1, 5, 9]};
	this.talents.StormMastery =			{skillName: 'StormMagic',	level: [1, 5, 9], bonus: [4, 3, 2]};
	
	// TIER_II:
	this.talents.Shock =				{skillName: 'StormMagic',	level: [4, 8, 12]};
	this.talents.ThunderClap = 			{skillName: 'StormMagic',	level: [4, 8, 12]};
	this.talents.Levitation =			{skillName: 'StormMagic',	level: [8]};
	
	// TIER_III:
	this.talents.StaticDischarge = 		{skillName: 'StormMagic',	level: [8, 12, 16]};
	
	// COLD_MAGIC:
	// ********************************************************************************************
	// TIER_I:
	this.talents.ConeOfCold =			{skillName: 'ColdMagic',	level: [1, 5, 9]};
	this.talents.ColdAttunement = 		{skillName: 'ColdMagic',	level: [1, 5, 9]};
	this.talents.ColdMastery =			{skillName: 'ColdMagic',	level: [1, 5, 9], bonus: [4, 3, 2]};
	
	// TIER_II:
	this.talents.FreezingCloud =		{skillName: 'ColdMagic',	level: [4, 8, 12]};
	this.talents.Freeze =				{skillName: 'ColdMagic',	level: [4, 8, 12]};
	this.talents.IceArmor =				{skillName: 'ColdMagic',	level: [8]};
	
	// TIER_III:
	this.talents.FlashFreeze =			{skillName: 'ColdMagic',	level: [8, 12, 16]};
	

	
	
	// ENCHANTMENT_MAGIC:
	// ********************************************************************************************
	// TIER_I:
	this.talents.Confusion =			{skillName: 'Enchantment',	level: [1, 5, 9]};
	this.talents.Fear =					{skillName: 'Enchantment',	level: [1, 5, 9]};
	
	// TIER_II:
	this.talents.Charm =				{skillName: 'Enchantment',	level: [4, 8, 12]};
	this.talents.Mesmerize =			{skillName: 'Enchantment',	level: [4, 8, 12]};
	this.talents.Swiftness =			{skillName: 'Enchantment',	level: [8]};
	
	// FOCUS:
	// ********************************************************************************************
	// Passive:
	this.talents.MagicMastery =			{skillName: 'Focus', 		level: [1, 5, 9], bonus: [4, 3, 2]};
	this.talents.Focus = 				{skillName: 'Focus', 		level: [1, 5, 9], bonusMp: [3, 2, 2]};
	this.talents.Tranquility =			{skillName: 'Focus', 		level: [4, 8, 12]};
	
	// DEFENSE:
	// ********************************************************************************************
	// Active:
	this.talents.ShieldsUp =			{skillName: 'Defense',		level: [1]};
	this.talents.Deflect =				{skillName: 'Defense',		level: [4, 8, 12]};
	// Defensive: like an extended shields up + deflect until you attack
	
	// Passive:
	this.talents.Fortitude = 				{skillName: 'Defense',		level: [1, 5, 9], bonusHp: [8, 6, 6]};
	this.talents.Regeneration =				{skillName: 'Defense',		level: [4, 8, 12]};
	this.talents.ShieldWall =				{skillName: 'Defense',		level: [4]};
	this.talents.FireResistance =			{skillName: 'Defense',		level: [4, 8, 12], resistance: [1, 2, 3]};
	this.talents.ColdResistance =			{skillName: 'Defense',		level: [4, 8, 12], resistance: [1, 2, 3]};
	this.talents.ShockResistance =			{skillName: 'Defense',		level: [4, 8, 12], resistance: [1, 2, 3]};
	this.talents.ToxicResistance =			{skillName: 'Defense',		level: [4, 8, 12], resistance: [1, 2, 3]};
	
	// MELEE:
	// ********************************************************************************************
	// Active:
	this.talents.PowerStrike = 			{skillName: 'Melee',		level: [1, 5, 9]};
	this.talents.Charge = 				{skillName: 'Melee',		level: [4, 8, 12]};
	this.talents.Berserk = 				{skillName: 'Melee',		level: [8, 12, 16]};
	this.talents.BloodLust =			{skillName: 'Melee',		level: [1, 5, 9], neverDrop: true};
	
	// Passive:
	this.talents.WeaponMastery =		{skillName: 'Melee',		level: [1, 5, 9], bonus: [4, 3, 2]};

	// RANGE:
	// ********************************************************************************************
	// Active:
	this.talents.PowerShot = 			{skillName: 'Range',		level: [1, 5, 9]};
	this.talents.TunnelShot = 			{skillName: 'Range',		level: [4, 8, 12]};
	this.talents.DeadEye = 				{skillName: 'Range',		level: [8, 12, 16]};
	
	// Passive:
	this.talents.RangeMastery =			{skillName: 'Range',		level: [1, 5, 9], bonus: [4, 3, 2]};
	this.talents.PerfectAim =			{skillName: 'Range',		level: [4]};
	
	
	// STEALTH:
	// ********************************************************************************************
	// Active:
	this.talents.SleepingDart = 		{skillName: 'Stealth',		level: [1, 5, 9]};
	this.talents.SmokeBomb =			{skillName: 'Stealth',		level: [4, 8, 12]};
	this.talents.NimbleFingers =		{skillName: 'Stealth',		level: [4, 8, 12]};
	this.talents.Evade = 				{skillName: 'Stealth',		level: [8]};
	
	// Passive:
	this.talents.StealthMastery =		{skillName: 'Stealth',		level: [1, 5, 9], bonus: [4, 3, 2]};
	this.talents.DungeonSense = 		{skillName: 'Stealth',		level: [4]};
	this.talents.KeenHearing = 			{skillName: 'Stealth',		level: [4, 8, 12], range: [10, 15, 20]};	
	
	// ATHLETICS:
	// ********************************************************************************************
	// Active:
	this.talents.StrafeAttack =			{skillName: 'Athletics',	level: [4]};
	this.talents.Sprint =				{skillName: 'Athletics',	level: [1, 5, 9]};
	
	// Passive:
	this.talents.Evasive =				{skillName: 'Athletics',	level: [1, 5, 9], bonus: [4, 3, 2]};
	
	
	//this.talents.Adrenaline = 		{level: [6, 8, 10, 12, 14]};
	//this.talents.ManaConservation = 	{level: [12, 14, 16, 18, 20]};
	//this.talents.WeaponShield = 		{level: [12, 14, 16, 18, 20], skillName: 'Melee'};
	//this.talents.Rage = 				{level: [1, 3, 5, 7, 9], skillName: 'Melee'};	
	
	//
	//this.talents.Sneak = 				{level: [6, 8, 10, 12, 14]};
	//this.talents.StrongArm = 			{level: [12, 14, 16, 18, 20], skillName: 'Range'};
	//this.talents.AmmoConservation = 	{level: [1, 4, 8, 12, 16], skillName: 'Range'};
	
	// Set Default Properties:
	this.talentList = [];
	this.nameTypes(this.talents);
	this.forEachType(this.talents, function (talent) {
		// Setting abilities:
		if (this.abilityTypes[talent.name]) {
			talent.ability = this.abilityTypes[talent.name];
		}
		
		// Setting effects:
		if (this.talentEffects[talent.name]) {
			talent.effect = this.talentEffects[talent.name];
		}
		
		// Setting onLearn:
		if (this.talentOnLearn[talent.name]) {
			talent.onLearn = this.talentOnLearn[talent.name];
		}
		
		this.talentList.push(talent);
	}, this);
	
	this.createTalentDesc();
};

// CREATE_TALENT_DESC:
// ************************************************************************************************
gs.createTalentDesc = function () {
	// NECROMANCY:
	this.talents.ToxicMastery.desc = function (talentLevel) {
		if (talentLevel <= this.level.length) {
			return '+' + this.bonus[talentLevel - 1] + ' toxic magic power.';
		}
		else {
			return '';
		}
	};	
	this.talents.LifeSpike.desc = 			'Drains the life of the target over time, healing the caster. Can be stacked multiple times.';
	this.talents.ToxicAttunement.desc = 	'Increases your toxic magic power and reduces toxic magic mana cost by 1MP for the duration of the effect.';
	this.talents.Cannibalise.desc = 		'Sacrifices 8 hit points to regain 6 points of mana.';
	this.talents.PoisonCloud.desc = 		'Summons a cloud of poison gas.';
	this.talents.SummonSkeleton.desc =		'Summons one or more skeletal minion to fight for you.';
	this.talents.InfectiousDisease.desc = 	'Infects a single target with a disease which will spread to nearby characters.';
	
	// FIRE_MAGIC:
	this.talents.FireMastery.desc = function (talentLevel) {
		if (talentLevel <= this.level.length) {
			return '+' + this.bonus[talentLevel - 1] + ' fire magic power.';
		}
		else {
			return '';
		}
	};	
	this.talents.FireBall.desc = 			'Shoots a ball of fire which explodes, damaging monsters and setting fire to flammable objects.';
	this.talents.FireAttunement.desc = 		'Increases your fire magic power and reduces fire magic mana cost by 1MP for the duration of the effect.';
	this.talents.BurstOfFlame.desc = 		'Creates a burst of flame on a single tile. Will create a large burst if used on a torch or other flaming object.';
	this.talents.InfernoOrb.desc = 			'Summons a slow moving fire ball which bursts upon impact in a powerful explosion.';
	this.talents.FlamingHands.desc =		'You will throw flaming projectiles with every attack for the duration of the effect.';
	this.talents.FireBolt.desc = 			'Sends forth a bolt of fire, hitting multiple monsters in a straight line.';
	
	// STORM_MAGIC:
	this.talents.StormMastery.desc = function (talentLevel) {
		if (talentLevel <= this.level.length) {
			return '+' + this.bonus[talentLevel - 1] + ' storm magic power.';
		}
		else {
			return '';
		}
	};	
	this.talents.LightningBolt.desc = 		'Sends forth a bolt of lightning, hitting multiple monsters in a straight line.';
	this.talents.StormAttunement.desc = 	'Increases your storm magic power and reduces storm magic mana cost by 1MP for the duration of the effect.';
	this.talents.Shock.desc =				'Shocks your target and spreads to all adjacent characters.';
	this.talents.ThunderClap.desc = 		'Creates a massive boom of thunder stunning all enemies for the duration of the effect.';
	this.talents.StaticDischarge.desc = 	'Lets loose a powerful burst of electricity damaging all nearby monsters.';
	
	// ICE_MAGIC:
	this.talents.ColdMastery.desc = function (talentLevel) {
		if (talentLevel <= this.level.length) {
			return '+' + this.bonus[talentLevel - 1] + ' ice magic power.';
		}
		else {
			return '';
		}
	};	
	this.talents.ColdAttunement.desc = 		'Increases your cold magic power and reduces cold magic mana cost by 1MP for the duration of the effect.';
	this.talents.ConeOfCold.desc =			'Blasts a group of enemies with freezing cold, damaging, slowing and knocking them back.';
	this.talents.FreezingCloud.desc =		'Summons a cloud of freezing vapours that will damage characters standing within it.';
	this.talents.Freeze.desc =				'Freezes a character in a block of ice, rendering them unable to act for the duration of the effect.';
	this.talents.IceArmor.desc =			'Grants +5 protection while maintaining the effect.';
	this.talents.FlashFreeze.desc =			'Freezes every character in your line of sight in a block of ice, rendering them unable to act.';
	
	// ENCHANTMENT_MAGIC:
	this.talents.Confusion.desc =			'Confuses one or more creatures causing them to attack their nearest target.';
	this.talents.Fear.desc =				'Causes all enemies in a radius around you to run away in fear.';
	this.talents.Charm.desc =				'Charms a single creature, turning it temporarily to your side.';
	this.talents.Mesmerize.desc =			'Puts a group of enemies into a deep sleep.';
	this.talents.Swiftness.desc =			'Allows you to move at double speed while maintaining this effect.';
	
	// MELEE:
	this.talents.WeaponMastery.desc = function (talentLevel) {
		if (talentLevel <= this.level.length) {
			return '+' + this.bonus[talentLevel - 1] + ' melee weapon power.';
		}
		else {
			return '';
		}
	};	
	this.talents.PowerStrike.desc = 		'Delivers a powerful strike with your weapon dealing increased damage and knockback.';
	this.talents.Charge.desc = 				'Allows you to sprint towards an enemy and attack in a single turn.';
	this.talents.Berserk.desc = 			'You will deal critical hits with every melee attack for the duration of the effect.';
	//this.talents.Rage.desc = 				'Your rage bar will fill with every kill, improving your melee damage. Your rage bar decreases over time.';
	//this.talents.WeaponShield.desc = 		"Gives a 10% chance to reflect projectiles when wielding a melee weapon.";
	this.talents.BloodLust.desc = 			'+1 max rage.';
	
	// RANGE:
	this.talents.RangeMastery.desc = function (talentLevel) {
		if (talentLevel <= this.level.length) {
			return '+' + this.bonus[talentLevel - 1] + ' range weapon power.';
		}
		else {
			return '';
		}
	};	
	this.talents.PowerShot.desc = 			'Delivers a powerful shot with your ranged weapon dealing increased damage and knockback.';
	this.talents.TunnelShot.desc = 			'Allows you to throw a projectile clear through a number of monsters, dealing increased damage.';
	this.talents.DeadEye.desc = 			'When activated, you will deal critical hits with every ranged attack for the duration of the effect.';
	this.talents.PerfectAim.desc =			'Allows you to shoot at your desired target through other enemies.';
	//this.talents.StrongArm.desc = 			'+1 range and +10% damage, with thrown weapons.';
	//this.talents.AmmoConservation.desc = 	'+10% chance to save ammo per talent level.';
	
	
	// DEFENSE:
	this.talents.ShieldsUp.desc =		'You will block and counterattack against every enemy that strikes you in the next turn';
	this.talents.ShieldWall.desc =		'Increases protection for every adjacent wall';
	this.talents.Deflect.desc =			'+10 reflection for the duration of the effect.';
	this.talents.Fortitude.desc = 		function (talentLevel) {
		if (talentLevel <= this.level.length) {
			return 'Increases your max hit points by ' + this.bonusHp[talentLevel - 1] + '.';
		}
		else {
			return '';
		}
	};	
	this.talents.Regeneration.desc =	'+1 HP regeneration.';
	this.talents.FireResistance.desc = function (talentLevel) {
		if (talentLevel <= this.level.length) {
			return '+1 Fire Resistance.';
		}
		else {
			return '';
		}
	};	
	this.talents.ColdResistance.desc = function (talentLevel) {
		if (talentLevel <= this.level.length) {
			return '+1 Cold Resistance.';
		}
		else {
			return '';
		}
	};	
	this.talents.ShockResistance.desc = function (talentLevel) {
		if (talentLevel <= this.level.length) {
			return '+1 Shock Resistance.';
		}
		else {
			return '';
		}
	};	
	this.talents.ToxicResistance.desc = function (talentLevel) {
		if (talentLevel <= this.level.length) {
			return '+1 Toxic Resistance.';
		}
		else {
			return '';
		}
	};	
	
	
	// FOCUS:
	this.talents.MagicMastery.desc = function (talentLevel) {
		if (talentLevel <= this.level.length) {
			return '+' + this.bonus[talentLevel - 1] + ' magic power.';
		}
		else {
			return '';
		}
	};	
	this.talents.Focus.desc = function (talentLevel) {
		if (talentLevel <= this.level.length) {
			return 'Increases your max mana points by ' + this.bonusMp[talentLevel - 1] + '.';
		}
		else {
			return '';
		}
	};	
	this.talents.Tranquility.desc =		'+1 MP regeneration.';
	//this.talents.Adrenaline.desc = 			'50% chance to save mana when less then 1/3 HP.';
	//this.talents.ManaConservation.desc = 	'There is a 20% chance when using an ability that mana will not be consumed.';


	// STEALTH:
	this.talents.StealthMastery.desc = function (talentLevel) {
		if (talentLevel <= this.level.length) {
			return '+' + this.bonus[talentLevel - 1] + ' stealth.';
		}
		else {
			return '';
		}
	};	
	this.talents.SleepingDart.desc = 	"Puts an enemy into a deep sleep.";
	this.talents.SmokeBomb.desc =		"Creates a cloud of opaque smoke, blocking line of sight.";
	this.talents.DungeonSense.desc = 	'Reveals the location of all treasure and stairs on your mini-map.';
	this.talents.NimbleFingers.desc =	'Allows you to pick up and place traps.';
	this.talents.Evade.desc = 			'When activated, all monsters will immediately forget about you.';
	this.talents.KeenHearing.desc = function (talentLevel) {
		if (talentLevel <= this.level.length) {
			return 'Allows you to detect nearby monsters on your mini-map up to a range of  ' + this.range[talentLevel - 1] + ' tiles.';
		}
		else {
			return '';
		}
	};	
	
	//this.talents.SneakAttack.desc = 	'Allows you to sneak attack unaware enemies. Additional talent levels will raise sneak attack damage by 20%';
	//this.talents.Sneak.desc = 			'When activated, your stealth skill will be greatly increased';
	//this.talents.KeenHearing.desc = 	'You gain the permanent ability to detect nearby monsters on your mini-map.';
				
	// ATHLETICS:
	this.talents.Evasive.desc = function (talentLevel) {
		if (talentLevel <= this.level.length) {
			return '+' + this.bonus[talentLevel - 1] + ' evasion.';
		}
		else {
			return '';
		}
	};	
	this.talents.StrafeAttack.desc =	'You will automatically attack the nearest enemy when moving towards or strafing.';
	this.talents.Sprint.desc = 			'Allows you to sprint multiple tiles in a single turn.';
	
};

// CREATE_TALENT_EFFECTS:
// ************************************************************************************************
gs.createTalentEffects = function () {
	this.talentEffects = {};
	this.talentOnLearn = {};
	
	this.talentEffects.FireMastery = function (character) {
		for (let i = 0; i < character.getTalentLevel('FireMastery'); i += 1) {
			character.firePower += gs.talents.FireMastery.bonus[i];
		}
	};
	
	this.talentEffects.StormMastery = function (character) {
		for (let i = 0; i < character.getTalentLevel('StormMastery'); i += 1) {
			character.stormPower += gs.talents.StormMastery.bonus[i];
		}
	};
	
	this.talentEffects.ColdMastery = function (character) {
		for (let i = 0; i < character.getTalentLevel('ColdMastery'); i += 1) {
			character.coldPower += gs.talents.ColdMastery.bonus[i];
		}
	};
	this.talentEffects.ToxicMastery = function (character) {
		for (let i = 0; i < character.getTalentLevel('ToxicMastery'); i += 1) {
			character.toxicPower += gs.talents.ToxicMastery.bonus[i];
		}
	};
	
	this.talentEffects.Evasive = function (character) {
		for (let i = 0; i < character.getTalentLevel('Evasive'); i += 1) {
			character.bonusEvasion += gs.talents.Evasive.bonus[i];
		}
	};
	
	// FOCUS:
	// ********************************************************************************************
	this.talentEffects.MagicMastery = function (character) {
		for (let i = 0; i < character.getTalentLevel('MagicMastery'); i += 1) {
			character.spellPower += gs.talents.MagicMastery.bonus[i];
		}
	};
	
	this.talentEffects.Focus = function (character) {
		for (let i = 0; i < character.getTalentLevel('Focus'); i += 1) {
			character.bonusMaxMp += gs.talents.Focus.bonusMp[i];
		}
	};
	
	this.talentOnLearn.Focus = function (character) {
		character.gainMp(gs.talents.Focus.bonusMp[character.getTalentLevel('Focus') - 1]);	
	};
	
	this.talentEffects.ManaConservation = function (character) {
		character.bonusSaveManaChance += 0.2;
	};
	
	this.talentEffects.Tranquility = function (character) {
		character.bonusMpRegenTime += character.getTalentLevel('Tranquility');
	};
	
	// DEFENSE:
	// ********************************************************************************************
	this.talentEffects.Fortitude = function (character) {
		for (let i = 0; i < character.getTalentLevel('Fortitude'); i += 1) {
			character.bonusMaxHp += gs.talents.Fortitude.bonusHp[i];
		}
		
	};
	this.talentOnLearn.Fortitude = function (character) {
		character.healHp(gs.talents.Fortitude.bonusHp[character.getTalentLevel('Fortitude') - 1]);
	};
	
	this.talentEffects.Regeneration = function (character) {
		character.bonusHpRegenTime += character.getTalentLevel('Regeneration');
	};
	
	this.talentEffects.FireResistance = function (character) {
		character.resistance.Fire += gs.talents.FireResistance.resistance[character.getTalentLevel('FireResistance') - 1];
	};
	this.talentEffects.ColdResistance = function (character) {
		character.resistance.Cold += gs.talents.ColdResistance.resistance[character.getTalentLevel('ColdResistance') - 1];
	};
	this.talentEffects.ShockResistance = function (character) {
		character.resistance.Shock += gs.talents.ShockResistance.resistance[character.getTalentLevel('ShockResistance') - 1];
	};
	this.talentEffects.ToxicResistance = function (character) {
		character.resistance.Toxic += gs.talents.ToxicResistance.resistance[character.getTalentLevel('ToxicResistance') - 1];
	};
	
	
	// MELEE:
	// ********************************************************************************************
	this.talentEffects.WeaponMastery = function (character) {
		for (let i = 0; i < character.getTalentLevel('WeaponMastery'); i += 1) {
			character.meleePower += gs.talents.WeaponMastery.bonus[i];
		}
	};
	
	this.talentEffects.Rage = function (character) {
		character.hasRage += 1;
	};
	
	this.talentEffects.WeaponShield = function (character) {
		if (character.inventory.getWeapon().type.effect.skill === 'Melee') {
			character.bonusReflection += 2;
		}
	};
	
	this.talentEffects.BloodLust = function (character) {
		character.maxRage += character.getTalentLevel('BloodLust');
	};

	
	// RANGE:
	// ********************************************************************************************
	this.talentEffects.RangeMastery = function (character) {
		for (let i = 0; i < character.getTalentLevel('RangeMastery'); i += 1) {
			character.rangePower += gs.talents.RangeMastery.bonus[i];
		}
	};
	
	/*
	this.talentEffects.AmmoConservation = function (character) {
		character.bonusSaveAmmoChance += 0.1 * character.getTalentLevel('AmmoConservation');
	};
	*/
	
	this.talentEffects.StrongArm = function (character) {
		character.bonusProjectileRange += 1;
		character.rangePower += 2;
	};
	
	// STEALTH:
	// ********************************************************************************************
	this.talentEffects.StealthMastery = function (character) {
		for (let i = 0; i < character.getTalentLevel('StealthMastery'); i += 1) {
			character.stealth += gs.talents.StealthMastery.bonus[i];
		}
	};
	this.talentOnLearn.DungeonSense = function () {
		gs.revealDungeonSenese();
	};
	
	this.talentEffects.KeenHearing = function (character) {
		character.hasKeenHearing += 1;
	};
	
	this.talentOnLearn.KeenHearing = function () {
		gs.HUD.miniMap.refresh();
	};
};

// GET_TALENT_DESCRIPTION:
// ************************************************************************************************
gs.getTalentDescription = function (talentName) {
	var talent = this.talents[talentName],
		str = '',
		baseLevel,
		upgrading;
	
	// Mastered:
	if (gs.pc.getTalentLevel(talentName) === talent.level.length) {
		str += 'Mastered ' + gs.capitalSplit(talentName) + '\n';
		baseLevel = gs.pc.getTalentLevel(talentName);
		upgrading = false;
	}
	// Upgrading:
	else if (gs.pc.getTalentLevel(talentName)) {
		baseLevel = gs.pc.getTalentLevel(talentName);
		
		str += 'Learn ' + gs.capitalSplit(talentName) + ' ' + (baseLevel + 1) + '\n';
		
		upgrading = true;
	}
	// Learning for first time:
	else {
		str += 'Learn ' + gs.capitalSplit(talentName) + '\n';
		baseLevel = 1;
		upgrading = false;
	}
	
	// Required Level:
	if (gs.pc.getTalentLevel(talentName) < talent.level.length) {
		str += 'Required Level: ' + talent.level[gs.pc.getTalentLevel(talentName)] + '\n';
	}
	
	
	
	// Ability Description:
	if (talent.ability) {
		// Sustained:
		if (talent.ability.isSustained) {
			str += 'Sustained Effect' + '\n';
		}
		
		// Mana:
		if (talent.ability.mana) {
			str += 'Mana: ' + talent.ability.mana + '\n';
		}
		
		// Hit Point Cost:
		if (talent.ability.hitPointCost) {
			str += 'Hit Points: ' + talent.ability.hitPointCost + '\n';
		}
		
		// Cool Down:
		if (talent.ability.coolDown) {
			str += 'Cooldown: ' + talent.ability.coolDown + '\n';
		}
		
		// Attributes:
		if (talent.ability.attributes) {
			this.forEachType(talent.ability.attributes, function (attribute) {
				str += this.capitalSplit(attribute.name) + ': ';
				
				if (upgrading && attribute.base[baseLevel] !== attribute.base[baseLevel + 1]) {
					str += attribute.base[baseLevel] + ' -> ' + attribute.base[baseLevel + 1] + '\n';
				}
				else {
					str += attribute.base[baseLevel] + '\n';
				}	
			}, this);
		}
	}
	
	// Talent Description:
	if (talent.desc && typeof talent.desc === 'string') {
		str += talent.desc;
	}
	else if (talent.desc && typeof talent.desc === 'function') {
		str += talent.desc(gs.pc.getTalentLevel(talentName) + 1);
	}
	
	return str;
};

// GET_BOOK_TALENTS:
// Returns a list of talent names to be placed in a skill book
// ************************************************************************************************
gs.getBookTalents = function (skillName) {
	var list, newList, oldList, returnList;
	
	list = this.talentList.filter(talent => talent.skillName === skillName && !talent.neverDrop);
	list = list.map(talent => talent.name);
	
	// newList contains only talents the player does not have:
	newList = list.filter(talentName => !gs.pc.hasAvailableTalent(talentName));
	oldList = list.filter(talentName => gs.pc.hasAvailableTalent(talentName));
	
	// Return only new talents:
	if (newList.length >= TALENTS_PER_BOOK) {
		return gs.randSubset(newList, TALENTS_PER_BOOK);
	}
	// Return only repeat talents:
	else if (newList.length === 0) {
		return gs.randSubset(oldList, TALENTS_PER_BOOK);
	}
	// Return a mix:
	else {
		return newList.concat(gs.randSubset(oldList, TALENTS_PER_BOOK - newList.length));
	}
};

// COUNT_PLAYER_ABILITIES:
// ************************************************************************************************
gs.countPlayerAbilities = function () {
	var key, count = 0;
	
	for (key in this.talents) {
		if (this.talents.hasOwnProperty(key)) {
			if (this.talents[key].ability) {
				count += 1;
			}
		}
	}
	
	return count;
};

/*
	// FIRE_MAGIC:
	this.talents.FireArrow = 		{level: 1};
	this.talents.FireBolt = 		{level: 6};
	this.talents.SummonOil = 		{level: 6};
	this.talents.FireArrow.desc = 'Shoots a flaming projectile which damages monsters and sets fire to flammable objects.';
	this.talents.SummonOil.desc = 'Summons a patch of flammable oil.';
	this.talents.FireBolt.desc = 'Sends forth a bolt of fire, hitting multiple monsters in a straight line.';

	// STORM_MAGIC:
	this.talents.Spark = 			{level: 1, skillName: 'StormMagic'};
	this.talents.Spark.desc = 'Shoots a spark of electricity which damages monsters and spreads across water.';
	
	// ICE_MAGIC:
	this.talents.IceArrow =			{level: 1, skillName: 'IceMagic'};
	this.talents.ColdResistance = 	{level: 1, skillName: 'IceMagic'};
	this.talents.Freeze = 			{level: 6, skillName: 'IceMagic'};
	this.talents.FreezingWind = 	{level: 12, skillName: 'IceMagic'};
	this.talents.IceArrow.desc = 		'Shoots a freezing projectile which damages monsters and reduces their movement speed.';
	this.talents.ColdResistance.desc = 	'+10% Cold Defense';
	this.talents.Freeze.desc = 			'Freezes a single monster in a block of ice rendering them unable to move or attack';
	this.talents.FreezingWind.desc = 	'Blasts all nearby monsters with a freezing wind, damaging them and knocking them back.';
	
	// FORTITUDE:
	this.talents.Shroomology = {level: 1, skillName: 'Fortitude'};
	this.talents.Shroomology.desc = '+5HP from healing mushrooms.';
	
	// HEAVY_HANDS:
	this.talents.HeavyHands = {};
	this.talents.HeavyHands.effect = function (character) {
		character.bonusMeleeCritChance += 0.05;
	};
	this.talents.HeavyHands.level = 2;
	this.talents.HeavyHands.skillName = 'Melee';
	this.talents.HeavyHands.desc = '+5% chance to strike a critical blow in melee combat.';
	
	// CLEAVE:
	this.talents.Cleave = {};
	this.talents.Cleave.ability = this.abilityTypes.Cleave;
	this.talents.Cleave.level = 8;
	this.talents.Cleave.skillName = 'Melee';
	this.talents.Cleave.desc = 'Hits every enemy around you for critical damage and knockback.';
	
	
*//*global gs*/
/*global FACTION*/
/*jshint esversion: 6*/
'use strict';

// STATUS_EFFECTS:
// Added to characters to maintain and manage their list of status effects
// ************************************************************************************************
function StatusEffects (character) {
	this.character = character;
	this.list = [];
}

// ON_UPDATE_TURN:
// ************************************************************************************************
StatusEffects.prototype.onUpdateTurn = function () {
	// Tick Duration and Destroy:
	for (let i = this.list.length - 1; i >= 0; i -= 1) {
		// Tick Duration:
		if (!this.list[i].noDuration) {
			this.list[i].duration -= 1;
		}
		
		// Destroy:
		if (this.list[i].duration <= 0 || this.list[i].shouldDestroy(this.character)) {
			this.list[i].onDestroy(this.character);
			this.list.splice(i, 1);
		}
	}
	
	// Apply status effects:
	for (let i = 0; i < this.list.length; i += 1) {
		this.list[i].onUpdateTurn(this.character);
		
		// Immediately halt if character was killed by one of his status effects:
		if (!this.character.isAlive) {
			break;
		}
	}
};


// ON_UPDATE_STATS:
// ************************************************************************************************
StatusEffects.prototype.onUpdateStats = function () {
	this.list.forEach(function (statusEffect) {
		statusEffect.onUpdateStats(this.character);
	}, this);
};

// HAS:
// Returns true if the character has the status effect of type name
// ************************************************************************************************
StatusEffects.prototype.has = function (typeName) {
	return Boolean(this.get(typeName));
};

// GET:
// Returns the status effect with the specified typeName:
// ************************************************************************************************
StatusEffects.prototype.get = function (typeName) {
	return this.list.find(statusEffect => statusEffect.name === typeName);
};

// ADD:
// Adds a status effect
// ************************************************************************************************
StatusEffects.prototype.add = function (typeName, properties, flags = {}) {
	var newStatusEffect;
	
	if (this.character.faction === FACTION.NEUTRAL || this.character.type.damageImmune) {
		return;
	}
	
	// Immune:
	if (gs.inArray(typeName, this.character.type.effectImmune)) {
		this.character.queuePopUpText('Immune', '#ffffff'); 
		return;
	}
	
	newStatusEffect = this.createStatusEffect(typeName, properties);
	
	// Existing status effect:
	if (this.has(newStatusEffect.name) && !newStatusEffect.canStack) {
		let oldStatusEffect = this.get(newStatusEffect.name);
		
		if (newStatusEffect.addDuration) {
			oldStatusEffect.duration += newStatusEffect.duration;
		}
		else {
			oldStatusEffect.duration = newStatusEffect.duration;
		}
	}
	// New status effect:
	else {
		newStatusEffect.onCreate(this.character);
		
		this.list.push(newStatusEffect);
		
		// Pop Up Text:
		if (gs.getTile(this.character.tileIndex).visible && !newStatusEffect.dontPopUpText && !flags.dontPopUpText) {
			this.character.queuePopUpText(gs.capitalSplit(newStatusEffect.name), '#ffffff'); 
		}
	}
	
	if (typeName === 'Immobile') {
		this.remove('Charge');
		this.remove('Sprint');
	}
	
	
	this.character.updateStats();
};

// CREATE_STATUS_EFFECT:
// ************************************************************************************************
StatusEffects.prototype.createStatusEffect = function (typeName, properties = {}) {
	var statusEffect;
	
	if (!gs.statusEffectTypes.hasOwnProperty(typeName)) {
		throw typeName + ' is not a valid statusEffectType';
	}
	
	// Create a copy of the base statusEffectType:
	statusEffect = Object.create(gs.statusEffectTypes[typeName]);
	
	// Property list remembers which properties to save when serializing toData (Always serialize duration):
	statusEffect.propertyList = ['duration'];
	
	for (let key in properties) {
		if (properties.hasOwnProperty(key)) {
			// First copying over the properties to the new statusEffect
			statusEffect[key] = properties[key];
				
			// Recording which properties to serialize:
			statusEffect.propertyList.push(key);
		}
	}
	
	return statusEffect;
};

// REMOVE:
// Removes and destroys all status effect
// ************************************************************************************************
StatusEffects.prototype.remove = function (typeName) {
	var statusEffect;
	
	// Remove from list:
	for (let i = 0; i < this.list.length; i += 1) {
		if (this.list[i].name === typeName) {
			statusEffect = this.list[i];
			this.list.splice(i, 1);
			break;
		}
	}
	
	// Destroy:
	if (statusEffect) {
		statusEffect.onDestroy(this.character);
		this.character.updateStats();
	}
};

// REMOVE_ALL:
// Removes and destroys all status effects
// ************************************************************************************************
StatusEffects.prototype.removeAll = function () {
	this.list.forEach(function (statusEffect) {
		statusEffect.onDestroy(this.character);
	}, this);
	
	this.list = [];
};

// ON_CHANGE_LEVEL:
// Called when the player is zoning to remove status effects that are destroyed on zoning:
// ************************************************************************************************
StatusEffects.prototype.onChangeLevel = function () {
	for (let i = this.list.length - 1; i >= 0; i -= 1) {
		if (this.list[i].destroyOnZoning) {
			this.remove(this.list[i].name);
		}
	}
};

// ON_AGRO_PLAYER:
// ************************************************************************************************
StatusEffects.prototype.onAgroPlayer = function () {
	if (this.has('DeepSleep')) {
		this.remove('DeepSleep');
	}
};

// ON_TELEPORT:
// Called when the character teleports
// ************************************************************************************************
StatusEffects.prototype.onTeleport = function () {
	if (this.has('Sprint')) {
		this.remove('Sprint');
	}
	
	if (this.has('Charge')) {
		this.remove('Charge');
	}
};

// ON_CHANGE_EQUIPMENT:
// Called when the character changes equipment
// ************************************************************************************************
StatusEffects.prototype.onChangeEquipment = function () {
	if (this.has('Deflect') && !this.character.inventory.hasShieldEquipped()) {
		this.remove('Deflect');
	}
};

// ON_END_TURN:
// Called when the character ends his turn
// ************************************************************************************************
StatusEffects.prototype.onEndTurn = function () {
	if (this.has('Charge')) {
		this.remove('Charge');
	}
	
	if (this.has('Sprint')) {
		this.remove('Sprint');
	}
};

// ON_OPEN_DIALOG:
// ************************************************************************************************
StatusEffects.prototype.onOpenDialog = function () {
	if (this.has('Charge')) {
		this.remove('Charge');
	}
	
	if (this.has('Sprint')) {
		this.remove('Sprint');
	}
};

// ON_TAKE_DAMAGE:
// ************************************************************************************************
StatusEffects.prototype.onTakeDamage = function (damageType) {
	if (!this.character.isAlive) {
		return;
	}
	
	// Cold attacks will slow:
	if (damageType === 'Cold' && this.character.resistance.Cold < 1) {
		this.add('Slow', {duration: 5});
	}
	
	// Remove Deep Sleep:
	if (this.has('DeepSleep')) {
		this.remove('DeepSleep');
	}
	
	// Run it backwards in case they want to remove themselves:
	for (let i = this.list.length - 1; i >= 0; i -= 1) {
		this.list[i].onTakeDamage(this.character, damageType);
	}
};

// ON_CURE:
// ************************************************************************************************
StatusEffects.prototype.onCure = function () {
	if (this.has('InfectiousDisease')) {
		this.remove('InfectiousDisease');
	}
	
	if (this.has('Draining')) {
		this.remove('Draining');
	}
};

// ON_MENTAL_CURE:
// ************************************************************************************************
StatusEffects.prototype.onMentalCure = function () {
	// Cure Confusion:
	if (this.has('Confusion')) {
		this.remove('Confusion');
	}
	
	if (this.has('NPCCharm')) {
		this.remove('NPCCharm');
	}
};

// TO_DATA:
// ************************************************************************************************
StatusEffects.prototype.toData = function () {
	var data = [];
	
	this.list.forEach(function (statusEffect) {
		if (!statusEffect.dontSave) {
			data.push(statusEffect.toData());
		}
	}, this);
	
	return data;
};

// LOAD_DATA:
// ************************************************************************************************
StatusEffects.prototype.loadData = function (data) {
	for (let i = 0; i < data.length; i += 1) {
		this.add(data[i].typeName, data[i].properties, {dontPopUpText: true});
	}
};

// TO_UI_STRING:
// ************************************************************************************************
StatusEffects.prototype.toUIString = function () {
	var str = '';
	
	this.list.forEach(function (statusEffect) {
		str += statusEffect.uiSymbol;
	}, this);
	
	return str;
};/*global game, gs, console, Phaser, util*/
/*global SCALE_FACTOR*/
/*global RED_BOX_FRAME, RED_SELECT_BOX_FRAME, FACTION*/
/*jshint laxbreak: true, esversion: 6*/
'use strict';

// STATUS_EFFECT_TYPE:
// Status effect instances are cloned from the generic status effect type.
// Instances then overwrite default properties to set unique damage, duration etc.
// ************************************************************************************************
function StatusEffectType () {
	// Default values
	this.duration = 10; 
	this.addDuration = true;
	this.uiSymbol = '';
	this.desc = '';
}

// ON_CREATE:
// ************************************************************************************************
StatusEffectType.prototype.onCreate = function (character) {
	// Pass
};

// ON_UPDATE_TURN:
// Called when the character updates his global turn.
// character: the character who has the status effect.
// ************************************************************************************************
StatusEffectType.prototype.onUpdateTurn = function (character) {
	// Pass
};

// ON_UPDATE_STATS:
// Called when the player is updating his stats.
// character: the character who has the status effect.
// ************************************************************************************************
StatusEffectType.prototype.onUpdateStats = function (character) {
	// Pass
};

// SHOULD_DESTROY:
// Called when the character updates his global turn and determines if the status effect should be prematurely destroyed.
// ************************************************************************************************
StatusEffectType.prototype.shouldDestroy = function (character) {
	return false; // By default, status effects do not end prematurely
};

// ON_TAKE_DAMAGE:
// Called when the character takes damage
StatusEffectType.prototype.onTakeDamage = function (character, damageType) {
	// Pass
};

// DESTROY:
// Called when the status effect is removed from a character
// Duration ends, character dies, forcibly removed etc.
// character: the character who has the status effect.
// ************************************************************************************************
StatusEffectType.prototype.onDestroy = function (character) {
	// Pass
};


// TO_DATA:
// Serializes the status effect type for saving
// ************************************************************************************************
StatusEffectType.prototype.toData = function () {
	var data = {};
	
	data.typeName = this.name;
	data.properties = {};
	
	// Properties:
	this.propertyList.forEach(function (key) {
		data.properties[key] = this[key];
	}, this);
	
	return data;
};

// TO_SHORT_DESC:
// The short name + duration that shows up on the HUD
// ************************************************************************************************
StatusEffectType.prototype.toShortDesc = function () {
	var str = gs.capitalSplit(this.name);
	
	if (this.duration > 1 && !this.noDuration) {
		str += ': ' + this.duration;
	}
	
	return str;
};

// TO_LONG_DESC:
// Fills the players chat box when mousing over the status effect.
// ************************************************************************************************
StatusEffectType.prototype.toLongDesc = function () {
	var str = gs.capitalSplit(this.name) + ':\n';
	
	if (this.duration > 1 && !this.noDuration) {
		str += 'Duration: ' + this.duration + '\n';
	}
	
	str += this.desc;
			
	return str;
};


// CREATE_STATUS_EFFECT_TYPES:
// ************************************************************************************************
gs.createStatusEffectTypes = function () {
	this.statusEffectTypes = {};
	
	// HIDE_IN_SHELL:
	// ********************************************************************************************
	this.statusEffectTypes.HideInShell = new StatusEffectType();
	this.statusEffectTypes.HideInShell.noDuration = true;	
	this.statusEffectTypes.HideInShell.onUpdateStats = function (character) {
		character.protection += 10;
		character.isImmobile += 1;
	};
	this.statusEffectTypes.HideInShell.shouldDestroy = function (character) {
		var nearestHostile = character.getNearestHostile();
		return !nearestHostile || gs.distance(character.tileIndex, nearestHostile.tileIndex) > 1.5;
	};
	
	// NPC_CHARM:
	// Cast by NPCs on the player, stops the player from moving away from the NPC.
	// ********************************************************************************************
	this.statusEffectTypes.NPCCharm = new StatusEffectType();
	this.statusEffectTypes.NPCCharm.duration = 10;
	this.statusEffectTypes.NPCCharm.destroyOnZoning = true;
	this.statusEffectTypes.NPCCharm.desc = 'You are unable to move away from the creature that has charmed you.';
	this.statusEffectTypes.NPCCharm.dontSave = true;
	
	
	// CHARM:
	// Cast by player on NPCs, converts the NPC to the players faction.
	// ********************************************************************************************
	this.statusEffectTypes.Charm = new StatusEffectType();
	this.statusEffectTypes.Charm.duration = 10;
	this.statusEffectTypes.Charm.onDestroy = function (character) {
		character.faction = FACTION.HOSTILE;
	};
	
	// DRAINING:
	// ********************************************************************************************
	this.statusEffectTypes.Draining = new StatusEffectType();
	this.statusEffectTypes.Draining.duration = 50;
	this.statusEffectTypes.Draining.addDuration = true;
	
	// DEEP_SLEEP:
	// ********************************************************************************************
	this.statusEffectTypes.DeepSleep = new StatusEffectType();
	this.statusEffectTypes.DeepSleep.duration = 20;
	this.statusEffectTypes.DeepSleep.onUpdateStats = function (character) {
		character.isAsleep = true;
	};
	this.statusEffectTypes.DeepSleep.neverOnPlayer = true;
	
	// SLOW_CHARGE:
	// ********************************************************************************************
	this.statusEffectTypes.SlowCharge = new StatusEffectType();
	this.statusEffectTypes.SlowCharge.noDuration = true;
	this.statusEffectTypes.SlowCharge.onUpdateStats = function (character) {
		character.isSlowProjectile += 1;
		character.bonusMovementSpeed += 2;
		character.knockBackOnHit += 2;
	};
	
	// WET:
	// ********************************************************************************************
	this.statusEffectTypes.Wet = new StatusEffectType();
	this.statusEffectTypes.Wet.onUpdateStats = function (character) {
		character.isWet = true;
	};
	this.statusEffectTypes.Wet.onUpdateTurn = function (character) {
		if (gs.zoneType().isCold) {
			character.coldTimer += 2;
		}
	};
	this.statusEffectTypes.Wet.noDuration = true;
	this.statusEffectTypes.Wet.dontPopUpText = true;
	this.statusEffectTypes.Wet.desc = 'You will take double damage from all electric attacks and half damage from fire.';
	
	// FLAMMABLE:
	// ********************************************************************************************
	this.statusEffectTypes.Flammable = new StatusEffectType();
	this.statusEffectTypes.Flammable.onUpdateStats = function (character) {
		character.isFlammable = true;
	};
	this.statusEffectTypes.Flammable.noDuration = true;
	this.statusEffectTypes.Flammable.addDuration = false;
	this.statusEffectTypes.Flammable.dontPopUpText = true;
	this.statusEffectTypes.Flammable.desc = 'You will take double damage from all fire attacks.';
	
	// UNSTABLE:
	// ********************************************************************************************
	this.statusEffectTypes.Unstable = new StatusEffectType();
	this.statusEffectTypes.Unstable.onUpdateStats = function (character) {
		character.isUnstable += 1;
	};
	this.statusEffectTypes.Unstable.noDuration = true;
	this.statusEffectTypes.Unstable.addDuration = false;
	this.statusEffectTypes.Unstable.dontPopUpText = true;
	this.statusEffectTypes.Unstable.desc = 'Your unstable footing will cause you to be critically hit by all physical attacks.';
	
	// IMMOBILE:
	// ********************************************************************************************
	this.statusEffectTypes.Immobile = new StatusEffectType();
	this.statusEffectTypes.Immobile.onUpdateStats = function (character) {
		character.isUnstable += 1;
		character.isImmobile += 1;
	};
	this.statusEffectTypes.Immobile.duration = 5;
	this.statusEffectTypes.Immobile.addDuration = false;
	this.statusEffectTypes.Immobile.desc = 'You are unable to move ad will be critically hit by all physical attacks.';
	
	// CONSTRICTING:
	// When a character constricts another character, he adds this status effect to himself to prevent himself from moving
	// ********************************************************************************************
	this.statusEffectTypes.Constricting = new StatusEffectType();
	this.statusEffectTypes.Constricting.duration = 5;
	this.statusEffectTypes.Constricting.addDuration = false;
	this.statusEffectTypes.Constricting.dontPopUpText = true;
	this.statusEffectTypes.Constricting.onUpdateStats = function (character) {
		character.isImmobile += 1;
	};
	this.statusEffectTypes.Constricting.shouldDestroy = function (character) {
		var targetChar = gs.getCharWithID(this.targetCharId);
		return !targetChar || gs.distance(character.tileIndex, targetChar.tileIndex) > 1.5; 
	};
	this.statusEffectTypes.Constricting.onDestroy = function (character) {
		var targetChar = gs.getCharWithID(this.targetCharId);
		
		if (targetChar) {
			targetChar.statusEffects.remove('Constricted');
		}
	};
	
	// CONSTRICTED:
	// ********************************************************************************************
	this.statusEffectTypes.Constricted = new StatusEffectType();
	this.statusEffectTypes.Constricted.duration = 5;
	this.statusEffectTypes.Constricted.addDuration = true;
	this.statusEffectTypes.Constricted.onUpdateStats = function (character) {
		character.isImmobile += 1;
		character.isUnstable += 1;
	};
	this.statusEffectTypes.Constricted.shouldDestroy = function (character) {
		var constrictingChar = gs.getCharWithID(this.constrictingCharId);
		return !constrictingChar || gs.distance(character.tileIndex, constrictingChar.tileIndex) > 1.5; 
	};
	this.statusEffectTypes.Constricted.onDestroy = function (character) {
		var constrictingChar = gs.getCharWithID(this.constrictingCharId);
		
		if (constrictingChar) {
			constrictingChar.statusEffects.remove('Constricting');
		}
	};
	
	// FEARED:
	// ********************************************************************************************
	this.statusEffectTypes.Feared = new StatusEffectType();
	this.statusEffectTypes.Feared.duration = 10;
	this.statusEffectTypes.Feared.addDuration = true;
	this.statusEffectTypes.Feared.onCreate = function (character) {
		character.isRunning = true;
	};
	this.statusEffectTypes.Feared.onDestroy = function (character) {
		character.isRunning = false;
	};
	
	
	
	
	
	
	// EXPERIENCE_BOOST:
	// ********************************************************************************************
	this.statusEffectTypes.ExperienceBoost = new StatusEffectType();
	this.statusEffectTypes.ExperienceBoost.onUpdateStats = function (character) {
			character.bonusExpMod += 1.0;
	};
	this.statusEffectTypes.ExperienceBoost.duration = 100;
	this.statusEffectTypes.ExperienceBoost.addDuration = true;
	this.statusEffectTypes.ExperienceBoost.desc = 'Doubles the experience you gain from killing enemies.';
	
	// STUNNED:
	// ********************************************************************************************
	this.statusEffectTypes.Stunned = new StatusEffectType();
	this.statusEffectTypes.Stunned.onUpdateStats = function (character) {
			character.isStunned += 1;
	};
	this.statusEffectTypes.Stunned.duration = 3;
	this.statusEffectTypes.Stunned.addDuration = true;
	
	// FROZEN:
	this.statusEffectTypes.Frozen = new StatusEffectType();
	this.statusEffectTypes.Frozen.onUpdateStats = function (character) {
		character.isImmobile += 1;
		character.isStunned += 1;
	};
	this.statusEffectTypes.Frozen.addDuration = false;
	
	// NETTED:
	// ********************************************************************************************
	this.statusEffectTypes.Netted = new StatusEffectType();
	this.statusEffectTypes.Netted.duration = 3;
	this.statusEffectTypes.Netted.addDuration = false;
	this.statusEffectTypes.Netted.destroyOnZoning = true;
	this.statusEffectTypes.Netted.onUpdateStats = function (character) {
		character.isUnstable += 1;
		character.isImmobile += 1;
	};
	this.statusEffectTypes.Netted.onCreate = function (character) {
		var pos = util.toPosition(character.tileIndex);
		this.sprite = gs.createSprite(pos.x, pos.y, 'Tileset', gs.projectileSpritesGroup);
		this.sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
    	this.sprite.anchor.setTo(0.5, 0.5);
    	this.sprite.frame = gs.projectileTypes.Net.frame;
	};
	this.statusEffectTypes.Netted.onDestroy = function (character) {
		this.sprite.destroy();	
	};
	this.statusEffectTypes.Netted.onTakeDamage = function (character, damageType) {
		if (util.frac() <= 0.5 || damageType === 'Fire') {
			character.statusEffects.remove(this.name);
		}
	};
	
	
	// WEBBED:
	// ********************************************************************************************
	this.statusEffectTypes.Webbed = new StatusEffectType();
	this.statusEffectTypes.Webbed.duration = 3;
	this.statusEffectTypes.Webbed.addDuration = false;
	this.statusEffectTypes.Webbed.destroyOnZoning = true;
	this.statusEffectTypes.Webbed.onUpdateStats = function (character) {
		character.isUnstable += 1;
		character.isImmobile += 1;
	};
	this.statusEffectTypes.Webbed.onCreate = function (character) {
		var pos = util.toPosition(character.tileIndex);
	
		this.sprite = gs.createSprite(pos.x, pos.y, 'Tileset', gs.projectileSpritesGroup);
		this.sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
    	this.sprite.anchor.setTo(0.5, 0.5);
    	this.sprite.frame = gs.projectileTypes.SpiderWeb.frame;
		
		// Remember the tileIndex in which the character was webbed so can remove:
		this.tileIndex = {x: character.tileIndex.x, y: character.tileIndex.y};
	};
	this.statusEffectTypes.Webbed.shouldDestroy = function (character) {
		return !gs.vectorEqual(character.tileIndex, this.tileIndex);
	};
	this.statusEffectTypes.Webbed.onDestroy = function (character) {
		this.sprite.destroy();	
	};
	this.statusEffectTypes.Webbed.onTakeDamage = function (character, damageType) {
		if (util.frac() <= 0.5 || damageType === 'Fire') {
			character.statusEffects.remove(this.name);
		}
	};
	
	
	// SLOW:
	// ********************************************************************************************
	this.statusEffectTypes.Slow = new StatusEffectType();
	this.statusEffectTypes.Slow.onUpdateStats = function (character) {
		character.bonusMovementSpeed -= 1;
	};
	this.statusEffectTypes.Slow.duration = 5;
	this.statusEffectTypes.Slow.addDuration = false;
	
	
	// HEALING:
	// ********************************************************************************************
	this.statusEffectTypes.Healing = new StatusEffectType();
	this.statusEffectTypes.Healing.duration = 10;
	this.statusEffectTypes.Healing.onUpdateTurn = function (character) {
		character.healHp(character.maxHp / 10);
	};
	this.statusEffectTypes.Healing.addDuration = true;
	
	// MARKED:
	// ********************************************************************************************
	this.statusEffectTypes.Marked = new StatusEffectType();
	this.statusEffectTypes.Marked.onUpdateStats = function (character) {
			character.isMarked += 1;
	};
	this.statusEffectTypes.Marked.duration = 10;
	this.statusEffectTypes.Marked.addDuration = false;
	this.statusEffectTypes.Marked.desc = 'You have been magically marked causing all creatures to track you.';
	

	// SNEAK:
	// ********************************************************************************************
	this.statusEffectTypes.Sneak = new StatusEffectType();
	this.statusEffectTypes.Sneak.onUpdateStats = function (character) {
			character.stealth += 10;
	};
	this.statusEffectTypes.Sneak.duration = 20;
	this.statusEffectTypes.Sneak.addDuration = true;
	
	// DEAD_EYE:
	// ********************************************************************************************
	this.statusEffectTypes.DeadEye = new StatusEffectType();
	this.statusEffectTypes.DeadEye.onUpdateStats = function (character) {
			character.alwaysProjectileCrit += 1;
	};
	this.statusEffectTypes.DeadEye.duration = 10;
	this.statusEffectTypes.DeadEye.addDuration = true;
	
	// CHARGE:
	// ********************************************************************************************
	this.statusEffectTypes.Charge = new StatusEffectType();
	this.statusEffectTypes.Charge.destroyOnZoning = true;
	this.statusEffectTypes.Charge.onUpdateStats = function (character) {
		character.isMultiMoving += 1;
		character.meleePower += 20;
	};
	this.statusEffectTypes.Charge.duration = 1;
	this.statusEffectTypes.Charge.addDuration = true;
	this.statusEffectTypes.Charge.dontPopUpText = true;
	this.statusEffectTypes.Charge.dontShowOnHUD = true;
	this.statusEffectTypes.Charge.dontSave = true;
	
	// SPRINT:
	// ********************************************************************************************
	this.statusEffectTypes.Sprint = new StatusEffectType();
	this.statusEffectTypes.Sprint.destroyOnZoning = true;
	this.statusEffectTypes.Sprint.onUpdateStats = function (character) {
		character.isMultiMoving += 1;
	};
	
	this.statusEffectTypes.Sprint.duration = 1;
	this.statusEffectTypes.Sprint.addDuration = true;
	this.statusEffectTypes.Sprint.dontPopUpText = true;
	this.statusEffectTypes.Sprint.dontShowOnHUD = true;
	this.statusEffectTypes.Sprint.dontSave = true;
	
	// BERSERK:
	// ********************************************************************************************
	this.statusEffectTypes.Berserk = new StatusEffectType();
	this.statusEffectTypes.Berserk.onUpdateStats = function (character) {
		character.alwaysCrit += 1;
		character.knockBackOnHit += 1;
	};
	
	this.statusEffectTypes.Berserk.duration = 10;
	this.statusEffectTypes.Berserk.addDuration = true;
	
	// LIFE_SPIKE:
	// ********************************************************************************************
	this.statusEffectTypes.LifeSpike = new StatusEffectType();
	this.statusEffectTypes.LifeSpike.duration = 8;
	this.statusEffectTypes.LifeSpike.damage = 2;
	this.statusEffectTypes.LifeSpike.onUpdateTurn = function (character) {
		var amount, actingCharacter;
		
		actingCharacter = gs.getCharWithID(this.actingCharacterId);
		
		amount = character.takeDamage(this.damage, 'Toxic', {killer: actingCharacter, neverCrit: true});
		
		if (actingCharacter && actingCharacter.isAlive) {
			actingCharacter.healHp(Math.ceil(amount / 2));
		}
	};
	this.statusEffectTypes.LifeSpike.addDuration = false;
	this.statusEffectTypes.LifeSpike.canStack = true;
	
	// STRONG_POISON:
	// ********************************************************************************************
	this.statusEffectTypes.StrongPoison = new StatusEffectType();
	this.statusEffectTypes.StrongPoison.duration = 5; // Remember this will be 4 ticks
	this.statusEffectTypes.StrongPoison.onUpdateTurn = function (character) {
		character.takeDamage(this.damage, 'Toxic', {neverCrit: true});
	};
	this.statusEffectTypes.StrongPoison.addDuration = false;
	this.statusEffectTypes.StrongPoison.dontPopUpText = true;
	
	
	// RESISTANCE:
	// ********************************************************************************************
	this.statusEffectTypes.Resistance = new StatusEffectType();
	this.statusEffectTypes.Resistance.onUpdateStats = function (character) {
		character.resistance.Fire += 1;
		character.resistance.Cold += 1;
		character.resistance.Shock += 1;
		character.resistance.Toxic += 1;
		character.protection += 4;
	};
	this.statusEffectTypes.Resistance.duration = 50;
	this.statusEffectTypes.Resistance.addDuration = true;
	
	// BLESS:
	// ********************************************************************************************
	this.statusEffectTypes.Bless = new StatusEffectType();
	this.statusEffectTypes.Bless.onUpdateStats = function (character) {
		character.resistance.Fire += 1;
		character.resistance.Cold += 1;
		character.resistance.Shock += 1;
		character.resistance.Toxic += 1;
		character.protection += 2;
		character.meleePower += 5;
		character.spellPower += 5;
		character.rangePower += 5;
	};
	this.statusEffectTypes.Bless.duration = 100;
	this.statusEffectTypes.Bless.addDuration = true;
	
	// POWER:
	// ********************************************************************************************
	this.statusEffectTypes.Power = new StatusEffectType();
	this.statusEffectTypes.Power.onUpdateStats = function (character) {
		character.meleePower += 20;
		character.spellPower += 20;
		character.rangePower += 20;
	};
	this.statusEffectTypes.Power.duration = 20;
	this.statusEffectTypes.Power.addDuration = true;
	
	// LEVITATION:
	// ********************************************************************************************
	this.statusEffectTypes.Levitation = new StatusEffectType();
	this.statusEffectTypes.Levitation.onUpdateStats = function (character) {
		character.isFlying += 1;
	};
	this.statusEffectTypes.Levitation.duration = 50;
	this.statusEffectTypes.Levitation.addDuration = true;
	
	// ENERGY_SHROOM_TEA:
	// ********************************************************************************************
	this.statusEffectTypes.EnergyShroomTea = new StatusEffectType();
	this.statusEffectTypes.EnergyShroomTea.onUpdateTurn = function (character) {
		if (gs.turn % 5 === 0) {
			character.gainMp(1);
		}	
	};
	this.statusEffectTypes.EnergyShroomTea.duration = 200;
	this.statusEffectTypes.EnergyShroomTea.addDuration = true;
	
	// HASTE:
	// ********************************************************************************************
	this.statusEffectTypes.Haste = new StatusEffectType();
	this.statusEffectTypes.Haste.onUpdateStats = function (character) {
		character.bonusMovementSpeed += 1;
	};
	this.statusEffectTypes.Haste.duration = 20;
	this.statusEffectTypes.Haste.addDuration = true;
	
	// CASTING_SMITE:
	// ********************************************************************************************
	this.statusEffectTypes.CastingSmite = new StatusEffectType();
	this.statusEffectTypes.CastingSmite.onCreate = function (character) {
		var pos = util.toPosition(this.tileIndex);
		this.sprite = gs.createSprite(pos.x, pos.y, 'Tileset', gs.projectileSpritesGroup);
		this.sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
    	this.sprite.anchor.setTo(0.5, 0.5);
    	this.sprite.frame = RED_SELECT_BOX_FRAME;
	};
	this.statusEffectTypes.CastingSmite.onDestroy = function (character) {
		var targetChar;
		
		// Note that destroyFunc is called when the character dies, as well as when the status effect naturally ends.
		// Only want to cast the smite if the character is still alive
		if (character.isAlive) {
			gs.createParticlePoof(character.tileIndex, 'PURPLE');
		
			targetChar = gs.getChar(this.tileIndex);
			if (targetChar) {
				targetChar.takeDamage(this.damage, 'Physical', {killer: character});
			}
			gs.createSmiteEffect(this.tileIndex);
		}
		
		
		this.sprite.destroy();	
	};
	this.statusEffectTypes.CastingSmite.onUpdateStats = function (character) {
		character.isStunned += 1;
	};
	this.statusEffectTypes.CastingSmite.duration = 2;
	
	// CASTING_FIRE_STORM:
	// ********************************************************************************************
	this.statusEffectTypes.CastingFireStorm = new StatusEffectType();
	this.statusEffectTypes.CastingFireStorm.onCreate = function (character) {
		this.spriteList = [];	
		this.createSprite(this.tileIndex);
		this.skipFirstTurn = true;
		this.size = 0.5;
	};
	
	this.statusEffectTypes.CastingFireStorm.onUpdateTurn = function () {
		if (this.skipFirstTurn) {
			this.skipFirstTurn = false;
			return;
		}
		// Create Fire:
		gs.getIndexInRadius(this.tileIndex, this.size).forEach(function (index) {
			if (gs.isStaticPassable(index)) {
				gs.createFire(index, this.damage);
			}
		}, this);
		
		// Destroy existing sprites:
		this.onDestroy();
		
		if (this.size < 2) {
			this.size += 0.5;
		}
		
		// Move up:
		if (gs.isStaticPassable(this.tileIndex.x + this.delta.x, this.tileIndex.y + this.delta.y)) {
			this.tileIndex = {x: this.tileIndex.x + this.delta.x, y: this.tileIndex.y + this.delta.y};
			this.createSprites(this.tileIndex);
		}
		else {
			this.duration = 0;
		}
	};
	this.statusEffectTypes.CastingFireStorm.createSprites = function (tileIndex) {
		gs.getIndexInRadius(tileIndex, this.size).forEach(function (index) {
			if (gs.isStaticPassable(index)) {
				this.createSprite(index);
			}
		}, this);
	};
	this.statusEffectTypes.CastingFireStorm.createSprite = function (tileIndex) {
		var sprite,
			pos = util.toPosition(tileIndex);
		
		sprite = gs.createSprite(pos.x, pos.y, 'Tileset', gs.projectileSpritesGroup);
		sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
    	sprite.anchor.setTo(0.5, 0.5);
    	sprite.frame = RED_SELECT_BOX_FRAME;
		
		this.spriteList.push(sprite);
	};
	this.statusEffectTypes.CastingFireStorm.onDestroy = function (character) {
		this.spriteList.forEach(function (sprite) {
			sprite.destroy();
		}, this);
	};
	this.statusEffectTypes.CastingFireStorm.onUpdateStats = function (character) {
		character.isStunned += 1;
	};
	this.statusEffectTypes.CastingFireStorm.duration = 10;
	
	// SEAL_DOORS:
	// When an NPC seals doors they add this status effect to themselves to keep the doors sealed
	// The status effect will unseal the doors when it completes (either duration or when the npc is killed)
	// Make sure to set indexList when creating the status effect
	// ********************************************************************************************
	this.statusEffectTypes.SealDoors = new StatusEffectType();
	this.statusEffectTypes.SealDoors.onCreate = function (character) {
		this.spriteList = [];
		
		this.indexList.forEach(function (tileIndex) {
			var sprite;
			
			// Create sprite:
			sprite = gs.createSprite(util.toPosition(tileIndex).x, util.toPosition(tileIndex).y, 'Tileset', gs.projectileSpritesGroup);
			sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
    		sprite.anchor.setTo(0.5, 0.5);
    		sprite.frame = RED_SELECT_BOX_FRAME;
			this.spriteList.push(sprite);
			
			// Seal Doors:
			gs.getObj(tileIndex).seal();
			
		}, this);
		
	};
	this.statusEffectTypes.SealDoors.onDestroy = function (character) {
		// Destroy sprites:
		this.spriteList.forEach(function (sprite) {
			sprite.destroy();
		}, this);
		
		// Unseal doors:
		this.indexList.forEach(function (tileIndex) {
			gs.getObj(tileIndex).isSealed = false;
		}, this);
	};
	this.statusEffectTypes.SealDoors.duration = 20;
	this.statusEffectTypes.SealDoors.dontSave = true;
	
	// SHIELDS_UP:
	// ********************************************************************************************
	this.statusEffectTypes.ShieldsUp = new StatusEffectType();
	this.statusEffectTypes.ShieldsUp.duration = 1;
	this.statusEffectTypes.ShieldsUp.dontPopUpText = true;
	this.statusEffectTypes.ShieldsUp.dontShowOnHUD = true;
	
	// DEFLECT:
	// ********************************************************************************************
	this.statusEffectTypes.Deflect = new StatusEffectType();
	this.statusEffectTypes.Deflect.onUpdateStats = function (character) {
		character.bonusReflection += 10;
	};
	this.statusEffectTypes.Deflect.duration = 5;
	
	// FIRE_ATTUNEMENT:
	// ********************************************************************************************
	this.statusEffectTypes.FireAttunement = new StatusEffectType();
	this.statusEffectTypes.FireAttunement.onUpdateStats = function (character) {
		character.firePower += this.firePower;
		character.manaConservation.Fire += 1;
	};
	this.statusEffectTypes.FireAttunement.duration = 10;
	
	// STORM_ATTUNEMENT:
	// ********************************************************************************************
	this.statusEffectTypes.StormAttunement = new StatusEffectType();
	this.statusEffectTypes.StormAttunement.onUpdateStats = function (character) {
		character.stormPower += this.stormPower;
		character.manaConservation.Storm += 1;
	};
	this.statusEffectTypes.StormAttunement.duration = 10;
	
	// COLD_ATTUNEMENT:
	// ********************************************************************************************
	this.statusEffectTypes.ColdAttunement = new StatusEffectType();
	this.statusEffectTypes.ColdAttunement.onUpdateStats = function (character) {
		character.coldPower += this.coldPower;
		character.manaConservation.Cold += 1;
	};
	this.statusEffectTypes.ColdAttunement.duration = 10;
	
	
	// TOXIC_ATTUNEMENT:
	// ********************************************************************************************
	this.statusEffectTypes.ToxicAttunement = new StatusEffectType();
	this.statusEffectTypes.ToxicAttunement.onUpdateStats = function (character) {
		character.toxicPower += this.toxicPower;
		character.manaConservation.Toxic += 1;
	};
	this.statusEffectTypes.ToxicAttunement.duration = 10;
	
	// CONFUSION:
	// ********************************************************************************************
	this.statusEffectTypes.Confusion = new StatusEffectType();
	this.statusEffectTypes.Confusion.onUpdateStats = function (character) {
		character.isConfused += 1;
	};
	this.statusEffectTypes.Confusion.duration = 10;
	
	// INFECTIOUS_DISEASE:
	// ********************************************************************************************
	this.statusEffectTypes.InfectiousDisease = new StatusEffectType();
	this.statusEffectTypes.InfectiousDisease.onUpdateTurn = function (character) {
		character.takeDamage(this.damage, 'Toxic', {neverCrit: true});
		
		// Spread:
		gs.getIndexListCardinalAdjacent(character.tileIndex).forEach(function (tileIndex) {
			var char = gs.getChar(tileIndex);
			
			if (char && (char.faction === FACTION.PLAYER || char.faction === FACTION.HOSTILE) && !char.statusEffects.has('InfectiousDisease') && !gs.inArray('InfectiousDisease', char.type.effectImmune)) {
				char.statusEffects.add('InfectiousDisease', {damage: this.damage, duration: this.duration});
			}
		}, this);
	};
	this.statusEffectTypes.InfectiousDisease.duration = 15;
	
	// FLAMING_HANDS:
	// ********************************************************************************************
	this.statusEffectTypes.FlamingHands = new StatusEffectType();
	this.statusEffectTypes.FlamingHands.duration = 10;
	
	// UI_SYMBOLS:
	// ********************************************************************************************
	this.statusEffectTypes.Berserk.uiSymbol = 'B';
	this.statusEffectTypes.Slow.uiSymbol = 'S';
	this.statusEffectTypes.Stunned.uiSymbol = 'S';
	this.statusEffectTypes.Haste.uiSymbol = 'H';
	this.statusEffectTypes.Confusion.uiSymbol = 'C';
	this.statusEffectTypes.InfectiousDisease.uiSymbol = 'D';
	
	this.nameTypes(this.statusEffectTypes);
};





/*global game, gs, Phaser, console, util*/
/*global Item*/
/*jshint laxbreak: true, esversion: 6*/
'use strict';

// CREATE_RELIGION_TYPES:
// ************************************************************************************************
gs.createReligionTypes = function () {
	this.religionTypes = {};
	
	// TROG:
	// Player will always crit when less then half hp
	this.religionTypes.Trog = {};
	this.religionTypes.Trog.desc = "You will go berserk and deal automatic critical hits whenever you are less then 1/3 HP.";
	this.religionTypes.Trog.effect = function (character) {
		if (character.currentHp <= character.maxHp / 3) {
			character.alwaysCrit += 1;
		}
	};
	
	// Wealth:
	// Player gains tons of gold when joining:
	this.religionTypes.Wealth = {};
	this.religionTypes.Wealth.desc = "You will immediately be giften with a hoard of gold coins.";
	this.religionTypes.Wealth.onSet = function (character) {
		gs.getIndexInBox(character.tileIndex.x - 1, character.tileIndex.y - 1, character.tileIndex.x + 2, character.tileIndex.y + 2).forEach(function (index) {
			if ((gs.isPassable(index) || gs.getChar(index)) && !gs.getItem(index)) {
				gs.createFloorItem(index, Item.createItem('GoldCoin', {amount: util.randInt(10, 20)}));
			}
		});
	};
	
	// ARCHER:
	// Player is occasionally gifted with projectiles
	this.religionTypes.TheArcher = {};
	this.religionTypes.TheArcher.desc = "The Archer will occasionally grant you a gift of projectiles.";
	this.religionTypes.TheArcher.onTurn = function (character) {
		var itemType;
		
		// Approx every 500 turns
		if (game.rnd.frac() < (1 / 500)) {
			itemType = util.randElem([gs.itemTypes.Dart, gs.itemTypes.Javelin]);
			gs.pc.inventory.addItem(Item.createItem(itemType.name, {mod: gs.dropItemModifier(itemType)}));
		}
	};
	
	// WIZARD:
	// Gives the player a chance to save mana on casting
	this.religionTypes.TheWizard = {};
	this.religionTypes.TheWizard.desc = "Your abilities will occasionally use no mana.";
	this.religionTypes.TheWizard.effect = function (character) {
		character.bonusSaveManaChance += 0.05;	
	};
	
	// HEALTH:
	// Player is occasionaly healed
	this.religionTypes.Health = {};
	this.religionTypes.Health.desc = "You will occasionally be healed when your health is less than 50%.";
	this.religionTypes.Health.onTurn = function (character) {
		// Every 200 turns
		if (gs.pc.currentHp < gs.pc.maxHp / 2 && game.rnd.frac() < (1 / 200)) {
			gs.pc.healHp(Math.ceil(gs.pc.maxHp / 2));
			gs.createParticlePoof(gs.pc.tileIndex, 'GREEN');
		}
	};
	
	// EXPLORATION:
	// Players health and mana is restored whenever a new level is generated
	this.religionTypes.Exploration = {};
	this.religionTypes.Exploration.desc = "If you are below 50% health when descending to a new, unexplored level, you will be healed to full.";
	
	this.nameTypes(this.religionTypes);
};

// CREATE_ALTER:
// ************************************************************************************************
gs.createAltar = function (tileIndex, typeName) {
	var indexList;
	this.createObject(tileIndex, typeName);
	
	indexList = gs.getIndexInBox(tileIndex.x - 1, tileIndex.y - 1, tileIndex.x + 2, tileIndex.y + 2);
	indexList = indexList.filter(index => game.rnd.frac() < 0.4);
	if (typeName === 'AltarOfTrog') {
		/*
		indexList = indexList.filter(index => gs.isValidSpawnIndex(index));
		if (gs.debugProperties.spawnMobs) {
			indexList.forEach(function (index) {
				gs.createNPC(index, 'GoblinBrute');
			}, this);
		}
		*/
	} 
	else if (typeName === 'AltarOfHealth') {
		/*
		indexList = indexList.filter(index => !gs.getItem(index) && gs.isPassable(index));
		indexList.forEach(function (index) {
			gs.createFloorItem(index, Item.createItem('PotionOfHealing'));
		}, this);
		*/
	} 
	else if (typeName === 'AltarOfTheWizard') {
		/*
		indexList = indexList.filter(index => !gs.getItem(index) && gs.isPassable(index));
		indexList.forEach(function (index) {
			gs.createFloorItem(index, Item.createItem('PotionOfEnergy'));
		}, this);
		*/
	} 
	else if (typeName === 'AltarOfWealth') {
		/*
		indexList = indexList.filter(index => !gs.getItem(index) && gs.isPassable(index));
		indexList.forEach(function (index) {
			gs.createFloorItem(index, Item.createItem('GoldCoin', {amount: gs.dropGoldAmount()}));
		}, this);
		*/
	} 
	else if (typeName === 'AltarOfTheArcher') {
		/*
		indexList = indexList.filter(index => !gs.getItem(index) && gs.isPassable(index));
		indexList.forEach(function (index) {
			gs.createFloorItem(index, Item.createItem('Javelin'));
		}, this);
		*/
	}
};/*global gs, game, console, util*/
/*global PARTICLE_FRAMES*/

'use strict';
// CREATE_PROJECTILE_TYPES:
// ************************************************************************************************
gs.createProjectileTypes = function () {
    this.createProjectileEffects();
    
    // Projectile Types:
    this.projectileTypes = {
		Dart: {
			frame: 1728,
			damageType: 'Physical',
			effect: null, 
			particleFrame: PARTICLE_FRAMES.WHITE
		},
		
		Stone: {
			frame: 1743,
			damageType: 'Physical',
			effect: null, 
			particleFrame: PARTICLE_FRAMES.WHITE
		},
		
		Oil: {
			frame: 1743,
			damageType: null,
			particleFrame: PARTICLE_FRAMES.WHITE,
			effect: this.projectileEffects.Oil,
			hitTargetTileIndex: true
		},
        
        Chakram: {
			frame: 52,
			damageType: 'Physical',
			effect: null,
            isTunnelShot: true,
			particleFrame: PARTICLE_FRAMES.WHITE
		},
		
		SleepingDart: {
			frame: 1728,
			damageType: null,
			effect: this.projectileEffects.SleepingDart,
			particleFrame: PARTICLE_FRAMES.WHITE,
			neverMiss: true
		},
		
		SmokeBomb: {
			frame: 1740,
			damageType: null,
			effect: this.projectileEffects.SmokeBomb,
			particleFrame: PARTICLE_FRAMES.WHITE,
			neverMiss: true,
			hitTargetTileIndex: true
		},
		
		SpiderWeb: {
			frame: 1730,
			damageType: null,
			effect: this.projectileEffects.Web,
			particleFrame: PARTICLE_FRAMES.WHITE,
			life: 5
		},
		
		Net: {
			frame: 1738,
			damageType: null,
			effect: this.projectileEffects.Net,
			particleFrame: PARTICLE_FRAMES.WHITE,
			life: 5
		},
		
		FireArrow: {
			frame: 1732,
			damageType: 'Fire',
			effect: this.projectileEffects.Fire,
			particleFrame: PARTICLE_FRAMES.RED,
			hitTargetTileIndex: true,
			neverMiss: true
		},
		
		FireBall: {
			frame: 1744,
			damageType: 'Fire',
			effect: this.projectileEffects.FireBall,
			particleFrame: PARTICLE_FRAMES.RED,
			hitTargetTileIndex: true,
			neverMiss: true,
			light: {color: '#ff0000', radius: 120, startAlpha: 66},
		},
		
		SparkBall: {
			frame: 1733,
			damageType: 'Fire',
			effect: this.projectileEffects.SparkBall,
			particleFrame: PARTICLE_FRAMES.WHITE,
			hitTargetTileIndex: true,
			neverMiss: true,
			light: {color: '#ffffff', radius: 30, startAlpha: 66},
		},
		
		Spark: {
			frame: 1733,
			damageType: 'Shock',
			effect: this.projectileEffects.Shock,
			particleFrame: PARTICLE_FRAMES.WHITE,
			hitTargetTileIndex: true,
			neverMiss: true,
			light: {color: '#ffffff', radius: 30, startAlpha: 66},
		},
		
		IceArrow: {
			frame: 1734,
			damageType: 'Cold',
			particleFrame: PARTICLE_FRAMES.WHITE,
			neverMiss: true,
			light: {color: '#ffffff', radius: 60, startAlpha: 44},
		},
		
		Snowball: {
			frame: 1742,
			damageType: 'Cold',
			particleFrame: PARTICLE_FRAMES.WHITE,
			neverMiss: true,
		},
		
		Acid: {
			frame: 1736,
			damageType: 'Toxic',
			particleFrame: PARTICLE_FRAMES.GREEN,
			neverMiss: true,
			light: {color: '#aaff00', radius: 60, startAlpha: 66},
		},
		
		PoisonArrow: {
			frame: 1736,
			damageType: 'Toxic',
			particleFrame: PARTICLE_FRAMES.GREEN,
			neverMiss: true,
			effect: this.projectileEffects.Poison,
			light: {color: '#aaff00', radius: 60, startAlpha: 66},
		},
		
		StrongPoisonArrow: {
			frame: 1736,
			damageType: 'Toxic',
			particleFrame: PARTICLE_FRAMES.GREEN,
			neverMiss: true,
			effect: this.projectileEffects.StrongPoison,
			light: {color: '#aaff00', radius: 60, startAlpha: 66},
		},
		
		LifeSpike: {
			frame: 1736,
			damageType: 'Toxic',
			particleFrame: PARTICLE_FRAMES.GREEN,
			neverMiss: true,
			effect: this.projectileEffects.LifeSpike,
			light: {color: '#aaff00', radius: 60, startAlpha: 66},
		},
		
		Bomb: {
			frame: 1740,
			hitTargetTileIndex: true,
			particleFrame: PARTICLE_FRAMES.WHITE,
			effect: this.projectileEffects.CreateBomb,
			perfectAim: true,
		},
		
		PlayerBomb: {
			frame: 1740,
			hitTargetTileIndex: true,
			particleFrame: PARTICLE_FRAMES.WHITE,
			effect: this.projectileEffects.FireBall,
		},
		
		PoisonGasBall: {
			frame: 1735,
			hitTargetTileIndex: true,
			particleFrame: PARTICLE_FRAMES.PURPLE,
			effect: this.projectileEffects.createPoisonGas
		},
		
		PlayerGasBall: {
			frame: 1735,
			hitTargetTileIndex: true,
			particleFrame: PARTICLE_FRAMES.PURPLE,
			effect: this.projectileEffects.createPlayerPoisonGas
		},
		
		MagicMissile: {
			frame: 1735,
			particleFrame: PARTICLE_FRAMES.PURPLE,
			damageType: 'Physical',
			effect: null,
			light: {color: '#ff00ff', radius: 60, startAlpha: 66},
			hitEffect: function () {
				var light = gs.createLightCircle(this.sprite.position, '#ff00ff', 30, 10);
				light.fade = false;
			}
		},
		
		SlimeBomb: {
			frame: 1736,
			particleFrame: PARTICLE_FRAMES.GREEN,
			neverMiss: true,
			effect: this.projectileEffects.createSlime
		},
	};
	gs.nameTypes(this.projectileTypes);
};

// CREATE_PROJECTILE_EFFECTS:
// ************************************************************************************************
gs.createProjectileEffects = function () {
    this.projectileEffects = {};
	
	// Web:
	this.projectileEffects.Web = function (targetChar, projectile) {
		targetChar.statusEffects.add('Webbed');
		gs.createVinePatch(targetChar.tileIndex, 1, 'SpiderWeb');
	};
	
	// Net:
	this.projectileEffects.Net = function (targetChar, projectile) {
		// Added test for traps:
		if (targetChar.statusEffects) {	
			targetChar.statusEffects.add('Netted', {duration: 8});
		}
	};
	
	// Fire:
	this.projectileEffects.Fire = function (targetChar, projectile) {
		gs.createFire(targetChar.tileIndex, projectile.damage, projectile.flags);
	};
	
	// Poison:
	this.projectileEffects.Poison = function (targetChar, projectile) {
		// Added test for traps:
		if (targetChar.statusEffects) {	
			targetChar.addPoisonDamage(projectile.damage);
		}
	};
	
	// Strong Poison:
	this.projectileEffects.StrongPoison = function (targetChar, projectile) {
		// Added test for traps:
		if (targetChar.statusEffects) {	
			targetChar.statusEffects.add('StrongPoison', {damage: projectile.damage});
		}
	};
	
	// Life Spike:
	this.projectileEffects.LifeSpike = function (targetChar, projectile) {
		
		gs.playSound(gs.sounds.playerHit, targetChar.tileIndex);
		targetChar.statusEffects.add('LifeSpike', {
			duration: projectile.flags.duration, 
			damage: projectile.damage, 
			actingCharacterId: projectile.fromCharacter.id
		});
		gs.createParticlePoof(targetChar.tileIndex, 'PURPLE');
	};
	
	// FireBall:
	this.projectileEffects.FireBall = function (targetChar, projectile) {
		//projectile.flags.damageDropOff = true;
		gs.createExplosion(targetChar.tileIndex, 1, projectile.damage, projectile.flags);
	};
	
	// SparkBall:
	this.projectileEffects.SparkBall = function (targetChar, projectile) {
		gs.getIndexInRadius(targetChar.tileIndex, 1.0).forEach(function (index) {
			if (gs.isStaticPassable(index)) {
				gs.createShock(index, projectile.damage, projectile.flags);
			}
		}, this);
	};
	
	
	
	// Shock:
	this.projectileEffects.Shock = function (targetChar, projectile) {
		gs.createShock(targetChar.tileIndex, projectile.damage, projectile.flags);
	};
	
	// Create Bomb:
	this.projectileEffects.CreateBomb = function (targetTile, projectile) {
		var bomb = gs.createObject(targetTile.tileIndex, 'Bomb');
		bomb.damage = projectile.damage;
	};
	
	// Smoke Bomb:
	this.projectileEffects.SmokeBomb = function (targetTile, projectile) {
		
		gs.createLightCircle(util.toPosition(targetTile.tileIndex), '#ffffff', 120, 10);
		
		gs.getIndexInRadius(targetTile.tileIndex, 1.5).forEach(function (tileIndex) {
			if (gs.isStaticPassable(tileIndex) && !gs.getCloud(tileIndex)) {
				gs.createCloud(tileIndex, 'WhiteSmoke', 0, projectile.flags.duration);
			}
		}, this);
		
		gs.calculateLoS();
	};
	
	// Oil:
	this.projectileEffects.Oil = function (targetTile, projectile) {
		gs.getIndexInRadius(targetTile.tileIndex, 1.5).forEach(function (tileIndex) {
			if (gs.isStaticPassable(tileIndex) && !gs.getObj(tileIndex)) {
				gs.createObject(tileIndex, 'Oil');
			}
		}, this);
	};
	
	// Sleeping Dart:
	this.projectileEffects.SleepingDart = function (targetChar, projectile) {
		targetChar.goToSleep();
		targetChar.statusEffects.add('DeepSleep', {duration: projectile.flags.duration});
	};
	
	// Poison Gas Ball:
	this.projectileEffects.createPoisonGas = function (targetTile, projectile) {
		gs.playSound(gs.sounds.fire, targetTile.tileIndex);
		gs.createCloud(targetTile.tileIndex, 'PoisonGas', projectile.damage, 15);	
	};
	
	// Player Gas Ball:
	this.projectileEffects.createPlayerPoisonGas = function (targetTile, projectile) {
		gs.playSound(gs.sounds.fire, targetTile.tileIndex);
		gs.createCloud(targetTile.tileIndex, 'PoisonGas', projectile.damage, 15);	
	};
	
	
	
	// Create Slime:
	this.projectileEffects.createSlime = function (targetChar, projectile) {
		gs.createVinePatch(targetChar.tileIndex, 2, 'Slime', 0.75);
		targetChar.onEnterTileBase();
	};
};/*global game, gs, console, util*/
/*global LOS_DISTANCE, TILE_SIZE*/
/*global Particle, ParticleGenerator, SPREAD_DAMAGE_MOD, PROJECTILE_SPEED, SCALE_FACTOR, REFLECTION_PERCENT_PER_POINT*/
/*jshint laxbreak: true, esversion: 6*/
'use strict';


// CREATE_PROJECTILE_POOL:
// ************************************************************************************************
gs.createProjectilePool = function () {
	this.projectilePool = [];
	for (let i = 0; i < 50; i += 1) {
		this.projectilePool[i] = new Projectile();
	}
};

// CREATE_PROJECTILE:
// ************************************************************************************************
gs.createProjectile = function (fromCharacter, targetTileIndex, typeName, damage, flags) {
	for (let i = 0; i < this.projectilePool.length; i += 1) {
		if (!this.projectilePool[i].isAlive) {
			this.projectilePool[i].init(fromCharacter, targetTileIndex, typeName, damage, flags);
			return this.projectilePool[i];
		}
	}
	
	// Pool size exceeded:
	this.projectilePool.push(new Projectile());
	this.projectilePool[this.projectilePool.length - 1].init(fromCharacter, targetTileIndex, typeName, damage, flags);
	return this.projectilePool[this.projectilePool.length -1];
};

// CONSTRUCTOR:
// ************************************************************************************************
function Projectile() {
	this.isAlive = false;
	
	// Sprite:
    this.sprite = gs.createSprite(0, 0, 'Tileset', gs.projectileSpritesGroup);
	this.sprite.anchor.setTo(0.5, 0.5);
    this.sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	this.sprite.visible = false;
}

// INIT:
// *******************************************************************************
Projectile.prototype.init = function (fromCharacter, targetTileIndex, typeName, damage, flags) {
	 var startPosition = util.toPosition(fromCharacter.tileIndex), light;
    
    flags = flags || {};
    
    // Properties:
    this.normal = gs.getNormal(startPosition, util.toPosition(targetTileIndex));
    this.ignoreCharacters = [fromCharacter];
    this.isAlive = true;
    this.type = gs.projectileTypes[typeName];
    this.targetTileIndex = {x: targetTileIndex.x, y: targetTileIndex.y};
    this.damage = damage;
    this.damageType = this.type.damageType;
    this.flags = flags;
    this.distance = 0;
    this.tileIndex = {x: fromCharacter.tileIndex.x, y: fromCharacter.tileIndex.y};
	this.isTunnelShot = flags.isTunnelShot || this.type.isTunnelShot;
	this.isCrit = flags.isCrit;
	this.knockBack = flags.knockBack || 0;
    this.particleTimer = 0;
	this.fromCharacter = fromCharacter;
	this.perfectAim = flags.perfectAim || this.type.perfectAim;

	// Sprite:
	this.sprite.x = startPosition.x;
	this.sprite.y = startPosition.y;
   	this.sprite.rotation = game.math.angleBetween(fromCharacter.tileIndex.x, fromCharacter.tileIndex.y, targetTileIndex.x, targetTileIndex.y) + Math.PI / 2;
	this.sprite.frame = this.type.frame;
	this.sprite.visible = true;
	
	// Light:
	if (this.type.light) {
		this.light = gs.createLightCircle(this.sprite.position, this.type.light.color, this.type.light.radius, 0, this.type.light.startAlpha);
		this.light.noLife = true;
		this.light.fade = false;
	}
		
	
    // Push to list:
    gs.projectileList.push(this);
};

// UPDATE:
// *******************************************************************************
Projectile.prototype.update = function () {
    var nextPos,
		tileIndex = gs.toTileIndex(this.sprite.position),
		didHit;
	
    // Hit characters:
    // Note the bit about passing solids is to handle perfect aim which passes through non-targets
    if (gs.getChar(tileIndex) && !gs.inArray(gs.getChar(tileIndex), this.ignoreCharacters) && (!this.perfectAim || this.isTunnelShot || gs.vectorEqual(tileIndex, this.targetTileIndex))) {
		
		didHit = this.hitCharacter(gs.getChar(tileIndex));
		this.ignoreCharacters.push(gs.getChar(tileIndex));
        
		// Destroy non tunnel shot projectiles:
		if (didHit && !this.isTunnelShot) {
			this.destroy();
			return;
		}
    }
	
	// Hit Trap:
	if (gs.vectorEqual(tileIndex, this.targetTileIndex) && gs.getObj(tileIndex) && gs.canShootTrap(tileIndex) && !gs.getChar(tileIndex)) {
        this.hitTrap(gs.getObj(tileIndex));
        this.destroy();
        return;
	}
	
	
	// Hit targetTileIndex:
	if (gs.vectorEqual(tileIndex, this.targetTileIndex) && this.type.hitTargetTileIndex) {
		if (!gs.getChar(tileIndex) || didHit) {
			this.hitTargetTileIndex(tileIndex);
			this.destroy();
			return;
		}	
	}
	
	// Hit Wall
	if (!gs.getChar(tileIndex) && !gs.isPassable(tileIndex)) {
		this.destroy();
		return;
	}

    // Move:
    this.sprite.x += this.normal.x * PROJECTILE_SPEED;
    this.sprite.y += this.normal.y * PROJECTILE_SPEED;
	this.distance += PROJECTILE_SPEED;
	this.tileIndex = gs.toTileIndex(this.sprite.position);
    
	// Move Light:
	if (this.light) {
		this.light.sprite.x = this.sprite.x;
		this.light.sprite.y = this.sprite.y;
	}
	
	// Particles:
	if (this.type.particleFrame) {
		this.particleTimer += 1;
		
		/*
		if (this.particleTimer > 2) {
			gs.createParticle(this.sprite.position, {frame: this.type.particleFrame, acc: {x: 0, y: 0}, duration: 30, fadePct: 0.5});
			this.particleTimer = 0;
		}
		*/
		
		if (this.particleTimer > 0 && this.distance > 50) {
			gs.createParticle(this.sprite.position, {frame: this.type.particleFrame, acc: {x: 0, y: 0}, duration: 12, fadePct: 0.5});
			this.particleTimer = 0;
		}
	}
	
    // Destroy after distance or out of bounds:
	if (this.distance >= LOS_DISTANCE * TILE_SIZE || !gs.isInBounds(gs.toTileIndex(this.sprite.position))) {
		this.destroy();
	}
};

// HIT_CHARACTER:
// ************************************************************************************************
Projectile.prototype.hitCharacter = function (character) {
    var attackResult = character.attackResult(this.fromCharacter, 'Range'),
        tileIndex = gs.toTileIndex(this.sprite.position);
    
	// Hitting (or missing) someone with a projectile agros and wakes them up
	character.isAgroed = true;
	character.isAsleep = false;
	
	// REFLECTION:
	if (game.rnd.frac() < character.reflectPercent()) {
		character.popUpText('REFLECT', '#ffffff');
		// Note how we effectively reset ignoreCharacters so that the shooter can be hit
		this.ignoreCharacters = [character];
		this.perfectAim = false;
		this.normal.x = -this.normal.x;
		this.normal.y = -this.normal.y;
		this.distance = 0;
		return false;
	}
    // MISS:
    else if (attackResult === 'MISS' && !this.isCrit && !this.type.neverMiss) {
        character.popUpText('MISS', '#ffffff');
        this.ignoreCharacters.push(character);
		return false;
    }
	// HIT or CRITICAL:
	else {
		// Projectile Effects:
		if (this.type.effect) {
			this.type.effect(character, this);
		}
        // Damaging projectiles hitting characters:
        else {
			if (character !== gs.pc && attackResult === 'CRITICAL') {
				this.flags.isCrit = true;
			}
            
			if (this.isCrit) {
				this.flags.isCrit = this.isCrit;
			}
			
            character.takeDamage(this.damage, this.damageType, this.flags);
        }
		
		if (this.knockBack > 0 && character.isAlive) {
			character.body.applyKnockBack(this.normal, this.knockBack);
		}
		return true;
    }
};

// HIT_TARGET_TILE_INDEX:
// ************************************************************************************************
Projectile.prototype.hitTargetTileIndex = function (tileIndex) {
	if (this.type.effect) {
		this.type.effect({tileIndex: tileIndex}, this);
	}
};

// HIT_TRAP:
// ************************************************************************************************
Projectile.prototype.hitTrap = function (trap) {
	if (gs.canShootTrap(trap.tileIndex)) {
		trap.stepOn(null);
	}
	
	if (this.type.effect) {
		this.type.effect({tileIndex: trap.tileIndex}, this);
	}
};

// DESTROY:
// ************************************************************************************************
Projectile.prototype.destroy = function () {
	gs.createAnimEffect(this.sprite.position, 'Hit');
	
	if (this.type.hitEffect) {
		this.type.hitEffect.call(this);
	}
	
    this.isAlive = false;
    this.sprite.visible = false;
	
	if (this.light) {
		this.light.destroy();
		this.light = null;
	}
};

// UPDATE_PROJECTILES:
// ************************************************************************************************
gs.updateProjectiles = function () {
    // Remove dead projectiles:
    for (let i = this.projectileList.length - 1; i >= 0; i -= 1) {
        if (!this.projectileList[i].isAlive) {
            this.projectileList.splice(i, 1);
        }
    }
    
    for (let i = 0; i < this.projectileList.length; i += 1) {
        this.projectileList[i].update();
    }
};

// DESTROY_ALL_PROJECTILES:
// ************************************************************************************************
gs.destroyAllProjectiles = function () {
	// Destroy Projectiles:
	for (let i = 0; i < this.projectileList.length; i += 1) {
		this.projectileList[i].destroy();
	}
	
	// Destroy particles:
	for (let i = 0; i < this.particleList.length; i += 1) {
		this.particleList[i].destroy();
	}
	
	// Destroy particle generators:
	for (let i = 0; i < this.particleGeneratorList.length; i += 1) {
		this.particleGeneratorList[i].destroy();
	}
	
	this.projectileList = [];
	this.particleList = [];
	this.particleGeneratorList = [];
	
};

/*global game, gs, console, util*/
/*global SCALE_FACTOR, KNOCK_BACK_SPEED*/
/*global Particle, ParticleGenerator, PARTICLE_FRAMES, TILE_SIZE*/
/*jshint esversion: 6*/

'use strict';

// CREATE_PARTICLE_POOL:
// ************************************************************************************************
gs.createParticlePool = function () {
	this.particlePool = [];
	for (let i = 0; i < 100; i += 1) {
		this.particlePool[i] = new Particle();
	}
};

// PARTICLE:
// ************************************************************************************************
gs.createParticle = function (position, attributes) {
	for (let i = 0; i < this.particlePool.length; i += 1) {
		if (!this.particlePool[i].isAlive) {
			this.particlePool[i].init(position, attributes);
			return this.particlePool[i];
		}
	}
	
	// Pool size exceeded:
	this.particlePool.push(new Particle());
	this.particlePool[this.particlePool.length - 1].init(position, attributes);
	return this.particlePool[this.particlePool.length -1];
	
};

// PARTICLE_CONSTRUCTOR:
// ************************************************************************************************
// attributes: {duration, fadePct, vel, acc, frame}
function Particle() {
	this.isAlive = false;
	
	// Sprite:
	this.sprite = gs.createSprite(0, 0, 'Tileset', gs.projectileSpritesGroup);
	this.sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	this.sprite.anchor.setTo(0.5, 0.5);
	this.sprite.visible = false;
}

// PARTICLE_INIT:
// ************************************************************************************************
Particle.prototype.init = function (position, attributes) {
	this.isAlive = true;
	this.life = 0;
	
	// Properties:
	this.duration = attributes.duration;
	this.fadePct = attributes.fadePct;
	this.velocity = attributes.vel || {x: 0, y: 0};
	this.acc = attributes.acc || {x: 0, y: -0.01};
	
	// Sprite:
	this.sprite.x = position.x;
	this.sprite.y = position.y;
	this.sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	this.sprite.frame = attributes.frame;
	this.sprite.visible = true;
	
	gs.particleList.push(this);
};

// PARTICLE_UPDATE:
// ************************************************************************************************
Particle.prototype.update = function () {
	var fade;
	
	// Destroy when the particle runs out of life:
	this.life += 1;
	if (this.life >= this.duration) {
		this.destroy();
	}
	
	// Fading the sprite by reducing size:
	if (this.life >= this.duration * this.fadePct) {
		fade = (this.duration - this.life) / (this.duration * (1 - this.fadePct));
		this.sprite.scale.setTo(fade * SCALE_FACTOR, fade * SCALE_FACTOR);
	}
	
	// Apply Acceleration:
	this.velocity.x += this.acc.x;
	this.velocity.y += this.acc.y;
	
	// Apply velocity:
	this.sprite.x += this.velocity.x;
	this.sprite.y += this.velocity.y;
};

// PARTICLE_DESTROY:
// ************************************************************************************************
Particle.prototype.destroy = function () {
	this.isAlive = false;
	this.sprite.visible = false;
};

// PARTICLE_GENERATOR:
// ************************************************************************************************
gs.createParticleGenerator = function (position, attributes) {
	return new ParticleGenerator(position, attributes);
};

function ParticleGenerator(position, attributes) {
	this.isAlive = true;
	this.life = 0;
	this.particleTimer = 0;
	this.position = {x: position.x, y: position.y};
	
	// Properties:
	this.duration = attributes.duration;
	this.numParticles = attributes.numParticles || 1;
	this.particleTime = attributes.particleTime;
	this.particleFrame = attributes.particleFrame;
	this.particleLife = attributes.particleLife;
	this.particleFadePct = attributes.particleFadePct;
	this.acc = attributes.acc;
	this.vel = attributes.vel;
	
	gs.particleGeneratorList.push(this);
}

// PARTICLE_GENERATOR_UPDATE:
// ************************************************************************************************
ParticleGenerator.prototype.update = function () {
	var i;
	
	this.life += 1;
	if (this.duration !== 'infinite' && this.life >= this.duration) {
		this.isAlive = false;
	}
	
	this.particleTimer += 1;
	if (this.particleTimer >= this.particleTime) {
		for (i = 0; i < this.numParticles; i += 1) {
			gs.createParticle({x: this.position.x + util.randInt(-16, 16),
									  y: this.position.y + util.randInt(-4, 4)},
									 {duration: this.particleLife,
									  fadePct: this.particleFadePct,
									  frame: this.particleFrame,
									  acc: this.acc,
									  vel: this.vel});
		}
		this.particleTimer = 0;
	}
};

// UPADATE_PARTICLE_GENERATORS:
// ************************************************************************************************
gs.updateParticleGenerators = function () {
    var i;
    
    // Remove dead particles generators:
    for (i = this.particleGeneratorList.length - 1; i >= 0; i -= 1) {
        if (!this.particleGeneratorList[i].isAlive) {
            this.particleGeneratorList.splice(i, 1);
        }
    }
    
    for (i = 0; i < this.particleGeneratorList.length; i += 1) {
        this.particleGeneratorList[i].update();
    }
};



// CREATE_SPELL_PARTICLE:
// Standard spell particle generator
// Color: [GREEN, PURPLE, RED, BLUE]
// ************************************************************************************************
gs.createParticlePoof = function (tileIndex, color) {
	var position = util.toPosition(tileIndex);
	
	if (!gs.getTile(tileIndex).visible) {
		return;
	}
	
	return gs.createParticleGenerator({x: position.x, y: position.y + 12},
									   {duration: 4,
										numParticles: 10,
										particleTime: 1,
										particleLife: 90,
										particleFadePct: 0.3,
										particleFrame: PARTICLE_FRAMES[color]});
};



// POOF:
gs.createParticlePoof = function (tileIndex, color, num) {
	var position = util.toPosition(tileIndex),
		i;
	
	num = num || 20;
	
	if (!gs.getTile(tileIndex).visible) {
		return;
	}
	
	color = color || 'WHITE';
	
	for (i = 0; i < num; i += 1) {
		
		this.createParticle({x: position.x + util.randInt(-20, 20), y: position.y + 10 + util.randInt(-10, 10)},
						    {duration: 50,
							 fadePct: 0.75,
							 vel: {x: util.randInt(-200, 200) * 0.005, y: -3.0 + util.randInt(0, 100) * 0.005},
							 acc: {x: 0, y: 0.1},
							 frame: PARTICLE_FRAMES[color]});
	}
};

// CREATE_PARTICLE_BURST:
// An angled burst of particles:
// ************************************************************************************************
gs.createParticleBurst = function (position, normal, color) {
	var i, num = 10;
	
	if (!gs.getTile(gs.toTileIndex(position)).visible) {
		return;
	}
	
	color = color || 'WHITE';
	
	for (i = 0; i < num; i += 1) {
		
		this.createParticle({x: position.x + util.randInt(-15, 15), y: position.y + util.randInt(-15, 15)},
						    {duration: 20,
							 fadePct: 0.75,
							 vel: {x: normal.x * 5, y: normal.y * 5},
							 acc: {x: 0, y: 0},
							 frame: PARTICLE_FRAMES[color]});
	}
};

// CREATE_CASTING_PARTICLE:
// Standard spell particle generator
// Color: [GREEN, PURPLE, RED, BLUE]
// ************************************************************************************************
gs.createCastingParticle = function (tileIndex, color) {
	var position = util.toPosition(tileIndex);
	
	if (!gs.getTile(tileIndex).visible) {
		return;
	}
	return gs.createParticleGenerator({x: position.x, y: position.y + 6},
																   {duration: 'infinite',
																	particleTime: 10,
																	particleLife: 90,
																	particleFadePct: 0.3,
																	particleFrame: PARTICLE_FRAMES[color]});
};

// UPADTE_PARTICLES:
// ************************************************************************************************
gs.updateParticles = function () {    
    // Remove dead particles:
    for (let i = this.particleList.length - 1; i >= 0; i -= 1) {
        if (!this.particleList[i].isAlive) {
            this.particleList.splice(i, 1);
        }
    }
    
    for (let i = 0; i < this.particleList.length; i += 1) {
        this.particleList[i].update();
    }
};/*global game, gs, console, util*/
/*global TILE_SIZE, SCALE_FACTOR*/
/*global SPREAD_DAMAGE_MOD*/
/*jshint esversion: 6, laxbreak: true*/
'use strict';

// CREATE_SHOCK:
// ************************************************************************************************
gs.createShock = function (tileIndex, damage, flags) {
	return new Shock(tileIndex, damage, flags);
};

// CREATE_FIRE:
// ************************************************************************************************
gs.createFire = function (tileIndex, damage, flags) {
	return new Fire(tileIndex, damage, flags);
};


// CREATE_EXPLOSION_CROSS:
// ************************************************************************************************
gs.createExplosionCross = function (tileIndex, range, damage, flags) {
	var indexList;
	
	indexList = gs.getIndexInRadius(tileIndex, range);
	indexList = indexList.filter(index => gs.isStaticPassable(index));
	indexList = indexList.filter(index => gs.isRayStaticPassable(index, tileIndex));
	indexList = indexList.filter(index => index.x === tileIndex.x || index.y === tileIndex.y);
	
	indexList.forEach(function (index) {
		this.createFire(index, damage, flags);
	}, this);
	
	// Camera shake:
	if (gs.getTile(tileIndex).visible) {
		game.camera.shake(0.010, 100);
	}
	
	// Sound:
	gs.playSound(gs.sounds.explosion, tileIndex);
};

// CREATE_EXPLOSION:
// ************************************************************************************************
gs.createExplosion = function (atTileIndex, range, damage, flags) {
	var indexList;
	
	indexList = gs.getIndexInRadius(atTileIndex, range);
	indexList = indexList.filter(index => gs.isPassable(index) || gs.getChar(index));
	indexList = indexList.filter(index => gs.isRayStaticPassable(index, atTileIndex));
	indexList.forEach(function (index) {
		
		if (flags.damageDropOff && gs.distance(atTileIndex, index) > 0) {
			this.createFire(index, Math.ceil(damage / 2), flags);
		}
		else {
			this.createFire(index, damage, flags);
		}
	}, this);
	
	// Camera shake:
	if (gs.getTile(atTileIndex).visible) {
		game.camera.shake(0.010, 100);
	}
	
	//game.camera.flash(0xff0000, 25);
	
	// Sound:
	gs.playSound(gs.sounds.explosion, atTileIndex);
};



// SHOCK_CONSTRUCTOR:
// ************************************************************************************************
function Shock (tileIndex, damage, flags = {}) {
	var startPos = util.toPosition(tileIndex),
		character;
	
    this.tileIndex = {x: tileIndex.x, y: tileIndex.y};
    this.damage = damage;
    this.isAlive = true;
    this.flags = flags;
	this.name = 'Electricity';
	this.life = 20;
	this.isTransparent = true;
	
	if (flags.hasOwnProperty('spread')) {
		this.spread = flags.spread;
	}
	else {
		this.spread = 4;
	}
	
	// Create sprite:
    this.sprite = gs.createSprite(startPos.x, startPos.y, 'Tileset', gs.projectileSpritesGroup);
    this.sprite.anchor.setTo(0.5, 0.5);
	this.sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
    this.sprite.animations.add('Explode', [1637, 1638, 1639, 1640, 1641], 10);
    this.sprite.play('Explode');
    
	// Lighting
	gs.createLightCircle(this.sprite.position, '#ffffff', 120, 30, '66');
	
	// Sound:
	gs.playSound(gs.sounds.shock, this.tileIndex);
	
	// Damage characters:
	character = gs.getChar(this.tileIndex);
    if (character && character.isAlive && (this.spread === 4 || !character.isFlying)) {
        character.takeDamage(damage, 'Shock', flags);
    }
	
	gs.getTile(this.tileIndex).effect = this;
	gs.projectileList.push(this);
}

// STEP_ON:
// ************************************************************************************************
Shock.prototype.stepOn = function () {
	console.log('Shock.stepOn() should never be called (report this)');
};

// CAN_SPREAD_ON:
// ************************************************************************************************
Shock.prototype.canSpreadOn = function (tileIndex) {
	if (gs.getEffect(tileIndex)) {
		return false;
	}
	else {
		return gs.getTile(tileIndex).type.name === 'Water'
			|| gs.getCloud(tileIndex) && gs.getCloud(tileIndex).type.name === 'Steam'
			|| gs.getCloud(tileIndex) && gs.getCloud(tileIndex).type.name === 'FreezingCloud';
	}
};

// UPDATE_SHOCK:
// ************************************************************************************************
Shock.prototype.update = function () {
	var spreadDamage = Math.floor(this.damage * SPREAD_DAMAGE_MOD),
		shock;
	
	if (this.sprite.frame === 1638 && spreadDamage > 0 && this.spread > 0) {
		gs.getIndexListCardinalAdjacent(this.tileIndex).forEach(function (tileIndex) {
			if (this.canSpreadOn(tileIndex)) {
				this.flags.spread = this.spread - 1;
				shock = gs.createShock(tileIndex, spreadDamage, this.flags);
			}
		}, this);
	}
			
	// Added life to make sure shock disapears
	this.life -= 1;
	if (this.sprite.frame >= 1641 || this.life <= 0) {
        this.destroy();
    }
};

// DESTROY:
// ************************************************************************************************
Shock.prototype.destroy = function () {
	this.sprite.destroy();
	gs.getTile(this.tileIndex).effect = null;
	this.isAlive = false;
};


// FIRE_CONSTRUCTOR:
// ************************************************************************************************
function Fire (tileIndex, damage, flags) {
    var startPos = util.toPosition(tileIndex);
    
    this.tileIndex = {x: tileIndex.x, y: tileIndex.y};
    this.damage = damage;
    this.isAlive = true;
    this.flags = flags;
	this.life = 20;
	this.isTransparent = true;
	this.spread = 6;
	
    // Create sprite:
    this.sprite = gs.createSprite(startPos.x, startPos.y, 'Tileset', gs.projectileSpritesGroup);
	this.sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
    this.sprite.anchor.setTo(0.5, 0.5);
    this.sprite.animations.add('Explode', [1632, 1633, 1634, 1635, 1636], 10);
    this.sprite.play('Explode');
	
	// Particle:
	//gs.createParticlePoof(this.tileIndex, 'RED', 10);
    
	// Light:
	gs.createLightCircle(this.sprite.position, '#ff0000', 120, 30, '66');
	
	// Sound:
	gs.playSound(gs.sounds.fire, this.tileIndex);
	
    // Damage characters:
    if (gs.getChar(this.tileIndex) && gs.getChar(this.tileIndex).isAlive) {
        gs.getChar(this.tileIndex).takeDamage(damage, 'Fire', flags);
    }
    
    // Destroy Flammable Objects:
	if (gs.getObj(this.tileIndex, obj => obj.type.isFlammable)) {
		gs.destroyObject(gs.getObj(this.tileIndex));
	}
	
	// Destroy Mushrooms:
	if (gs.getObj(this.tileIndex, obj => obj.type.name === 'FireShroom')) {
		gs.destroyObject(gs.getObj(this.tileIndex));
	}
	
	// Destroy Ice:
	if (gs.getObj(this.tileIndex, obj => obj.type.name === 'Ice')) {
		gs.destroyObject(gs.getObj(this.tileIndex));
	}
	
	// Destroy Flammable effects:
	if (gs.getCloud(this.tileIndex) && gs.getCloud(this.tileIndex).type.isFlammable) {
		gs.getCloud(this.tileIndex).destroy();
	}
	
	// Destroy Freezing Cloud:
	if (gs.getCloud(this.tileIndex) && gs.getCloud(this.tileIndex).type.name === 'FreezingCloud') {
		gs.getCloud(this.tileIndex).destroy();
	}
	
	// Create Steam:
	if (gs.getTile(this.tileIndex).type.name === 'Water' && !gs.getCloud(tileIndex)) {
		gs.createCloud(this.tileIndex, 'Steam', 0, 10);
		gs.calculateLoS();
	}
	
    gs.projectileList.push(this);
}

// STEP_ON:
// ************************************************************************************************
Fire.prototype.stepOn = function () {
	console.log('Fire.stepOn() should never be called (report this)');
};

// CAN_SPREAD_ON:
// ************************************************************************************************
Fire.prototype.canSpreadOn = function (tileIndex) {
	return gs.getObj(tileIndex, obj => obj.type.isFlammable)
		|| gs.getCloud(tileIndex) && gs.getCloud(tileIndex).type.isFlammable;
};

// UPDATE_FIRE:
// ************************************************************************************************
Fire.prototype.update = function () {
	var spreadDamage = this.damage, //Math.floor(this.damage * SPREAD_DAMAGE_MOD),
		fire;
	
	this.life -= 1;
	
    // Set adjacent vines on fire:
    if (this.sprite.frame === 1633 && spreadDamage > 0 && this.spread > 0) {
		gs.getIndexListCardinalAdjacent(this.tileIndex).forEach(function (tileIndex) {
			if (this.canSpreadOn(tileIndex)) {
				fire = gs.createFire(tileIndex, spreadDamage, this.flags);
				fire.spread = this.spread - 1;
			}
		}, this);
    }
	
	
	// Destroy fire:
	if (this.sprite.frame >= 1636 || this.life <= 0) {
       this.destroy();
    }
};

// DESTROY:
// ************************************************************************************************
Fire.prototype.destroy = function () {
	this.sprite.destroy();
	this.isAlive = false;
};




/*global gs, console, util*/
/*global SCALE_FACTOR, MOVEMENT_SPEED*/
/*jshint esversion: 6*/

'use strict';

// CREATE_CLOUD_TYPES:
// ************************************************************************************************
gs.createCloudTypes = function () {
	this.cloudUpdateTurn = {};
	this.cloudCharacterTurnEffect = {};
	this.cloudOnEnterTile = {};
	this.cloudOnDestroy = {};
	
	// POISON_GAS_UPDATE_TURN:
	this.cloudUpdateTurn.PoisonGas = function () {
		var newGas;

		if (this.life > this.startLife * 0.75) { 
			gs.getIndexListCardinalAdjacent(this.tileIndex).forEach(function (tileIndex) {
				if (gs.isTileIndexTransparent(tileIndex) && !gs.getCloud(tileIndex)) {
					newGas = gs.createCloud(tileIndex, this.type.name, this.damage, this.life - 1);
					newGas.startLife = this.startLife;
				}
			}, this);
		} 
	};
	
	// SMOKE_UPDATE_TURN:
	this.cloudUpdateTurn.Smoke = function () {
		if (this.sprite.frame === this.type.frame) {
			this.sprite.frame = this.type.frame + 1;
		}
	};
	
	// POISON_GAS_CHARACTER_TURN_EFFECT:
	this.cloudCharacterTurnEffect.PoisonGas = function (character) {
		if (!character.type.gasImmune) {
			character.takeDamage(this.damage, 'Toxic', {killer: 'Gas'});
		}
	};
	
	// FLAMING_CLOUD_CHARACTER_TURN_EFFECT:
	this.cloudCharacterTurnEffect.FlamingCloud = function (character) {
		if (!character.type.flamingCloudImmune) {
			character.takeDamage(this.damage, 'Fire', {killer: 'FlamingCloud'});
		}
	};
	
	// FREEZING_CLOUD_CHARACTER_TURN_EFFECT:
	this.cloudCharacterTurnEffect.FreezingCloud = function (character) {
		character.takeDamage(this.damage, 'Cold', {killer: 'FreezingCloud'});
	};
	
	// FLAMING_CLOUD_ON_DESTROY:
	this.cloudOnDestroy.FlamingCloud = function () {
		gs.createCloud(this.tileIndex, 'Smoke', 0, 2);
	};
	
	// Create Cloud Types:
	this.cloudTypes = {
		PoisonGas: {
			frame: 1600,
			alpha: 0.75,
			updateTurn: this.cloudUpdateTurn.PoisonGas,
			characterTurnEffect: this.cloudCharacterTurnEffect.PoisonGas,
			isFlammable: true
		},
		
		PoisonCloud: {
			frame: 1600,
			alpha: 0.75,
			characterTurnEffect: this.cloudCharacterTurnEffect.PoisonGas,
			isFlammable: true
		},
		
		FreezingCloud: {
			frame: 1601,
			alpha: 0.75,
			characterTurnEffect: this.cloudCharacterTurnEffect.FreezingCloud
		},
		
		FlamingCloud: {
			frame: 1603,
			alpha: 0.75,
			updateTurn: null,
			characterTurnEffect: this.cloudCharacterTurnEffect.FlamingCloud,
			onDestroy: this.cloudOnDestroy.FlamingCloud,
		},
		
		Smoke: {
			frame: 1604,
			alpha: 0.75,
			updateTurn: this.cloudUpdateTurn.Smoke,
			isSafe: true,
		},
		
		WhiteSmoke: {
			frame: 1606,
			alpha: 0.75,
			isTransparent: false,
			isSafe: true,
		},
		
		Steam: {
			frame: 1606,
			alpha: 0.75,
			isTransparent: false,
			isSafe: true,
			updateTurn: this.cloudUpdateTurn.PoisonGas,
		},
		
		Dust: {
			frame: 1608,
			alpha: 0.5,
			isTransparent: false,
			isSafe: true,
		}
	};
	
	this.nameTypes(this.cloudTypes);
	
	this.forEachType(this.cloudTypes, function (type) {
		if (!type.hasOwnProperty('isTransparent')) {
			type.isTransparent = true;
		}
	}, this);
};


// CREATE_CLOUD:
// ************************************************************************************************
gs.createCloud = function (tileIndex, typeName, damage, life) {
	// Clouds will overwrite existing clouds:
	if (gs.getCloud(tileIndex)) {
		gs.getCloud(tileIndex).destroy();
	}
	
    return new Cloud(tileIndex, typeName, damage, life);
};

// CLOUD_CONSTRUCTOR:
// ************************************************************************************************
function Cloud(tileIndex, typeName, damage, life) {
	var position = util.toPosition(tileIndex);
	
	// Properties:
	this.type = gs.cloudTypes[typeName];
	this.name = gs.capitalSplit(this.type.name);
	this.life = life || 20;
	this.startLife = this.life;
	this.damage = damage || 0;
	this.isAlive = true;
	this.isTransparent = this.type.isTransparent;
	this.isSafe = this.type.isSafe;
	
	this.tileIndex = {x: tileIndex.x, y: tileIndex.y};
	this.isPassable = true;
	
	// Sprite:
	this.sprite = gs.createSprite(position.x, position.y, 'Tileset', gs.projectileSpritesGroup);
	this.sprite.anchor.setTo(0.5, 0.5);
	this.sprite.frame = this.type.frame;
	this.sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	this.sprite.alpha = this.type.alpha;
	
	// Creating ice object on water:
	if (this.type.name === 'FreezingCloud' && gs.getTile(this.tileIndex).type.name === 'Water' && !gs.getObj(this.tileIndex)) {
		gs.createObject(this.tileIndex, 'Ice');
	}
	
	// Place on map:
    gs.getTile(tileIndex).cloud = this;
    
	// Push to effect list:
    gs.cloudList.push(this);
}

// DESTROY:
// ************************************************************************************************
Cloud.prototype.destroy = function () {
	this.sprite.destroy();
	gs.getTile(this.tileIndex).cloud = null;
	this.isAlive = false;
		
	gs.removeFromArray(this, gs.cloudList);
};

// STEP_ON:
// Called when a character enters the tile:
// ************************************************************************************************
Cloud.prototype.stepOn = function (character) {
	if (this.type.onEnterTile) {
		this.type.onEnterTile.call(this, character);
	}
};

// UPDATE_TURN:
// ************************************************************************************************
Cloud.prototype.updateTurn = function () {
	this.life -= 1;
	
	if (this.type.updateTurn) {
		this.type.updateTurn.call(this);
	}
	
	// Running out of life:
	if (this.life === 0) {
		// Make sure to call destroy first to safely remove from tile
		this.destroy();
		
		if (this.type.onDestroy) {
			this.type.onDestroy.call(this);
		}
		
	}
};

// CHARACTER_TURN_EFFECT:
// ************************************************************************************************
Cloud.prototype.characterTurnEffect = function (character) {
	if (this.type.characterTurnEffect) {
		this.type.characterTurnEffect.call(this, character);
	}
};

// CREATE_ICE:
// ************************************************************************************************
gs.createIce = function (tileIndex, duration) {
   return new Ice(tileIndex, duration);
};

// ICE_CONSTRUCTOR:
// ************************************************************************************************
function Ice (tileIndex, duration) {
	var startPos = util.toPosition(tileIndex);
    
    // Create sprite:
    this.sprite = gs.createSprite(startPos.x, startPos.y, 'Tileset', gs.projectileSpritesGroup);
    this.sprite.anchor.setTo(0.5, 0.5);
	this.sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
    this.sprite.frame = 1642;
    this.sprite.alpha = 0.75;
    
    // Properties:
    this.life = duration;
    this.tileIndex = {x: tileIndex.x, y: tileIndex.y};
    this.isAlive = true;
    this.name = 'Ice';
	this.isTransparent = true;
    this.type = {name: 'Ice'};
	
	// Sound:
	gs.playSound(gs.sounds.ice, tileIndex);
	
	// Stun:
	if (gs.getChar(tileIndex) && gs.getChar(tileIndex).isAlive) {
		gs.getChar(tileIndex).statusEffects.add('Frozen', {duration: duration}, {dontPopUpText: true});
		
		gs.getChar(tileIndex).popUpText('Frozen!', '#ffffff');
	}
	
    // Destroy existing Cloud:
	if (gs.getTile(tileIndex).cloud) {
		gs.getTile(tileIndex).cloud.destroy();
	}
	
	// Place on map:
    gs.getTile(tileIndex).cloud = this;
    
	// Push to ice list:
    gs.cloudList.push(this);
}

// UPDATE_ICE_TURN:
// ************************************************************************************************
Ice.prototype.updateTurn = function () {
    this.life -= 1;
    
	if (this.life === 0) {
        this.destroy();
    }
};

// DESTROY:
// ************************************************************************************************
Ice.prototype.destroy = function () {
	this.sprite.destroy();
	gs.getTile(this.tileIndex).cloud = null;
	this.isAlive = false;
};

// DESTROY_ALL_CLOUDS:
// ************************************************************************************************
gs.destroyAllClouds = function () {
	for (let i = this.cloudList.length - 1; i >= 0 ; i -= 1) {
		this.cloudList[i].destroy();
	}
	
	this.cloudList = [];
};/*global game, gs, util*/
/*global Item*/
/*global FIRE_SHROOM_MIN_DAMAGE, FIRE_SHROOM_MAX_DAMAGE*/
/*global BEAR_TRAP_MIN_DAMAGE, BEAR_TRAP_MAX_DAMAGE*/
/*global FIRE_GLYPH_MIN_DAMAGE, FIRE_GLYPH_MAX_DAMAGE*/
/*global SPIKE_TRAP_MIN_DAMAGE, SPIKE_TRAP_MAX_DAMAGE*/
/*global FIRE_VENT_MIN_DAMAGE, FIRE_VENT_MAX_DAMAGE*/
/*global GAS_VENT_MIN_DAMAGE, GAS_VENT_MAX_DAMAGE*/

/*global MAX_LEVEL, SKELETON_REVIVE_TIME, ZONE_FADE_TIME*/
/*jshint esversion: 6*/
'use strict';



// CREATE_OBJECT_TYPES:
// ************************************************************************************************
gs.createObjectTypes = function () {
	this.createObjectFuncs();
	
	// Object Types:
	this.objectTypes = {
		// Floor Objects:
		Bones:				{frame: 1536, isPassable: 1, isTransparent: 1, isUnstable: 1},
		Vine:				{frame: 1537, isPassable: 1, isTransparent: 1, isUnstable: 1, isFlammable: 1},
		SpiderWeb:			{frame: 1538, isPassable: 1, isTransparent: 1, isUnstable: 1, isFlammable: 1},
		LongGrass:			{frame: 1539, isPassable: 1, isTransparent: 1, isUnstable: 0, isFlammable: 1},
		Rubble:				{frame: 1540, isPassable: 1, isTransparent: 1, isUnstable: 1},
		Ice:				{frame: 1541, isPassable: 1, isTransparent: 1, isUnstable: 2, isSlippery: 1},
		Oil:				{frame: 1542, isPassable: 1, isTransparent: 1, isUnstable: 2, isSlippery: 1, isFlammable: 1},
		Blood:				{frame: 1543, isPassable: 1, isTransparent: 1, isUnstable: 0},
		StoneChips:			{frame: 1544, isPassable: 1, isTransparent: 1, isUnstable: 1},
		Slime:				{frame: 1545, isPassable: 1, isTransparent: 1, isUnstable: 1, isSlippery: 1},
        IceRock:            {frame: 1743, isPassable: 1, isTransparent: 1, isUnstable: 1, frames: [1747, 1746]},
        Scrap:				{frame: 1546, isPassable: 1, isTransparent: 1, isUnstable: 1},
		
		// Trap Objects:
		BearTrap:			{frame: 1552, isPassable: 1, isTransparent: 1, isDangerous: 1, activate: 'bearTrapActivate', updateTurn: 'bearTrapUpdateTurn'},
		SpikeTrap:			{frame: 1554, isPassable: 1, isTransparent: 1, isDangerous: 1, activate: 'spikeTrapActivate', updateTurn: 'spikeTrapUpdateTurn'},
		GasVent:			{frame: 1556, isPassable: 1, isTransparent: 1, isDangerous: 1, updateTurn: 'gasVentUpdateTurn'},
        InactiveGasVent:	{frame: 1551, isPassable: 1, isTransparent: 1, onTrigger: 'activateGasVent'},
		FireVent:			{frame: 1557, isPassable: 1, isTransparent: 1, isDangerous: 1, activate: 'fireVentActivate', updateTurn: 'FireVentUpdateTurn', canBurstOfFlame: true},
        InactiveFireVent:	{frame: 1550, isPassable: 1, isTransparent: 1, onTrigger: 'activateFireVent'},
		PitTrap:			{frame: 1548, isPassable: 1, isTransparent: 1, isHidden: 1, activate: 'pitTrapActivate'},
		TeleportTrap:		{frame: 1549, isPassable: 1, isTransparent: 1, isHidden: 1, activate: 'teleportTrapActivate'},
		FireGlyph:			{frame: 1558, isPassable: 1, isTransparent: 1, isDangerous: 1, activate: 'fireGlyphActivate', canBurstOfFlame: true},
		Portal:				{frame: 1559, isPassable: 1, isTransparent: 1, isDangerous: 1, interactFunc: 'portalActivate'},
		HealingShroom:		{frame: 1560, isPassable: 1, isTransparent: 1, activate: 'healingShroomActivate'},
		EnergyShroom:		{frame: 1562, isPassable: 1, isTransparent: 1, activate: 'manaShroomActivate'},
		FireShroom:			{frame: 1564, isPassable: 1, isTransparent: 1, isDangerous: 1, activate: 'fireShroomActivate', canBurstOfFlame: true},
		
		
		// Wall Objects:
		Torch:				{frame: 1568, isPassable: 0, isTransparent: 1, canBurstOfFlame: true},
		WallFlag:			{frame: 1572, isPassable: 0, isTransparent: 1, frames: [1572, 1574]},
		Shackles:			{frame: 1573, isPassable: 0, isTransparent: 1},
		
		// Stalagmite and Pillar:
		Stalagmite:			{frame: 1600, isPassable: 0, isTransparent: 1, frames: [1600, 1601, 1602]},
		Pillar:				{frame: 1608, isPassable: 0, isTransparent: 1, frames: this.range(1608, 1614)},
		WaterStalagmite:	{frame: 1732, isPassable: 0, isTransparent: 1},
		
		// Fountains:
		WellOfWishing:		{frame: 1632, isPassable: 0, isTransparent: 1, interactFunc: 'wellOfWishing', emptyFrame: 1636},
		HealthFountain:		{frame: 1633, isPassable: 0, isTransparent: 1, interactFunc: 'drinkHealthFountain', emptyFrame: 1636},
		EnergyFountain:		{frame: 1634, isPassable: 0, isTransparent: 1, interactFunc: 'drinkEnergyFountain', emptyFrame: 1636},
		ExperienceFountain:	{frame: 1635, isPassable: 0, isTransparent: 1, interactFunc: 'drinkExperienceFountain', emptyFrame: 1636},
		AttributeFountain:	{frame: 1637, isPassable: 0, isTransparent: 1, interactFunc: 'drinkAttributeFountain', emptyFrame: 1636},
		
		// Altars:
		AltarOfTrog:		{frame: 1648, isPassable: 0, isTransparent: 1, interactFunc: 'useAltar', religion: 'Trog'},
		AltarOfWealth:		{frame: 1649, isPassable: 0, isTransparent: 1, interactFunc: 'useAltar', religion: 'Wealth'},
		AltarOfTheArcher:		{frame: 1650, isPassable: 0, isTransparent: 1, interactFunc: 'useAltar', religion: 'TheArcher'},
		AltarOfTheWizard:		{frame: 1651, isPassable: 0, isTransparent: 1, interactFunc: 'useAltar', religion: 'TheWizard'},
		AltarOfHealth:		{frame: 1652, isPassable: 0, isTransparent: 1, interactFunc: 'useAltar', religion: 'Health'},
		AltarOfExploration:	{frame: 1653, isPassable: 0, isTransparent: 1, interactFunc: 'useAltar', religion: 'Exploration'},

		// Interactable Objects: 
		BookShelf:			{frame: 1666, isPassable: 0, isTransparent: 1, interactFunc: 'readBookShelf', emptyFrame: 1667},
		MeatRack:			{frame: 1668, isPassable: 0, isTransparent: 1, interactFunc: 'meatRack', emptyFrame: 1669},
        FishRack:           {frame: 1675, isPassable: 0, isTransparent: 1, interactFunc: 'meatRack', emptyFrame: 1669},
		CampFire:			{frame: 1670, isPassable: 0, isTransparent: 1, updateTurn: 'campFireUpdateTurn', canBurstOfFlame: true},
		Switch:				{frame: 1671, isPassable: 0, isTransparent: 1, interactFunc: 'useSwitch', emptyFrame: 1672},
		CrystalChest:		{frame: 1673, isPassable: 0, isTransparent: 1, interactFunc: 'openCrystalChest', emptyFrame: 1674},
		EnchantmentTable:	{frame: 1724, isPassable: 0, isTransparent: 1, interactFunc: 'useEnchantmentTable', emptyFrame: 1725},
		TransferanceTable:	{frame: 1726, isPassable: 0, isTransparent: 1, interactFunc: 'useTransferanceTable', emptyFrame: 1727},
		
		// Timer Objects:
		Bomb:				{frame: 1680, isPassable: 1, isTransparent: 1, updateTurn: 'bombUpdateTurn'},
		IceBomb:			{frame: 1681, isPassable: 0, isTransparent: 1, updateTurn: 'IceBombUpdateTurn'},
		SkeletonCorpse:		{frame: 1682, isPassable: 1, isTransparent: 1, updateTurn: 'skeletonUpdateTurn', isUnstable: 1},
		
		// Non-Interactable Objects:
		Casket:				{frame: 1696, isPassable: 0, isTransparent: 1, frames: this.range(1773, 1776)},
		Table:				{frame: 1697, isPassable: 0, isTransparent: 1},
		WorkBench:			{frame: 1698, isPassable: 0, isTransparent: 1},
		UnfinishedGolem:	{frame: 1699, isPassable: 0, isTransparent: 1},
		StoneBlocks:		{frame: 1700, isPassable: 0, isTransparent: 1},
		StepLadder:			{frame: 1701, isPassable: 0, isTransparent: 1},
		PracticeDummy:		{frame: 1702, isPassable: 0, isTransparent: 1},
		Fern:				{frame: 1703, isPassable: 0, isTransparent: 1, isFlammable: 1},
		Bed:				{frame: 1704, isPassable: 0, isTransparent: 1, frames: [1683]},
		Flag:				{frame: 1705, isPassable: 0, isTransparent: 1},
		Stock:				{frame: 1707, isPassable: 0, isTransparent: 1},
		Bars:				{frame: 1708, isPassable: 0, isTransparent: 1, frames: this.range(1708, 1710)},
		TikiTorch:			{frame: 1728, isPassable: 0, isTransparent: 1, canBurstOfFlame: true},
		Tree:				{frame: 1733, isPassable: 0, isTransparent: 1, frames: [1733, 1706, 1735, 1736, 1737, 1738]},
		WaterTree:			{frame: 1734, isPassable: 0, isTransparent: 1},
		Throne:				{frame: 1713, isPassable: 0, isTransparent: 1},
        Fence:              {frame: 1859, isPassable: 0, isTransparent: 1, frames: this.range(1860, 1873)},
        FountainFloor:      {frame: 1977, isPassable: 1, isTransparent: 1, frames: this.range(1978, 1979)},
        FountainFloor2:     {frame: 2009, isPassable: 1, isTransparent: 1, frames: this.range(2010, 2011)},
        FountainFloor3:     {frame: 2041, isPassable: 1, isTransparent: 1, frames: this.range(2042, 2043)},
        Anvil:              {frame: 1749, isPassable: 0, isTransparent: 1},
        Furnace:            {frame: 1714, isPassable: 0, isTransparent: 1},
        Shelf:              {frame: 1711, isPassable: 0, isTransparent: 1, frames: [1712]},
        Rock:               {frame: 1740, isPassable: 0, isTransparent: 1, frames: [1741, 1744, 1745]},
        Bench:              {frame: 1685, isPassable: 1, isTransparent: 1, frames: [1685, 1686, 1687]},
        Igloo:              {frame: 1721, isPassable: 0, isTransparent: 1, frames: [1722, 1723, 1689, 1690, 1691]},
        LilyPads:           {frame: 1750, isPassable: 1, isTransparent: 1},
        Reeds:              {frame: 1751, isPassable: 1, isTransparent: 1},
        OilTank:			{frame: 1760, isPassable: 0, isTransparent: 1, frames: [1760, 1761, 1792, 1793, 1794, 1795]},
        GasLamp:			{frame: 1762, isPassable: 0, isTransparent: 1},
		Statue:				{frame: 1752, isPassable: 0, isTransparent: 1},
		Barrel:				{frame: 1753, isPassable: 0, isTransparent: 1},
		UnlitBrazer:		{frame: 1754, isPassable: 0, isTransparent: 1},
		Brazer:				{frame: 1755, isPassable: 0, isTransparent: 1, canBurstOfFlame: true},
		Chair:				{frame: 1764, isPassable: 1, isTransparent: 1, frames: [1764, 1765]},
		BigTable:			{frame: 1766, isPassable: 0, isTransparent: 1, frames: this.range(1766, 1771)},
		Pipe:				{frame: 1779, isPassable: 0, isTransparent: 1, frames: this.range(1779, 1788)},
		Altar:				{frame: 1777, isPassable: 0, isTransparent: 1, frames: [1777, 1778, 1808, 1809, 1810]},
		SkullStatue:		{frame: 1772, isPassable: 0, isTransparent: 1, frames: [1772, 1798]},
		
		// Zone Lines:
		DownStairs:			{frame: 1616, 	isPassable: 1, isTransparent: 1},
		UpStairs:			{frame: 1617, 	isPassable: 1, isTransparent: 1},
		
		// Doors:
		Door:				{frame: 1584, frames: [1584, 1585], isTransparent: false, interactFunc: 'useDoor'},
		Gate: 				{frame: 1586, frames: [1586, 1587], isTransparent: true, interactFunc: 'useDoor'},
		StoneDoor: 			{frame: 1588, frames: [1588, 1589], isTransparent: false, interactFunc: 'useDoor'},
		TimedGate:			{frame: 1590, frames: [1590, 1591], isTransparent: true, interactFunc: 'useDoor'},
		SwitchGate:			{frame: 1592, frames: [1592, 1593], isTransparent: true, interactFunc: 'useDoor'},
		
		// Containers:		
		Chest:				{frame: 1664, isPassable: 0, isTransparent: true, openSound: gs.sounds.door, interactFunc: 'useContainer'},
		
		Generic:			{frame: 0,   isPassable: 1, isTransparent: 1}
	};
	
	// Animations:
	this.objectTypes.Torch.anim = [1568, 1569, 1570, 1571];
	this.objectTypes.HealingShroom.anim = [1560, 1561];
	this.objectTypes.EnergyShroom.anim = [1562, 1563];
	this.objectTypes.FireShroom.anim = [1564, 1565];
	this.objectTypes.TikiTorch.anim = [1728, 1729, 1730, 1731];
	this.objectTypes.GasLamp.anim = [1762, 1763];
	this.objectTypes.Brazer.anim = [1755, 1756, 1757, 1758];
	
	// LIGHTS:
	//this.objectTypes.HealthFountain.light = {color: '#00ff00', radius: 160, startAlpha: '66'};
	//this.objectTypes.EnergyFountain.light = {color: '#ff00ff', radius: 120, startAlpha: '66'};
	//this.objectTypes.ExperienceFountain.light = {color: '#ffff00', radius: 120, startAlpha: '66'};
	//this.objectTypes.AttributeFountain.light = {color: '#ff0000', radius: 120, startAlpha: '66'};
	//this.objectTypes.WellOfWishing.light = {color: '#00ffff', radius: 120, startAlpha: '66'};
											 
											 
	// Set Default Properties:
	this.nameTypes(this.objectTypes);
	this.forEachType(this.objectTypes, function (type) {
		// Interact:
		if (type.interactFunc) {
			type.interactFunc = this.objectFuncs[type.interactFunc];
		}
		
		// Activate:
		if (type.activate) {
			type.activate = this.objectFuncs[type.activate];
		}
		
		// Update Turn:
		if (type.updateTurn) {
			type.updateTurn = this.objectFuncs[type.updateTurn];
		}
        
        //onTrigger:
        if (type.onTrigger) {
            type.onTrigger = this.objectFuncs[type.onTrigger];
        }
	}, this);


	
	
	
	this.objectTypes.HealthFountain.desc = 'Completely restores your hit points.';
	this.objectTypes.EnergyFountain.desc = 'Completely restores your mana points.';
	this.objectTypes.LongGrass.desc = 'Ignites and spreads fire.';
	this.objectTypes.FireShroom.desc = 'Dangerous mushrooms which explode in a burst of fire when stepped on.';
	this.objectTypes.HealingShroom.desc = 'Pick them to eat later and restore your hit points.';
	this.objectTypes.EnergyShroom.desc = 'Pick them to eat later and restore your mana points.';
	this.objectTypes.Vine.desc = 'Unstable Terrain\nPhysical attacks against unstable characters are always criticals.';
};

// CREATE_OBJECT_FUNCS:
// ************************************************************************************************
gs.createObjectFuncs = function () {
	this.objectFuncs = {};
	this.objectFuncs.drinkHealthFountain = function (character) {
		if (character.currentHp < character.maxHp || character.poisonDamage > 0) {
			character.healHp(character.maxHp);
			gs.pc.cure();

			gs.playSound(gs.sounds.cure, this.tileIndex);
			gs.pc.popUpText('Fully Healed', '#ffffff');
			//gs.createParticlePoof(character.tileIndex, 'GREEN');
			
			// Effect:
			gs.createHealingEffect(gs.pc.tileIndex);
			
			this.setIsFull(false);
			
			gs.HUD.miniMap.refresh();
		}
		else {
			gs.pc.popUpText('Already full health', '#ffffff');
		}
	};
	
	this.objectFuncs.drinkEnergyFountain = function (character) {
		if (character.currentMp < character.maxMp || character.hasCoolDown()) {	
			gs.pc.mentalCure();
			
			character.gainMp(character.maxMp);
			character.resetAllCoolDowns();
			
			gs.pc.popUpText('Full Energy', '#ffffff');
			
			// Sound:
			gs.playSound(gs.sounds.cure, this.tileIndex);
		
			// Effect:
			gs.createManaEffect(gs.pc.tileIndex);
			
			this.setIsFull(false);
			
			gs.HUD.miniMap.refresh();
		}
		else {
			gs.pc.popUpText('Already full energy', '#ffffff');
		}
	};

	this.objectFuncs.drinkExperienceFountain = function (character) {
		// Status Effect:
		character.statusEffects.add('ExperienceBoost');
		
		// Spell Effect:
		gs.createEXPEffect(character.tileIndex);
		
		// Sound:
		gs.playSound(gs.sounds.cure, character.tileIndex);
		
		this.setIsFull(false);
		
		gs.HUD.miniMap.refresh();
	};
	
	this.objectFuncs.wellOfWishing = function (character) {
		gs.usingFountain = this;
		gs.acquirementMenu.open();
	};
	
	this.objectFuncs.useEnchantmentTable = function (character) {
		gs.usingFountain = this;
		gs.enchantmentMenu.open();
	};
	
	this.objectFuncs.useTransferanceTable = function (character) {
		gs.usingFountain = this;
		gs.transferanceMenu.open();
	};
	
	this.objectFuncs.drinkAttributeFountain = function (character) {
		gs.usingFountain = this;
		gs.openAttributeGainMenu();
		gs.playSound(gs.sounds.cure, this.tileIndex);
		this.setIsFull(false);
		
		// Spell Effect:
		gs.createFireEffect(gs.pc.tileIndex);
		
		gs.HUD.miniMap.refresh();
	};
	
	
	this.objectFuncs.readBookShelf = function (character) {
		var talent = gs.pc.getUnavailableTalent(),
			skillName = gs.pc.getRandomSkillName(),
			choice,
			list = [
				{name: 'Scroll', percent: 20}, 
				{name: 'Book', percent: 5}, 
				{name: 'TalentPoint', percent: 5},
				{name: 'SkillPoint', percent: 20},
			];
			
		
		if (skillName) {
			list.push({name: 'RandomSkill', percent: 40});
		}
		
		if (talent) {
			list.push({name: 'RandomTalent', percent: 10});
		}
		
		choice = gs.chooseRandom(list);
		
		if (choice === 'Scroll') {
			gs.pc.inventory.addItem(gs.createRandomItem('Scrolls'));
		}
		else if (choice === 'Book') {
			gs.pc.inventory.addItem(gs.createRandomItem('Books'));
		}
		else if (choice === 'SkillPoint') {
			gs.pc.skillPoints += 1;
			gs.pc.popUpText('+1 Skill Point', '#ffffff');
		}
		else if (choice === 'RandomSkill') {
			gs.pc.skillPoints += 1; // gainSkill will -1 skillPoints
			gs.pc.gainSkill(skillName);
			gs.pc.popUpText('+1 ' + gs.capitalSplit(skillName) + ' skill', '#ffffff');
		}
		else if (choice === 'TalentPoint') {
			gs.pc.talentPoints += 1;
			gs.pc.popUpText('+1 Talent Point', '#ffffff');
		}
		else if ( choice === 'RandomTalent') {
			gs.pc.availableTalents.push(talent.name);
			gs.pc.popUpText(gs.capitalSplit(talent.name) + ' available', '#ffffff');
		}
		
		// Stop exploration:
		gs.pc.stopExploring();
		
		gs.createParticlePoof(character.tileIndex, 'WHITE');
		gs.playSound(gs.sounds.point, this.tileIndex);
		
		this.setIsFull(false);
		
		gs.HUD.miniMap.refresh();
	};
	

	this.objectFuncs.meatRack = function (character) {
		gs.pc.inventory.addItem(Item.createItem('Meat'));
		gs.playSound(gs.sounds.food, this.tileIndex);
		this.setIsFull(false);
		this.isOpen = true;
		gs.pc.stopExploring();
		
		gs.HUD.miniMap.refresh();
	};
	
	this.objectFuncs.openCrystalChest = function (character) {
		// Sealed:
		if (gs.crystalChestGroupIsOpen[this.groupId]) {
			gs.openingContainer = this;
			gs.dialogMenu.open(gs.dialog.SealedCrystalChest);
		}
		// Not sealed:
		else {
			gs.openingContainer = this;
			gs.dialogMenu.open(gs.dialog.CrystalChest);
		}
	};
	
	this.objectFuncs.useDoor = function (character) {
		// Guarded (Zoo):
		if (this.isGuarded && character === gs.pc) {
			gs.dialogMenu.open(gs.dialog.GuardedDoor);
			gs.openingDoor = this;
			gs.pc.actionQueue = [];
		}
		// Locked (Closed Time Gate):
		else if (this.isLocked && character === gs.pc && this.isPermaLocked) {
			gs.dialogMenu.open(gs.dialog.PermaLockedDoor);
			gs.openingDoor = this;
			gs.pc.actionQueue = [];
		}
		// Locked (Switch):
		else if (this.isLocked && character === gs.pc && this.type.name === 'SwitchGate') {
			gs.dialogMenu.open(gs.dialog.SwitchGate);
			gs.openingDoor = this;
			gs.pc.actionQueue = [];
		}
		// Locked (Treasure Room):
		else if (this.isLocked && character === gs.pc) {
			gs.dialogMenu.open(gs.dialog.LockedDoor);
			gs.openingDoor = this;
			gs.pc.actionQueue = [];
		}
		else {
			this.openDoor();
		}
	};
	
	this.objectFuncs.useContainer = function (character) {
		if (this.isGuarded) {
			gs.dialogMenu.open(gs.dialog.GuardedContainer);
			gs.openingContainer = this;
		} 
		else {
			this.openContainer();
		}
	};
	

	this.objectFuncs.bearTrapActivate = function (character) {
		if (this.resetTime === 0) {
			gs.playSound(gs.sounds.melee, this.tileIndex);
			this.resetTime = 5;
			if (character) {
				
				character.statusEffects.add('Immobile', {duration: 5});
				
				character.takeDamage(gs.getScaledTrapDamage(BEAR_TRAP_MIN_DAMAGE, BEAR_TRAP_MAX_DAMAGE), 'Physical', {killer: 'BearTrap'});
			}
			this.sprite.frame = this.type.frame + 1;
		}
	};

	this.objectFuncs.bearTrapUpdateTurn = function () {
		if (this.resetTime > 0) {
			this.resetTime -= 1;
		} else {
			this.sprite.frame = this.type.frame;
		}
	};
	
	this.objectFuncs.IceBombUpdateTurn = function () {
		// Count Down:
		if (this.resetTime < 3) {
			this.resetTime += 1;
		} 
		// Explode:
		else {
			gs.getIndexInBox(this.tileIndex.x - 1, this.tileIndex.y - 1, this.tileIndex.x + 2, this.tileIndex.y + 2).forEach(function (index) {
				if (!gs.vectorEqual(this.tileIndex, index)) {
					gs.createProjectile(this, index, 'IceArrow', this.damage, {killer: this});
				}
			}, this);
			
			gs.playSound(gs.sounds.ice, this.tileIndex);
			gs.destroyObject(this);
		}
	};
	
	this.objectFuncs.bombUpdateTurn = function () {
		// Count Down:
		if (this.resetTime < 1) {
			this.resetTime += 1;
		} 
		// Explode:
		else {
			gs.destroyObject(this);
			gs.createExplosionCross(this.tileIndex, 3, this.damage || 4, {killer: 'Bomb'});
		}
	};
	
	
	this.objectFuncs.skeletonUpdateTurn = function () {
		var npc;
		
		return;
		
		/*
		if (gs.zoneName !== 'TheCrypt') {
			return;
		}
		
		// Count Down:
		if (this.resetTime < SKELETON_REVIVE_TIME) {
			this.resetTime += 1;
		}
		// Revive:
		else if (gs.isPassable(this.tileIndex)) {
			npc = gs.createNPC(this.tileIndex, this.npcTypeName || 'SkeletonWarrior');
			gs.destroyObject(this);
		}
		*/
		
	};
	
	this.objectFuncs.spikeTrapActivate = function (character) {
		if (this.resetTime === 0) {
			gs.playSound(gs.sounds.melee, this.tileIndex);
			this.resetTime = 5;
			if (character) {
				character.takeDamage(gs.getScaledTrapDamage(SPIKE_TRAP_MIN_DAMAGE, SPIKE_TRAP_MAX_DAMAGE), 'Physical', {killer: 'SpikeTrap'});
			}
			this.sprite.frame = this.type.frame + 1;
		}
	};

	this.objectFuncs.spikeTrapUpdateTurn = function () {
		if (this.resetTime > 0) {
			this.resetTime -= 1;
		} else {
			this.sprite.frame = this.type.frame;
		}
	};
	
	this.objectFuncs.fireVentActivate = function () {
		if (this.resetTime === 0) {
			gs.createExplosion(this.tileIndex, 1, gs.getScaledTrapDamage(FIRE_VENT_MIN_DAMAGE, FIRE_VENT_MAX_DAMAGE), {killer: 'FireVent'});
			this.resetTime = 3;
			this.sprite.frame = this.type.frame - 1;
		}
	};
	
	this.objectFuncs.FireVentUpdateTurn = function () {
		if (this.resetTime > 0) {
			this.resetTime -= 1;
		} else {
			this.sprite.frame = this.type.frame;
		}
	};
    
	// Used for one time triggered fire vents (trap rooms):
    this.objectFuncs.activateFireVent = function () {
		gs.createExplosion(this.tileIndex, 1, gs.getScaledTrapDamage(FIRE_VENT_MIN_DAMAGE, FIRE_VENT_MAX_DAMAGE), {killer: 'FireVent'});
    };
	

	this.objectFuncs.healingShroomActivate = function (character) {
		if (character === gs.pc) {
			gs.pc.inventory.addItem(Item.createItem('HealingShroom'));
		} 
		
		gs.playSound(gs.sounds.point, this.tileIndex);
		gs.createParticlePoof(this.tileIndex, 'GREEN', 10);
		gs.destroyObject(this);
	};
	
	this.objectFuncs.manaShroomActivate = function (character) {
		if (character === gs.pc) {
			gs.pc.inventory.addItem(Item.createItem('EnergyShroom'));
		}
		
		gs.playSound(gs.sounds.point, this.tileIndex);
		gs.createParticlePoof(this.tileIndex, 'PURPLE', 10);
		gs.destroyObject(this);
	};

	this.objectFuncs.fireShroomActivate = function (character) {
		gs.destroyObject(this);
		gs.createFire(this.tileIndex, gs.getScaledTrapDamage(FIRE_SHROOM_MIN_DAMAGE, FIRE_SHROOM_MAX_DAMAGE), {killer: 'FireShroom'});
	};
	
	this.objectFuncs.fireGlyphActivate = function (character) {
		var damage = gs.getScaledTrapDamage(FIRE_GLYPH_MIN_DAMAGE, FIRE_GLYPH_MAX_DAMAGE);
		gs.destroyObject(this);
		gs.createFire(this.tileIndex, damage, {killer: 'FireGlyph'});
		
		gs.createCloud(this.tileIndex, 'FlamingCloud', Math.ceil(damage / 2), 10);
		
	};

	this.objectFuncs.gasVentUpdateTurn = function () {
		if (this.resetTime <= 0) {
			gs.createCloud(this.tileIndex, 'PoisonGas', gs.getScaledTrapDamage(GAS_VENT_MIN_DAMAGE, GAS_VENT_MAX_DAMAGE), 15);
			this.resetTime = 25;
		} else {
			this.resetTime -= 1;
		}
	};
    
    this.objectFuncs.activateGasVent = function () {
        gs.createCloud(this.tileIndex, 'PoisonGas', gs.getScaledTrapDamage(GAS_VENT_MIN_DAMAGE, GAS_VENT_MAX_DAMAGE), 15);   
    };
	
	this.objectFuncs.pitTrapActivate = function (character) {
		if (character === gs.pc && !gs.pc.isFlying) {
			gs.destroyObject(this);
			gs.descendLevel();
			gs.playSound(gs.sounds.pitTrap, gs.pc.tileIndex);
			gs.pc.randomTeleport();
			gs.pc.popUpText('Pit Trap!', '#ffffff');
			gs.createParticlePoof(gs.pc.tileIndex, 'WHITE');
		}
	};
	
	this.objectFuncs.teleportTrapActivate = function (character) {
		if (character === gs.pc) {
			gs.destroyObject(this);
			gs.createParticlePoof(character.tileIndex, 'PURPLE');
			gs.playSound(gs.sounds.teleport, gs.pc.tileIndex);
			gs.pc.randomTeleport();
			gs.pc.popUpText('Teleport Trap!', '#ffffff');
			gs.createParticlePoof(character.tileIndex, 'PURPLE');
			
		}
	};
	
	this.objectFuncs.portalActivate = function (character) {
		var pos;
		
		if (character === gs.pc) {
			gs.createParticlePoof(character.tileIndex, 'PURPLE');
			gs.playSound(gs.sounds.teleport, character.tileIndex);
			gs.pc.teleportTo(gs.getNearestPassableIndex(this.toTileIndex));
			gs.createParticlePoof(character.tileIndex, 'PURPLE');
			
			pos = util.toPosition(character.tileIndex);
			gs.createLightCircle({x: pos.x, y: pos.y + 10}, '#ff00ff', 120, 50, '88');
			
			// Pull all allies to new position:
			gs.getAllAllies().forEach(function (char) {
				let tileIndex = gs.getNearestPassableIndex(gs.pc.tileIndex);
				
				if (tileIndex) {
					char.body.snapToTileIndex(tileIndex);
				}
		
			}, this);
		}
	};
	
	this.objectFuncs.useAltar = function (character) {
		gs.currentAltar = this;
		gs.openAltarMenu();
		
	};
	
	this.objectFuncs.campFireUpdateTurn = function () {
		if (gs.distance(this.tileIndex, gs.pc.tileIndex) < 2 && gs.pc.coldLevel > 0) {
			gs.pc.coldLevel -= 1;
		}
	};
	
	this.objectFuncs.useSwitch = function () {
		if (!gs.getObj(this.toTileIndex).isOpen) {
			
			gs.getObj(this.toTileIndex).openDoor();
			this.setIsFull(false);
		}
		
	};

};

// GET_SCALED_TRAP_DAMAGE:
// ************************************************************************************************
gs.getScaledTrapDamage = function (min, max, DL) {
	DL = DL || gs.dangerLevel();
	
	return Math.ceil(min + (DL - 1) * ((max - min) / (MAX_LEVEL - 1)));
};/*global game, gs, console, util*/
/*global Item*/
/*global Door, Container, DefaultObject, ZoneLine, levelController*/
/*global TILE_SIZE, SCALE_FACTOR, FACTION*/


/*jshint white: true, laxbreak: true, esversion: 6*/
'use strict';



// CREATE_ZONE_LINE:
// ************************************************************************************************
gs.createZoneLine = function (tileIndex, typeName, toZoneName, toZoneLevel) {
	var obj = this.createObject(tileIndex, typeName);
	
	obj.toZoneName = toZoneName;
	obj.toZoneLevel = toZoneLevel;
	
	return obj;
};

// CREATE_DOOR:
// ************************************************************************************************
gs.createDoor = function (tileIndex, typeName, closedFrame, isOpen, isGuarded) {
	var obj = this.createObject(tileIndex, typeName);
	
	obj.closedFrame = closedFrame || obj.type.frame;
	obj.isOpen = isOpen || false;
	obj.isGuarded = isGuarded || false;
	obj.isSealed = false;
	
	obj.sprite.frame = obj.isOpen ? obj.closedFrame + 1 : obj.closedFrame;
	
	return obj;
};

// CREATE_CONTAINER:
// ************************************************************************************************
gs.createContainer = function (tileIndex, typeName, isOpen, isGuarded, itemDropTableName) {
	var obj = this.createObject(tileIndex, typeName);
	
	obj.isOpen = isOpen ? true : false;
	obj.isGuarded = isGuarded || false;
	
	// Select random item for container:
	obj.item = this.createRandomItem(itemDropTableName);
	
	// Set sprite open/closed:
	obj.sprite.frame = obj.isOpen ? obj.closedFrame + 1 : obj.closedFrame;
	
	
	return obj;
};

// CREATE_CRYSTAL_CHEST:
// ************************************************************************************************
gs.createCrystalChest = function (tileIndex) {
	var obj = this.createObject(tileIndex, 'CrystalChest');
	obj.groupId = gs.nextCrystalChestGroupId;
	
	return obj;
};

// CREATE_CRYSTAL_CHEST_GROUP:
// ************************************************************************************************
gs.createCrystalChestGroup = function () {
	gs.nextCrystalChestGroupId += 1;
	gs.crystalChestGroupIsOpen[gs.nextCrystalChestGroupId] = false;
};

// CREATE_OBJECT:
// ************************************************************************************************
gs.createObject = function (tileIndex, typeName, frame) {
	/*
	var i;
	for (i = 0; i < this.objectPool.length; i += 1) {
		if (!this.objectPool[i].isAlive) {
			this.objectPool[i].init(tileIndex, typeName, frame);
			return this.objectPool[i];
		}
	}
	
	// Pool size exceeded:
	this.objectPool.push(new DefaultObject());
	this.objectPool[this.objectPool.length - 1].init(tileIndex, typeName, frame);
	return this.objectPool[this.objectPool.length - 1];
	*/
	
	var obj = new DefaultObject();
	obj.init(tileIndex, typeName, frame);
	return obj;
};

// DEFAULT_OBJECT_CONSTRUCTOR:
// ************************************************************************************************
function DefaultObject() {
	this.isAlive = false;
	
	// Sprite:
	this.sprite = gs.createSprite(0, 0, 'MapTileset', gs.objectSpritesGroup);
	this.sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	this.sprite.anchor.setTo(0.5, 0.75);
	this.sprite.visible = false;
}

// DEFAULT_OBJECT_INIT:
// ************************************************************************************************
DefaultObject.prototype.init = function (tileIndex, typeName, frame) {
	var indexList, pos;
	
	if (gs.getObj(tileIndex)) {
		console.log('Existing object name: ' + gs.getObj(tileIndex).type.name);
		console.log('Creating object name: ' + typeName);
		throw 'Object already exists at: ' + tileIndex.x + ', ' + tileIndex.y;
	}
	
	
	gs.ASSERT(gs.objectTypes[typeName], 'Not a valid typeName: ' + typeName);

	// Generic Properties:
	this.type = gs.objectTypes[typeName];
	this.tileIndex = {x: tileIndex.x, y: tileIndex.y};
	this.resetTime = 0; // For bear traps
	this.isAlive = true;
	this.isFull = true; // for fountains
	this.isSealed = false;
	
	// Zone Line Properties:
	this.toZoneName = null;
	this.toZoneLevel = null;
	
	// Sprite:
	pos = util.toPosition(tileIndex);
	this.sprite.x = pos.x;
	this.sprite.y = pos.y;
	this.sprite.frame = frame || this.type.frame;
	this.initAnimations();
	
	if (!gs.getTile(tileIndex).type.passable) {
		this.sprite.y += 2;
	}
		
	if (this.type.isPassable) {
		gs.floorObjectSpritesGroup.add(this.sprite);
		gs.objectSpritesGroup.remove(this.sprite);
	}
	else {
		gs.floorObjectSpritesGroup.remove(this.sprite);
		gs.objectSpritesGroup.add(this.sprite);
	}
	
	// Light:
	if (this.type.light) {
		this.light = gs.createLightCircle(this.sprite.position, this.type.light.color, this.type.light.radius, 0, this.type.light.startAlpha);
		this.light.noLife = true;
		this.light.fade = false;
	}
	
	// Lists:
	gs.objectList.push(this);
	gs.getTile(tileIndex).object = this;
};

// INIT_ANIMATIONS:
// ************************************************************************************************
DefaultObject.prototype.initAnimations = function () {
	// Destroy old animation:
	if (this.sprite.animations.getAnimation("anim")) {
		this.sprite.animations.getAnimation("anim").destroy();
	}
	
	if (this.type.anim) {
		this.sprite.animations.add('anim', this.type.anim);
		this.sprite.play('anim', 5, true);
		this.sprite.animations.currentAnim.setFrame(util.randElem(this.type.anim), true);
	}
};


// DEFAULT_OBJECT_DESTROY:
// ************************************************************************************************
DefaultObject.prototype.destroy = function () {
	this.isAlive = false;
	this.sprite.visible = false;
	this.sprite.destroy();
	
	if (this.light) {
		this.light.destroy();
	}
};

// UPDATE_TURN:
// ************************************************************************************************
DefaultObject.prototype.updateTurn = function () {
	if (this.isAlive && this.type.updateTurn) {
		this.type.updateTurn.call(this);
	}
	
	if (this.isAlive && this.timer > 0) {
		this.timer -= 1;
		
		if (this.timer === 0) {
			this.isOpen = false;
			this.sprite.frame = this.type.frame;
			this.isLocked = true;
			this.isPermaLocked = true;
		}
	}
};

// STEP_ON:
// ************************************************************************************************
DefaultObject.prototype.stepOn = function (character) {
	if (this.isAlive && this.type.activate) {
		this.type.activate.call(this, character);
	}
};

// CAN_INTERACT:
// ************************************************************************************************
DefaultObject.prototype.canInteract = function (character) {
	if (this.isDoor()) {
		return gs.distance(character.tileIndex, this.tileIndex) <= 1.5 && !this.isOpen && !this.isSealed;
	}
	else if (this.isContainer()) {
		return gs.distance(character.tileIndex, this.tileIndex) <= 1.5 && !this.isOpen;
	}
	else {
		return gs.distance(character.tileIndex, this.tileIndex) <= 1.5
			&& this.type.interactFunc
			&& this.isFull
			&& !this.isSealed;
	}
};

// INTERACT:
// ************************************************************************************************
DefaultObject.prototype.interact = function (character) {
	this.type.interactFunc.call(this, character);
	
	
};

// OPEN_CONTAINER:
// ************************************************************************************************
DefaultObject.prototype.openContainer = function () {
	this.isOpen = true;
	this.sprite.frame = this.type.frame + 1;
	gs.createFloorItem(this.tileIndex, this.item);
	gs.playSound(this.type.openSound, this.tileIndex);

	if (this.isGuarded) {
		this.shout();
	}
			
	if (this.triggerTileIndex) {
		this.triggerTileIndex.forEach(function (tileIndex) {
			if (gs.getObj(tileIndex) && gs.getObj(tileIndex).type.onTrigger) {
				gs.getObj(tileIndex).type.onTrigger.call(gs.getObj(tileIndex));
			}
		}, this);
	}
};


// SET_IS_FULL:
// ************************************************************************************************
DefaultObject.prototype.setIsFull = function (b) {
	this.isFull = b;
	
	if (!this.isFull) {
		if (this.type.emptyFrame) {
			this.sprite.frame = this.type.emptyFrame;
		}
		
		if (this.light) {
			this.light.destroy();
			this.light = null;
		}
	}
};

// OPEN_DOOR
// ************************************************************************************************
DefaultObject.prototype.openDoor = function () {
	if (!this.isOpen) {
		
		gs.playSound(gs.sounds.door, this.tileIndex);
		this.isOpen = true;
		this.sprite.frame += 1;
		gs.calculateLoS();
		gs.HUD.miniMap.refresh();

		if (this.isGuarded) {
			this.shout();
		}
		
		levelController.onOpenDoor(this);

		// Open Adjacent Doors:
		gs.getIndexListCardinalAdjacent(this.tileIndex).forEach(function (tileIndex) {
			var obj = gs.getObj(tileIndex);
			if (obj && obj.isDoor() && !obj.isOpen) {
				obj.openDoor();
			}
		}, this);
	}
};

// CLOSE_DOOR
// ************************************************************************************************
DefaultObject.prototype.closeDoor = function () {
	if (this.isOpen) {
		gs.playSound(gs.sounds.door, this.tileIndex);
		this.isOpen = false;
		this.sprite.frame -= 1;
		gs.calculateLoS();
		
		// Close Adjacent Doors:
		gs.getIndexListCardinalAdjacent(this.tileIndex).forEach(function (tileIndex) {
			var obj = gs.getObj(tileIndex);
			if (obj && obj.isDoor() && obj.isOpen) {
				obj.closeDoor();
			}
		}, this);
	}
};

// SHOUT:
// ************************************************************************************************
DefaultObject.prototype.shout = function () {
	gs.shout(this.tileIndex, FACTION.HOSTILE);
};

// IS_PASSABLE:
// ************************************************************************************************
DefaultObject.prototype.isPassable = function () {
	if (this.isDoor()) {
		return this.isOpen;
	}
	else {
		return this.type.isPassable;
	}
};

// IS_TRANSPARENT:
// ************************************************************************************************
DefaultObject.prototype.isTransparent = function () {
	if (this.isDoor()) {
		return this.isOpen || this.type.isTransparent;
	}
	else {
		return this.type.isTransparent;
	}
};

// IS_ZONE_LINE:
// ************************************************************************************************
DefaultObject.prototype.isZoneLine = function () {
	return this.type.name === 'DownStairs'
		|| this.type.name === 'UpStairs';
};

// IS_DOOR:
// ************************************************************************************************
DefaultObject.prototype.isDoor = function () {
	return this.type.interactFunc === gs.objectFuncs.useDoor;
};

// IS_CONTAINER:
// ************************************************************************************************
DefaultObject.prototype.isContainer = function () {
	return this.type.interactFunc === gs.objectFuncs.useContainer
		|| this.type.interactFunc === gs.objectFuncs.meatRack;
};

// SEAL:
// ************************************************************************************************
DefaultObject.prototype.seal = function () {
	this.isSealed = true;
	
	
	if (this.isDoor() && this.isOpen) {
		this.closeDoor();
	}
};

// TO_DATA:
// ************************************************************************************************
DefaultObject.prototype.toData = function () {
	var data = {};
	
	data.frame = this.sprite.frame;
	data.typeFrame = this.type.frame;
	data.isFull = this.isFull;
	
	// Zone Line:
	if (this.isZoneLine()) {
		data.toZoneName = this.toZoneName;
		data.toZoneLevel = this.toZoneLevel;
	}
	
	// Door:
	if (this.isDoor()) {
		data.closedFrame = this.closedFrame;
		data.isOpen = this.isOpen;
		data.isGuarded = this.isGuarded;
		data.isLocked = this.isLocked;
		data.timer = this.timer;
		data.isPermaLocked = this.isPermaLocked;
	}
	
	// Container:
	if (this.isContainer()) {
		data.isOpen = this.isOpen;
		data.isGuarded = this.isGuarded;
	}
	
	// Crystal Chest:
	if (this.item) {
		data.item = this.item.toData();
	}
	
	if (this.groupId) {
		data.groupId = this.groupId;
	}
	
	// Storing the name of corpses:
	if (this.npcTypeName) {
		data.npcTypeName = this.npcTypeName;
	}

	// Storing toTileIndex of portals:
	if (this.toTileIndex) {
		data.toTileIndex = this.toTileIndex;
	}
	
	// Storing triggerTileIndex:
	if (this.triggerTileIndex) {
		data.triggerTileIndex = this.triggerTileIndex;
	}

	// Storing damage of ice bombs:
	if (this.damage) {
		data.damage = this.damage;
	}
				
	return data;
};

// LOAD_OBJ:
// ************************************************************************************************
gs.loadObj = function (tileIndex, data) {
	var obj, typeName;
	
	typeName = this.getNameFromFrame(data.typeFrame, this.objectTypes);
	
	if (!typeName) {
		throw 'Cannot load object, unknown typeFrame: ' + data.typeFrame;
	}
	
	// Zone Line:
	if (gs.isFrameZoneLine(data.typeFrame)) {
		obj = this.createZoneLine(tileIndex, typeName, data.toZoneName, data.toZoneLevel);
	}
	// Door:
	else if (gs.isFrameDoor(data.typeFrame)) {
		obj = this.createDoor(tileIndex, typeName, data.closedFrame, data.isOpen, data.isGuarded);
		obj.isLocked = data.isLocked;
		obj.timer = data.timer;
		obj.isPermaLocked = data.isPermaLocked;
	}
	// Container:
	else if (gs.isFrameContainer(data.typeFrame)) {
		obj = this.createContainer(tileIndex, typeName, data.isOpen, data.isGuarded);
	}
	else {
		obj = this.createObject(tileIndex, typeName);
	}
	
	// Container contents:
	if (data.item) {
		obj.item = Item.createAndLoadItem(data.item);
	}
	
	// Creating Crystal chest item (used when loading from a static json file):
	if (obj.type.name === 'CrystalChest' && !data.item && data.itemDropTableName) {
		obj.item = gs.createRandomItem(data.itemDropTableName);
	}
	
	if (data.groupId) {
		obj.groupId = data.groupId;
	}
	
	if (data.hasOwnProperty('isFull')) {
		obj.isFull = data.isFull;
	}
	
	
	// Storing the name of corpses:
	if (data.npcTypeName) {
		obj.npcTypeName = data.npcTypeName;
	}

	// Storing toTileIndex of portals:
	if (data.toTileIndex) {
		obj.toTileIndex = data.toTileIndex;
	}
	
	// Storing triggerTileIndex:
	if (data.triggerTileIndex) {
		obj.triggerTileIndex = data.triggerTileIndex;
	}

	// Storing damage of ice bombs:
	if (data.damage) {
		obj.damage = data.damage;
	}
	
	obj.sprite.frame = data.frame;
	
	return obj;
};

// DESTROY_OBJECT:
// Call this from anywhere to safely destroy object and remove it from lists
// ************************************************************************************************
gs.destroyObject = function (obj) {
	this.removeFromArray(obj, this.objectList);
	this.getTile(obj.tileIndex).object = null;
	obj.destroy();
};

// DESTROY_ALL_OBJECTS:
// ************************************************************************************************
gs.destroyAllObjects = function () {
	for (let i = 0; i < this.objectList.length; i += 1) {
		this.objectList[i].destroy();
	}

	this.objectList = [];
};

// OBJECT_DESC:
// ************************************************************************************************
gs.objectDesc = function (object) {
	var str;
	
	// ZoneLine:
	if (object.isZoneLine()) {
		if (object.type.name === 'DownStairs') {
			str = 'Down stairs\n';
			str += 'To ' + gs.capitalSplit(object.toZoneName) + ' level ' + gs.niceZoneLevel(object.toZoneName, object.toZoneLevel) + '\n';
			str += '\nUse s or > to descend stairs. You can also use > to fast travel to down stairs once discovered.';
			return  str;
		} 
		else {
			str = 'Up stairs\n';
			str += 'To ' + gs.capitalSplit(object.toZoneName) + ' level ' + gs.niceZoneLevel(object.toZoneName, object.toZoneLevel) + '\n';
			str += '\nUse s or < to ascend stairs. You can also use < to fast travel to up stairs once discovered.'; 
			return  str;
		}
	}
	// Object:
	else {
		str = object.type.niceName + '\n';
		
		if (object.type.desc) {
			str += object.type.desc;
		}
		
		if (object.item && object.type.name === 'CrystalChest') {
			str += object.item.toLongDesc();
		}
		return str;
	}
};

gs.canShootTrap = function (tileIndex) {
	return this.getObj(tileIndex, ['FireShroom', 'BearTrap', 'SpikeTrap', 'FireVent', 'FireGlyph']);
};

// FIND_OBJECT:
// Find an object anywhere on the current level based on either a predicate or a typeName
// ************************************************************************************************
gs.findObj = function (pred) {
	if (typeof pred === 'string') {
		return gs.objectList.find(obj => obj.name === pred);
	}
	else {
		return gs.objectList.find(pred);
	}
};

// CREATE_OBJECT_POOL:
// ************************************************************************************************
gs.createObjectPool = function () {
	/*
	var i;
	this.objectPool = [];
	for (i = 0; i < 200; i += 1) {
		this.objectPool[i] = new DefaultObject();
	}
	*/
};

// IS_FRAME_ZONE_LINE:
// Used when loading when only available information is frame.
// ************************************************************************************************
gs.isFrameZoneLine = function (frame) {
	var type = this.objectTypes[this.getNameFromFrame(frame, this.objectTypes)];
	return type && type.interactFunc === this.objectFuncs.useZoneLine;
};

// IS_FRAME_DOOR:
// Used when loading when only available information is frame.
// ************************************************************************************************
gs.isFrameDoor = function (frame) {
	var type = this.objectTypes[this.getNameFromFrame(frame, this.objectTypes)];
	return type && type.interactFunc === this.objectFuncs.useDoor;
};

// IS_FRAME_CONTAINER:
// Used when loading when only available information is frame.
// ************************************************************************************************
gs.isFrameContainer = function (frame) {
	var type = this.objectTypes[this.getNameFromFrame(frame, this.objectTypes)];
	return type && (type.interactFunc === this.objectFuncs.useContainer || type.interactFunc === this.objectFuncs.meatRack);
};/*global game, gs, console, util, PIXI*/
/*global TILE_SIZE, SCALE_FACTOR*/
/*jshint esversion: 6, laxbreak: true*/
'use strict';

// CREATE_SUMMON_EFFECT:
// ************************************************************************************************
gs.createSummonEffect = function (tileIndex, callBack, context) {
	var effect, position = util.toPosition(tileIndex), callBackWrap;
	
	if (!gs.getTile(tileIndex).visible) {
		callBack.call(context);
		return;
	}
	
	callBackWrap = function () {
		callBack.call(context);
		
		// Light:
		gs.createLightCircle({x: position.x, y: position.y + 10}, '#94fdff', 120, 60, '66');
	};
			
	// Anim Effect:
	effect = gs.createAnimEffect({x: position.x, y: position.y + 5}, 'SummonCircle');
	gs.createAnimEffect({x: position.x, y: position.y + 5}, 'SummonParticles');
			
	// Call Back:		
	effect.setOnFrame(5, callBackWrap, context);
	
	
};

// CREATING_HEALING_EFFECT:
// ************************************************************************************************
gs.createHealingEffect = function (tileIndex) {
	var pos = util.toPosition(tileIndex);
	
	if (!gs.getTile(tileIndex).visible) {
		return;
	}
	
	gs.createAnimEffect({x: pos.x, y: pos.y + 15}, 'HealingCircle');
	gs.createAnimEffect({x: pos.x, y: pos.y + 15}, 'HealingParticles');
	
	// Light:
	gs.createLightCircle({x: pos.x, y: pos.y + 10}, '#00ff00', 120, 50, '88');
};

// CREATING_MANA_EFFECT:
// ************************************************************************************************
gs.createManaEffect = function (tileIndex) {
	var pos = util.toPosition(tileIndex);
	
	if (!gs.getTile(tileIndex).visible) {
		return;
	}
	
	gs.createAnimEffect({x: pos.x, y: pos.y + 15}, 'ManaCircle');
	gs.createAnimEffect({x: pos.x, y: pos.y + 15}, 'ManaParticles');
	
	// Light:
	gs.createLightCircle({x: pos.x, y: pos.y + 10}, '#ff00ff', 120, 50, '88');
};

// CREATING_EXP_EFFECT:
// ************************************************************************************************
gs.createEXPEffect = function (tileIndex) {
	var pos = util.toPosition(tileIndex);
	
	if (!gs.getTile(tileIndex).visible) {
		return;
	}
	
	// Effects:
	gs.createAnimEffect({x: pos.x, y: pos.y + 40}, 'EXPCircle');
	gs.createAnimEffect({x: pos.x, y: pos.y + 10}, 'EXPParticles');
	
	// Light:
	gs.createLightCircle({x: pos.x, y: pos.y + 10}, '#ffff00', 120, 90, '66');
};

// CREATE_DISEASE_EFFECT:
// ************************************************************************************************
gs.createDiseaseEffect = function (tileIndex) {
	var pos = util.toPosition(tileIndex);
	
	if (!gs.getTile(tileIndex).visible) {
		return;
	}
	
	// Effects:
	gs.createAnimEffect({x: pos.x, y: pos.y}, 'DiseaseParticles');
};

// CREATE_FIRE_EFFECT:
// ************************************************************************************************
gs.createFireEffect = function (tileIndex) {
	var pos = util.toPosition(tileIndex);
	
	if (!gs.getTile(tileIndex).visible) {
		return;
	}
	
	// Effects:
	gs.createAnimEffect({x: pos.x, y: pos.y + 15}, 'FireCircle');
	gs.createAnimEffect({x: pos.x, y: pos.y + 15}, 'FireParticles');
	
	// Light:
	gs.createLightCircle({x: pos.x, y: pos.y + 10}, '#ff0000', 120, 90, '88');
};

// CREATE_ICE_EFFECT::
// ************************************************************************************************
gs.createIceEffect = function (tileIndex) {
	var pos = util.toPosition(tileIndex);
	
	if (!gs.getTile(tileIndex).visible) {
		return;
	}
	
	// Effects:
	gs.createAnimEffect({x: pos.x, y: pos.y + 15}, 'IceCircle');
	gs.createAnimEffect({x: pos.x, y: pos.y + 15}, 'IceParticles');
	
	// Light:
	gs.createLightCircle({x: pos.x, y: pos.y + 10}, '#6666ff', 120, 90, '88');
};

// CREATE_YELLOW_MAGIC_EFFECT::
// ************************************************************************************************
gs.createYellowMagicEffect = function (tileIndex) {
	var pos = util.toPosition(tileIndex);
	
	if (!gs.getTile(tileIndex).visible) {
		return;
	}
	
	// Effects:
	gs.createAnimEffect({x: pos.x, y: pos.y + 15}, 'YellowCircle');
	gs.createAnimEffect({x: pos.x, y: pos.y + 15}, 'YellowParticles');
	
	// Light:
	gs.createLightCircle({x: pos.x, y: pos.y + 10}, '#ffff00', 120, 90, '88');
};

// CREATE_SMITE_EFFECT:
// ************************************************************************************************
gs.createSmiteEffect = function (tileIndex) {
	var pos = util.toPosition(tileIndex), effect;
	
	if (!gs.getTile(tileIndex).visible) {
		return;
	}
	
	effect = gs.createAnimEffect({x: pos.x, y: pos.y + 15}, 'Smite');	
	effect.setOnFrame(5, function () {
		gs.createLightCircle({x: pos.x, y: pos.y + 10}, '#ff0000', 120, 30, '88');
	}, this);
};

// CREATE_MAGIC_SHOOT_EFFECT:
// ************************************************************************************************
gs.createMagicShootEffect = function (fromChar, toTileIndex, shootEffect) {
	var pos, normal, angle, light, alpha, animEffect;
	
	if (!gs.getTile(fromChar.tileIndex).visible) {
		return;
	}
	
	// Position and angle:
	normal = gs.getNormal(fromChar.tileIndex, toTileIndex);
	pos = {x: fromChar.body.position.x + fromChar.body.offset.x + normal.x * 8, y: fromChar.body.position.y + fromChar.body.offset.y + normal.y * 8};
	angle = 225 - util.angleToFace(fromChar.tileIndex, toTileIndex);
	
	// Effect:
	animEffect = gs.createAnimEffect(pos, shootEffect, angle);
	animEffect.setFollowSprite(fromChar.sprite);
	
	// Light:
	alpha = this.animEffectTypes[shootEffect].startAlpha || 'aa';
	light = gs.createLightCircle(pos, this.animEffectTypes[shootEffect].lightColor, 30, 10, alpha);
	light.fade = false;
	light.setFollowSprite(fromChar.sprite);
};

// CREATE_ANIM_EFFECT_TYPES:
// ************************************************************************************************
gs.createAnimEffectTypes = function () {
	this.animEffectTypes = {};
	
	// HIT:
	this.animEffectTypes.Hit = {
		startFrame: 1792,
		numFrames: 5,
		speed: 20,
		randAngle: true
	};
	
	// MAGIC_SHOOT:
	this.animEffectTypes.MagicShoot = {
		startFrame: 1798,
		numFrames: 4,
		speed: 20,
		lightColor: '#ff00ff'
	};
	
	// FIRE_SHOOT:
	this.animEffectTypes.FireShoot = {
		startFrame: 1802,
		numFrames: 4,
		speed: 20,
		lightColor: '#ff0000'
	};
	
	// ELECTRIC_SHOOT:
	this.animEffectTypes.ElectricShoot = {
		startFrame: 1806,
		numFrames: 4,
		speed: 20,
		lightColor: '#0238b3'
	};
	
	// COLD_SHOOT:
	this.animEffectTypes.ColdShoot = {
		startFrame: 1810,
		numFrames: 4,
		speed: 20,
		lightColor: '#ffffff',
		startAlpha: '11',
	};
	
	// TOXIC_SHOOT:
	this.animEffectTypes.ToxicShoot = {
		startFrame: 1814,
		numFrames: 4,
		speed: 20,
		lightColor: '#aaff00',
		startAlpha: '66',
	};
	
	// SUMMON_CIRCLE:
	this.animEffectTypes.SummonCircle = {
		tileset: 'EffectsTileset',
		startFrame: 64,
		numFrames: 16,
		speed: 20,
		pauseGame: true,
		backLayer: true,
	};
	
	// SUMMON_PARTICLES:
	this.animEffectTypes.SummonParticles = {
		tileset: 'EffectsTileset',
		startFrame: 96,
		numFrames: 16,
		speed: 20,
	};
	
	// HEALING_CIRCLE:
	this.animEffectTypes.HealingCircle = {
		tileset: 'EffectsTileset',
		startFrame: 128,
		numFrames: 12,
		speed: 20,
		pauseGame: true,
		backLayer: true,
	};
	
	// HEALING_PARTICLES:
	this.animEffectTypes.HealingParticles = {
		tileset: 'EffectsTileset',
		startFrame: 160,
		numFrames: 12,
		speed: 20,
		pauseGame: true,
	};
	
	// MANA_CIRCLE:
	this.animEffectTypes.ManaCircle = {
		tileset: 'EffectsTileset',
		startFrame: 192,
		numFrames: 12,
		speed: 20,
		pauseGame: true,
		backLayer: true,
	};
	
	// MANA_PARTICLES:
	this.animEffectTypes.ManaParticles = {
		tileset: 'EffectsTileset',
		startFrame: 224,
		numFrames: 12,
		speed: 20,
		pauseGame: true,
	};
	
	// EXP_CIRCLE:
	this.animEffectTypes.EXPCircle = {
		tileset: 'EffectsTileset',
		startFrame: 256,
		numFrames: 16,
		speed: 20,
		pauseGame: true,
		backLayer: true,
	};
	
	// EXP_PARTICLES:
	this.animEffectTypes.EXPParticles = {
		tileset: 'EffectsTileset',
		startFrame: 288,
		numFrames: 16,
		speed: 20,
		pauseGame: true,
	};
	
	// DISEASE_PARTICLES:
	this.animEffectTypes.DiseaseParticles = {
		tileset: 'EffectsTileset',
		startFrame: 416,
		numFrames: 16,
		speed: 15,
		pauseGame: true,
	};
	
	// FIRE_CIRCLE:
	this.animEffectTypes.FireCircle = {
		tileset: 'EffectsTileset',
		startFrame: 144	,
		numFrames: 12,
		speed: 15,
		pauseGame: true,
		backLayer: true,
	};
	
	// FIRE_PARTICLES:
	this.animEffectTypes.FireParticles = {
		tileset: 'EffectsTileset',
		startFrame: 176,
		numFrames: 12,
		speed: 15,
		pauseGame: true,
	};
	
	// ICE_CIRCLE:
	this.animEffectTypes.IceCircle = {
		tileset: 'EffectsTileset',
		startFrame: 208	,
		numFrames: 12,
		speed: 15,
		pauseGame: true,
		backLayer: true,
	};
	
	// ICE_PARTICLES:
	this.animEffectTypes.IceParticles = {
		tileset: 'EffectsTileset',
		startFrame: 240,
		numFrames: 12,
		speed: 15,
		pauseGame: true,
	};
	
	// YELLOW_CIRCLE:
	this.animEffectTypes.YellowCircle = {
		tileset: 'EffectsTileset',
		startFrame: 272	,
		numFrames: 12,
		speed: 15,
		pauseGame: true,
		backLayer: true,
	};
	
	// YELLOW_PARTICLES:
	this.animEffectTypes.YellowParticles = {
		tileset: 'EffectsTileset',
		startFrame: 304,
		numFrames: 12,
		speed: 15,
		pauseGame: true,
	};
	
	// SMITE:
	this.animEffectTypes.Smite = {
		tileset: 'EffectsTileset',
		startFrame: 640,
		numFrames: 8,
		speed: 15,
	};
	
};

// CREATE_ANIM_EFFECT:
// ************************************************************************************************
gs.createAnimEffect = function (position, typeName, angle) {
	return new AnimEffect(position, typeName, angle);
};

// ANIM_EFFECT:
// ************************************************************************************************
function AnimEffect (position, typeName, angle) {
	var tileset, group;
	
	
	// Properties:
	this.type = gs.animEffectTypes[typeName];
	this.isAlive = true;
	this.followSprite = null;
	
	// Sprite:
	tileset = this.type.tileset || 'Tileset';
	
	if (this.type.backLayer) {
		group = gs.floorObjectSpritesGroup;
	}
	else {
		group = gs.projectileSpritesGroup;
	}
	
	
	this.sprite = gs.createSprite(position.x, position.y, tileset, group);
    this.sprite.anchor.setTo(0.5, 0.5);
	this.sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	
	if (tileset === 'EffectsTileset') {
		this.sprite.anchor.setTo(0.5, 0.75);
	}
	
	if (this.type.randAngle) {
		this.sprite.angle = util.randInt(0, 7) * 45;
	}
	
	if (angle) {
		this.sprite.angle = angle;
	}
	
	// Anim:
    this.sprite.animations.add('Anim', gs.range(this.type.startFrame, this.type.startFrame + this.type.numFrames), this.type.speed, false);
    this.sprite.play('Anim');
	
	if (this.type.pauseGame) {
		gs.projectileList.push(this);
	}
	else {
		gs.particleList.push(this);
	}
	
}

// SET_FOLLOW_SPRITE:
// Will follow the sprite with each update, maintaining the initial offset
// ************************************************************************************************
AnimEffect.prototype.setFollowSprite = function (sprite) {
	this.followSprite = sprite;
	this.offset = {x: this.sprite.x - sprite.x, y: this.sprite.y - sprite.y};
};

// SET_ON_FRAME:
// ************************************************************************************************
AnimEffect.prototype.setOnFrame = function (frame, func, context) {
	this.onFrame = frame;
	this.onFrameFunc = func;
	this.onFrameContext = context;
};

// UPDATE:
// ************************************************************************************************
AnimEffect.prototype.update = function () {
	// Follow Sprite:
	if (this.followSprite) {
		this.sprite.x = this.followSprite.x + this.offset.x;
		this.sprite.y = this.followSprite.y + this.offset.y;
	}
	
	// On Frame:
	if (this.sprite.frame === this.type.startFrame + this.onFrame) {
		this.onFrameFunc.call(this.onFrameContext);
		this.onFrame = -1;
	}
	
	if (this.animComplete()) {
		this.destroy();
	}
};

// ANIMATION_COMPLETE:
// ************************************************************************************************
AnimEffect.prototype.animComplete = function () {
	return this.sprite.frame >= this.type.startFrame + this.type.numFrames
		|| this.sprite.animations.getAnimation('Anim').isFinished;
};

// DESTROY:
// ************************************************************************************************
AnimEffect.prototype.destroy = function () {
	this.isAlive = false;
	this.sprite.destroy();
};

// CREATE_LIGHT_CIRCLE:
// ************************************************************************************************
gs.createLightCircle = function (position, color, radius, life, startAlpha) {
	return new LightCircle(position, color, radius, life, startAlpha);
};

// LIGHT_CIRCLE:
// ************************************************************************************************
function LightCircle (position, color, radius, life, startAlpha) {	
	
	startAlpha = startAlpha || 'aa';
	
	
	// Properties:
	this.isAlive = true;
	this.life = life;
	this.startLife = life;
	this.fade = true;
	this.followSprite = null;
	
	// Bitmap:
	this.bmp = game.add.bitmapData(radius * 2, radius * 2);
	
	var gradient = this.bmp.context.createRadialGradient(radius, radius, radius * 2 * 0.05, radius, radius, radius * 2 * 0.5);
	gradient.addColorStop(0, color + startAlpha);//'rgba(255, 255, 255, 0.25');
	gradient.addColorStop(1, color + '00'); //'rgba(255, 255, 255, 0.0');
	this.bmp.context.fillStyle = gradient;
	this.bmp.context.fillRect(0, 0, radius * 2, radius * 2);
	
	// Sprite:
	this.sprite = gs.createSprite(position.x, position.y, this.bmp, gs.hudTileSpritesGroup);
	this.sprite.anchor.setTo(0.5, 0.5);
	this.sprite.blendMode = PIXI.blendModes.ADD;
	this.sprite.alpha = 0.4;
	
	gs.particleList.push(this);
	
}

// SET_FOLLOW_SPRITE:
// Will follow the sprite with each update, maintaining the initial offset
// ************************************************************************************************
LightCircle.prototype.setFollowSprite = function (sprite) {
	this.followSprite = sprite;
	this.offset = {x: this.sprite.x - sprite.x, y: this.sprite.y - sprite.y};
};

// UPDATE:
// ************************************************************************************************
LightCircle.prototype.update = function () {
	var alpha;
	
	// Follow Sprite:
	if (this.followSprite) {
		this.sprite.x = this.followSprite.x + this.offset.x;
		this.sprite.y = this.followSprite.y + this.offset.y;
	}
	
	if (!this.noLife) {
		this.life -= 1;
	}
	
	if (this.fade) {
		alpha = Math.min(1.0, (1.5 * this.life)  / this.startLife);
		this.sprite.alpha = Math.max(0, alpha * 0.4);
	}
	
	
	if (!this.noLife && this.life <= 0) {
		this.destroy();
	}
};

// DESTROY:
// ************************************************************************************************
LightCircle.prototype.destroy = function () {
	this.isAlive = false;
	this.bmp.destroy();
	this.sprite.destroy();
};/*global game, gs, util*/
/*global TILE_SIZE, HELL_FIRE_DAMAGE, RED_TARGET_BOX_FRAME, SHROOM_HP, SHROOM_EP, FACTION, RED_BOX_FRAME*/
/*jshint esversion: 6, laxbreak: true*/
'use strict';

// CREATE_WEAPON_EFFECTS:
// ********************************************************************************************
gs.createWeaponEffects = function () {
	this.weaponEffects = {};

    // WEAPON_EFFECT_MELEE:
    // ********************************************************************************************
	this.weaponEffects.Melee = {};
	this.weaponEffects.Melee.effect = function (tileIndex, item) {
		var flags = {};
		
		if (item.type.knockBack && util.frac() < 0.25) {
			flags.knockBack = 1;
		}
		
		// Melee Attack:
        gs.meleeAttack(gs.pc, tileIndex, gs.pc.weaponDamage(item), flags);
		
		// Play Sound:
		gs.playSound(gs.sounds.melee, gs.pc.tileIndex);
	};
	this.weaponEffects.Melee.showTarget = function (tileIndex, weapon) {
		gs.targetSprites[0].x = tileIndex.x * TILE_SIZE;
		gs.targetSprites[0].y = tileIndex.y * TILE_SIZE;
		gs.targetSprites[0].frame = RED_TARGET_BOX_FRAME;
		gs.targetSprites[0].visible = true;
	};
	this.weaponEffects.Melee.skill = 'Melee';
	
	// WEAPON_EFFECTS_POLEARM:
	// ********************************************************************************************
	this.weaponEffects.PoleArm = {};
	this.weaponEffects.PoleArm.effect = function (tileIndex, item) {
		var flags = {};
		
		// Weapon Knock Back:
		if (item.type.knockBack && util.frac() < 0.25) {
			flags.knockBack = 1;
		}
		
		// Polearm Attack:
		this.getTargetList(tileIndex).forEach(function (index) {
			gs.meleeAttack(gs.pc, index, gs.pc.weaponDamage(item), flags);
		}, this);
		
		// Play Sound:
		gs.playSound(gs.sounds.melee, gs.pc.tileIndex);
	};
	this.weaponEffects.PoleArm.showTarget = function (tileIndex, weapon) {
		var i = 0;
		
		this.getTargetList(tileIndex).forEach(function (index) {
			gs.targetSprites[i].x = index.x * TILE_SIZE;
			gs.targetSprites[i].y = index.y * TILE_SIZE;
			gs.targetSprites[i].frame = RED_TARGET_BOX_FRAME;
			gs.targetSprites[i].visible = true;
			i += 1;
		}, this);
		
		if (i === 0 && gs.canShootTrap(tileIndex)) {
			gs.targetSprites[0].x = tileIndex.x * TILE_SIZE;
			gs.targetSprites[0].y = tileIndex.y * TILE_SIZE;
			gs.targetSprites[0].frame = RED_TARGET_BOX_FRAME;
			gs.targetSprites[0].visible = true;
		}
		
	};
	this.weaponEffects.PoleArm.getTargetList = function (tileIndex) {
		var list, normal, newTileIndex;
		
		normal = gs.getNormal(gs.pc.tileIndex, tileIndex);
		newTileIndex = {x: gs.pc.tileIndex.x + normal.x * 2, y: gs.pc.tileIndex.y + normal.y * 2};
		
		list = gs.getIndexInRay(gs.pc.tileIndex, newTileIndex);
		list = list.filter(index => gs.getChar(index) && (gs.pc.isHostileToMe(gs.getChar(index)) || gs.getChar(index).faction === FACTION.DESTRUCTABLE));
		
		return list;
	};
	
	this.weaponEffects.PoleArm.skill = 'Melee';
	
	
	 // WEAPON_EFFECT_FLAME:
    // ********************************************************************************************
	this.weaponEffects.Flame = {};
	this.weaponEffects.Flame.effect = function (tileIndex, item) {
		gs.playSound(gs.sounds.melee, gs.pc.tileIndex);
		
		// Crit unaware characters:
		let isCrit = false;
		if (!gs.getChar(tileIndex).isAgroed) {
			isCrit = true;
		}
		
		gs.createFire(tileIndex, Math.ceil(item.getModdedStat('damage') * gs.pc.meleeDamageMultiplier), {killer: gs.pc, isCrit: isCrit});
	};
	this.weaponEffects.Flame.showTarget = function (tileIndex, weapon) {
		gs.targetSprites[0].x = tileIndex.x * TILE_SIZE;
		gs.targetSprites[0].y = tileIndex.y * TILE_SIZE;
		gs.targetSprites[0].frame = RED_TARGET_BOX_FRAME;
		gs.targetSprites[0].visible = true;
	};
	this.weaponEffects.Flame.skill = 'Melee';
    
	

    
    // WEAPON_EFFECT_CLEAVE:
    // ************************************************************************************************
	this.weaponEffects.Cleave = {};
	this.weaponEffects.Cleave.effect = function (tileIndex, item) {
        // Cleave Hit:
		this.getTargetList(tileIndex).forEach(function (index) {
			gs.meleeAttack(gs.pc, index, gs.pc.weaponDamage(item));
		}, this);
		
		// Sound:
        gs.playSound(gs.sounds.melee, gs.pc.tileIndex);
        
	};
	this.weaponEffects.Cleave.showTarget = function (tileIndex, weapon) {
		var i = 0;
		
		this.getTargetList(tileIndex).forEach(function (index) {
			gs.targetSprites[i].x = index.x * TILE_SIZE;
			gs.targetSprites[i].y = index.y * TILE_SIZE;
			gs.targetSprites[i].frame = RED_TARGET_BOX_FRAME;
			gs.targetSprites[i].visible = true;
			i += 1;
		}, this);
	};
	this.weaponEffects.Cleave.getTargetList = function (tileIndex) {
		var list = gs.getIndexInRadius(gs.pc.tileIndex, 1.5);
		list = list.filter(index => gs.getChar(index) && (gs.pc.isHostileToMe(gs.getChar(index)) || gs.getChar(index).faction === FACTION.DESTRUCTABLE));
		return list;
	};
	this.weaponEffects.Cleave.skill = 'Melee';

	// WEAPON_EFFECT_STORM_CHOPPER:
    // ************************************************************************************************
	this.weaponEffects.StormChopper = {};
	this.weaponEffects.StormChopper.effect = function (tileIndex, item) {
        // Cleave Hit:
		this.getTargetList(tileIndex).forEach(function (index) {
			let isCrit = false;
			
			// Crit unaware characters:
			// Must recheck for char existance in case he was killed by previous part of the cleave
			// Ex. consider hitting a bloat, that explodes, killing his friend, and then trying to hit the now dead
			if (gs.getChar(index) && !gs.getChar(index).isAgroed) {
				isCrit = true;
			}
			
			gs.createShock(index, Math.ceil(item.getModdedStat('damage') * gs.pc.meleeDamageMultiplier), {killer: gs.pc, isCrit: isCrit});
		}, this);
		
		// Sound:
        gs.playSound(gs.sounds.melee, gs.pc.tileIndex);
	};
	this.weaponEffects.StormChopper.showTarget = this.weaponEffects.Cleave.showTarget;
	this.weaponEffects.StormChopper.getTargetList = this.weaponEffects.Cleave.getTargetList;
	this.weaponEffects.StormChopper.skill = 'Melee';
	
	// WEAPON_EFFECT_MOB_FUCKER:
	// ********************************************************************************************
	this.weaponEffects.MobFucker = {};
	this.weaponEffects.MobFucker.effect = function (tileIndex, item) {
		var i;

		for (i = 0; i < gs.characterList.length; i += 1) {
			if (gs.getTile(gs.characterList[i].tileIndex).visible && gs.characterList[i].isAlive && gs.characterList[i] !== gs.pc) {
				gs.createFire(gs.characterList[i].tileIndex, 100, {killer: gs.pc});
			}
		}
	};
	this.weaponEffects.MobFucker.showTarget = function (tileIndex, weapon) {
		gs.targetSprites[0].x = tileIndex.x * TILE_SIZE;
		gs.targetSprites[0].y = tileIndex.y * TILE_SIZE;
		gs.targetSprites[0].visible = true;
	};
	this.weaponEffects.MobFucker.skill = 'Range';

	
	 // WEAPON_EFFECT_POISON_DAGGER:
    // ********************************************************************************************
	this.weaponEffects.PoisonDagger = {};
	this.weaponEffects.PoisonDagger.effect = function (tileIndex, item) {
		// Melee Attack:
        gs.meleeAttack(gs.pc, tileIndex, gs.pc.weaponDamage(item));
		
		// Play Sound:
		gs.playSound(gs.sounds.melee, gs.pc.tileIndex);
		
		// Apply Poison:
		if (gs.getChar(tileIndex) && gs.getChar(tileIndex).isAlive) {
			gs.getChar(tileIndex).addPoisonDamage(10);
		}
	};
	this.weaponEffects.PoisonDagger.showTarget = function (tileIndex, weapon) {
		gs.targetSprites[0].x = tileIndex.x * TILE_SIZE;
		gs.targetSprites[0].y = tileIndex.y * TILE_SIZE;
		gs.targetSprites[0].frame = RED_TARGET_BOX_FRAME;
		gs.targetSprites[0].visible = true;
	};
	this.weaponEffects.PoisonDagger.skill = 'Melee';
	 


	// SINGLE_PROJECTILE_WEAPON_EFFECT:
	// ********************************************************************************************
	this.weaponEffects.SingleProjectile = {};
	this.weaponEffects.SingleProjectile.effect = function (tileIndex, item, flags) {
		var projectile;
		
		flags = flags || {};
		flags.killer = gs.pc;
		flags.isCrit = flags.isCrit || gs.pc.alwaysProjectileCrit;
		
		if (gs.pc.hasTalent('PerfectAim')) {
			flags.perfectAim = true;
		}
		
		gs.playSound(item.type.shootSound || gs.sounds.throw, gs.pc.tileIndex);
		
		projectile = gs.createProjectile(gs.pc, tileIndex, item.type.projectileName, gs.pc.weaponDamage(item), flags);
			
		// Consuming Ammo:
		if (!item.type.noAmmo) {
			if (game.rnd.frac() <= gs.pc.saveAmmoChance) {
				gs.pc.popUpText('Saved Ammo', '#ffffff');
			} 
			else {
				if (item.amount === 1) {
					gs.pc.popUpText('Out of Ammo', '#ffffff');
				}

				gs.pc.inventory.removeItem(item, 1);
			}
		}
		
		// Character bounce:
		gs.pc.body.faceTileIndex(tileIndex);
		gs.pc.body.bounceTowards(tileIndex);
		
		return projectile;
		
	};
	this.weaponEffects.SingleProjectile.showTarget = function (tileIndex, weapon) {
		// Show red X line if target blocked:
		if (gs.pc.hasTalent('PerfectAim')) {
			if (gs.distance(gs.pc.tileIndex, tileIndex) > gs.pc.weaponRange(weapon)
				|| !gs.isRayClear(gs.pc.tileIndex, tileIndex)
				|| !gs.isRayStaticPassable(gs.pc.tileIndex, tileIndex)) {
				gs.showTargetLine(tileIndex);
			}
		}
		else {
			if (gs.distance(gs.pc.tileIndex, tileIndex) > gs.pc.weaponRange(weapon)
				|| gs.distance(gs.pc.tileIndex, tileIndex) < gs.pc.weaponMinRange(weapon)
				|| (!gs.isRayClear(gs.pc.tileIndex, tileIndex) && !gs.getTile(tileIndex).visible)
				|| !gs.isRayPassable(gs.pc.tileIndex, tileIndex)) {
				gs.showTargetLine(tileIndex);
			}
		}
	
		// Show red target:
		gs.targetSprites[0].x = tileIndex.x * TILE_SIZE;
		gs.targetSprites[0].y = tileIndex.y * TILE_SIZE;
		gs.targetSprites[0].frame = RED_TARGET_BOX_FRAME;
		gs.targetSprites[0].visible = true;
	};
	this.weaponEffects.SingleProjectile.skill = 'Range';
	
	// MAGIC_STAFF:
	// ********************************************************************************************
	this.weaponEffects.MagicStaff = {};
	this.weaponEffects.MagicStaff.skill = 'Range';
	this.weaponEffects.MagicStaff.effect = function (tileIndex, item, flags = {}) {
		flags.killer = gs.pc;
		
		// Sound:
		gs.playSound(gs.sounds.throw, gs.pc.tileIndex);
		
		// Projectile:
		gs.createProjectile(gs.pc, tileIndex, item.type.projectileName, gs.pc.weaponDamage(item), flags);
		
		// Character bounce:
		gs.pc.body.faceTileIndex(tileIndex);
		gs.pc.body.bounceTowards(tileIndex);
		
		// Shoot effect:
		if (item.type.shootEffect) {
			gs.createMagicShootEffect(gs.pc, tileIndex, item.type.shootEffect);
		}
	};
	this.weaponEffects.MagicStaff.showTarget = function (tileIndex, weapon) {
		var indexList, i = 0;
		
		// Show red X line if target blocked:
		if (gs.distance(gs.pc.tileIndex, tileIndex) > gs.pc.weaponRange(weapon)
			|| (!gs.isRayClear(gs.pc.tileIndex, tileIndex) && !gs.getTile(tileIndex).visible)
			|| !gs.isRayPassable(gs.pc.tileIndex, tileIndex)) {
			gs.showTargetLine(tileIndex);
			
			// Show red target:
			gs.targetSprites[0].x = tileIndex.x * TILE_SIZE;
			gs.targetSprites[0].y = tileIndex.y * TILE_SIZE;
			gs.targetSprites[0].frame = RED_TARGET_BOX_FRAME;
			gs.targetSprites[0].visible = true;
		}
		else if (weapon.type === gs.itemTypes.GreaterStaffOfStorms) {
			indexList = gs.getIndexInRadius(tileIndex, 1.0);
			indexList = indexList.filter(index => gs.isStaticPassable(index));
			
			indexList.forEach(function (index) {
				gs.targetSprites[i].x = index.x * TILE_SIZE;
				gs.targetSprites[i].y = index.y * TILE_SIZE;
				gs.targetSprites[i].visible = true;
				gs.targetSprites[i].frame = RED_TARGET_BOX_FRAME;
				i += 1;
			}, this);
		}
		else {
			// Show red target:
			gs.targetSprites[0].x = tileIndex.x * TILE_SIZE;
			gs.targetSprites[0].y = tileIndex.y * TILE_SIZE;
			gs.targetSprites[0].frame = RED_TARGET_BOX_FRAME;
			gs.targetSprites[0].visible = true;
		}
		
			
		
		
	};
};

// CREATE_ITEM_EFFECTS:
// ************************************************************************************************
gs.createItemEffects = function () {
	
	this.itemEffects = {};
	
	// SCROLL_OF_TELEPORTATION:
	// ********************************************************************************************
	this.itemEffects.Teleportation = {};
	this.itemEffects.Teleportation.useImmediately = true;
	this.itemEffects.Teleportation.useOn = function (actingCharacter, targetTileIndex) {
		gs.createParticlePoof(gs.pc.tileIndex, 'PURPLE');
		gs.playSound(gs.sounds.teleport, gs.pc.tileIndex);
		gs.pc.randomTeleport();
		gs.pc.popUpText('Teleport!', '#ffffff');
		gs.createParticlePoof(gs.pc.tileIndex, 'PURPLE');
	};

	// SCROLL_OF_ENCHANTMENT:
	// ********************************************************************************************
	this.itemEffects.ScrollOfEnchantment = {};
	this.itemEffects.ScrollOfEnchantment.useImmediately = true;
	this.itemEffects.ScrollOfEnchantment.useOn = function () {
		gs.enchantmentMenu.open();
	};
	
	// SCROLL_OF_ACQUIREMENT:
	// ********************************************************************************************
	this.itemEffects.ScrollOfAcquirement = {};
	this.itemEffects.ScrollOfAcquirement.useImmediately = true;
	this.itemEffects.ScrollOfAcquirement.useOn = function () {
		gs.acquirementMenu.open();
	};
	
	// ********************************************************************************************
	// POTIONS:
	// ********************************************************************************************
	// HEALING_SHROOM:
	// ********************************************************************************************
	this.itemEffects.HealingShroom = {};
	this.itemEffects.HealingShroom.useImmediately = true;
	this.itemEffects.HealingShroom.useOn = function () {
		gs.pc.healHp(SHROOM_HP);
		gs.createParticlePoof(gs.pc.tileIndex, 'GREEN');
	};
	
	// ENERGY_SHROOM:
	// ********************************************************************************************
	this.itemEffects.EnergyShroom = {};
	this.itemEffects.EnergyShroom.useImmediately = true;
	this.itemEffects.EnergyShroom.useOn = function () {
		gs.pc.gainMp(SHROOM_EP);
		gs.createParticlePoof(gs.pc.tileIndex, 'PURPLE');
	};

	// EAT:
	// ********************************************************************************************
	this.itemEffects.Eat = {};
	this.itemEffects.Eat.useImmediately = true;
	this.itemEffects.Eat.useOn = function (item) {
		gs.pc.currentFood = gs.pc.maxFood;
		gs.pc.healHp(Math.ceil(gs.pc.maxHp / 2));
		gs.pc.gainMp(Math.ceil(gs.pc.maxMp / 2));
	};

	// POTION_OF_HEALING:
	// ********************************************************************************************
	this.itemEffects.PotionOfHealing = {};
	this.itemEffects.PotionOfHealing.useImmediately = true;
	this.itemEffects.PotionOfHealing.useOn = function () {		
		if (gs.pc.currentHp === gs.pc.maxHp) {
			gs.pc.permanentHpBonus += 4;
			gs.pc.popUpText('+4 Max HP', '#ffffff');
			gs.pc.updateStats();
		}
		else {
			gs.pc.popUpText('Fully Healed', '#ffffff');
		}
		// Full Heal:
		gs.pc.healHp(gs.pc.maxHp);
		gs.pc.cure();
		
		// Sound:
		gs.playSound(gs.sounds.cure, gs.pc.tileIndex);
	
		// Effect:
		gs.createHealingEffect(gs.pc.tileIndex);
		
	};
	
	// POTION_OF_ENERGY:
	// ********************************************************************************************
	this.itemEffects.PotionOfEnergy = {};
	this.itemEffects.PotionOfEnergy.useImmediately = true;
	this.itemEffects.PotionOfEnergy.useOn = function () {
		if (gs.pc.currentMp === gs.pc.maxMp) {
			gs.pc.permanentMpBonus += 1;
			gs.pc.popUpText('+1 Max MP', '#ffffff');
			gs.pc.updateStats();
		}
		else {
			gs.pc.popUpText('Full Energy', '#ffffff');
		}
		
		// Full Mana and cool Downs:
		gs.pc.gainMp(gs.pc.maxMp);
		gs.pc.mentalCure();
		gs.pc.resetAllCoolDowns();
		
		// Sound:
		gs.playSound(gs.sounds.cure, gs.pc.tileIndex);
		
		// Effect:
		gs.createManaEffect(gs.pc.tileIndex);
	};
	
	// POTION_OF_EXPERIENCE:
	// ********************************************************************************************
	this.itemEffects.PotionOfExperience = {};
	this.itemEffects.PotionOfExperience.useImmediately = true;
	this.itemEffects.PotionOfExperience.useOn = function () {
		// Status Effect:
		gs.pc.statusEffects.add('ExperienceBoost');
		
		// Spell Effect:
		gs.createEXPEffect(gs.pc.tileIndex);
		
		// Sound:
		gs.playSound(gs.sounds.cure, gs.pc.tileIndex);
	};
	
	// POTION_OF_POWER:
	// ********************************************************************************************
	this.itemEffects.PotionOfPower = {};
	this.itemEffects.PotionOfPower.useImmediately = true;
	this.itemEffects.PotionOfPower.useOn = function () {
		// Full Mana and cool Downs:
		gs.pc.gainMp(gs.pc.maxMp);
		gs.pc.mentalCure();
		gs.pc.resetAllCoolDowns();
		
		// Status Effect:
		gs.pc.statusEffects.add('Power');
		
		// Spell Effect:
		gs.createIceEffect(gs.pc.tileIndex);
		
		// Sound:
		gs.playSound(gs.sounds.cure, gs.pc.tileIndex);
	};
	
	// POTION_OF_RESISTANCE:
	// ********************************************************************************************
	this.itemEffects.PotionOfResistance = {};
	this.itemEffects.PotionOfResistance.useImmediately = true;
	this.itemEffects.PotionOfResistance.useOn = function () {
		// Full Heal:
		gs.pc.healHp(gs.pc.maxHp);
		gs.pc.cure();
		
		// Status Effect:
		gs.pc.statusEffects.add('Resistance');
		
		// Spell Effect:
		gs.createIceEffect(gs.pc.tileIndex);
		
		// Sound:
		gs.playSound(gs.sounds.cure, gs.pc.tileIndex);
	};
	
	// POTION_OF_GAIN_ATTRIBUTE:
	// ********************************************************************************************
	this.itemEffects.PotionOfGainAttribute = {};
	this.itemEffects.PotionOfGainAttribute.useImmediately = true;
	this.itemEffects.PotionOfGainAttribute.useOn = function () {
		gs.openAttributeGainMenu();
		
		// Spell Effect:
		gs.createFireEffect(gs.pc.tileIndex);
		
		// Sound:
		gs.playSound(gs.sounds.cure, gs.pc.tileIndex);
	};
};

/*global game, gs, console, Phaser*/
/*global SHROOM_HP, SHROOM_EP, MAX_ENCHANTMENT*/
/*jshint white: true, laxbreak: true */
'use strict';

// CREATE_ITEM_TYPES:
// ************************************************************************************************
gs.createItemTypes = function () {
	var key,
		pct,
		LOW_ITEM_COST,
		MED_ITEM_COST,
		HIGH_ITEM_COST;

	this.createWeaponEffects();
	this.createItemEffects();
	
	// ITEM_TYPES:
	// ********************************************************************************************
	this.itemTypes = {
		// MISC_WEAPONS:
		Fists: 				{f: 0, slot: 'weapon', hands: 1, effect: 'Melee', range: 1.5},
		MobFucker: 			{f: 0, slot: 'weapon', hands: 1, effect: 'MobFucker', range: 1000},
		FlamingHands:		{f: 0, slot: 'weapon', hands: 1, effect: 'MagicStaff', projectileName: 'FireArrow', range: 5.5},
		
		// MELEE_WEAPONS:
		Staff:				{f: 0, slot: 'weapon', hands: 1, effect: 'Melee', range: 1.5},
		ShortSword:			{f: 1, slot: 'weapon', hands: 1, effect: 'Melee', range: 1.5},
		LongSword: 			{f: 2, slot: 'weapon', hands: 1, effect: 'Melee', range: 1.5},
		Spear: 				{f: 3, slot: 'weapon', hands: 1, effect: 'PoleArm', range: 2.0},
		HandAxe:			{f: 4, slot: 'weapon', hands: 1, effect: 'Cleave', range: 1.5},
        TwoHandSword: 		{f: 5, slot: 'weapon', hands: 2, effect: 'Melee', range: 1.5},
		Halberd:			{f: 6, slot: 'weapon', hands: 2, effect: 'PoleArm', range: 2.0},
		BattleAxe: 			{f: 7, slot: 'weapon', hands: 2, effect: 'Cleave', range: 1.5},
		ShortBow:			{f: 8, slot: 'weapon', hands: 2, effect: 'SingleProjectile', projectileName: 'Dart', range: 7.0, noAmmo: true},
		LongBow:			{f: 9, slot: 'weapon', hands: 2, effect: 'SingleProjectile', projectileName: 'Dart', range: 7.0, noAmmo: true},
		Sling:				{f: 10, slot: 'weapon', hands: 1, effect: 'SingleProjectile', projectileName: 'Stone', range: 7.0, noAmmo: true},
		Mace:				{f: 11, slot: 'weapon', hands: 1, effect: 'Melee', knockBack: 1, range: 1.5},
		WarHammer:			{f: 12, slot: 'weapon', hands: 2, effect: 'Melee', knockBack: 1, range: 1.5},
		BroadAxe:			{f: 13, slot: 'weapon', hands: 1, effect: 'Cleave', range: 1.5},
		
		// MAGIC_MELEE_WEAPONS:
		InfernoSword:		{f: 16, slot: 'weapon', hands: 1, effect: 'Flame', range: 1.5},
		StormChopper:		{f: 17, slot: 'weapon', hands: 1, effect: 'StormChopper', range: 1.5},
		PoisonDagger:		{f: 18, slot: 'weapon', hands: 1, effect: 'PoisonDagger', range: 1.5},
		
		
		// MAGIC_STAVES:
		GreaterStaffOfFire:		{f: 32, slot: 'weapon', hands: 1, effect: 'MagicStaff', projectileName: 'FireArrow', range: 5.5, shootEffect: 'FireShoot'},
		GreaterStaffOfStorms:	{f: 33, slot: 'weapon', hands: 1, effect: 'MagicStaff', projectileName: 'SparkBall', range: 5.5, shootEffect: 'ElectricShoot'},
		GreaterStaffOfIce:		{f: 34, slot: 'weapon', hands: 1, effect: 'MagicStaff', projectileName: 'IceArrow', range: 5.5, shootEffect: 'ColdShoot'},
		GreaterStaffOfPoison:	{f: 35, slot: 'weapon', hands: 1, effect: 'MagicStaff', projectileName: 'StrongPoisonArrow', range: 5.5, shootEffect: 'ToxicShoot'},
		StaffOfEnergy:			{f: 36, slot: 'weapon', hands: 1, effect: 'MagicStaff', projectileName: 'MagicMissile', range: 5.5, shootEffect: 'MagicShoot'},
		StaffOfPower:			{f: 38, slot: 'weapon', hands: 1, effect: 'MagicStaff', projectileName: 'MagicMissile', range: 5.5, shootEffect: 'MagicShoot'},
		
		// LESSER_STAVES:
		StaffOfFire:			{f: 40, slot: 'weapon', hands: 1, effect: 'MagicStaff', projectileName: 'FireArrow', range: 5.5, shootEffect: 'FireShoot'},
		StaffOfStorms:			{f: 41, slot: 'weapon', hands: 1, effect: 'MagicStaff', projectileName: 'Spark', range: 5.5, shootEffect: 'ElectricShoot'},
		StaffOfIce:				{f: 42, slot: 'weapon', hands: 1, effect: 'MagicStaff', projectileName: 'IceArrow', range: 5.5, shootEffect: 'ColdShoot'},
		StaffOfPoison:			{f: 43, slot: 'weapon', hands: 1, effect: 'MagicStaff', projectileName: 'StrongPoisonArrow', range: 5.5, shootEffect: 'ToxicShoot'},
		StaffOfMagicMissiles:	{f: 37, slot: 'weapon', hands: 1, effect: 'MagicStaff', projectileName: 'MagicMissile', range: 5.5, shootEffect: 'MagicShoot'},

		
		// RANGED_WEAPONS:
		Dart:				{f: 48, slot: 'weapon', hands: 1, effect: 'SingleProjectile', projectileName: 'Dart', range: 7.0, dropAmount: 12, stackable: true},
		Javelin:			{f: 49, slot: 'weapon', hands: 1, effect: 'SingleProjectile', projectileName: 'Dart', range: 7.0, dropAmount: 6, stackable: true},
		ThrowingNet:		{f: 50, slot: 'weapon', hands: 1, effect: 'SingleProjectile', projectileName: 'Net', range: 7.0, cantEnchant: true, dropAmount: 6, stackable: true},
		Bomb:				{f: 51, slot: 'weapon', hands: 1, effect: 'SingleProjectile', projectileName: 'PlayerBomb', range: 7.0, cantEnchant: true, dropAmount: 6, stackable: true},
        Chakram:            {f: 52, slot: 'weapon', hands: 1, effect: 'SingleProjectile', projectileName: 'Chakram', range: 7.0, dropAmount: 6, stackable: true},
		
		// SHIELDS:
		WoodenShield:			{f: 64, slot: 'shield'},
		MetalShield:			{f: 65, slot: 'shield'},
		ShieldOfReflection:		{f: 66, slot: 'shield'},
		OrbOfMana:				{f: 67, slot: 'shield'},
		RedDragonScaleShield:	{f: 68, slot: 'shield'},
		GreenDragonScaleShield:	{f: 69, slot: 'shield'},
		BlueDragonScaleShield:	{f: 70, slot: 'shield'},
		WhiteDragonScaleShield:	{f: 71, slot: 'shield'},
		OrbOfPower:				{f: 72, slot: 'shield'},
		
		// ARMOR (BODY):
		Robe:					{f: 80, slot: 'body'},
		LeatherArmor: 			{f: 81, slot: 'body'},
		PlateArmor: 			{f: 82, slot: 'body'},
		RobeOfWizardry:			{f: 83, slot: 'body'},
		CloakOfStealth:			{f: 84, slot: 'body'},
		RedDragonScaleArmor:	{f: 85, slot: 'body'},
		GreenDragonScaleArmor:	{f: 86, slot: 'body'},
		BlueDragonScaleArmor:	{f: 87, slot: 'body'},
		WhiteDragonScaleArmor:	{f: 88, slot: 'body'},
		
		// HELMETS (HEAD):
		Hat:					{f: 96, slot: 'head'},
		LeatherHelm:			{f: 97, slot: 'head'},
		PlateHelm:				{f: 98, slot: 'head'},
		HelmOfTelepathy:		{f: 99, slot: 'head', cantEnchant: true},
		CircletOfKnowledge:		{f: 100, slot: 'head'},
		ArcheryGoggles: 		{f: 101, slot: 'head'},
		
		// GLOVES (HANDS):
		ClothGloves:			{f: 112, slot: 'hands'},
		LeatherGloves: 			{f: 113, slot: 'hands'},
		PlateGloves: 			{f: 114, slot: 'hands'},
		GauntletsOfStrength:	{f: 115, slot: 'hands'},
		GlovesOfVampirism:		{f: 116, slot: 'hands'},
		
		// BOOTS (FEET):
		Shoes:					{f: 128, slot: 'feet'},
		LeatherBoots: 			{f: 129, slot: 'feet'},
		PlateBoots: 			{f: 130, slot: 'feet'},
		BootsOfStealth: 		{f: 133, slot: 'feet'},
		BootsOfFlight:			{f: 131, slot: 'feet', cantEnchant: true},
		BootsOfSpeed: 			{f: 132, slot: 'feet', cantEnchant: true},
		
		// COMMON RINGS:
		RingOfFire: 			{f: 144, slot: 'ring'},
		RingOfToxic:			{f: 145, slot: 'ring'},
		RingOfStorm:			{f: 146, slot: 'ring'},
		RingOfIce:				{f: 147, slot: 'ring'},
		RingOfSustenance: 		{f: 148, slot: 'ring'},
		RingOfStealth:			{f: 149, slot: 'ring'},
		RingOfHealth:			{f: 150, slot: 'ring'},
		RingOfMana:				{f: 151, slot: 'ring'},
		RingOfProtection:		{f: 152, slot: 'ring'},
		RingOfEvasion:			{f: 153, slot: 'ring'},
		RingOfStrength:			{f: 154, slot: 'ring'},
		RingOfIntelligence:		{f: 155, slot: 'ring'},
		RingOfDexterity:		{f: 156, slot: 'ring'},
		
		// UNCOMMON RINGS:
		RingOfFlight:			{f: 160, slot: 'ring', cantEnchant: true},
		RingOfWizardry:			{f: 161, slot: 'ring'},
		RingOfTheVampire:		{f: 162, slot: 'ring', baseMod: 1},
		RingOfLearning: 		{f: 163, slot: 'ring', cantEnchant: true},
		
		// RARE_RINGS:
		InfernoRing:			{f: 176, slot: 'ring', cantEnchant: true},
		RingOfThunder:			{f: 177, slot: 'ring', cantEnchant: true},
		RingOfReflection:		{f: 178, slot: 'ring'},
		RingOfLifeSaving:		{f: 179, slot: 'ring', cantEnchant: true},
		RingOfSpeed:			{f: 180, slot: 'ring', cantEnchant: true},
		RingOfWealth:			{f: 181, slot: 'ring', cantEnchant: true},
		
		// CHARMS:
		CharmOfEnergy:			{f: 272, slot: 'charm', useEffect: 'Energy', 			chargeTime: 250, baseMod: 1, maxMod: 3},
		CharmOfHealing:			{f: 273, slot: 'charm', useEffect: 'Healing', 			chargeTime: 250, baseMod: 1, maxMod: 3},
		CharmOfFire:			{f: 274, slot: 'charm', useEffect: 'BurstOfFlame', 		chargeTime: 150, baseMod: 1, maxMod: 3},
		CharmOfLightning:		{f: 275, slot: 'charm', useEffect: 'Shock', 			chargeTime: 150, baseMod: 1, maxMod: 3},
		CharmOfDisease:			{f: 276, slot: 'charm', useEffect: 'InfectiousDisease', chargeTime: 150, baseMod: 1, maxMod: 3},
		CharmOfFreezing:		{f: 277, slot: 'charm', useEffect: 'Freeze', 			chargeTime: 150, baseMod: 1, maxMod: 3},
		CharmOfBlinking:		{f: 278, slot: 'charm', useEffect: 'Blink', 			chargeTime: 250, baseMod: 1, maxMod: 3},
		CharmOfConfusion:		{f: 279, slot: 'charm', useEffect: 'Confusion',	 		chargeTime: 250, baseMod: 1, maxMod: 3},
		CharmOfClarity:			{f: 280, slot: 'charm', maxMod: 3},
		CharmOfRegeneration:	{f: 281, slot: 'charm', maxMod: 3},
		
		
		// WANDS:
		WandOfFire:				{f: 288, slot: 'consumable', useEffect: 'FireBall', stackable: false, sound: gs.sounds.jewlery},
		WandOfLightning:		{f: 289, slot: 'consumable', useEffect: 'LightningBolt', stackable: false, sound: gs.sounds.jewlery},
		WandOfCold:				{f: 290, slot: 'consumable', useEffect: 'ConeOfCold', stackable: false, sound: gs.sounds.jewlery},
		WandOfDraining:			{f: 291, slot: 'consumable', useEffect: 'LifeSpike', stackable: false, sound: gs.sounds.jewlery},
		WandOfConfusion:		{f: 292, slot: 'consumable', useEffect: 'Confusion', stackable: false, sound: gs.sounds.jewlery},
		WandOfBlades:			{f: 293, slot: 'consumable', useEffect: 'SummonBlades', stackable: false, sound: gs.sounds.jewlery},
		
		// CONSUMABLES:
		PotionOfHealing:		{f: 192, slot: 'consumable', useEffect: 'PotionOfHealing', edible: true},
		PotionOfEnergy:			{f: 193, slot: 'consumable', useEffect: 'PotionOfEnergy', edible: true},
		PotionOfExperience:		{f: 194, slot: 'consumable', useEffect: 'PotionOfExperience', edible: true},
		PotionOfResistance: 	{f: 195, slot: 'consumable', useEffect: 'PotionOfResistance', edible: true},
		PotionOfPower:			{f: 196, slot: 'consumable', useEffect: 'PotionOfPower', edible: true},
		PotionOfLevitation:		{f: 197, slot: 'consumable', statusEffectName: 'Levitation', edible: true},
		PotionOfGainAttribute:	{f: 198, slot: 'consumable', useEffect: 'PotionOfGainAttribute', edible: true},
		
		// MISC_CONSUMABLES:
		Meat:					{f: 224, slot: 'consumable', useEffect: 'Eat', sound: gs.sounds.food, edible: true},
		HealingShroom:			{f: 225, slot: 'consumable', useEffect: 'HealingShroom', sound: gs.sounds.food, edible: true},
		EnergyShroom:			{f: 226, slot: 'consumable', useEffect: 'EnergyShroom', sound: gs.sounds.food, edible: true},
		EnergyShroomTea:		{f: 227, slot: 'consumable', statusEffectName: 'EnergyShroomTea', edible: true},

		// TRAPS:
		FireShroom:				{f: 352, slot: 'consumable', useEffect: 'PlaceTrap'},
		BearTrap:				{f: 353, slot: 'consumable', useEffect: 'PlaceTrap'},
		FirePot:				{f: 354, slot: 'consumable', useEffect: 'PlaceTrap'},
		GasPot:					{f: 355, slot: 'consumable', useEffect: 'PlaceTrap'},
		
		
		// SCROLLS:
		ScrollOfTeleportation:	{f: 208, slot: 'consumable', useEffect: 'Teleportation', sound: gs.sounds.scroll},
		ScrollOfBlink:			{f: 209, slot: 'consumable', useEffect: 'Blink', sound: gs.sounds.scroll},
		ScrollOfFear:			{f: 210, slot: 'consumable', useEffect: 'ScrollOfFear', sound: gs.sounds.scroll},
		ScrollOfEnchantment:	{f: 211, slot: 'consumable', useEffect: 'ScrollOfEnchantment', sound: gs.sounds.scroll},
		ScrollOfAcquirement:	{f: 212, slot: 'consumable', useEffect: 'ScrollOfAcquirement', sound: gs.sounds.scroll},
		ScrollOfHellFire:		{f: 213, slot: 'consumable', useEffect: 'HellFire', sound: gs.sounds.scroll},
		ScrollOfDomination:		{f: 214, slot: 'consumable', useEffect: 'Domination', sound: gs.sounds.scroll},
		
		// TALENT_BOOKS:
		TomeOfInferno:		{f: 256, slot: 'book', skillName: 'FireMagic'},
		TomeOfStorms:		{f: 257, slot: 'book', skillName: 'StormMagic'},
		TomeOfIce:			{f: 258, slot: 'book', skillName: 'ColdMagic'},
		TomeOfDeath:		{f: 259, slot: 'book', skillName: 'Necromancy'},
		TomeOfStealth:		{f: 260, slot: 'book', skillName: 'Stealth'},
		TomeOfDefense:		{f: 261, slot: 'book', skillName: 'Defense'},
		TomeOfWar:			{f: 262, slot: 'book', skillName: 'Melee'},
		TomeOfArchery:		{f: 263, slot: 'book', skillName: 'Range'},
		TomeOfAthletics:	{f: 264, slot: 'book', skillName: 'Athletics'},
		TomeOfPower:		{f: 265, slot: 'book', skillName: 'Focus'},
		TomeOfEnchantment:	{f: 265, slot: 'book', skillName: 'Enchantment'},
		
		// MISC:
		GoldCoin:			{f: 240, slot: 'none'},
		Key:				{f: 242, slot: 'none'},
		GobletOfYendor:		{f: 243, slot: 'none'},
		
	};
	this.nameTypes(this.itemTypes);
	
	
	// ITEM_ANIMS:
	// ********************************************************************************************
	this.itemTypes.GoldCoin.anim = [240, 241];

	this.setItemDescriptions();
	
	// ITEM_STATS:
	// ********************************************************************************************
	this.itemTypes.Fists.stats =					{damage: 1};
	this.itemTypes.MobFucker.stats =				{damage: 200};
	this.itemTypes.FlamingHands.stats =				{damage: 5};
	
	// MELEE_WEAPONS:
	this.itemTypes.ShortSword.stats =				{parryChance: 0.20, damage: 4};
	this.itemTypes.LongSword.stats =				{parryChance: 0.20, damage: 6};
	this.itemTypes.TwoHandSword.stats = 			{parryChance: 0.20, damage: 8};
	
	this.itemTypes.Spear.stats =					{damage: 6};
	this.itemTypes.Halberd.stats =					{damage: 8};
	
	this.itemTypes.HandAxe.stats =					{damage: 4};
	this.itemTypes.BroadAxe.stats =					{damage: 6};
	this.itemTypes.BattleAxe.stats =				{damage: 8};
	
	this.itemTypes.Mace.stats =						{damage: 8};
	this.itemTypes.WarHammer.stats =				{damage: 10};
	
	this.itemTypes.Sling.stats = 					{damage: 3};
	this.itemTypes.ShortBow.stats =					{damage: 3};
	this.itemTypes.LongBow.stats =					{damage: 5};
	
	this.itemTypes.Staff.stats =					{damage: 4};
	
	
	// MAGIC_MELEE_WEAPONS:
	this.itemTypes.InfernoSword.stats =				{damage: 10, parryChance: 0.20};
	this.itemTypes.StormChopper.stats =				{damage: 8};
	this.itemTypes.PoisonDagger.stats = 			{damage: 3};
	
	// LESSER_STAVES:
	this.itemTypes.StaffOfMagicMissiles.stats =		{damage: 3};
	this.itemTypes.StaffOfFire.stats =		{damage: 4};
	this.itemTypes.StaffOfStorms.stats =		{damage: 3};
	this.itemTypes.StaffOfIce.stats =			{damage: 3};
	this.itemTypes.StaffOfPoison.stats =		{damage: 2};
	
	// STAVES:
	this.itemTypes.GreaterStaffOfFire.stats =				{damage: 5, firePower: 2};
	this.itemTypes.GreaterStaffOfStorms.stats =			{damage: 3, stormPower: 2};
	this.itemTypes.GreaterStaffOfIce.stats =				{damage: 3, coldPower: 2};
	this.itemTypes.GreaterStaffOfPoison.stats =			{damage: 3, toxicPower: 2};
	this.itemTypes.StaffOfEnergy.stats =			{damage: 3, bonusMaxMp: 5};
	this.itemTypes.StaffOfPower.stats =				{damage: 3, spellPower: 4};
	
	// RANGE_WEAPONS:
	this.itemTypes.Dart.stats =						{damage: 6};
	this.itemTypes.Javelin.stats =					{damage: 12};
	this.itemTypes.ThrowingNet.stats =				{damage: 0};
	this.itemTypes.Bomb.stats =						{damage: 24};
    this.itemTypes.Chakram.stats =					{damage: 16};
	
	// SHIELDS:
	this.itemTypes.WoodenShield.stats =				{protection: 2, blockChance: 0.20};
	this.itemTypes.MetalShield.stats =				{protection: 4, blockChance: 0.20, spellPowerModifier: -0.25, stealthModifier: -0.20};
	this.itemTypes.ShieldOfReflection.stats =		{protection: 2, blockChance: 0.20, bonusReflection: 5};
	this.itemTypes.OrbOfMana.stats =				{bonusMaxMp: 3};
	this.itemTypes.RedDragonScaleShield.stats =		{protection: 4, blockChance: 0.20, fireResistance: 1, spellPowerModifier: -0.25, stealthModifier: -0.20};
	this.itemTypes.GreenDragonScaleShield.stats =	{protection: 4, blockChance: 0.20, toxicResistance: 1, spellPowerModifier: -0.25, stealthModifier: -0.20};
	this.itemTypes.BlueDragonScaleShield.stats =	{protection: 4, blockChance: 0.20, shockResistance: 1, spellPowerModifier: -0.25, stealthModifier: -0.20};
	this.itemTypes.WhiteDragonScaleShield.stats =	{protection: 4, blockChance: 0.20, coldResistance: 1, spellPowerModifier: -0.25, stealthModifier: -0.20};
	this.itemTypes.OrbOfPower.stats =				{spellPower: 5};
	
	// ARMOR (BODY):
	this.itemTypes.Robe.stats =						{bonusMaxMp: 5};
	this.itemTypes.LeatherArmor.stats =				{protection: 3};
	this.itemTypes.PlateArmor.stats =				{protection: 5, spellPowerModifier: -0.20, stealthModifier: -0.20};
	this.itemTypes.RedDragonScaleArmor.stats =		{protection: 5, fireResistance: 1, spellPowerModifier: -0.20, stealthModifier: -0.20};
	this.itemTypes.GreenDragonScaleArmor.stats =	{protection: 5, toxicResistance: 1, spellPowerModifier: -0.20, stealthModifier: -0.20};
	this.itemTypes.BlueDragonScaleArmor.stats =		{protection: 5, shockResistance: 1, spellPowerModifier: -0.20, stealthModifier: -0.20};
	this.itemTypes.WhiteDragonScaleArmor.stats =	{protection: 5, coldResistance: 1, spellPowerModifier: -0.20, stealthModifier: -0.20};
	this.itemTypes.CloakOfStealth.stats =			{stealth: 5};
	this.itemTypes.RobeOfWizardry.stats =			{spellPower: 5, bonusMaxMp: 3};
	
	// BOOTS (FEET):
	this.itemTypes.Shoes.stats =					{bonusMaxMp: 3};
	this.itemTypes.LeatherBoots.stats =				{protection: 1};
	this.itemTypes.PlateBoots.stats =				{protection: 2, spellPowerModifier: -0.10, stealthModifier: -0.10};
	this.itemTypes.BootsOfStealth.stats =			{stealth: 3};
	this.itemTypes.BootsOfSpeed.stats =				{bonusMovementSpeed: 1, maxHpModifier: -0.30};
	this.itemTypes.BootsOfFlight.stats =			{isFlying: 1, maxHpModifier: -0.30};
	
	// HELMETS (HEAD):
	this.itemTypes.Hat.stats =						{bonusMaxMp: 3};
	this.itemTypes.LeatherHelm.stats =				{protection: 1};
	this.itemTypes.PlateHelm.stats =				{protection: 2, spellPowerModifier: -0.10, stealthModifier: -0.10};
	this.itemTypes.CircletOfKnowledge.stats =		{spellPower: 5};
	this.itemTypes.ArcheryGoggles.stats =			{rangePower: 5};
	this.itemTypes.HelmOfTelepathy.stats =			{isTelepathic: 1};
	
	// GLOVES (HANDS):
	this.itemTypes.ClothGloves.stats =				{bonusMaxMp: 3};
	this.itemTypes.LeatherGloves.stats =			{protection: 1};
	this.itemTypes.PlateGloves.stats =				{protection: 2, spellPowerModifier: -0.10, stealthModifier: -0.10};
	this.itemTypes.GauntletsOfStrength.stats =		{strength: 5};
	this.itemTypes.GlovesOfVampirism.stats =		{meleeLifeTap: 1};
		
	// CHARMS:
	this.itemTypes.CharmOfFire.stats =				{maxCharges: 1};	
	this.itemTypes.CharmOfLightning.stats =			{maxCharges: 1};		
	this.itemTypes.CharmOfDisease.stats =			{maxCharges: 1};	
	this.itemTypes.CharmOfFreezing.stats =			{maxCharges: 1};
	this.itemTypes.CharmOfBlinking.stats =			{maxCharges: 1};		
	this.itemTypes.CharmOfHealing.stats =			{maxCharges: 1};			
	this.itemTypes.CharmOfEnergy.stats =			{maxCharges: 1};			
	this.itemTypes.CharmOfConfusion.stats =			{maxCharges: 1};		
	this.itemTypes.CharmOfRegeneration.stats =		{bonusHpRegenTime: 1};
	this.itemTypes.CharmOfClarity.stats =			{bonusMpRegenTime: 1};
	
	// WANDS:	
	this.itemTypes.WandOfFire.stats =				{maxCharges: 5};
	this.itemTypes.WandOfLightning.stats =			{maxCharges: 5};
	this.itemTypes.WandOfCold.stats =				{maxCharges: 5};
	this.itemTypes.WandOfDraining.stats =			{maxCharges: 5};
	this.itemTypes.WandOfConfusion.stats =			{maxCharges: 5};
	this.itemTypes.WandOfBlades.stats =				{maxCharges: 5};

	// COMMON RINGS:
	this.itemTypes.RingOfFire.stats =				{fireResistance: 1, firePower: 4};
	this.itemTypes.RingOfStorm.stats =				{shockResistance: 1, stormPower: 4};
	this.itemTypes.RingOfToxic.stats =				{toxicResistance: 1, toxicPower: 4};
	this.itemTypes.RingOfIce.stats =				{coldResistance: 1, coldPower: 4};
	this.itemTypes.RingOfSustenance.stats =			{bonusMaxFood: 20};
	this.itemTypes.RingOfStealth.stats =			{stealth: 3};
	this.itemTypes.RingOfHealth.stats =				{bonusMaxHp: 10};
	this.itemTypes.RingOfMana.stats =				{bonusMaxMp: 5};
	this.itemTypes.RingOfProtection.stats =			{protection: 3};
	this.itemTypes.RingOfEvasion.stats =			{bonusEvasion: 5};
	this.itemTypes.RingOfStrength.stats =			{strength: 3};
	this.itemTypes.RingOfIntelligence.stats =		{intelligence: 3};
	this.itemTypes.RingOfDexterity.stats =			{dexterity: 3};
	
	// UNCOMMON RINGS:
	this.itemTypes.RingOfFlight.stats =				{isFlying: 1, maxHpModifier: -0.30};
	this.itemTypes.RingOfWizardry.stats =			{spellPower: 5};
	this.itemTypes.RingOfTheVampire.stats =			{meleeLifeTap: 1};
	this.itemTypes.RingOfLearning.stats =			{bonusExpMod: 0.5, maxHpModifier: -0.30};
	
	// RARE_RINGS:
	this.itemTypes.RingOfLifeSaving.stats =			{hasLifeSaving: 1};
	this.itemTypes.InfernoRing.stats =				{fireResistance: 1, firePower: 4, hasInferno: 1};
	this.itemTypes.RingOfThunder.stats =			{shockResistance: 1, stormPower: 4, hasThunder: 1};
	this.itemTypes.RingOfReflection.stats =			{bonusReflection: 3};
	this.itemTypes.RingOfSpeed.stats =				{bonusMovementSpeed: 1, maxHpModifier: -0.30};
	this.itemTypes.RingOfWealth.stats =				{bonusGoldMod: 1.0, maxHpModifier: -0.30};
	
	
	
	// ITEM_COST:
	// ********************************************************************************************
	LOW_ITEM_COST = 40;
	MED_ITEM_COST = 80;
	HIGH_ITEM_COST = 120;
	
	
	// MELEE_WEAPONS:
	this.itemTypes.ShortSword.cost = LOW_ITEM_COST;
	this.itemTypes.Staff.cost = LOW_ITEM_COST;
	this.itemTypes.HandAxe.cost = LOW_ITEM_COST;
	this.itemTypes.ShortBow.cost = LOW_ITEM_COST;
	this.itemTypes.StaffOfFire.cost = LOW_ITEM_COST;
	this.itemTypes.StaffOfStorms.cost = LOW_ITEM_COST;
	this.itemTypes.StaffOfIce.cost = LOW_ITEM_COST;
	this.itemTypes.StaffOfPoison.cost = LOW_ITEM_COST;
	
	this.itemTypes.LongSword.cost = MED_ITEM_COST;
	this.itemTypes.TwoHandSword.cost = MED_ITEM_COST;
	this.itemTypes.Spear.cost = MED_ITEM_COST;
	this.itemTypes.Halberd.cost = MED_ITEM_COST;
	this.itemTypes.BattleAxe.cost = MED_ITEM_COST;
	this.itemTypes.Mace.cost = MED_ITEM_COST;
	this.itemTypes.WarHammer.cost = MED_ITEM_COST;
	this.itemTypes.Sling.cost = MED_ITEM_COST;
	this.itemTypes.LongBow.cost = MED_ITEM_COST;
	this.itemTypes.BroadAxe.cost = MED_ITEM_COST;
	this.itemTypes.PoisonDagger.cost = MED_ITEM_COST;
	this.itemTypes.StormChopper.cost = HIGH_ITEM_COST;
	this.itemTypes.InfernoSword.cost = HIGH_ITEM_COST;
	this.itemTypes.GreaterStaffOfFire.cost = MED_ITEM_COST;
	this.itemTypes.GreaterStaffOfStorms.cost = MED_ITEM_COST;
	this.itemTypes.GreaterStaffOfIce.cost = MED_ITEM_COST;
	this.itemTypes.GreaterStaffOfPoison.cost = MED_ITEM_COST;
	this.itemTypes.StaffOfEnergy.cost = MED_ITEM_COST;
	this.itemTypes.StaffOfMagicMissiles.cost = MED_ITEM_COST;
	this.itemTypes.StaffOfPower.cost = MED_ITEM_COST;
	
	
	// RANGE_WEAPONS:
	this.itemTypes.Dart.cost = 1;
	this.itemTypes.Javelin.cost = 2;
	this.itemTypes.ThrowingNet.cost = 5;
	this.itemTypes.Bomb.cost = 5;
	this.itemTypes.Chakram.cost = 5;
	
	// SHIELDS:
	this.itemTypes.WoodenShield.cost = LOW_ITEM_COST;
	this.itemTypes.MetalShield.cost = LOW_ITEM_COST;
	this.itemTypes.ShieldOfReflection.cost = HIGH_ITEM_COST;
	this.itemTypes.OrbOfMana.cost = HIGH_ITEM_COST;
	this.itemTypes.RedDragonScaleShield.cost = HIGH_ITEM_COST;
	this.itemTypes.GreenDragonScaleShield.cost = HIGH_ITEM_COST;
	this.itemTypes.BlueDragonScaleShield.cost = HIGH_ITEM_COST;
	this.itemTypes.WhiteDragonScaleShield.cost = HIGH_ITEM_COST;
	this.itemTypes.OrbOfPower.cost = HIGH_ITEM_COST;
	
	// ARMOR (BODY):
	this.itemTypes.Robe.cost = LOW_ITEM_COST;
	this.itemTypes.LeatherArmor.cost = LOW_ITEM_COST;
	this.itemTypes.PlateArmor.cost = LOW_ITEM_COST;
	this.itemTypes.CloakOfStealth.cost = HIGH_ITEM_COST;
	this.itemTypes.RobeOfWizardry.cost = HIGH_ITEM_COST;
	this.itemTypes.RedDragonScaleArmor.cost = HIGH_ITEM_COST;
	this.itemTypes.GreenDragonScaleArmor.cost = HIGH_ITEM_COST;
	this.itemTypes.BlueDragonScaleArmor.cost = HIGH_ITEM_COST;
	this.itemTypes.WhiteDragonScaleArmor.cost = HIGH_ITEM_COST;
	
	// BOOTS (FEET):
	this.itemTypes.Shoes.cost = LOW_ITEM_COST;
	this.itemTypes.LeatherBoots.cost = LOW_ITEM_COST;
	this.itemTypes.PlateBoots.cost = LOW_ITEM_COST;
	this.itemTypes.BootsOfStealth.cost = HIGH_ITEM_COST;
	this.itemTypes.BootsOfSpeed.cost = HIGH_ITEM_COST;
	this.itemTypes.BootsOfFlight.cost = HIGH_ITEM_COST;

	// HELMETS (HEAD):
	this.itemTypes.Hat.cost = LOW_ITEM_COST;
	this.itemTypes.LeatherHelm.cost = LOW_ITEM_COST;
	this.itemTypes.PlateHelm.cost = LOW_ITEM_COST;
	this.itemTypes.CircletOfKnowledge.cost = HIGH_ITEM_COST;
	this.itemTypes.ArcheryGoggles.cost = HIGH_ITEM_COST;
	this.itemTypes.HelmOfTelepathy.cost = HIGH_ITEM_COST;
	
	// GLOVES (HANDS):
	this.itemTypes.ClothGloves.cost = LOW_ITEM_COST;
	this.itemTypes.LeatherGloves.cost = LOW_ITEM_COST;
	this.itemTypes.PlateGloves.cost = LOW_ITEM_COST;
	this.itemTypes.GauntletsOfStrength.cost = HIGH_ITEM_COST;
	this.itemTypes.GlovesOfVampirism.cost = HIGH_ITEM_COST;
	
	// Traps:
	this.itemTypes.FireShroom.cost = 0;
	this.itemTypes.BearTrap.cost = 0;
	this.itemTypes.FirePot.cost = 0;
	this.itemTypes.GasPot.cost = 0;
	
	// COMMON RINGS:
	this.itemTypes.RingOfFire.cost = LOW_ITEM_COST;
	this.itemTypes.RingOfStorm.cost = LOW_ITEM_COST;
	this.itemTypes.RingOfToxic.cost = LOW_ITEM_COST;
	this.itemTypes.RingOfIce.cost = LOW_ITEM_COST;
	this.itemTypes.RingOfSustenance.cost = LOW_ITEM_COST;
	this.itemTypes.RingOfStealth.cost = LOW_ITEM_COST;
	this.itemTypes.RingOfHealth.cost = LOW_ITEM_COST;
	this.itemTypes.RingOfMana.cost = LOW_ITEM_COST;
	this.itemTypes.RingOfProtection.cost = LOW_ITEM_COST;
	this.itemTypes.RingOfEvasion.cost = LOW_ITEM_COST;
	this.itemTypes.RingOfStrength.cost = LOW_ITEM_COST;
	this.itemTypes.RingOfIntelligence.cost = LOW_ITEM_COST;
	this.itemTypes.RingOfDexterity.cost = LOW_ITEM_COST;
	
	// UNCOMMON RINGS:
	this.itemTypes.RingOfFlight.cost = MED_ITEM_COST;
	this.itemTypes.RingOfWizardry.cost = MED_ITEM_COST;
	this.itemTypes.RingOfTheVampire.cost = MED_ITEM_COST;
	this.itemTypes.RingOfLearning.cost = MED_ITEM_COST;
	
	// RARE_RINGS:
	this.itemTypes.RingOfLifeSaving.cost = HIGH_ITEM_COST;
	this.itemTypes.InfernoRing.cost = HIGH_ITEM_COST;
	this.itemTypes.RingOfThunder.cost = HIGH_ITEM_COST;
	this.itemTypes.RingOfReflection.cost = HIGH_ITEM_COST;
	this.itemTypes.RingOfSpeed.cost = HIGH_ITEM_COST;
	this.itemTypes.RingOfWealth.cost = HIGH_ITEM_COST;
	
	// CHARMS:
	this.itemTypes.CharmOfFire.cost = MED_ITEM_COST;
	this.itemTypes.CharmOfLightning.cost = MED_ITEM_COST;
	this.itemTypes.CharmOfDisease.cost = MED_ITEM_COST;
	this.itemTypes.CharmOfFreezing.cost = MED_ITEM_COST;
	this.itemTypes.CharmOfBlinking.cost = MED_ITEM_COST;
	this.itemTypes.CharmOfHealing.cost = MED_ITEM_COST;
	this.itemTypes.CharmOfEnergy.cost = MED_ITEM_COST;
	this.itemTypes.CharmOfConfusion.cost = MED_ITEM_COST;
	this.itemTypes.CharmOfRegeneration.cost = MED_ITEM_COST;
	this.itemTypes.CharmOfClarity.cost = MED_ITEM_COST;
	
	// WANDS:
	this.itemTypes.WandOfFire.cost = MED_ITEM_COST;
	this.itemTypes.WandOfLightning.cost = MED_ITEM_COST;
	this.itemTypes.WandOfCold.cost = MED_ITEM_COST;
	this.itemTypes.WandOfDraining.cost = MED_ITEM_COST;
	this.itemTypes.WandOfConfusion.cost = MED_ITEM_COST;
	this.itemTypes.WandOfBlades.cost = MED_ITEM_COST;
	
	// POTIONS:
	this.itemTypes.HealingShroom.cost = 1;
	this.itemTypes.EnergyShroom.cost = 1;
	this.itemTypes.Meat.cost = 30;
	this.itemTypes.PotionOfHealing.cost = 30;
	this.itemTypes.PotionOfEnergy.cost = 30;
	this.itemTypes.PotionOfExperience.cost = 30;
	this.itemTypes.PotionOfResistance.cost = 30;
	this.itemTypes.PotionOfLevitation.cost = 30;
	this.itemTypes.PotionOfGainAttribute.cost = 60;
	this.itemTypes.PotionOfPower.cost = 30;
	this.itemTypes.EnergyShroomTea.cost = 30;

	
	// SCROLLS:
	this.itemTypes.ScrollOfTeleportation.cost = 20;
	this.itemTypes.ScrollOfBlink.cost = 20;
	this.itemTypes.ScrollOfFear.cost = 30;
	this.itemTypes.ScrollOfHellFire.cost = 30;
	this.itemTypes.ScrollOfDomination.cost = 30;
	this.itemTypes.ScrollOfEnchantment.cost = 40;
	this.itemTypes.ScrollOfAcquirement.cost = 60;
	
	// TALENT_BOOKS:
	this.itemTypes.TomeOfInferno.cost = MED_ITEM_COST;
	this.itemTypes.TomeOfStorms.cost = MED_ITEM_COST;
	this.itemTypes.TomeOfIce.cost =	MED_ITEM_COST;
	this.itemTypes.TomeOfDeath.cost = MED_ITEM_COST;
	this.itemTypes.TomeOfStealth.cost = MED_ITEM_COST;
	this.itemTypes.TomeOfDefense.cost = MED_ITEM_COST;
	this.itemTypes.TomeOfWar.cost = MED_ITEM_COST;
	this.itemTypes.TomeOfArchery.cost = MED_ITEM_COST;
	this.itemTypes.TomeOfAthletics.cost = MED_ITEM_COST;
	this.itemTypes.TomeOfPower.cost = MED_ITEM_COST;
	this.itemTypes.TomeOfEnchantment.cost = MED_ITEM_COST;
	
	// MISC:
	this.itemTypes.GoldCoin.cost = 1;
	this.itemTypes.GobletOfYendor.cost = 1000;
	
	this.setItemTypeDefaultProperties();
};

// SET_ITEM_DESCRIPTIONS:
// ************************************************************************************************
gs.setItemDescriptions = function () {
	
	this.itemTypes.Meat.desc = "Completely satiates your hunger. Restores half your maximum health and mana points.";
	this.itemTypes.HealingShroom.desc = "Heals " + SHROOM_HP + " hit points. Will also cure poison.";
	this.itemTypes.EnergyShroom.desc = "Restores " + SHROOM_EP + " mana points.";
	this.itemTypes.PotionOfHealing.desc = "Completely restores your HP and cures physical effects. Will raise your max HP by 4 if used at full health.";
	this.itemTypes.PotionOfEnergy.desc = "Completely restores your MP and cures mental effects. Will raise your max MP by 1 if used at full mana.";
	this.itemTypes.PotionOfExperience.desc = "Temporarily increases your rate of experience.";
	//this.itemTypes.PotionOfSpeed.desc = "Temporarily increases your movement speed.";
	this.itemTypes.PotionOfPower.desc = "Increases your melee, range and spell damage by 100% for 20 turns.";
	this.itemTypes.PotionOfPower.desc = "Increases your melee, range and spell damage by 100% for 20 turns.";
	this.itemTypes.PotionOfResistance.desc = "Completely restores your HP and cures physical effects. Increases your defense to all damage types for 50 turns.";
	this.itemTypes.PotionOfLevitation.desc = "Allows you to levitate for 50 turns.";
	this.itemTypes.PotionOfGainAttribute.desc = "Allows you to permenantly increase either strength, intelligence or dexterity";
	
	this.itemTypes.EnergyShroomTea.desc = "Regain 1MP every 5 turns for a total of 200 turns.";
	this.itemTypes.RingOfTheVampire.desc = "Heals 1 hit point every time you hit an enemy with a melee weapon.";
	this.itemTypes.RingOfFlight.desc = "Allows you to fly, avoiding all negative terrain effects.";
	this.itemTypes.RingOfLifeSaving.desc = "Grants you a one time resurrection upon death. The ring will be consumed in the process.";
	this.itemTypes.RingOfSpeed.desc = "Allows you to run at double normal movement speed.";
	this.itemTypes.RingOfWealth.desc = "You will pick up double gold.";
	this.itemTypes.InfernoRing.desc = "Burns anyone hitting you with melee.";
	this.itemTypes.RingOfThunder.desc = "Shocks anyone hitting you with melee.";
	
	this.itemTypes.BootsOfFlight.desc = "Allows you to fly, avoiding all negative terrain effects.";
	this.itemTypes.BootsOfSpeed.desc = "Allows you to run at double normal movement speed.";
	
	this.itemTypes.ScrollOfTeleportation.desc = "Immediately teleports you to a random location in the current level.";
	this.itemTypes.ScrollOfBlink.desc = "Allows you to immediately teleport to any visible tile.";
	this.itemTypes.ScrollOfFear.desc = "Fears all visible enemies, causing them to run away from you.";
	this.itemTypes.ScrollOfEnchantment.desc = "Allows you to enchant a piece of equipment.";
	this.itemTypes.ScrollOfAcquirement.desc = "Randomly summons an item. You can choose from weapons, armor, rings, scrolls, potions and food, but cannot select the exact item.";
	this.itemTypes.ScrollOfHellFire.desc = "Engulfs all visible enemies in hell fire.";
	this.itemTypes.ScrollOfDomination.desc = 'Allows you to permanently charm a creature, turning it to your side';
	
	// WANDS:
	this.itemTypes.WandOfBlades.desc = 'Summons a temporary swarm of spectral blades which will attack your enemies.';
	
	this.itemTypes.Key.desc = "Allows you to open locked doors";
    
    this.itemTypes.Chakram.desc = "Hits multiple enemies in a line";
	
	// CHARMS:
	this.itemTypes.CharmOfClarity.desc = 'Increases the rate at which you regenerate mana.';
	this.itemTypes.CharmOfRegeneration.desc = 'Increases the rate at which you regenerate hit points.';
	
	this.itemTypes.TwoHandSword.desc = 'A two handed weapon.';
    this.itemTypes.Mace.desc = 'Has a 25% chance to knock enemies back.';
    this.itemTypes.WarHammer.desc = 'A two handed weapon. Has a 25% chance to knock enemies back.';
	this.itemTypes.HandAxe.desc = 'Will cleave with every attack, hitting all adjacent enemies.';
	this.itemTypes.BattleAxe.desc = 'A two handed weapon. Will cleave with every attack, hitting all adjacent enemies.';
	this.itemTypes.BroadAxe.desc = 'Will cleave with every attack, hitting all adjacent enemies.';
	this.itemTypes.Spear.desc = 'Has an extra long reach, allowing you to hit enemies two tiles away.';
	this.itemTypes.Halberd.desc = 'A two handed weapon. Has an extra long reach, allowing you to hit enemies two tiles away.';
	//this.itemTypes.Staff.desc = 'Has an extra long reach, allowing you to hit enemies two tiles away.';
	this.itemTypes.GreaterStaffOfFire.desc = 'Damage is improved by increasing fire magic power.';
	this.itemTypes.GreaterStaffOfPoison.desc = 'Fires projectiles that will poison enemies. Damage is improved by increasing toxic magic power.';
	this.itemTypes.GreaterStaffOfStorms.desc = 'Damage is improved by increasing storm magic power.';
	this.itemTypes.GreaterStaffOfIce.desc = 'Fires freezing projectiles that will slow enemies. Power is improved by increasing ice magic power.';
	this.itemTypes.StormChopper.desc = 'Attacks all adjacent enemies with a powerful shocking attack.';
	this.itemTypes.InfernoSword.desc = 'Attacks with a powerful flaming attack. Gives a 20% chance to block incoming melee attacks.';	
	
	this.itemTypes.StaffOfFire.desc = 'Damage is improved by increasing fire magic power.';
	this.itemTypes.StaffOfPoison.desc = 'Fires projectiles that will poison enemies. Damage is improved by increasing toxic magic power.';
	this.itemTypes.StaffOfStorms.desc = 'Damage is improved by increasing storm magic power.';
	this.itemTypes.StaffOfIce.desc = 'Fires freezing projectiles that will slow enemies. Power is improved by increasing ice magic power.';
};

// SET_ITEM_TYPE_DEFAULT_PROPERTIES:
// ************************************************************************************************
gs.setItemTypeDefaultProperties = function () {
	var key;
	
	this.forEachType(this.itemTypes, function (itemType) {
		// Setting frame:
		if (itemType.hasOwnProperty('f')) {	
			itemType.frame = itemType.f;
		}
		else {
			throw 'itemType has no frame: ' + itemType.name;
		}
		
		// Weapon Effect:
		if (itemType.hasOwnProperty('effect')) {
			if (!this.weaponEffects[itemType.effect]) throw 'Invalid weaponEffect: ' + itemType.effect;
			itemType.effect = this.weaponEffects[itemType.effect];
		}
		
		// Use Effect (Consumables):
		if (itemType.hasOwnProperty('useEffect')) {
			// Ability:
			if (this.abilityTypes[itemType.useEffect]) {
				itemType.useEffect = this.createItemAbilityType(itemType);
			}
			// Item Effect:
			else if (this.itemEffects[itemType.useEffect]) {
				itemType.useEffect = this.itemEffects[itemType.useEffect];
			}
			// Invalid:
			else {
				throw 'Invalid itemEffect: ' + itemType.useEffect;
			}
		}

		// Stackable:
		if (itemType.stackable === undefined) {
			if (this.inArray(itemType.slot, ['weapon', 'shield', 'ring', 'body', 'head', 'hands', 'feet', 'book', 'charm'])) {
				itemType.stackable = false;
			} 
			else {
				itemType.stackable = true;
			}
		}
		
		// Base Mod:
		if (itemType.baseMod === undefined) {
			itemType.baseMod = 0;
		}
		
		// Max Mod:
		if (itemType.maxMod === undefined) {
			itemType.maxMod = MAX_ENCHANTMENT;
		}

		// Drop Amount:
		if (itemType.dropAmount === undefined) {
			itemType.dropAmount = 1;
		}
		
		// Stats:
		if (!itemType.hasOwnProperty('stats')) {
			itemType.stats = {};
		}
		
		// Min Range:
		if (!itemType.hasOwnProperty('minRange')) {
			itemType.minRange = 0;
		}
		
		// Cost:
		if (!itemType.hasOwnProperty('cost')) {
			itemType.cost = 1;
		}
		
	}, this);
};

/*global game, gs, console, Phaser, util*/
/*global ASSERT_EQUAL, ASSERT_THROW*/
/*global NICE_STAT_NAMES, STAT_AS_PERCENT, STAT_AS_FLAG, MAX_ENCHANTMENT, LINEAR_MODDED_STATS, SELL_ITEM_PERCENT*/
/*jshint white: true, laxbreak: true, esversion: 6*/
'use strict';

// ITEM_CONSTRUCTOR:
// ************************************************************************************************
function Item (typeName, flags = {}) {
	ASSERT_EQUAL(gs.itemTypes.hasOwnProperty(typeName), true, 'Invalid typeName: ' + typeName);
	
	this.type = gs.itemTypes[typeName];
	
	this.mod = flags.mod || this.type.baseMod;
	this.amount =  flags.amount || this.type.dropAmount;
	this.charges = flags.charges || 0;
	this.chargeTimer = flags.chargeTimer || 0;
	this.talents = flags.talents || null;
	
	Object.seal(this);
}

// TO_SHORT_DESC:
// ************************************************************************************************
Item.prototype.toShortDesc = function () {
	var str = '';
	
	if (this.amount > 1) {
		str += this.amount + ' x ';
	}
	
	if (this.mod > 0) {
		str += '+' + this.mod + ' ';
	}
	
	str += this.type.niceName;
	
	return str;
};

// TO_LONG_DESC:
// ************************************************************************************************
Item.prototype.toLongDesc = function () {
	var str = '', statName, val, niceName;

	// Name of item:
	str +=  this.toShortDesc() + '\n';
	
	// Damage of Melee Weapons:
	if (this.type.slot === 'weapon' && this.type.stats.damage > 0) {
		str += 'Damage: ' + this.getModdedStat('damage') + ' [' + gs.pc.weaponDamage(this) + ']\n';
	}

	// Range:
	if (this.type.slot === 'weapon') {
		str += 'Range: ' + Math.floor(gs.pc.weaponRange(this)) + '\n';
	}

	// Equipment Stats:
	for (statName in this.type.stats) {
		if (this.type.stats.hasOwnProperty(statName) && statName !== 'damage') {
			niceName = NICE_STAT_NAMES[statName];
			val = this.getModdedStat(statName);
			
			if (niceName) {
				// Display the stat as a percent:
				if (STAT_AS_PERCENT[statName]) {
					str +=  niceName + ': ' + (val > 0 ? '+' : '') + gs.toPercentStr(val) + '\n';
				}
				// Display just the stat name:
				else if (STAT_AS_FLAG[statName]) {
					str += niceName + '\n';
				}
				// Display as value:
				else {
					str += niceName + ': ' + (val > 0 ? '+' : '') + val + '\n';
				}
			}
			
		}
	}
	
	
	// Charges:
	if (this.type.stats.maxCharges) {
		str += 'Charges: ' + this.charges + '/' + this.getModdedStat('maxCharges') + '\n';
	}
	
	// Ability Desc:
	if (this.type.useEffect && gs.abilityTypes[this.type.useEffect.name]) {
		if (gs.abilityDesc({type: this.type.useEffect}, this)) {
			str += gs.abilityDesc({type: this.type.useEffect}, this);
		}
		
	}
	
	// Talents:
	if (this.talents) {
		for (let i = 0; i < this.talents.length; i += 1) {
			str += '- ' + gs.capitalSplit(this.talents[i]) + '\n';
		}
	}

	// Item Desc:
	if (this.type.desc) {
		str += this.type.desc;
	}

	return str;
};

// TO_STRING:
// ************************************************************************************************
Item.prototype.toString = function () {
	var str = this.type.name;
	str += this.mod ? ', mod: ' + this.mod : '';
	str += this.amount > 1 ? ', amount: ' + this.amount : '';
	str += this.charges ? ', charges: ' + this.charges : '';
	str += this.chargeTimer ? ', chargeTimer: ' + this.chargeTimer : '';
	str += this.talents ? ', talents: ' + this.talents : '';
	
	return str;
};

// CAN_STACK:
// Returns true if this item can stack with otherItem
// ************************************************************************************************
Item.prototype.canStack = function (otherItem) {
	ASSERT_EQUAL(Item.isItem(otherItem), true, 'Not a valid item: ' + otherItem);
	
	return this.type === otherItem.type && this.mod === otherItem.mod && this.type.stackable;
};

// CAN_ENCHANT_ITEM:
// ************************************************************************************************
Item.prototype.canEnchant = function () {
	// Cannot enchant the itemType:
	if (!Item.canEnchantItemType(this.type)) {
		return false;
	}
	
	// Exceeded MAX_ENCHANTMENT:
	if (this.mod >= MAX_ENCHANTMENT) {
		return false;
	}
	
	// Weapons can be maximally enchanted to 2x their base damage
	if (this.type.slot === 'weapon' && this.mod >= this.type.stats.damage) {
		return false;
	}
	
	return true;
};

// ON_UPDATE_TURN:
// ************************************************************************************************
Item.prototype.onUpdateTurn = function () {
	if (this.type.slot === 'charm' && this.charges < this.getModdedStat('maxCharges')) {
		this.chargeTimer += 1;
		
		// Gaining a charge:
		if (this.chargeTimer >= this.type.chargeTime) {
			this.charges += 1;
			this.chargeTimer = 0;
			gs.pc.popUpText(this.type.niceName + ' charged', '#ffffff');
		}
	}
};

// TO_DATA:
// ************************************************************************************************
Item.prototype.toData = function () {
	var data = {};
	
	data.typeName = this.type.name;
	data.mod = this.mod;
	data.amount = this.amount;
	data.charges = this.charges;
	data.chargeTimer = this.chargeTimer;
	data.talents = this.talents;
	
	return data;
};

// LOAD_DATA:
// ************************************************************************************************
Item.prototype.loadData = function (data) {
	this.type = gs.itemTypes[data.typeName];
	this.mod = data.mod;
	this.amount = data.amount;
	this.charges = data.charges;
	this.chargeTimer = data.chargeTimer;
	this.talents = data.talents;
};


// GET_MODDED_STAT:
// ************************************************************************************************
Item.prototype.getModdedStat = function (statName) {
	var baseVal = this.type.stats[statName];
	
	// Don't mod negative stats:
	if (baseVal < 0) {
		return baseVal;
	}
	// Linear increase (1 stat per mod):
	else if (gs.inArray(statName, LINEAR_MODDED_STATS)) {
		return baseVal + this.mod - this.type.baseMod;
	} 
	// Capped linear:
	else if (gs.inArray(statName, ['fireResistance', 'coldResistance', 'shockResistance', 'toxicResistance'])) {
		return Math.min(3, baseVal + this.mod);	 
	}
	// Large fraction increase (0.2 stat per mod and rounded to whole):
	else if (gs.inArray(statName, ['bonusMaxHp', 'bonusMaxFood'])) {
		return Math.ceil(baseVal + (baseVal * this.mod * 0.2));
	}
	// Default:
	else {
		return baseVal;
	}		
};

// APPLY_EQUIPMENT_STATS:
// Add the stats of an equipped item to the character
// ********************************************************************************************
Item.prototype.applyEquipmentStats = function (character) {
	var statName;

	for (statName in this.type.stats) {
		if (this.type.stats.hasOwnProperty(statName)) {
			// Damage:
			if (statName == 'damage') {
				// Damage is not added to player
			}
			// Adding resistance:
			else if (statName === 'fireResistance') {
				character.resistance.Fire += this.getModdedStat(statName);
			}
			else if (statName === 'coldResistance') {
				character.resistance.Cold += this.getModdedStat(statName);
			}
			else if (statName === 'shockResistance') {
				character.resistance.Shock += this.getModdedStat(statName);
			}
			else if (statName === 'toxicResistance') {
				character.resistance.Toxic += this.getModdedStat(statName);
			}
			// Everything Else:
			else {
				character[statName] += this.getModdedStat(statName);
			}			
		}
	}
};

// ENCHANT:
// ************************************************************************************************
Item.prototype.enchant = function () {
	this.mod += 1;
	
	// Fully recharge wands when enchanting:
	if (this.type.stats.maxCharges) {
		this.charges = this.getModdedStat('maxCharges');
	}
};

// GET_SOUND:
// ************************************************************************************************
Item.prototype.getSound = function () {
	if (this.type.sound) {
		return this.type.sound;
	}
	else if (gs.inArray(this.type.slot, ['body', 'head', 'feet', 'hands', 'shield'])) {
		return gs.sounds.armor;
	}
	else if (gs.inArray(this.type.slot, ['ring', 'charm']) || this.type.name === 'Key') {
		return gs.sounds.jewlery;
	}
	else if (this.type.slot === 'weapon') {
		return gs.sounds.weapon;
	}
	else if (this.type.slot === 'consumable') {
		return gs.sounds.potion;
	}
	else if (this.type.name === 'GoldCoin') {
		return gs.sounds.coin;
	}
	else if (this.type.slot === 'book') {
		return gs.sounds.scroll;
	}
	
};

// BASE_VALUE:
// ************************************************************************************************
Item.prototype.baseValue = function () {
	var cost = Math.ceil(this.type.cost + (0.4 * this.mod * this.type.cost));
	
	// Wand:
	if (this.type.slot === 'consumable' && this.type.stats.maxCharges) {
		cost = Math.ceil(cost * (this.charges / this.type.stats.maxCharges));
	}
	
	return cost;
};


// SELL_VALUE:
// How much does the player get when selling the item
// ************************************************************************************************
Item.prototype.sellValue = function () {
	if (this.type.cost === 0) {
		return 0;
	}
	else {
		return Math.max(1, Math.floor(SELL_ITEM_PERCENT * this.baseValue()));
	}
};

// ************************************************************************************************
// ITEM_STATIC_FUNCTIONS:
// ************************************************************************************************
// ************************************************************************************************
// CREATE_ITEM:
// ************************************************************************************************
Item.createItem = function (typeName, flags = {}) {
	ASSERT_EQUAL(gs.itemTypes.hasOwnProperty(typeName), true, 'Invalid typeName: ' + typeName);
	
	var item;
	
	// Unspecified amount for gold:
	if (typeName === 'GoldCoin' && !flags.amount) {
		flags.amount = util.randInt(Math.ceil(gs.dropGoldAmount() / 2), gs.dropGoldAmount());
	}
	
	item = new Item(typeName, flags);
	
	// Wands have their charges set to max by default:
	if (item.type.stats.maxCharges && item.type.slot === 'consumable' && !flags.charges) {
		item.charges = item.getModdedStat('maxCharges');
	}
	
	// Book talents:
	if (item.type.slot === 'book' && gs.pc) {
		item.talents = gs.getBookTalents(item.type.skillName);
	}
	
	return item;
};

// CREATE_AND_LOAD_ITEM:
// Creates and loads an item from data
// ************************************************************************************************
Item.createAndLoadItem = function (data) {
	return new Item(data.typeName, data);
};

// IS_ITEM:
// Used to confirm that the object in question is actually a valid item
// ************************************************************************************************
Item.isItem = function (item) {
	return Boolean(typeof item === 'object' && item.type && gs.itemTypes[item.type.name]);
};

// CAN_ENCHANT_ITEM_TYPE:
// Note the test for maxCharges to catch wands.
// ************************************************************************************************
Item.canEnchantItemType = function (itemType) {
	var equipmentSlots = ['body', 'ring', 'feet', 'head', 'hands', 'weapon', 'shield', 'charm'];
	return !itemType.cantEnchant && (gs.inArray(itemType.slot, equipmentSlots) || itemType.stats.maxCharges);
};/*global gs, game, console, util*/
/*global Item*/
/*global TILE_SIZE, SCALE_FACTOR*/
/*global ITEM_ENCHANTED_PERCENT*/
/*jshint esversion: 6, laxbreak: true*/
'use strict';

// CREATE_FLOOR_ITEM:
// Creates an item on the floor of the dungeon
// ************************************************************************************************
gs.createFloorItem = function (tileIndex, item) {
	return new FloorItem(tileIndex, item);
};

// CREATE_RANDOM_FLOOR_ITEM:
// ************************************************************************************************
gs.createRandomFloorItem = function (tileIndex, itemDropTableName) {
	return new FloorItem(tileIndex, this.createRandomItem(itemDropTableName));
};



// CONSTRUCTOR:
// ************************************************************************************************
function FloorItem (tileIndex, item) {
	var position;
	
	// Constraints:
	if (gs.getItem(tileIndex)) throw 'Cannot create FloorItem, tileIndex already occupied';
	
	// Properties:
	this.isAlive = true;
	this.item = item;
	this.tileIndex = {x: tileIndex.x, y: tileIndex.y};
	
	// Sprite:
	position = util.toPosition(this.tileIndex);
	this.sprite = gs.createSprite(position.x, position.y - 1, 'Tileset', gs.objectSpritesGroup);
	this.sprite.anchor.setTo(0.5, 0.5);
	this.sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	this.sprite.frame = item.type.frame;
	
	// When spawning on an object, make sure to appear above the object.
	if (!gs.isStaticPassable(this.tileIndex)) {
		this.sprite.y += 2;
		this.sprite.anchor.setTo(0.5, 1.0);
	}
	
	// Sprite Anim:
	if (item.type.anim) {
		this.sprite.animations.add('anim', item.type.anim);
		this.sprite.play('anim', 5, true);
		this.sprite.animations.currentAnim.setFrame(util.randElem(item.type.anim), true);
	}
	
	// Place on tileMap:
	gs.getTile(tileIndex).item = this;
	
	// Push to global list:
	gs.floorItemList.push(this);
}

// TO_DATA:
// ************************************************************************************************
FloorItem.prototype.toData = function () {
	var data = this.item.toData();
	data.tileIndex = this.tileIndex;
	data.wasDropped = Boolean(this.wasDropped);
	return data;
};

// LOAD_FLOOR_ITEM:
// ************************************************************************************************
gs.loadFloorItem = function (data) {
	var item;
	item = this.createFloorItem(data.tileIndex, Item.createAndLoadItem(data));
	item.wasDropped = data.wasDropped;
	return item;
};

// DESTROY_FLOOR_ITEM:
// ************************************************************************************************
gs.destroyFloorItem = function (floorItem) {
	floorItem.isAlive = false;
	floorItem.sprite.destroy();
	this.getTile(floorItem.tileIndex).item = null;
};

// DESTROY_ALL_ITEMS:
// ************************************************************************************************
gs.destroyAllFloorItems = function () {
	for (let i = 0; i < this.floorItemList.length; i += 1) {
		this.destroyFloorItem(this.floorItemList[i]);
	}
	this.floorItemList = [];
};


// INVALID_ITEM_INDEX:
// returns true if items should not drop on the tileIndex
// This could be because of traps, stairs or portals
// ************************************************************************************************
gs.invalidItemIndex = function (tileIndex) {
	return (this.getObj(tileIndex) && !this.isIndexSafe(tileIndex)) 
		|| this.getObj(tileIndex, obj => obj.isZoneLine())
		|| this.getObj(tileIndex, 'Portal');
};

// GET_VALID_DROP_INDEX:
// Returns a tileIndex that is valid for dropping loop either at the input tileIndex or adjacent.
// Returns null if no valid drop index is available in which case loot should not drop.
// ************************************************************************************************
gs.getValidDropIndex = function (tileIndex) {
	var indexList;
	
	if (!this.invalidItemIndex(tileIndex) && !gs.getItem(tileIndex)) {
		return tileIndex;
	}
	
	indexList = this.getIndexInBox(tileIndex.x - 1, tileIndex.y - 1, tileIndex.x + 2, tileIndex.y + 2);
	indexList = indexList.filter(index => gs.isPassable(index));
	indexList = indexList.filter(index => !gs.getItem(index));
	indexList = indexList.filter(index => !gs.invalidItemIndex(index));
	
	return indexList.length > 0 ? util.randElem(indexList) : null;
};

/*global game, gs, console, Phaser*/
/*global Item*/
/*global ASSERT_EQUAL, ASSERT_THROW*/
/*jslint white: true, esversion: 6 */
'use strict';

// ITEM_SLOT:
// - Item slots used by characters and containers for holding items.
// - Item slots can be made generic by setting itemTypeSlot to null.
// - Item slots can be restricted to only hold certain items by setting itemTypeSlot to: 'weapon', 'body', feet' etc. This is used for player equipment slots.
// ************************************************************************************************
function ItemSlot(item = null, itemTypeSlot = null) {
	this.item = null;
	this.itemTypeSlot = itemTypeSlot;
	this.index = -1; // Use when the item slot is part of a list;
	
	if (item) {
		this.addItem(item);
	}
	
	Object.seal(this);
}

// HAS_ITEM:
// ************************************************************************************************
ItemSlot.prototype.hasItem = function () {
	return Boolean(this.item);
};

// IS_EMPTY:
// ************************************************************************************************
ItemSlot.prototype.isEmpty = function () {
	return !this.hasItem();
};

// CAN_ADD_ITEM:
// ************************************************************************************************
ItemSlot.prototype.canAddItem = function (item) {
	ASSERT_EQUAL(Item.isItem(item), true, 'Not a valid item: ' + item);
	
	// Slot mismatch:
	if (this.itemTypeSlot && this.itemTypeSlot !== item.type.slot) {
		return false;
	}
	// Stackable:
	else if (this.hasItem() && this.item.canStack(item)) {
		return true;
	}
	// Full:
	else if (this.hasItem()) {
		return false;
	}
	// Empty:
	else {
		return true;
	}
};

// ADD_ITEM:
// ************************************************************************************************
ItemSlot.prototype.addItem = function (item) {
	ASSERT_EQUAL(Item.isItem(item), true, 'Not a valid item: ' + item);
	ASSERT_EQUAL(this.canAddItem(item), true, 'Cannot add item: ' + item);
	
	// Adding to empty slot:
	if (this.isEmpty()) {
		this.item = item;
	}
	// Adding to stack:
	else if (this.item.canStack(item)) {
		this.item.amount += item.amount;
	}
	else {
		throw 'failed to add item';
	}
};

// REMOVE_ITEM:
// ************************************************************************************************
ItemSlot.prototype.removeItem = function (amount) {
	if (!amount) {
		this.item = null;
	} 
	else {
		this.item.amount -= amount;
		if (this.item.amount <= 0) {
			this.item = null;
		}
	}
};

// TO_DATA:
// ************************************************************************************************
ItemSlot.prototype.toData = function () {
	var data = {};
	
	data.itemTypeSlot = this.itemTypeSlot;
	data.item = this.hasItem() ? this.item.toData() : null;
	data.index = this.index;
	
	return data;
};

// LOAD_DATA:
// ************************************************************************************************
ItemSlot.prototype.loadData = function (data) {
	
	this.itemTypeSlot = data.itemTypeSlot;
	this.item = data.item ? Item.createAndLoadItem(data.item) : null;
	this.index = data.index;
};

// UNIT_TESTS:
// ************************************************************************************************
ItemSlot.UnitTests = function () {
	var itemSlot, data;
	
	// HAS_ITEM / IS_EMPTY:
	// ********************************************************************************************
	itemSlot = new ItemSlot(null, null);
	ASSERT_EQUAL(itemSlot.hasItem(), false, 'hasItem() [1]');
	ASSERT_EQUAL(itemSlot.isEmpty(), true, 'hasItem() [2]');
	
	itemSlot.addItem(Item.createItem('PotionOfHealing'));
	ASSERT_EQUAL(itemSlot.hasItem(), true, 'hasItem() [3]');
	ASSERT_EQUAL(itemSlot.isEmpty(), false, 'hasItem() [4]');
	
	itemSlot.removeItem();
	ASSERT_EQUAL(itemSlot.hasItem(), false, 'hasItem() [5]');
	ASSERT_EQUAL(itemSlot.isEmpty(), true, 'hasItem() [6]');
	
	// CAN_ADD_ITEM:
	// ********************************************************************************************
	itemSlot = new ItemSlot(null, null);
	ASSERT_EQUAL(itemSlot.canAddItem(Item.createItem('PotionOfHealing')), true, 'canAddItem() [1]');
	itemSlot.addItem(Item.createItem('PotionOfHealing'));
	ASSERT_EQUAL(itemSlot.canAddItem(Item.createItem('PotionOfHealing')), true, 'canAddItem() [2]');
	ASSERT_EQUAL(itemSlot.canAddItem(Item.createItem('LongSword')), false, 'canAddItem() [3]');
	
	itemSlot = new ItemSlot(null, 'weapon');
	ASSERT_EQUAL(itemSlot.canAddItem(Item.createItem('PotionOfHealing')), false, 'canAddItem() [4]');
	ASSERT_EQUAL(itemSlot.canAddItem(Item.createItem('LongSword')), true, 'canAddItem() [5]');
	
	// ADD_ITEM:
	// ********************************************************************************************
	itemSlot = new ItemSlot(null, null);
	itemSlot.addItem(Item.createItem('PotionOfHealing'));
	itemSlot.addItem(Item.createItem('PotionOfHealing'));
	ASSERT_EQUAL(itemSlot.item.amount, 2, 'addItem() [1]');
	
	// REMOVE_ITEM:
	// ********************************************************************************************
	itemSlot = new ItemSlot(null, null);
	itemSlot.addItem(Item.createItem('PotionOfHealing'));
	itemSlot.addItem(Item.createItem('PotionOfHealing'));
	itemSlot.removeItem(1);
	ASSERT_EQUAL(itemSlot.isEmpty(), false, 'removeItem() [1]');
	itemSlot.removeItem(1);
	ASSERT_EQUAL(itemSlot.isEmpty(), true, 'removeItem() [2]');
	
	// TO_DATA / LOAD_DATA:
	// ********************************************************************************************
	itemSlot = new ItemSlot(Item.createItem('LongSword', {mod: 5}), 'weapon');
	data = itemSlot.toData();
	
	itemSlot = new ItemSlot(null, null);
	itemSlot.loadData(data);
	
	ASSERT_EQUAL(itemSlot.itemTypeSlot, 'weapon');
	ASSERT_EQUAL(itemSlot.item.type.name, 'LongSword');
	ASSERT_EQUAL(itemSlot.item.mod, 5);
	
};/*global game, gs, console, Phaser*/
/*global ASSERT_EQUAL, ASSERT_THROW*/
/*global ItemSlot, Item*/
/*jshint esversion: 6*/
'use strict';


// ITEM_SLOT_LIST:
// - A list of ItemSlots with a specific size.
// - The purpose is to allow items to be added and removed from the list without specifying a specific itemSlot.
// - The list can also be accessed on a per slot basis.
// - The main use of ItemSlotList is for inventories.
// ************************************************************************************************
function ItemSlotList(length, itemSlotType = null) {
	// Properties:
	this.itemSlots = [];
	this.length = length;
	
	// Initialize Item Slots:
	for (let i = 0; i < length; i += 1) {
		this.itemSlots[i] = new ItemSlot(null, itemSlotType);
		this.itemSlots[i].index = i;
	}
	
	Object.seal(this);
}

// CONTAINS_ITEM:
// Returns true if the list contains the exact item
// ************************************************************************************************
ItemSlotList.prototype.containsItem = function (item) {
	ASSERT_EQUAL(Item.isItem(item), true, 'ItemSlotList.containsItem() - not a valid item: ' + item);
	
	for (let i = 0; i < this.length; i += 1) {
		if (this.itemAtIndex(i) === item) {
			return true;
		}
	}
	
	return false;
};

// ITEM_SLOT_INDEX:
// Returns the slot index [number] that the item is located in
// ************************************************************************************************
ItemSlotList.prototype.itemSlotIndex = function (item) {
	ASSERT_EQUAL(Item.isItem(item), true, 'ItemSlotList.itemSlotIndex() - not a valid item: ' + item);
	ASSERT_EQUAL(this.containsItem(item), true, 'ItemSlotList.itemSlotIndex() - does not contain item: ' + item);
	
	for (let i = 0; i < this.length; i += 1) {
		if (this.itemAtIndex(i) === item) {
			return i;
		}
	}
};

// COUNT_ITEM_OF_TYPE:
// ************************************************************************************************
ItemSlotList.prototype.countItemOfType = function (type) {
	ASSERT_EQUAL(gs.itemTypes[type.name], type, 'ItemSlotList.itemOfType() - invalid itemType: ' + type);
	
	if (this.itemOfType(type)) {
		return this.itemOfType(type).amount;
	}
	else {
		return 0;
	}
};

// ITEM_OF_TYPE:
// Returns the item in this list which matches the type or null if no such item exists
// ************************************************************************************************
ItemSlotList.prototype.itemOfType = function (type) {
	ASSERT_EQUAL(gs.itemTypes[type.name], type, 'ItemSlotList.itemOfType() - invalid itemType: ' + type);
	
	for (let i = 0; i < this.length; i += 1) {
		if (this.itemAtIndex(i) && this.itemAtIndex(i).type === type) {
			return this.itemAtIndex(i);
		}
	}
	
	return null;
};

// CAN_STACK_ITEM:
// Returns true if the list contains an item of the same type and mod and the type is stackable:
// ************************************************************************************************
ItemSlotList.prototype.canStackItem = function (item) {
	ASSERT_EQUAL(Item.isItem(item), true, 'ItemSlotList.canStackItem() - not a valid item: ' + item);
	
	for (let i = 0; i < this.length; i += 1) {
		if (this.itemAtIndex(i) && this.itemAtIndex(i).canStack(item)) {
			return true;
		}
	}
	
	return false;
};

// ITEM_AT_INDEX:
// Returns the item in the slot at index or null
// ************************************************************************************************
ItemSlotList.prototype.itemAtIndex = function (index) {
	ASSERT_EQUAL(typeof index, 'number', 'index is not a number');
	ASSERT_EQUAL(index >= 0 && index < this.length, true, 'index out of bounds');
	
	return this.itemSlots[index].item;
};

// ADD_ITEM:
// Adds the item to the first valid slot (either stacking, or empty slot)
// Throws an exception if cannot add the item
// ************************************************************************************************
ItemSlotList.prototype.addItem = function (item) {    
	ASSERT_EQUAL(Item.isItem(item), true, 'Invalid item: ' + item);
   
	// Try to add to an existing stack:
	for (let i = 0; i < this.length; i += 1) {
		if (this.itemSlots[i].hasItem() && this.itemSlots[i].item.canStack(item)) {
			this.itemSlots[i].addItem(item);
			return;
		}
	}
	
	// Try to add to the first empty slot:
	for (let i = 0; i < this.length; i += 1) {
		if (this.itemSlots[i].isEmpty()) {
			this.itemSlots[i].addItem(item);
			return;
		}
	}
		
	throw 'No room for item';
};

// CAN_ADD_ITEM:
// ************************************************************************************************
ItemSlotList.prototype.canAddItem = function (item) {
	ASSERT_EQUAL(Item.isItem(item), true, 'Invalid item: ' + item);
	
	return Boolean(this.itemSlots.find(slot => slot.canAddItem(item)));
};

// REMOVE_ITEM:
// Tries to remove the item from the entire list:
// ************************************************************************************************
ItemSlotList.prototype.removeItem = function (item, amount = 1) {
	ASSERT_EQUAL(Item.isItem(item), true, 'Not an item: ' + item);
	ASSERT_EQUAL(typeof amount === 'number' && amount > 0, true, 'Invalid amount: ' + amount);
	
	for (let i = 0; i < this.length; i += 1) {
		if (this.itemSlots[i].item === item) {
			this.itemSlots[i].item.amount -= amount;

			// Destroy empty stacks:
			if (this.itemSlots[i].item.amount <= 0) {
				this.itemSlots[i].removeItem();
			}
			
			return;
		}
	}
	
	throw 'item does not exist';
};

// CLEAR:
// Remove all items from slots:
// ************************************************************************************************
ItemSlotList.prototype.clear = function () {
	for (let i = 0; i < this.length; i += 1) {
		if (this.itemSlots[i].hasItem()) {
			this.itemSlots[i].removeItem();
		}
	}
};

// FOR_EACH_ITEM:
// ************************************************************************************************
ItemSlotList.prototype.forEachItem = function (func, context) {
	for (let i = 0; i < this.length; i += 1) {
		if (this.itemSlots[i].hasItem()) {
			func.call(context, this.itemSlots[i].item);
		}
	}
};

// ALL_FULL_ITEM_SLOTS:
// ************************************************************************************************
ItemSlotList.prototype.allFullItemSlots = function () {
	var list = [];
	
	for (let i = 0; i < this.length; i += 1) {
		if (this.itemSlots[i].hasItem()) {
			list.push(this.itemSlots[i]);
		}
	}
	
	return list;
};

// TO_DATA:
// ************************************************************************************************
ItemSlotList.prototype.toData = function () {
	var data = {};
	
	data.length = this.length;
	data.itemSlots = [];
	
	for (let i = 0; i < this.itemSlots.length; i += 1) {
		data.itemSlots.push(this.itemSlots[i].toData());
	}
	
	return data;
};

// LOAD_DATA:
// ************************************************************************************************
ItemSlotList.prototype.loadData = function (data) {
	for (let i = 0; i < data.length; i += 1) {
		this.itemSlots[i].loadData(data.itemSlots[i]);
	}
};

// UNIT_TESTS:
// ************************************************************************************************
ItemSlotList.UnitTests = function () {
	var itemSlotList, items, data;
	
	// CONTAINS_ITEM:
	// ********************************************************************************************
	itemSlotList = new ItemSlotList(10);
	items = [];
	items[0] = Item.createItem('PotionOfHealing');
	
	ASSERT_EQUAL(itemSlotList.containsItem(items[0]), false, 		'containsItem() [1]');
	
	itemSlotList.addItem(items[0]);
	ASSERT_EQUAL(itemSlotList.containsItem(items[0]), true, 		'containsItem() [2]');
	
	itemSlotList.removeItem(items[0]);
	ASSERT_EQUAL(itemSlotList.containsItem(items[0]), false, 		'containsItem() [3]');
	
	ASSERT_THROW(itemSlotList.containsItem.bind(itemSlotList, 'blabla'), 	'containsItem() [4]');
	
	// ITEM_SLOT_INDEX:
	// ********************************************************************************************
	itemSlotList = new ItemSlotList(10);
	items = [];
	items[0] = Item.createItem('PotionOfHealing');
	items[1] = Item.createItem('PotionOfEnergy');
	
	
	itemSlotList.addItem(items[0]);
	ASSERT_EQUAL(itemSlotList.itemSlotIndex(items[0]), 0, 			'itemSlotIndex() [1]');
	ASSERT_THROW(itemSlotList.itemSlotIndex.bind(itemSlotList, items[1]), 	'itemSlotIndex() [2]');
	
	itemSlotList.addItem(items[1]);
	ASSERT_EQUAL(itemSlotList.itemSlotIndex(items[1]), 1, 			'itemSlotIndex() [3]');
	
	// ITEM_OF_TYPE:
	// ********************************************************************************************
	itemSlotList = new ItemSlotList(10);
	items = [];
	items[0] = Item.createItem('PotionOfHealing');
	
	itemSlotList.addItem(items[0]);
	ASSERT_EQUAL(itemSlotList.itemOfType(gs.itemTypes.PotionOfHealing), items[0], 		'itemOfType() [1]');
	ASSERT_EQUAL(itemSlotList.itemOfType(gs.itemTypes.PotionOfEnergy), null, 		'itemOfType() [2]');
	
	// CAN_STACK_ITEM:
	// ********************************************************************************************
	itemSlotList = new ItemSlotList(10);
	items = [];
	items[0] = Item.createItem('PotionOfHealing', {amount: 3});
	items[1] = Item.createItem('PotionOfHealing', {amount: 3});
	items[2] = Item.createItem('PotionOfEnergy');
	items[3] = Item.createItem('LongSword');
	items[4] = Item.createItem('LongSword');
	
	ASSERT_EQUAL(itemSlotList.canStackItem(items[0]), false,	'canStackItem() [1]');
	
	itemSlotList.addItem(items[0]);
	ASSERT_EQUAL(itemSlotList.canStackItem(items[1]), true, 	'canStackItem() [2]');
	ASSERT_EQUAL(itemSlotList.canStackItem(items[2]), false, 	'canStackItem() [3]');
	
	itemSlotList.addItem(items[3]);
	ASSERT_EQUAL(itemSlotList.canStackItem(items[4]), false,	'canStackItem() [4]');
	
	// ITEM_AT_INDEX:
	// ********************************************************************************************
	itemSlotList = new ItemSlotList(10);
	items = [];
	items[0] = Item.createItem('PotionOfHealing');
	
	ASSERT_THROW(itemSlotList.itemAtIndex.bind(itemSlotList, -1), 		'itemAtIndex() [1]');
	ASSERT_THROW(itemSlotList.itemAtIndex.bind(itemSlotList, 10), 		'itemAtIndex() [2]');
	ASSERT_THROW(itemSlotList.itemAtIndex.bind(itemSlotList, 'blabla'), 'itemAtIndex() [3]');
	
	itemSlotList.addItem(items[0]);
	ASSERT_EQUAL(itemSlotList.itemAtIndex(0), items[0], 		'itemAtIndex() [4]');
	ASSERT_EQUAL(itemSlotList.itemAtIndex(1), null, 			'itemAtIndex() [5]');
	
	// ADD_ITEM:
	// ********************************************************************************************
	itemSlotList = new ItemSlotList(2);
	items = [];
	items[0] = Item.createItem('PotionOfHealing');
	items[1] = Item.createItem('PotionOfEnergy');
	items[2] = Item.createItem('PotionOfHealing');
	items[3] = Item.createItem('LongSword');
	
	itemSlotList.addItem(items[0]);
	itemSlotList.addItem(items[1]);
	itemSlotList.addItem(items[2]);
	
	ASSERT_EQUAL(itemSlotList.itemAtIndex(0).amount, 2, 			'addItem() [1]');
	ASSERT_EQUAL(itemSlotList.itemAtIndex(1).amount, 1, 			'addItem() [2]');
	ASSERT_THROW(itemSlotList.addItem.bind(itemSlotList, items[3]), 'addItem() [3]');
	
	// CAN_ADD_ITEM:
	// ********************************************************************************************
	itemSlotList = new ItemSlotList(2);
	items = [];
	items[0] = Item.createItem('PotionOfHealing');
	items[1] = Item.createItem('PotionOfEnergy');
	items[2] = Item.createItem('PotionOfHealing');
	items[3] = Item.createItem('LongSword');
	
	itemSlotList.addItem(items[0]);
	itemSlotList.addItem(items[1]);
	
	ASSERT_EQUAL(itemSlotList.canAddItem(items[2]), true, 	'canAddItem() [1]');
	ASSERT_EQUAL(itemSlotList.canAddItem(items[3]), false, 	'canAddItem() [2]');
	
	// REMOVE_ITEM:
	// ********************************************************************************************
	itemSlotList = new ItemSlotList(2);
	items = [];
	items[0] = Item.createItem('PotionOfHealing');
	
	itemSlotList.addItem(items[0]);
	itemSlotList.removeItem(items[0]);
	ASSERT_EQUAL(itemSlotList.itemAtIndex(0), null, 					'removeItem() [1]');
	ASSERT_THROW(itemSlotList.removeItem.bind(itemSlotList, items[0]), 	'removeItem() [2]');
	
	// SAVE_DATA_AND_LOAD_DATA:
	// ********************************************************************************************
	itemSlotList = new ItemSlotList(10);
	items = [];
	items[0] = Item.createItem('PotionOfHealing');
	items[1] = Item.createItem('PotionOfHealing', {amount: 3});
	items[2] = Item.createItem('LongSword', {mod: 1});
	itemSlotList.addItem(items[0]);
	itemSlotList.addItem(items[1]);
	itemSlotList.addItem(items[2]);
	
	data = itemSlotList.toData();
	itemSlotList = new ItemSlotList(10);
	itemSlotList.loadData(data);
	
	ASSERT_EQUAL(itemSlotList.length, 10, 											'saveData() [1]');
	ASSERT_EQUAL(itemSlotList.itemAtIndex(0).type, gs.itemTypes.PotionOfHealing, 	'saveData() [2]');
	ASSERT_EQUAL(itemSlotList.itemAtIndex(0).amount, 4, 							'saveData() [3]');
	ASSERT_EQUAL(itemSlotList.itemAtIndex(1).type, gs.itemTypes.LongSword, 			'saveData() [4]');
	ASSERT_EQUAL(itemSlotList.itemAtIndex(1).mod, 1, 								'saveData() [5]');
};/*global gs, game, util*/
/*global Item*/
/*global ITEM_ENCHANTED_PERCENT*/
/*global COMMON_ITEM_PERCENT, UNCOMMON_ITEM_PERCENT, RARE_ITEM_PERCENT*/
/*jshint esversion: 6*/
'use strict';

/*
	ITEM_DROP_TABLE:
	
	Everything that has to do with randomly creating items should be placed here.
	Items can enter the game in a number of ways:
		- Floor Spawns
		- Merchant Inventory
		- Good Items: zoos, endLevel treasure rooms
		- Crystal chests
		- Acquirement
*/

// GET_RANDOM_ITEM_NAME:
// itemDropTableName is optional, if ommited a table will be randomly chosen
// ************************************************************************************************
gs.getRandomItemName = function (itemDropTableName) {
	itemDropTableName = itemDropTableName || this.chooseRandom(this.itemDropTable);	
	return this.chooseRandom(this.getModifiedItemDropTable(itemDropTableName));
};

// CREATE_RANDOM_ITEM:
// Creates a random item appropriate to the current zoneName and zoneLevel
// Used for generating floor spawns and enemy item drops
// itemDropTableName can refr to ['Melee', 'RangedWeapons', 'Armor', 'Rings'... etc.]
// ************************************************************************************************
gs.createRandomItem = function (itemDropTableName, isEnchanted = false) {
	var typeName, itemType, amount, mod;

	typeName = this.getRandomItemName(itemDropTableName);
	itemType = this.itemTypes[typeName];
	amount = itemType.dropAmount;
	mod = itemType.baseMod;

	// Mod:
	if (Item.canEnchantItemType(itemType) && game.rnd.frac() < (ITEM_ENCHANTED_PERCENT || isEnchanted)) {
		mod = this.dropItemModifier(itemType);
	}
	
	// Upgrade: (Always drop one higher mod than player currently has)
	if (gs.pc && Item.canEnchantItemType(itemType) && gs.pc.inventory.itemOfType(itemType) && !itemType.stackable) {
		mod = gs.playerHighestMod(itemType) + 1;
	}

	return new Item.createItem(typeName, {mod: mod, amount: amount});
};


// STOCK_MERCHANT:
// Call during first generation of merchant to add to the global merchant inventory
// ************************************************************************************************
gs.stockMerchant = function () {
	var itemName, numAdded = 0, count = 0;
	
	// During main menu there is no merchant inventory:
	if (!gs.merchantInventory) {
		return;
	}
	
	// Merchant always sells one food (for emergencies):
	if (gs.merchantInventory.canAddItem({type: gs.itemTypes.Meat, mod: 0, amount: 1})) {
		gs.merchantInventory.addItem(Item.createItem('Meat'));
	}
	
	// Merchant always sells one potion:
	itemName = gs.getRandomItemName('Potions');
	if (gs.merchantInventory.canAddItem({type: gs.itemTypes[itemName], mod: 0, amount: 1})) {
		gs.merchantInventory.addItem(Item.createItem(itemName));
	}
	
	// Randomly choose items to stock the inventory:
	while (numAdded < 4 && count < 50) {
		if (this.addRandomItemToMerchant()) {
			numAdded += 1;
		}
		
		// Safety break:
		count += 1;
	}
};

// ADD_RANDOM_ITEM_TO_MERCHANT:
// Creates and tries to add a random item to merchant inventory.
// Returns true if succeeded, else false
// ************************************************************************************************
gs.addRandomItemToMerchant = function () {
	var itemTableName = util.randElem(['RangedWeapons', 'Melee', 'Staves', 'Armor', 'Shields', 'Rings', 'Charms', 'Potions', 'Scrolls', 'Books']),	
		itemName = gs.getRandomItemName(itemTableName),
		itemMod = 0,
		itemType = gs.itemTypes[itemName];

	// Mod:
	if (Item.canEnchantItemType(itemType)) {
		itemMod = gs.dropItemModifier(itemType);

		// When stocking, the merchant will try to stack upgrades
		if (gs.pc.inventory.itemOfType(itemType) && !itemType.stackable) {
			itemMod = gs.pc.inventory.itemOfType(itemType).mod + 1;
		}
	}

	// Always add stackable items:
	if (itemType.stackable && gs.merchantInventory.canAddItem({type: itemType, mod: itemMod, amount: itemType.dropAmount})) {
		gs.merchantInventory.addItem(Item.createItem(itemName, {mod: itemMod, amount: itemType.dropAmount}));
		return true;
	}
	// Adding new items:
	else if (!gs.merchantInventory.itemOfType(itemType) && gs.merchantInventory.canAddItem({type: itemType, mod: itemMod, amount: 1})) {
		gs.merchantInventory.addItem(Item.createItem(itemName, {mod: itemMod, amount: itemType.dropAmount}));
		return true;
	}
	// Replacing items w/ higher mods:
	else if (gs.merchantInventory.itemOfType(itemType) && Item.canEnchantItemType(itemType)) {
		gs.merchantInventory.itemOfType(itemType).mod = Math.max(itemMod, gs.merchantInventory.itemOfType(itemType).mod + 1);
		return true;
	}
	
	return false;
};

// DROP_ITEM_MODIFIER:
// What should the mod be on an item
// This will be based on the dangerLevel()
// Will randomly roll
// ************************************************************************************************
gs.dropItemModifier = function (itemType) {
	var maxMod = Math.ceil(this.dangerLevel() / 4),
		minMod = Math.ceil(maxMod / 2),
		mod;
	
	// Random roll:
	mod = util.randInt(minMod, maxMod);
	
	// Projectiles must have an odd multiple:
	if (itemType.effect && itemType.effect.skill === 'Range' && itemType.stackable && mod % 2 === 0) {
		mod += 1;
	}
	
	return mod;
};

// PLAYER_HIGHEST_MOD:
// Given an itemType, if the player has one or more of the items, return the highest mod.
// Returns 0 if the player does not have the item or his highest mod is 0.
// This can be used to force upgrades for the player.
// ************************************************************************************************
gs.playerHighestMod = function (itemType) {
	return gs.pc.inventory.highestMod(itemType);
};

// CREATE_ITEM_DROP_TABLES:
// ************************************************************************************************
gs.createItemDropTables = function () {
	
	// DROP_TYPE_TABLE:
	// ********************************************************************************************
	this.itemDropTable = [
		// Equipment: 40
		{name: 'Books',			percent: 3},
		{name: 'Melee',			percent: 6},
		{name: 'Staves',		percent: 1},
		{name: 'Rings',			percent: 8},
		{name: 'Armor',			percent: 14},
		{name: 'Shields',		percent: 4},
		{name: 'Charms',		percent: 4},
		
		// Consumable: 60
		{name: 'Wands',			percent: 6},
		{name: 'Keys',			percent: 5},
		{name: 'Scrolls',		percent: 12},
		{name: 'Food',			percent: 5},
		{name: 'RangedWeapons', percent: 10},
		{name: 'Potions',		percent: 22},
	];

	// The drop rate for individual item types within a class:
	this.itemTypeDropRate = {};

	// MELEE_WEAPONS:
	// ********************************************************************************************
	this.itemTypeDropRate.Melee = [
		{name: 'LongSword',				freq: 'COMMON'},
		{name: 'Spear',					freq: 'COMMON'},
		{name: 'BroadAxe',				freq: 'COMMON'},
		{name: 'Mace',					freq: 'COMMON'},
		
		{name: 'TwoHandSword',			freq: 'COMMON'},
		{name: 'Halberd',				freq: 'COMMON'},
		{name: 'BattleAxe',				freq: 'COMMON'},
		{name: 'WarHammer',				freq: 'COMMON'},
		
		{name: 'Sling',					freq: 'COMMON'},
		{name: 'LongBow',				freq: 'COMMON'},
		
		{name: 'InfernoSword',			freq: 'RARE'},
		{name: 'StormChopper',			freq: 'RARE'},
	];
	
	// STAVES:
	// ********************************************************************************************
	this.itemTypeDropRate.Staves = [
		{name: 'GreaterStaffOfFire',		freq: 'COMMON'},
		{name: 'GreaterStaffOfStorms',		freq: 'COMMON'},
		{name: 'GreaterStaffOfPoison',		freq: 'COMMON'},
		{name: 'GreaterStaffOfIce',			freq: 'COMMON'},
		{name: 'StaffOfPower',				freq: 'UNCOMMON'},
		{name: 'StaffOfEnergy',				freq: 'UNCOMMON'},
	];

	// RANGED_WEAPONS:
	// ********************************************************************************************
	this.itemTypeDropRate.RangedWeapons = [
		{name: 'Dart',				freq: 'COMMON'},
		{name: 'Javelin',			freq: 'COMMON'},
		{name: 'ThrowingNet',		freq: 'UNCOMMON'},
		{name: 'Bomb',				freq: 'UNCOMMON'},
        {name: 'Chakram',           freq: 'UNCOMMON'},
	];

	// ARMOR:
	// ********************************************************************************************
	this.itemTypeDropRate.Armor = [
		// MUNDANE ARMOR:
		{name: 'Robe',					freq: 'COMMON'},
		{name: 'Shoes',					freq: 'COMMON'},
		{name: 'Hat',					freq: 'COMMON'},
		{name: 'ClothGloves',			freq: 'COMMON'},
		{name: 'LeatherArmor',			freq: 'COMMON'},
		{name: 'LeatherBoots',			freq: 'COMMON'},
		{name: 'LeatherHelm',			freq: 'COMMON'},
		{name: 'LeatherGloves',			freq: 'COMMON'},
		{name: 'PlateArmor',			freq: 'COMMON'},
		{name: 'PlateBoots',			freq: 'COMMON'},
		{name: 'PlateHelm',				freq: 'COMMON'},
		{name: 'PlateGloves',			freq: 'COMMON'},
		
		// MAGIC ARMOR:
		{name: 'RedDragonScaleArmor',		freq: 'UNCOMMON'},
		{name: 'GreenDragonScaleArmor',		freq: 'UNCOMMON'},
		{name: 'BlueDragonScaleArmor',		freq: 'UNCOMMON'},
		{name: 'WhiteDragonScaleArmor',		freq: 'UNCOMMON'},
		{name: 'CloakOfStealth',			freq: 'UNCOMMON'},
		{name: 'RobeOfWizardry',			freq: 'UNCOMMON'},
		{name: 'BootsOfStealth',			freq: 'UNCOMMON'},
		{name: 'BootsOfSpeed',				freq: 'UNCOMMON'},
		{name: 'BootsOfFlight',				freq: 'UNCOMMON'},
		{name: 'CircletOfKnowledge',		freq: 'UNCOMMON'},
		{name: 'ArcheryGoggles',			freq: 'UNCOMMON'},
		{name: 'HelmOfTelepathy',			freq: 'UNCOMMON'},
		{name: 'GauntletsOfStrength',		freq: 'UNCOMMON'},
		{name: 'GlovesOfVampirism',			freq: 'UNCOMMON'},
	];
	
	// SHIELDS:
	// ********************************************************************************************
	this.itemTypeDropRate.Shields = [
		// MUNDANE_SHIELDS:
		{name: 'WoodenShield',				freq: 'COMMON'},
		{name: 'MetalShield',				freq: 'COMMON'},
		
		// MAGIC_SHIELDS:
		{name: 'RedDragonScaleShield',		freq: 'UNCOMMON'},
		{name: 'GreenDragonScaleShield',	freq: 'UNCOMMON'},
		{name: 'BlueDragonScaleShield',		freq: 'UNCOMMON'},
		{name: 'WhiteDragonScaleShield',	freq: 'UNCOMMON'},
		
		{name: 'ShieldOfReflection',		freq: 'RARE'},
		{name: 'OrbOfMana',					freq: 'RARE'},
		{name: 'OrbOfPower',				freq: 'RARE'},
	];

	// RINGS:
	// ********************************************************************************************
	this.itemTypeDropRate.Rings = [
		// COMMON:
		{name: 'RingOfFire',			freq: 'COMMON'},
		{name: 'RingOfStorm',			freq: 'COMMON'},
		{name: 'RingOfToxic',			freq: 'COMMON'},
		{name: 'RingOfIce',				freq: 'COMMON'},
		{name: 'RingOfSustenance',		freq: 'COMMON'},
		{name: 'RingOfStealth',			freq: 'COMMON'},
		{name: 'RingOfHealth',			freq: 'COMMON'},
		{name: 'RingOfMana',			freq: 'COMMON'},
		{name: 'RingOfProtection',		freq: 'COMMON'},
		{name: 'RingOfEvasion',			freq: 'COMMON'},
		{name: 'RingOfStrength',		freq: 'COMMON'},
		{name: 'RingOfIntelligence',	freq: 'COMMON'},
		{name: 'RingOfDexterity',		freq: 'COMMON'},
		
		// UNCOMMON:
		{name: 'RingOfFlight',			freq: 'UNCOMMON'},
		{name: 'RingOfWizardry',		freq: 'UNCOMMON'},
		{name: 'RingOfTheVampire',		freq: 'UNCOMMON'},
		{name: 'RingOfLearning',		freq: 'UNCOMMON'},
		
		// RARE:
		{name: 'RingOfLifeSaving',		freq: 'RARE'},
		{name: 'InfernoRing',			freq: 'RARE'},
		{name: 'RingOfThunder',			freq: 'RARE'},
		{name: 'RingOfReflection',		freq: 'RARE'},
		{name: 'RingOfSpeed',			freq: 'RARE'},
		{name: 'RingOfWealth',			freq: 'RARE'},

	];
	
	// CHARMS:
	// ********************************************************************************************
	this.itemTypeDropRate.Charms = [
		{name: 'CharmOfFire',			freq: 'COMMON'},
		{name: 'CharmOfLightning',		freq: 'COMMON'},
		{name: 'CharmOfDisease',		freq: 'COMMON'},
		{name: 'CharmOfFreezing',		freq: 'COMMON'},
		{name: 'CharmOfConfusion',		freq: 'COMMON'},
		{name: 'CharmOfRegeneration',	freq: 'COMMON'},
		{name: 'CharmOfClarity',		freq: 'COMMON'},
		
		{name: 'CharmOfBlinking',		freq: 'UNCOMMON'},
		{name: 'CharmOfHealing',		freq: 'UNCOMMON'},
		{name: 'CharmOfEnergy',			freq: 'UNCOMMON'},
	];
	
	// WANDS:
	// ********************************************************************************************
	this.itemTypeDropRate.Wands = [
		{name: 'WandOfFire',			freq: 'COMMON'},
		{name: 'WandOfLightning',		freq: 'COMMON'},
		{name: 'WandOfCold',			freq: 'COMMON'},
		{name: 'WandOfDraining',		freq: 'COMMON'},
		{name: 'WandOfConfusion',		freq: 'COMMON'},
		{name: 'WandOfBlades',			freq: 'COMMON'},
	];
	
	// POTIONS:
	// ********************************************************************************************
	this.itemTypeDropRate.Potions = [
		{name: 'PotionOfHealing',		freq: 'COMMON'},
		{name: 'PotionOfEnergy',		freq: 'COMMON'},
		{name: 'PotionOfResistance',	freq: 'UNCOMMON'},
		{name: 'PotionOfExperience', 	freq: 'UNCOMMON'},
		{name: 'PotionOfLevitation', 	freq: 'UNCOMMON'},
		{name: 'PotionOfPower',			freq: 'UNCOMMON'},
		{name: 'PotionOfGainAttribute', freq: 'RARE'},
		{name: 'EnergyShroomTea',		freq: 'RARE'},
	];

	// SCROLLS:
	// ********************************************************************************************
	this.itemTypeDropRate.Scrolls = [
		{name: 'ScrollOfTeleportation',		freq: 'COMMON'},
		{name: 'ScrollOfBlink',				freq: 'COMMON'},
		{name: 'ScrollOfFear',				freq: 'COMMON'},
		{name: 'ScrollOfHellFire',			freq: 'COMMON'},
		{name: 'ScrollOfDomination',		freq: 'UNCOMMON'},
		{name: 'ScrollOfEnchantment',		freq: 'UNCOMMON'},
		{name: 'ScrollOfAcquirement',		freq: 'RARE'}
	];
	
	this.itemTypeDropRate.GoodScrolls = [
		{name: 'ScrollOfEnchantment',		freq: 'COMMON'},
		{name: 'ScrollOfAcquirement',		freq: 'COMMON'}
	];
	
	// FOOD:
	// ********************************************************************************************
	this.itemTypeDropRate.Food = [
		{name: 'Meat',					freq: 'COMMON'}
	];
	
	// KEYS:
	// ********************************************************************************************
	this.itemTypeDropRate.Keys = [
		{name: 'Key',					freq: 'COMMON'}
	];
	
	// BOOKS:
	// ********************************************************************************************
	this.itemTypeDropRate.Books = [
		// SKILL_BOOKS:
		{name: 'TomeOfInferno',			freq: 'COMMON'},
		{name: 'TomeOfStorms',			freq: 'COMMON'},
		{name: 'TomeOfIce',				freq: 'COMMON'},
		{name: 'TomeOfDeath',			freq: 'COMMON'},
		{name: 'TomeOfStealth',			freq: 'COMMON'},
		{name: 'TomeOfDefense',			freq: 'COMMON'},
		{name: 'TomeOfWar',				freq: 'COMMON'},
		{name: 'TomeOfArchery',			freq: 'COMMON'},
		{name: 'TomeOfAthletics',		freq: 'COMMON'},
		{name: 'TomeOfPower',			freq: 'COMMON'},
		{name: 'TomeOfEnchantment',		freq: 'COMMON'},
	];
	
	// Setting default values:
	this.forEachType(this.itemTypeDropRate, function (table) {
		table.forEach(function (element) {
			element.minLevel = element.minLevel || 0;
			
			// Checking for unknown items:
			if (!this.itemTypes[element.name]) {
				throw 'Unknown item in dropTable: ' + element.name;
			}
		}, this);
	}, this);
};

// GET_MODIFIED_ITEM_DROP_TABLE:
// Use this function to get a modified (percent) based table of the item class
// This function will take into account the relative dungeon level and ommit certain items from the table
// Input: the name of a table with freq: ['COMMON', 'UNCOMMON', 'RARE']
// Output: a new table with percent: [1-100];
// ************************************************************************************************
gs.getModifiedItemDropTable = function (itemClassName) {
	var table, numCommon, numUncommon, numRare, i;

	// Create a new copy of the table:
	table = this.itemTypeDropRate[itemClassName].slice(0);
	
	// Count Common:
	numCommon = table.reduce(function (pv, nv) {
		return pv + (nv.freq === 'COMMON' && gs.dangerLevel() >= nv.minLevel ? 1 : 0);
	}, 0);
		
	// Count Uncommon:
	numUncommon = table.reduce(function (pv, nv) {
		return pv + (nv.freq === 'UNCOMMON' && gs.dangerLevel() >= nv.minLevel ? 1 : 0);
	}, 0);
		
	// Count Rare:
	numRare = table.reduce(function (pv, nv) {
		return pv + (nv.freq === 'RARE' && gs.dangerLevel() >= nv.minLevel ? 1 : 0);
	}, 0);
	
	// Create new percent table:
	for (i = 0; i < table.length; i += 1) {
		if (table[i].freq === 'COMMON' && gs.dangerLevel() >= table[i].minLevel) {
			table[i].percent = COMMON_ITEM_PERCENT / numCommon;
		} else if (table[i].freq === 'UNCOMMON' && gs.dangerLevel() >= table[i].minLevel) {
			table[i].percent = UNCOMMON_ITEM_PERCENT / numUncommon;
		} else if (table[i].freq === 'RARE' && gs.dangerLevel() >= table[i].minLevel) {
			table[i].percent = RARE_ITEM_PERCENT / numRare;
		} else {
			table[i].percent = 0;
		}
	}
	return table;
};/*global game, gs, Phaser*/
/*global SCREEN_HEIGHT, TILE_SIZE, SCALE_FACTOR, HUD_START_X, WIDE_SCREEN*/
/*global INVENTORY_SIZE, LARGE_RED_FONT, LARGE_WHITE_FONT, SMALL_WHITE_FONT, NUM_DAMAGE_TEXT_SPRITES, MAX_STATUS_EFFECTS, LARGE_WHITE_FONT, FONT_NAME*/
/*global UIToggleButton, UIMap, UIAbilityBar, UIItemSlot, UIItemSlotList, NUM_EQUIPMENT_SLOTS, SCREEN_WIDTH, localStorage*/
/*global MINI_MAP_SIZE_X, MINI_MAP_TILE_SIZE, MAX_COLD_LEVEL, MAX_LEVEL*/
/*global POISON_BAR_FRAME*/
/*global HEALTH_BAR_FRAME, MANA_BAR_FRAME, FOOD_BAR_FRAME, EXP_BAR_FRAME, SLOT_SELECT_BOX_FRAME, COLD_BAR_FRAME, HUGE_WHITE_FONT, LARGE_BOLD_WHITE_FONT*/
/*global CHARACTER_BUTTON_FRAME, CLOSE_BUTTON_FRAME, OPTIONS_BUTTON_FRAME, SOUND_ON_BUTTON_FRAME, MUSIC_ON_BUTTON_FRAME*/
/*global QUIT_BUTTON_FRAME, EXPLORE_BUTTON_FRAME, SOUND_OFF_BUTTON_FRAME, MUSIC_OFF_BUTTON_FRAME*/
/*global WEAPON_HOT_BAR_WIDTH, WEAPON_HOT_BAR_HEIGHT*/
/*global CONSUMABLE_HOT_BAR_WIDTH, CONSUMABLE_HOT_BAR_HEIGHT*/
/*global TIER_II_ZONES, TIER_III_ZONES*/
/*jshint laxbreak: true, esversion: 6*/
'use strict';

// HUD_CONSTRUCTOR:
// ************************************************************************************************
function HUD() {
	var i, startX = HUD_START_X, width = SCREEN_WIDTH - startX;
	
	// Group:
	this.group = game.add.group();
	this.group.fixedToCamera = true;
	
	// Background Sprite:
	this.menu = gs.createSprite(0, 0, 'HUD', this.group);
	this.menu.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	
	
	// Bars:
	this.hpBar = gs.createBar(startX + 18, 6, HEALTH_BAR_FRAME, this.group);
	this.mpBar = gs.createBar(startX + 158, 6, MANA_BAR_FRAME, this.group);
	this.foodBar = gs.createBar(startX + 18, 32, FOOD_BAR_FRAME, this.group);
	this.expBar = gs.createBar(startX + 158, 32, EXP_BAR_FRAME, this.group);
	this.expBar.text.setStyle(LARGE_BOLD_WHITE_FONT);
	this.expBar.text.x += 8;
	
	this.coldBar = gs.createBar(60, 32, COLD_BAR_FRAME, this.group);
	this.rageBar = gs.createBar(startX + 158, 6, FOOD_BAR_FRAME, this.group);
	
	this.poisonBar = gs.createSprite(startX + 10, 8, 'Tileset', this.hpBar.group);
	this.poisonBar.frame = POISON_BAR_FRAME;
	this.poisonBar.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	this.hpBar.group.moveUp(this.hpBar.text);
	
	// Dungeon Level Text:
    this.zoneLevelText = gs.createText(startX + width / 2, 64, '', LARGE_WHITE_FONT, this.group);
   
	// Mini Map:
	this.miniMap = new UIMap(startX + (width - (MINI_MAP_SIZE_X * MINI_MAP_TILE_SIZE)) / 2, 74, this.group);
	
	
	// Chat Log:
	this.chatLogTitle = gs.createText(startX + 6, 316, '', LARGE_WHITE_FONT, this.group);
    this.chatLogText = gs.createText(startX + 6, 334, '', SMALL_WHITE_FONT, this.group);
	this.chatLogText.lineSpacing = -5;
	
	let y = 60;
	if (WIDE_SCREEN) {
		y = 80;
	}
	
	// Gold:
	this.goldText = gs.createText(startX + 4, 448 + y, 'Gold: ', SMALL_WHITE_FONT, this.group);
	
	// Top Row Buttons:
	this.helpButton = gs.createSmallButton(startX + 236, 406 + y, 1301, this.helpClicked, this, this.group);
	this.quitButton = gs.createSmallButton(startX + 266, 406 + y, QUIT_BUTTON_FRAME, this.quitClicked, this, this.group);
	
	// Buttons:
	this.downStairsButton = gs.createSmallButton(startX + 146, 436 + y, 1297, this.useZoneLineClicked, this, this.group);
	this.upStairsButton = gs.createSmallButton(startX + 146, 436 + y, 1299, this.useZoneLineClicked, this, this.group);
	this.exploreButton = gs.createSmallButton(startX + 176, 436 + y, EXPLORE_BUTTON_FRAME, this.exploreClicked, this, this.group);
	this.characterMenuButton = gs.createSmallButton(startX + 206, 436 + y, CHARACTER_BUTTON_FRAME, this.characterMenuClicked, this, this.group);
	this.soundButton = gs.createSmallButton(startX + 236, 436 + y, SOUND_ON_BUTTON_FRAME, this.toggleSoundClicked, this, this.group);
	this.musicButton = gs.createSmallButton(startX + 266, 436 + y, MUSIC_ON_BUTTON_FRAME, this.toggleMusicClicked, this, this.group);
	
	if (!gs.musicOn) {
		this.musicButton.setFrames(MUSIC_OFF_BUTTON_FRAME + 1, MUSIC_OFF_BUTTON_FRAME);
	}
	
	if (!gs.soundOn) {
		this.soundButton.setFrames(SOUND_OFF_BUTTON_FRAME + 1, SOUND_OFF_BUTTON_FRAME);
	}
	
	// Ability Bar:
	this.abilityBar = new UIAbilityBar(startX + 6, 470 + y, 4, 2, this.group);
	
	// Weapon List:
	this.weaponList = new UIItemSlotList(startX + 174, 470 + y, WEAPON_HOT_BAR_WIDTH, WEAPON_HOT_BAR_HEIGHT, gs.pc.inventory.weaponHotBar.itemSlots, this.weaponSlotClicked, this, this.group, 5);
	
	// Quick Weapon Slot:
	this.quickWeaponSlot = new UIItemSlot(startX + 258, 512 + y, gs.pc.inventory.quickWeaponSlot, 1288, this.weaponSlotClicked, this, this.group);
	
	// Consumable List:
	this.consumableList = new UIItemSlotList(startX + 6, 554 + y, CONSUMABLE_HOT_BAR_WIDTH, CONSUMABLE_HOT_BAR_HEIGHT, gs.pc.inventory.consumableHotBar.itemSlots, this.consumableSlotClicked, this, this.group);
	
	// Weapon Slot Selector:
	this.weaponSlotSelector = gs.createSprite(0, 0, 'Tileset', this.group);
	this.weaponSlotSelector.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	this.weaponSlotSelector.frame = SLOT_SELECT_BOX_FRAME;
	this.weaponSlotSelector.visible = true;
	
	this.consumableSlotSelector = gs.createSprite(0, 0, 'Tileset', this.group);
	this.consumableSlotSelector.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	this.consumableSlotSelector.frame = SLOT_SELECT_BOX_FRAME;
	this.consumableSlotSelector.visible = true;
	
	// State Text:
	this.stateText = gs.createText(390, 24, 'STATE', HUGE_WHITE_FONT, this.group);
	this.stateText.visible = false;
	
	
	// Status Effects:
	this.statusEffectText = [];
	for (i = 0; i < MAX_STATUS_EFFECTS; i += 1) {
		this.statusEffectText[i] = gs.createText(6, 4 + i * 20, '',  LARGE_WHITE_FONT, this.group);
		this.statusEffectText[i].inputEnabled = true;
	}

	// DebugText:
	this.debugText = gs.createText(5, SCREEN_HEIGHT - 23, '', LARGE_WHITE_FONT);
	this.debugText.fixedToCamera = true;
}

// REFRESH:
// ************************************************************************************************
HUD.prototype.refresh = function () {
	this.refreshDebugText();
	

	this.menu.frame = gs.pc.currentHp <= gs.pc.maxHp / 3 && gs.state !== 'CHARACTER_MENU_STATE '? 1 : 0;
	
	this.updateStateText();
	this.weaponList.refresh();
	this.abilityBar.refresh();
	this.consumableList.refresh();
	this.quickWeaponSlot.refresh();
	this.updateSlotSelectors();
	

	// Chat Log:
	this.refreshChatLog();
	
	// Button visibility:
	this.downStairsButton.visible = gs.getObj(gs.pc.tileIndex, 'DownStairs');
	this.upStairsButton.visible = gs.getObj(gs.pc.tileIndex, 'UpStairs');
	
	this.refreshBars();
	this.refreshStatusEffects();
	this.refreshZoneTitle();
	
	
};

// UPDATE_SLOT_SELECTORS:
// ************************************************************************************************
HUD.prototype.updateSlotSelectors = function () {
	// Show weapon slot selector:
	if (gs.pc.inventory.quickWeaponEquipped) {
		this.weaponSlotSelector.visible = true;
		this.weaponSlotSelector.x = this.quickWeaponSlot.x;
		this.weaponSlotSelector.y = this.quickWeaponSlot.y;
	}
	else if (gs.pc.inventory.weaponIndex !== -1 && gs.pc.inventory.weaponHotBar.itemAtIndex(gs.pc.inventory.weaponIndex) !== null) {
		this.weaponSlotSelector.visible = true;
		this.weaponSlotSelector.x = this.weaponList.uiItemSlots[gs.pc.inventory.weaponIndex].x;
		this.weaponSlotSelector.y = this.weaponList.uiItemSlots[gs.pc.inventory.weaponIndex].y;
	} 
	else {
		this.weaponSlotSelector.visible = false;
	}
	
	// Show consumable slot selector:
	if (gs.pc.selectedItem) {
		this.consumableSlotSelector.visible = true;
		this.consumableSlotSelector.x = this.consumableList.uiItemSlots[gs.pc.inventory.consumableHotBar.itemSlotIndex(gs.pc.selectedItem)].x;
		this.consumableSlotSelector.y = this.consumableList.uiItemSlots[gs.pc.inventory.consumableHotBar.itemSlotIndex(gs.pc.selectedItem)].y;
	}
	else {
		this.consumableSlotSelector.visible = false;
	}
};

// UPDATE_STATE_TEXT:
// ************************************************************************************************
HUD.prototype.updateStateText = function () {
	if (gs.state === 'USE_ABILITY_STATE') {
		this.stateText.visible = true;
		this.stateText.setText(gs.pc.selectedAbility.type.niceName);
		gs.centerText(this.stateText);
	}
	else if (gs.getObj(gs.pc.tileIndex, 'DownStairs')) {
		this.stateText.visible = true;
		this.stateText.setText('Use s or > to descend stairs');
		gs.centerText(this.stateText);
	}
	else if (gs.getObj(gs.pc.tileIndex, 'UpStairs')) {
		this.stateText.visible = true;
		this.stateText.setText('Use s or < to ascend stairs');
		gs.centerText(this.stateText);
	}
	else {
		this.stateText.visible = false;
	}
};

// REFRESH_CHAT_LOG:
// ************************************************************************************************
HUD.prototype.refreshChatLog = function () {
	var lines = gs.wrapText(this.getDescUnderPointer(), 32);
	
	this.chatLogTitle.setText(lines[0] || '');
	this.chatLogText.setText(lines.slice(1).join('\n') || '');
};

// REFRESH_DEBUG_TEXT:
// ************************************************************************************************
HUD.prototype.refreshDebugText = function () {
	var str;
	
	if (gs.debugProperties.showDebugText) {
		str = '';
		str += 'X: ' + gs.pointerTileIndex().x;
		str += ', Y: ' + gs.pointerTileIndex().y;
		str += ', T: ' + gs.turn;
		str += ', [' + gs.timeToString(gs.gameTime()) + ']';
		str += ', FPS: ' + game.time.fps || '--';
		
		this.debugText.setText(str);
	}
	else {
		this.debugText.visible = false;
	}
	
};


// REFRESH_BARS:
// ************************************************************************************************
HUD.prototype.refreshBars = function () {
	// Update Text:
	
    this.hpBar.text.setText('HP: ' + gs.pc.currentHp + '/' + gs.pc.maxHp);
	this.mpBar.text.setText('MP: ' + gs.pc.currentMp + '/' + gs.pc.maxMp);
	this.foodBar.text.setText('FD: ' + gs.pc.currentFood + '/' + gs.pc.maxFood);
	this.goldText.setText('GOLD: ' + gs.pc.inventory.gold + '  KEYS: ' + gs.pc.inventory.keys);
	this.coldBar.text.setText('COLD: ' + gs.pc.coldLevel + '/' + MAX_COLD_LEVEL);
	this.rageBar.text.setText('RAGE: ' + gs.pc.rage + '/' + gs.pc.maxRage);
	
	if (gs.pc.level < MAX_LEVEL) {
		this.expBar.text.setText('LVL: ' + gs.pc.level + ' ['+ gs.pc.expPercent() + '%]');
	}
	else {
		this.expBar.text.setText('LVL: ' + gs.pc.level);
	}
	
	// Update Bars:
	this.mpBar.bar.scale.setTo(Math.max(0, (gs.pc.currentMp / gs.pc.maxMp) * 63 * SCALE_FACTOR) - 1, SCALE_FACTOR);
	this.foodBar.bar.scale.setTo(Math.max(0, (gs.pc.currentFood / gs.pc.maxFood) * 63 * SCALE_FACTOR) - 1, SCALE_FACTOR);
	this.expBar.bar.scale.setTo(Math.max(0, gs.pc.expPercent() * 0.01 * 63 * SCALE_FACTOR) - 1, SCALE_FACTOR);
	this.coldBar.bar.scale.setTo(Math.max(0, (gs.pc.coldLevel / MAX_COLD_LEVEL) * 63 * SCALE_FACTOR) - 1, SCALE_FACTOR);
	this.rageBar.bar.scale.setTo(Math.max(0, (gs.pc.rage / gs.pc.maxRage) * 63 * SCALE_FACTOR) - 1, SCALE_FACTOR);
	
	// Cold Bar:
	if (gs.zoneType().isCold) {
		this.coldBar.group.visible = true;
	} else {
		this.coldBar.group.visible = false;
	}
	
	// Rage Bar:
	if (gs.pc.hasRage) {
		this.rageBar.group.visible = true;
		this.mpBar.group.visible = false;
	} 
	else {
		this.rageBar.group.visible = false;
		this.mpBar.group.visible = true;
	}
   
	
	// Update Bar Scale:
	this.hpBar.bar.scale.setTo(Math.max(0, (gs.pc.currentHp / gs.pc.maxHp) * 62 * SCALE_FACTOR), SCALE_FACTOR);
	
	// Poison Bar:
	if (gs.pc.poisonDamage > 0) {
		this.poisonBar.visible = true;
		this.poisonBar.x = this.hpBar.bar.x + Math.max(0, ((gs.pc.currentHp - gs.pc.poisonDamage) / gs.pc.maxHp) * 62 * SCALE_FACTOR);
		this.poisonBar.scale.setTo(Math.max(0, (gs.pc.poisonDamage / gs.pc.maxHp) * 62 * SCALE_FACTOR), SCALE_FACTOR);
	}
	else {
		this.poisonBar.visible = false;
	}
	
	// Update Text Color:
	this.hpBar.text.setStyle(gs.pc.currentHp < gs.pc.maxHp / 4 ? LARGE_RED_FONT : LARGE_BOLD_WHITE_FONT);
	this.mpBar.text.setStyle(gs.pc.currentMp < gs.pc.maxMp / 4 ? LARGE_RED_FONT : LARGE_BOLD_WHITE_FONT);
	this.foodBar.text.setStyle(gs.pc.currentFood <= 3 ? LARGE_RED_FONT : LARGE_BOLD_WHITE_FONT);
    this.coldBar.text.setStyle(gs.pc.coldLevel === MAX_COLD_LEVEL ? LARGE_RED_FONT : LARGE_BOLD_WHITE_FONT);
	
	// Mummy has no food:
	if (gs.pc.race && gs.pc.race.name === 'Mummy') {
		this.foodBar.group.visible = false;
	}
};

// REFRESH_STATUS_EFFECTS:
// ************************************************************************************************
HUD.prototype.refreshStatusEffects = function () {
	var i, j = 0;

	
	for (i = 0; i < gs.pc.statusEffects.list.length; i += 1) {
		if (!gs.pc.statusEffects.list[i].dontShowOnHUD) {
			this.statusEffectText[j].visible = true;
			this.statusEffectText[j].setText(gs.pc.statusEffects.list[i].toShortDesc());
			j += 1;
		}
	}
	
	// Show it poisoned:
	if (gs.pc.poisonDamage > 0) {
		this.statusEffectText[j].setText('Poisoned');
		this.statusEffectText[j].visible = true;
		j += 1;
	}
	
	// Show is asleep:
	if (gs.pc.isAsleep) {
		this.statusEffectText[j].setText('Sleeping');
		this.statusEffectText[j].visible = true;
		j += 1;
	}

	// Hide remaining status effect text:
	for (j = j; j < MAX_STATUS_EFFECTS; j += 1) {
		this.statusEffectText[j].visible = false;
	}
	
};

// REFRESH_ZONE_TITLE:
// ************************************************************************************************
HUD.prototype.refreshZoneTitle = function () {
	var str;
	
	str = gs.capitalSplit(gs.zoneName) + ': ' + gs.niceZoneLevel(gs.zoneName, gs.zoneLevel);
	
	if (gs.inArray(gs.zoneName, ['TheUpperDungeon', 'VaultOfYendor'].concat(TIER_II_ZONES).concat(TIER_III_ZONES))) {
		str += '/16';
	}
	else {
		str += '/' + gs.zoneType().numLevels;
	}
	
	str += ' [' + gs.timeToString(gs.gameTime()) + ']';
	this.zoneLevelText.setText(str);
	gs.centerText(this.zoneLevelText);
};

// USE_ZONE_LINE_CLICKED:
// ************************************************************************************************
HUD.prototype.useZoneLineClicked = function () {
	gs.pc.useZoneLine();
	
};

// SKILL_CLICKED:
// ************************************************************************************************
HUD.prototype.skillClicked = function () {
	gs.pc.actionQueue = [];
	
	if (gs.state !== 'SHOP_MENU_STATE' && gs.state !== 'DIALOG_MENU_STATE') {
		if (gs.state === 'GAME_STATE') {
			gs.statMenu.open();
		} else if (gs.state === 'SKILL_MENU_STATE') {
			gs.statMenu.close();
		}
	}
};

// WEAPON_SLOT_CLICKED:
// ************************************************************************************************
HUD.prototype.weaponSlotClicked = function (slot) {
	
	if (gs.state === 'CHARACTER_MENU_STATE') {
		gs.characterMenu.slotClicked(slot);
	}
	else if (gs.state === 'GAME_STATE') {
		if (slot !== gs.pc.inventory.quickWeaponSlot) {
			gs.pc.weaponSlotClicked(slot);
		}
	}
	
};

// CONSUMABLE_SLOT_CLICKED:
// ************************************************************************************************
HUD.prototype.consumableSlotClicked = function (slot) {
	if (gs.state === 'CHARACTER_MENU_STATE') {
		gs.characterMenu.slotClicked(slot);
	}
	else if (gs.state === 'GAME_STATE' || gs.state === 'USE_ABILITY_STATE') {
		if (slot.hasItem()) {
			gs.pc.consumableSlotClicked(slot);
		}
	}
};

// PICK_UP_CLICKED:
// ************************************************************************************************
HUD.prototype.pickUpClicked = function () {
	if (gs.getItem(gs.pc.tileIndex)) {
		gs.pc.pickUpItem(gs.getItem(gs.pc.tileIndex));
	}
};

// EXPLORE_CLICKED:
// ************************************************************************************************
HUD.prototype.exploreClicked = function () {
	gs.pc.startExploring();
};


// CHARACTER_MENU_CLICKED:
// ************************************************************************************************
HUD.prototype.characterMenuClicked = function () {
	gs.pc.actionQueue = [];
	gs.onCharacterMenuClicked();
};

// OPTIONS_MENU_CLICKED:
// ************************************************************************************************
HUD.prototype.optionsMenuClicked = function () {
	gs.pc.actionQueue = [];
	gs.openOptionsMenu();
};

// TOGGLE_SOUND_CLICKED:
// ************************************************************************************************
HUD.prototype.toggleSoundClicked = function () {
	// Toggle sound off:
	if (gs.soundOn) {
		gs.soundOn = false;
		this.soundButton.setFrames(SOUND_OFF_BUTTON_FRAME + 1, SOUND_OFF_BUTTON_FRAME);
	}
	// Toggle sound on:
	else {
		gs.soundOn = true;
		this.soundButton.setFrames(SOUND_ON_BUTTON_FRAME + 1, SOUND_ON_BUTTON_FRAME);
	}
	
	gs.help.soundOn = gs.soundOn;
	localStorage.setItem('Help', JSON.stringify(gs.help));
};

// TOGGLE_MUSIC_CLICKED:
// ************************************************************************************************
HUD.prototype.toggleMusicClicked = function () {
	// Toggle music off:
	if (gs.musicOn) {
		gs.musicOn = false;
		this.musicButton.setFrames(MUSIC_OFF_BUTTON_FRAME + 1, MUSIC_OFF_BUTTON_FRAME);
		gs.stopAllMusic();
	}
	// Toggle music on:
	else {
		gs.musicOn = true;
		this.musicButton.setFrames(MUSIC_ON_BUTTON_FRAME + 1, MUSIC_ON_BUTTON_FRAME);
		gs.startMusic();
	}
	
	gs.help.musicOn = gs.musicOn;
	localStorage.setItem('Help', JSON.stringify(gs.help));
};

// HELP_CLICKED:
// ************************************************************************************************
HUD.prototype.helpClicked = function () {
	if (gs.state === 'GAME_STATE') {
		gs.helpMenu.open();
	}
	else if (gs.state === 'HELP_MENU_STATE') {
		gs.helpMenu.close();
	}
};

// QUIT_CLICKED:
// ************************************************************************************************
HUD.prototype.quitClicked = function () {
	if (gs.activeCharacter === gs.pc) {
		gs.saveLevel();
		gs.pc.save();
		game.state.start('menu');
	}
	
};
// GET_DESC_UNDER_POINTER:
// ************************************************************************************************
HUD.prototype.getDescUnderPointer = function () {
	
	// Ability Bar:
	if (this.abilityBar.getAbilityUnderPointer()) {
		return gs.abilityDesc(this.abilityBar.getAbilityUnderPointer());
	}
	// Items:
	else if (this.getItemUnderPointer()) {
		return this.getItemUnderPointer().toLongDesc();
	}
	// Quick Weapon slot:
	else if (this.quickWeaponSlot.isPointerOver()) {
		if (gs.pc.inventory.quickWeaponSlot.hasItem()) {
			return gs.pc.inventory.quickWeaponSlot.item.toLongDesc();
		}
		else {
			return 'Quick Weapon Slot:\nPlace a weapon here to use when right clicking.';
		}
		
	}
	// Mini-Map:
	else if (this.miniMap.getDescUnderPointer()) {
		return this.miniMap.getDescUnderPointer();
	}
	// Status Effect:
	else if (this.getStatusEffectDescUnderPointer()) {
		return this.getStatusEffectDescUnderPointer();
	}
	// Button:
	else if (this.getButtonDescUnderPointer()) {
		return this.getButtonDescUnderPointer();
	}
	// Talent:
	else if (gs.state === 'CHARACTER_MENU_STATE' && gs.characterMenu.getTalentDescUnderPointer()) {
		return gs.characterMenu.getTalentDescUnderPointer();
    }
	// Skills:
	else if (gs.state === 'CHARACTER_MENU_STATE' && gs.characterMenu.getSkillDescUnderPointer()) {
		return gs.characterMenu.getSkillDescUnderPointer();
	}
	// Stats:
	else if (gs.state === 'CHARACTER_MENU_STATE' && gs.characterMenu.isPointerOverStats()) {
		return gs.characterMenu.getStatDescUnderPointer();
	}
	// Dialog:
	else if (gs.state === 'DIALOG_MENU_STATE' && gs.dialogMenu.getDescUnderPointer()) {
		return gs.dialogMenu.getDescUnderPointer();
	}
	// Tile, Object, Item, Character (in world):
	else if (this.getTileDescUnderCursor()) {
        return this.getTileDescUnderCursor();
	}
	else {
		return '';
	}
};

HUD.prototype.getItemUnderPointer = function () {
	// Inventory:
	if (gs.state === 'CHARACTER_MENU_STATE' && gs.characterMenu.getItemUnderPointer()) {
		return gs.characterMenu.getItemUnderPointer();
	}
	// Enchantment:
	else if (gs.state === 'ENCHANTMENT_MENU_STATE' && gs.enchantmentMenu.getItemUnderPointer()) {
		return gs.enchantmentMenu.getItemUnderPointer();
	}
	// Transferance:
	else if (gs.state === 'TRANSFERANCE_MENU_STATE' && gs.transferanceMenu.getItemUnderPointer()) {
		return gs.transferanceMenu.getItemUnderPointer();
	}
	// HUD Weapon:
	else if (this.weaponList.getItemUnderPointer()) {
		return this.weaponList.getItemUnderPointer();
	}
	// HUD Consumable:
	else if (this.consumableList.getItemUnderPointer()) {
		return this.consumableList.getItemUnderPointer();
	}
	// Shop:
	else if (gs.state === 'SHOP_MENU_STATE' && gs.shopMenu.getItemUnderPointer()) {
		return gs.shopMenu.getItemUnderPointer();
	}
	else {
		return null;
	}
};

// GET_BUTTON_DESC_UNDER_POINTER:
// ************************************************************************************************
HUD.prototype.getButtonDescUnderPointer = function () {
	
	if (this.characterMenuButton.input.checkPointerOver(game.input.activePointer)) {
		return 'Open character menu\nKeyboard shortcut: C.';
	} 
	else if (this.soundButton.input.checkPointerOver(game.input.activePointer)) {
		return 'Toggle Sound';
	} 
	else if (this.musicButton.input.checkPointerOver(game.input.activePointer)) {
		return 'Toggle Music';
	} 
	else if (this.exploreButton.input.checkPointerOver(game.input.activePointer)) {
		return 'Auto Explore\nKeyboard shortcut: E.';
	} 
	else if (this.quitButton.input.checkPointerOver(game.input.activePointer)) {
		return 'Save and Quit';
	}
	else if (this.downStairsButton.input.checkPointerOver(game.input.activePointer)) {
		return 'Descend Stairs\nKeyboard shortcut: >\nThe > key Can also be used to fast travel to down stairs once discovered.';
	}
	else if (this.downStairsButton.input.checkPointerOver(game.input.activePointer)) {
		return 'Ascend Stairs\nKeyboard shortcut: <\nThe < key Can also be used to fast travel to up stairs once discovered.';
	}
	return null;
};



// GET_STATUS_EFFECT_DESC_UNDER_POINTER:
// ************************************************************************************************
HUD.prototype.getStatusEffectDescUnderPointer = function () {
	for (let i = 0; i < MAX_STATUS_EFFECTS; i += 1) {
		if (i < gs.pc.statusEffects.list.length && this.statusEffectText[i].input.checkPointerOver(game.input.activePointer)) {
			return gs.pc.statusEffects.list[i].toLongDesc();
		}
	}
	
	return null;
};


// GET_TILE_DESC_UNDER_CURSOR:
// ************************************************************************************************
HUD.prototype.getTileDescUnderCursor = function () { 
	// In a menu:
	if (gs.state !== 'GAME_STATE' && gs.state !== 'USE_ABILITY_STATE') {
		return null;
	}
	// Offscreen:
    else if (!gs.isPointerInWorld()) {
		return null;
	}
	else {
		return gs.descriptionOfTileIndex(gs.cursorTileIndex);
	}
};/*global game, gs, Phaser, console, localStorage*/
/*global LARGE_WHITE_FONT*/
/*jshint esversion: 6*/
'use strict';


// OPEN_OPTIONS_MENU:
// *****************************************************************************
gs.openOptionsMenu = function () {
	if (gs.state === 'GAME_STATE') {
		gs.optionsMenu.open();
	} else if (gs.state === 'OPTIONS_MENU_STATE') {
		gs.optionsMenu.close();
	}
};
	
// OPEN_DEATH_MENU:
// *****************************************************************************
gs.openDeathMenu = function () {
	var dialog,
		respawnClicked,
		mainMenuClicked,
		deathText,
		charClicked;
	
	deathText = 'Your level ' + gs.pc.level + ' ' + gs.capitalSplit(gs.pc.characterClass) + ' ' + gs.deathText + ' in the ' + gs.capitalSplit(gs.zoneName) + '.';
	
	respawnClicked = function () {
		gs.pc.healHp(1000);
		gs.pc.poisonDamage = 0;
		gs.pc.isAlive = true;
	};
	
	mainMenuClicked = function () {
		game.state.start('menu');
	};
	
	charClicked = function () {
		gs.characterMenu.open();
	};
	
	// Setup Dialog:
	dialog = [{}];
	dialog[0].text = deathText;
	dialog[0].responses = [
		{text: 'Instant Respawn (Testing)', nextLine: 'exit', prereq: function () {return gs.debugProperties.allowRespawn; }, func: respawnClicked},
		{text: 'View Character', nextLine: 'exit', func: charClicked},
		{text: 'Main Menu', nextLine: 'exit', func: mainMenuClicked}
	];
	
	
	this.dialogMenu.open(dialog);
};

// LIFE_SAVING_MENU:
// *****************************************************************************
gs.openLifeSavingMenu = function () {
	var dialog;
	
	gs.pc.inventory.removeItem(gs.pc.inventory.itemOfType(gs.itemTypes.RingOfLifeSaving));
		
	gs.pc.isAlive = true;
	gs.pc.healHp(gs.pc.maxHp);
	gs.pc.gainMp(gs.pc.maxMp);
		
	// Force players turn:
	gs.pc.waitTime = 0;
	gs.activeCharacterIndex = 0;
	gs.activeCharacter = gs.pc;
	
	// Setup Dialog:
	dialog = [{}];
	dialog[0].text = 'You have been killed. Your Ring of Life Saving flashes brightly and disolves, bringing you back to life.';
	dialog[0].responses = [
		{text: 'ok', nextLine: 'exit'}
	];
	
	this.dialogMenu.open(dialog);
};

// OPEN_ALTER_MENU:
// *****************************************************************************
gs.openAltarMenu = function () {
	var okClicked, dialog, religionName;
	
	religionName = gs.currentAltar.type.religion;
	
	okClicked = function () {
		gs.pc.setReligion(religionName);
		gs.playSound(gs.sounds.cure, gs.pc.tileIndex);
	};
	
	dialog = [{}];
	
	if (gs.pc.religion) {
		dialog[0].text = 'You pray at the altar of ' + gs.capitalSplit(religionName) + '. You are already worshipping a god!';
		dialog[0].responses = [{text: 'Ok', nextLine: 'exit'}];
	}
	else {
		dialog[0].text = 'You pray at the altar of ' + gs.capitalSplit(religionName) + ". " + gs.religionTypes[religionName].desc + ' Would you like to join this religion?';
		dialog[0].responses = [{text: 'Yes', nextLine: 'exit', func: okClicked},
							   {text: 'No', nextLine: 'exit'}
							  ];
	}
	
	
	this.dialogMenu.open(dialog);
};



// OPEN_VICTORY_MENU:
// *****************************************************************************
gs.openVictoryMenu = function () {
	var dialog = [{}],
		okClicked,
		time,
		mins;
	
	time = gs.gameTime();
	
	if (gs.achievements[gs.pc.characterClass] === 0 || time < gs.achievements[gs.pc.characterClass]) {
		gs.achievements[gs.pc.characterClass] = time;
	}
	
	
	gs.clearGameData();
	

	//gs.postStats('successfully retrieved the Goblet of Yendor');
	this.logGameRecord('successfully retrieved the Goblet of Yendor', true);
	
	okClicked = function () {
		gs.stopAllMusic();
		localStorage.setItem('Achievements', JSON.stringify(gs.achievements));
		
		game.state.start('menu');
	};

	dialog[0].text = 'Your level ' + gs.pc.level + ' ' + gs.pc.characterClass + ' successfully retrieved the Goblet of Yendor in ' + this.timeToString(time) + '.';
	dialog[0].responses = [{text: '[Done]', nextLine: 'exit', func: okClicked}
						  ];
	gs.createEXPEffect(gs.pc.tileIndex);
	this.dialogMenu.open(dialog);
};

// OPEN_INSTRUCTION_MENU:
// *****************************************************************************
gs.openInstructionMenu = function () {
	var dialog = [{}];
	

	
	dialog[0].text = "Welcome to the Karhakas Mountains. You have been tasked by the Societas Eruditorum to explore these blasted peaks and recover the Codex of Knowledge, the legendary repository of ancient wisdom. The societies scholars believe that the codex is located in a ruined vault to the east of here. Good luck and stay safe!";
	dialog[0].responses = [{text: 'Warrior', nextLine: 'exit', func: gs.pc.setClass.bind(gs.pc, 'Warrior')},
						   {text: 'Ranger', nextLine: 'exit', func: gs.pc.setClass.bind(gs.pc, 'Ranger')},
						   {text: 'Rogue', nextLine: 'exit', func: gs.pc.setClass.bind(gs.pc, 'Rogue')},
						   {text: 'Psyker', nextLine: 'exit', func: gs.pc.setClass.bind(gs.pc, 'Psyker')}
						  ];
	
	this.dialogMenu.open(dialog);
};


// OPEN_ATTRIBUTE_GAIN_MENU:
// *****************************************************************************
gs.openAttributeGainMenu = function () {
	var dialog = [{}], strFunc, dexFunc, intFunc;
	
	strFunc = function () {
		gs.pc.baseStrength += 1;
		gs.pc.popUpText('+1 Str', '#ffffff');
		gs.pc.updateStats();
		gs.pc.currentHp += 2;
		
		gs.usingFountain = null;
	};
	
	dexFunc = function () {
		gs.pc.baseDexterity += 1;
		gs.pc.popUpText('+1 Dex', '#ffffff');
		gs.pc.updateStats();
		
		gs.usingFountain = null;
	};
	
	intFunc = function () {
		gs.pc.baseIntelligence += 1;
		gs.pc.popUpText('+1 Int', '#ffffff');
		gs.pc.updateStats();
		gs.pc.currentEp += 1;
		
		gs.usingFountain = null;
	};
	

	dialog[0].text = 'Select an attribute to increase.';
	dialog[0].responses = [
		// Strength:
		{
			text: function () {
				return 'Strength: ' + gs.pc.strength + ' -> ' + (gs.pc.strength + 1); 
			}, 
			nextLine: 'exit', 
			func: strFunc,
			desc: 'Strength:\nIncreases your melee power and maximum hit points.'
		},
		
		// Dexterity:
		{
			text: function () {
				return 'Dexterity: ' + gs.pc.dexterity + ' -> ' + (gs.pc.dexterity + 1);
			},
			nextLine: 'exit',
			func: dexFunc,
			desc: 'Dexterity:\nIncreases your range power, stealth and evasion.'
		},
		
		// Intelligence:
		{
			text: function () {
				return 'Intelligence: ' + gs.pc.intelligence + ' -> ' + (gs.pc.intelligence + 1);
			},
			nextLine: 'exit',
			func: intFunc,
			desc: 'Intelligence:\nIncreases your spell power and maximum mana points.'
		},
	];
	
	this.dialogMenu.open(dialog);
};

// OPEN_HELP_MENU:
// ************************************************************************************************
gs.openHelpMenu = function () {
	var dialog = [];
	
	dialog[0] = {};
	dialog[0].text = 'KEYBOARD CONTROLS:' + '\n\n';
	dialog[0].text += 'NumPad: 8-way move, attack, interact.' + '\n';
	dialog[0].text += 'NumPad[5]: wait a turn.' + '\n';
	dialog[0].text += '[A]: Ranged targeting, NumPad[5] to confirm.' + '\n';
	dialog[0].text += '[W]: Wield previous weapon.' + '\n';
	dialog[0].text += '[R]: Recast previous spell.' + '\n';
	dialog[0].text += '[E]: Explore automatically.' + '\n';
	dialog[0].responses = [{text: 'Keyboard Conrols', nextLine: 0},
						   {text: 'Mouse Controls', nextLine: 1},
						   {text: 'General Advice', nextLine: 2},
						   {text: '[Done]', nextLine: 'exit'}];
	
	dialog[1] = {};
	dialog[1].text = 'MOUSE CONTROLS:' + '\n\n';
	dialog[1].text += 'Click Tile: move, attack, interact.' + '\n';
	dialog[1].text += 'Click Self: wait a turn.' + '\n';
	dialog[1].text += 'Click Mini Map: move to.' + '\n';
	dialog[1].text += 'Click Inventory: use/equip an item.' + '\n';
	dialog[1].responses = dialog[0].responses;
	
	dialog[2] = {};
	dialog[2].text = 'Your spear has a 2 tile range, you should be able to get a free hit on most enemies.';
	dialog[2].responses = [{text: '[More]', nextLine: 3},
						   {text: 'Keyboard Conrols', nextLine: 0},
						   {text: 'Mouse Controls', nextLine: 1},
						   {text: '[Done]', nextLine: 'exit'}];
	
	dialog[3] = {};
	dialog[3].text = 'Waiting a turn is a good way to get enemies to position themselves optimally. Its often better to find a good position and let them come to you.';
	dialog[3].responses = [{text: '[More]', nextLine: 4},
						   {text: 'Keyboard Conrols', nextLine: 0},
						   {text: 'Mouse Controls', nextLine: 1},
						   {text: '[Done]', nextLine: 'exit'}];
	
	dialog[4] = {};
	dialog[4].text = 'Water, rubble, vines and other surfaces provide an unstable footing. Any character, including yourself who is unstable is automatically critically hit.';
	dialog[4].responses = [{text: '[More]', nextLine: 5},
						   {text: 'Keyboard Conrols', nextLine: 0},
						   {text: 'Mouse Controls', nextLine: 1},
						   {text: '[Done]', nextLine: 'exit'}];
	
	dialog[5] = {};
	dialog[5].text = 'Your healing items are precious. You get full hp upon leveling and also when you find restoration tanks in dungeons. Try to conserve your consumables as much as possible.';
	dialog[5].responses = [{text: '[More]', nextLine: 6},
						   {text: 'Keyboard Conrols', nextLine: 0},
						   {text: 'Mouse Controls', nextLine: 1},
						   {text: '[Done]', nextLine: 'exit'}];
	
	this.dialogMenu.open(dialog);
};

// UI_TOGGLE_BUTTON:
// ************************************************************************************************
function UIToggleButton(x, y, tileset, upFrame, downFrame, group) {
	
	gs.createSprite(x, y, 'Slot', group);
	this.button = gs.createButton(x + 2, y + 2, tileset, this.clicked, this, group);
	this.button.frame = upFrame;
	this.state = 'UP';
	this.upFrame = upFrame;
	this.downFrame = downFrame;
}

UIToggleButton.prototype.toggleUp = function () {
	this.state = 'UP';
	this.button.frame = this.upFrame;
};

UIToggleButton.prototype.toggleDown = function () {
	this.state = 'DOWN';
	this.button.frame = this.downFrame;
};

UIToggleButton.prototype.clicked = function () {
	if (this.state === 'UP') {
		this.toggleDown();
	} else {
		this.toggleUp();
	}
};

UIToggleButton.prototype.isDown = function () {
	return this.state === 'DOWN';
};/*global game, gs, console, Phaser*/
/*global EQUIPMENT_SLOT_FRAMES*/
/*global LARGE_WHITE_FONT, SMALL_WHITE_FONT, SMALL_GREEN_FONT, SCALE_FACTOR, ITEM_SLOT_FRAME, ABILITY_SLOT_RED_FRAME*/
'use strict';

/*
// ************************************************************************************************
						UI_ITEM_SLOT:
// ************************************************************************************************	
- Used to give a visual and interactable representation of an ItemSlot
- Needs to be passed an itemSlot at construction
- By calling refresh the UIItemSlot will update its appearence to match the contents of the ItemSlot
- Can pass in a callback function for when the UIItemSlot is clicked
*/
function UIItemSlot(x, y, itemSlot, emptyFrame, callback, context, group) {
	this.itemSlot = itemSlot;
	this.callback = callback;
	this.context = context;
	this.emptyFrame = emptyFrame || 0;
	this.x = x;
	this.y = y;
	
	// Slot Sprite:
	this.slotSprite = game.add.button(x, y, 'Tileset', this.slotClicked, this, ITEM_SLOT_FRAME + 1, ITEM_SLOT_FRAME);
	this.slotSprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	group.add(this.slotSprite);
	
	
	// Item Sprite:
	this.itemSprite = gs.createSprite(x, y, 'Tileset');
	this.itemSprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	group.add(this.itemSprite);
	
	// Item text:
	this.amountText = gs.createText(x + 18, y + 22, '10', SMALL_WHITE_FONT, group);
}

// SET_POSITION:
// ************************************************************************************************
UIItemSlot.prototype.setPosition = function (x, y) {
	this.x = x;
	this.y = y;
	
	this.slotSprite.x = x;
	this.slotSprite.y = y;
	this.itemSprite.x = x;
	this.itemSprite.y = y;
	this.amountText.x = x + 18;
	this.amountText.y = y + 22;
};

// REFRESH:
// ************************************************************************************************
UIItemSlot.prototype.refresh = function () {
	// Not connected to an item slot:
	if (!this.itemSlot) {
		this.itemSprite.visible = false;
		this.amountText.visible = false;
		return;
	}
	
	this.slotSprite.setFrames(ITEM_SLOT_FRAME + 1, ITEM_SLOT_FRAME);
	
	if (this.itemSlot.hasItem()) {
		this.refreshFullSlot();
	} 
	else {
		this.refreshEmptySlot();
	}
};

// REFRESH_EMPTY_SLOT:
// ************************************************************************************************
UIItemSlot.prototype.refreshEmptySlot = function () {
	// Set emptyFrame:
	if (this.itemSlot && EQUIPMENT_SLOT_FRAMES[this.itemSlot.itemTypeSlot]) {
		this.emptyFrame = EQUIPMENT_SLOT_FRAMES[this.itemSlot.itemTypeSlot];
	}

	if (this.emptyFrame) {
		this.itemSprite.frame = this.emptyFrame;
	} 
	else {
		this.itemSprite.visible = false;
	}
	this.amountText.visible = false;
};

// REFRESH_FULL_SLOT:
// ************************************************************************************************
UIItemSlot.prototype.refreshFullSlot = function () {
	var str = '';
	
	// Set shields red (two handed):
	if (this.itemSlot.itemTypeSlot === 'shield' && !gs.pc.inventory.canWieldShield()) {
		this.slotSprite.setFrames(ABILITY_SLOT_RED_FRAME + 1, ABILITY_SLOT_RED_FRAME);
	}

	// Set item icons:
	this.itemSprite.frame = this.itemSlot.item.type.frame;
	this.itemSprite.visible = true;


	// Color Modded items:
	if (this.itemSlot.item.mod > 0) {
		this.amountText.setStyle(SMALL_GREEN_FONT);
	} 
	else {
		this.amountText.setStyle(SMALL_WHITE_FONT);
	}

	// Set item count:
	if (this.itemSlot.item.amount > 1) {

		str = '' + this.itemSlot.item.amount;
		this.amountText.visible = true;
	} 
	else {
		if (this.itemSlot.item.mod > 0) {
			str = '+' + this.itemSlot.item.mod;
			this.amountText.visible = true;
		} 
		else {
			this.amountText.visible = false;
		}
	}
	
	this.amountText.setText(str);
	if (str.length === 2) {
		this.amountText.x = this.slotSprite.x + 18;
		this.amountText.y = this.slotSprite.y + 22;
	} else {
		this.amountText.x = this.slotSprite.x + 28;
		this.amountText.y = this.slotSprite.y + 22;
	}
};
// SLOT_CLICKED:
// ************************************************************************************************
UIItemSlot.prototype.slotClicked = function () {
	if (this.callback) {
		this.callback.call(this.context, this.itemSlot, this);
	}
};

// GET_ITEM:
// ************************************************************************************************
UIItemSlot.prototype.getItem = function () {
	if (this.itemSlot) {
		return this.itemSlot.item;
	}
	else {
		return null;
	}
	
};

// IS_POINTER_OVER:
// ************************************************************************************************
UIItemSlot.prototype.isPointerOver = function () {
	return this.slotSprite.input.checkPointerOver(game.input.activePointer);
};/*global game, gs, console*/
/*global LARGE_WHITE_FONT, INVENTORY_SIZE, UIItemSlot, SCALE_FACTOR, TILE_SIZE*/
/*jslint esversion: 6*/
'use strict';

// CONSTRUCTOR:
// ************************************************************************************************
function UIItemSlotList(startX, startY, numSlotX, numSlotY, itemSlotList, callback, context, group, maxSlots) {
    var i = 0, button, slotSize = (TILE_SIZE + SCALE_FACTOR);
       
    this.group = game.add.group();
	this.callback = callback;
	this.context = context;
	
	maxSlots = maxSlots || numSlotX * numSlotY;

	// Create item slots:
	this.uiItemSlots = [];
    for (let y = 0; y < numSlotY; y += 1) {
        for (let x = 0; x < numSlotX; x += 1) {
			if (i < maxSlots) {
				this.uiItemSlots[i] = new UIItemSlot(startX + x * slotSize, startY + y * slotSize, null, 0, callback, context, group);
            	this.uiItemSlots[i].index = i;
            	i += 1;
			}
        }
    }
	
	if (itemSlotList) {
		this.setItemSlots(itemSlotList);
	}
	
	group.add(this.group);
}

// SET_ITEM_SLOTS:
// Sets the ItemSlotList which the UIItemSlotList displays and interacts with.
// Can be called post construction to change which ItemSlotList the UIItemSlotList is refering to.
// This is primarily used so that the UIShopMenu can display the inventories of different shops.
// ************************************************************************************************
UIItemSlotList.prototype.setItemSlots = function (list) {
	for (let i = 0; i < this.uiItemSlots.length; i += 1) {
		if (i < list.length) {
			this.uiItemSlots[i].itemSlot = list[i];
		}
		else {
			this.uiItemSlots[i].itemSlot = null;
		}
		
	}
};

// GET_ITEM_UNDER_POINTER:
// ************************************************************************************************
UIItemSlotList.prototype.getItemUnderPointer = function () {
	for (let i = 0; i < this.uiItemSlots.length; i += 1) {
		if (this.uiItemSlots[i].isPointerOver()) {
			return this.uiItemSlots[i].getItem();
		}
	}
	return null;
};

// REFRESH:
// ************************************************************************************************
UIItemSlotList.prototype.refresh = function () {
	for (let i = 0; i < this.uiItemSlots.length; i += 1) {
		this.uiItemSlots[i].refresh();
	}
};
/*global game, gs, console*/
/*global MINI_MAP_SIZE_X, MINI_MAP_SIZE_Y, MINI_MAP_TILE_SIZE, SCALE_FACTOR, FACTION*/
/*jshint esversion: 6, laxbreak: true*/
'use strict';



// CONSTRUCTOR:
// ************************************************************************************************
function UIMap(startX, startY, group) {
	var sprite;
	
	this.startX = startX;
	this.startY = startY;
	
	// Boarder:
	sprite = gs.createSprite(startX - 2, startY - 2, 'MiniMap', group);
	sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	
    // Map sprite:
    this.miniMapBMP = game.add.bitmapData(MINI_MAP_SIZE_X * MINI_MAP_TILE_SIZE, MINI_MAP_SIZE_Y * MINI_MAP_TILE_SIZE);
    this.sprite = game.add.sprite(startX, startY, this.miniMapBMP);
    group.add(this.sprite);
	
	this.colorMap = gs.create2DArray(MINI_MAP_SIZE_X, MINI_MAP_SIZE_Y, (x, y) => 'rgb(0,0,0)');
	
	this.friendlyNPCNames = ['Merchant', 'SkillTrainer', 'TalentTrainer', 'Priest'];
}


// DESTROY:
// ************************************************************************************************
UIMap.prototype.destroy = function () {
	this.sprite.destroy();
};

// IS_POINTER_OVER:
// ************************************************************************************************
UIMap.prototype.isPointerOver = function () {
	return game.input.activePointer.x >= this.sprite.x
		&& game.input.activePointer.y >= this.sprite.y
		&& game.input.activePointer.x < this.sprite.x + this.sprite.width
		&& game.input.activePointer.y < this.sprite.y + this.sprite.height;
};

// INDEX_UNDER_POINTER:
// ************************************************************************************************
UIMap.prototype.indexUnderPointer = function () {
	var x = Math.floor((game.input.activePointer.x - this.sprite.x) / MINI_MAP_TILE_SIZE),
		y = Math.floor((game.input.activePointer.y - this.sprite.y) / MINI_MAP_TILE_SIZE),
		tileIndex;
	
	tileIndex = {x: x + gs.pc.tileIndex.x - Math.floor(MINI_MAP_SIZE_X / 2),
				 y: y + gs.pc.tileIndex.y - Math.floor(MINI_MAP_SIZE_Y / 2)};
			
	if (gs.numTilesX <= MINI_MAP_SIZE_X) {
		tileIndex.x = x - Math.floor((MINI_MAP_SIZE_X - gs.numTilesX) / 2);
	}

	if (gs.numTilesY <= MINI_MAP_SIZE_Y) {
		tileIndex.y = y - Math.floor((MINI_MAP_SIZE_Y - gs.numTilesY) / 2);
	}
	
	return tileIndex;
};

// REFRESH:
// ************************************************************************************************
UIMap.prototype.refresh = function (fullRefresh) {
	var color;
	
	if (gs.pc.hasTalent('KeenHearing')) {
		this.keenHearingRange = gs.talents.KeenHearing.range[gs.pc.getTalentLevel('KeenHearing') - 1];
	}

    // Draw dots:
    for (let x = 0; x < MINI_MAP_SIZE_X; x += 1) {
        for (let y = 0; y < MINI_MAP_SIZE_Y; y += 1) {
			color = this.getTileColor(x, y);

            // Inner Fill (player, upstairs, downstairs)
			if (color.color !== this.colorMap[x][y] || fullRefresh) {
				if (color.outline) {
					// Draw the outline:
					this.miniMapBMP.context.fillStyle = '#000000';
					this.miniMapBMP.context.fillRect(x * MINI_MAP_TILE_SIZE, y * MINI_MAP_TILE_SIZE, MINI_MAP_TILE_SIZE, MINI_MAP_TILE_SIZE);
					
					// Draw the fill:
					this.miniMapBMP.context.fillStyle = color.color;
					this.miniMapBMP.context.fillRect(x * MINI_MAP_TILE_SIZE + 1, y * MINI_MAP_TILE_SIZE + 1, MINI_MAP_TILE_SIZE - 2, MINI_MAP_TILE_SIZE - 2);
				}
				else {
					this.miniMapBMP.context.fillStyle = color.color;
					this.miniMapBMP.context.fillRect(x * MINI_MAP_TILE_SIZE, y * MINI_MAP_TILE_SIZE, MINI_MAP_TILE_SIZE, MINI_MAP_TILE_SIZE);
				}
				
				this.colorMap[x][y] = color.color;
			}
		}
    }
	
    this.miniMapBMP.dirty = true;
};


// GET_TILE_COLOR:
// ************************************************************************************************
UIMap.prototype.getTileColor = function (x, y) {
	var char, obj, tile;
	
	tile = gs.tileMap[x][y];
	char = tile.character;
	obj = tile.object;
	
	// Player:
	if (char && char === gs.pc) {
		return {color: 'rgb(0,255,0)', outline: true};
	}
	// Colored:
	else if (tile.color) {
		return {color: tile.color};
	} 
	// NPC:
	// Note that this must be placed above unexplored to let player see enemies 'through walls'
	else if (char && char.faction === FACTION.HOSTILE && (gs.debugProperties.showCharactersOnMap || gs.pc.isTelepathic)) {
		return {color: 'rgb(255,0,0)'};
	} 
	// KEEN_HEARING:
	else if (gs.pc.hasKeenHearing && char && char.faction === FACTION.HOSTILE && gs.distance(gs.pc.tileIndex, {x: x, y: y}) < this.keenHearingRange) {
		return {color: 'rgb(255,0,0)'};
	} 
	// Unexplored (black):
	else if (!tile.explored) {
		return {color: 'rgb(0,0,0)'};
	}
	// Wall:
	else if (!tile.type.passable) {
		return {color: 'rgb(96,96,96)'};
	}
	// Friendly NPC:
	else if (char && gs.inArray(char.type.name, this.friendlyNPCNames)) {
		return {color: 'rgb(255,110,20)'};
	}
	// Water:
	else if (tile.type === gs.tileTypes.Water) {
		return {color: 'rgb(65,40,200)'};
	}
	// Lava:
	else if (tile.type === gs.tileTypes.Lava) {
		return {color: 'rgb(200, 24, 24)'};
	}
	
	// Objects:
	if (obj) {
		// Stone Door:
		if (obj.type === gs.objectTypes.StoneDoor) {
			return {color: '#b62828'};
		}
		// Door:
		else if (obj.isDoor()) {
			return {color: 'rgb(140,90,34)'};
		}
		// Up Stair:
		else if (obj.type === gs.objectTypes.UpStairs) {
			return {color: 'rgb(0,255,255)', outline: true};
		}
		// Down Stair:
		else if (obj.type === gs.objectTypes.DownStairs) {
			return {color: 'rgb(255,0,255)', outline: true};
		}
		// Camp Fire:
		else if (obj.type === gs.objectTypes.CampFire) {
			return {color: 'rgb(255,0,0)'};
		}
		// Altar
		else if (obj.type.religion) {
			return {color: 'rgb(255,110,20)'};
		}
		
		if (obj.isFull) {
			// Healing Fountain:
			if (obj.type === gs.objectTypes.HealthFountain) {
				return {color: 'rgb(100,243,4)'};
			}
			// Mana Fountain:
			else if (obj.type === gs.objectTypes.EnergyFountain) {
				return {color: 'rgb(166,40,214)'};
			}
			// Experience Fountain:
			else if (obj.type === gs.objectTypes.ExperienceFountain) {
				return {color: 'rgb(255,255,0)'};
			}
			// Wishing Well:
			else if (obj.type === gs.objectTypes.WellOfWishing) {
				return {color: '#639bff'};
			}
			// Attribute Fountain:
			else if (obj.type === gs.objectTypes.AttributeFountain) {
				return {color: '#ea323c'};
			}
			// Enchantment Table:
			else if (obj.type === gs.objectTypes.EnchantmentTable) {
				return {color: '#8b9bb4'};
			}
			// TransferanceTable:
			else if (obj.type === gs.objectTypes.TransferanceTable) {
				return {color: '#feae34'};
			}
		}
		
		// Portal:
		if (obj.type === gs.objectTypes.Portal) {
			return {color: '#8be9ff'};
		}
		// Chest:
		else if (obj.type === gs.objectTypes.Chest && !obj.isOpen) {
			return {color: 'rgb(255,255,0)'};
		}
		// Crystal Chest:
		else if (obj.type === gs.objectTypes.CrystalChest && !gs.crystalChestGroupIsOpen[obj.groupId]) {
			return {color: 'rgb(255,255,0)'};
		}
	}
	
	
	// Item
	if (tile.item) {
		return {color: 'rgb(255,255,0)'};
	}
	// Pit:
	else if (tile.type.isPit) {
		return {color: 'rgb(32,32,32)'};
	}
	// Floor: 
	else if (!obj || obj.type.isPassable) {
		return {color: 'rgb(180,180,180)'};
	}
	else {
		return {color: 'rgb(96,96,96)'};
	}
	
};

// GET_DESC_OF_MINI_MAP:
// ************************************************************************************************
UIMap.prototype.getDescUnderPointer = function () {
	if (!this.isPointerOver()) {
		return null;
	}
	else {
		return gs.descriptionOfTileIndex(this.indexUnderPointer());
	}
};/*global game, gs, console, SCREEN_HEIGHT*/
/*global UIItemSlot, UITextButtonList*/
/*global LARGE_WHITE_FONT, HUGE_WHITE_FONT, SKILL_NAMES, LARGE_WHITE_FONT, SCALE_FACTOR, MAX_SKILL*/
/*global UIItemSlotList, NUM_EQUIPMENT_SLOTS, SLOT_SELECT_BOX_FRAME, SKILL_DESC, RIGHT_RING_SELECT_BOX_FRAME, LEFT_RING_SELECT_BOX_FRAME*/
/*global TILE_SIZE, SMALL_WHITE_FONT, SMALL_GREEN_FONT*/
/*global EQUIPMENT_SLOT_NAMES, EQUIPMENT_SLOT_FRAMES, INVENTORY_WIDTH, INVENTORY_HEIGHT*/
/*jshint esversion: 6, laxbreak: true*/
'use strict';

// CONSTRUCTOR
// ************************************************************************************************
function UICharacterMenu() {
	var startX = 2,
		startY = 0,
		sprite;

	this.group = game.add.group();
	this.group.fixedToCamera = true;
	
	// Menu Sprite:
	sprite = gs.createSprite(2, 2, 'Menu', this.group);
	sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	
	// PANELS:
	// ***************************************
	this.createStatPanel(startX + 4, startY + 4);
	this.createTalentPanel(startX + 324, startY);
	this.createInventoryPanel(startX + 464, startY + 488);
	this.createSkillPanel(startX + 324, startY + 434);
	
	// Close Button:
	// ***************************************
	this.closeButton = gs.createButton(688, -6, 'Tileset', this.close, this, this.group);
	this.closeButton.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	this.closeButton.setFrames(1251, 1250);
	
	// Rearanging abilities:
	// ***************************************
	this.abilityIndexOnCursor = -1;
	this.cursorSprite = gs.createSprite(0, 0, 'Tileset', this.group);
	this.cursorSprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	this.cursorSprite.visible = false;
	
	// Moving items:
	this.itemOnCursor = null;
	
	
	this.group.visible = false;
}

// CREATE_SKILL_PANEL:
// ************************************************************************************************
UICharacterMenu.prototype.createSkillPanel = function (startX, startY) {
	//gs.createText(startX - 100, startY, 'Skills', HUGE_WHITE_FONT, this.group);
	this.skillPointText = gs.createText(startX - 100, startY + 30, 'Skill Points', LARGE_WHITE_FONT, this.group);
	
	
	this.skillButtonList = new UITextButtonList(startX, startY + 66, SKILL_NAMES.length, this.group, this, this.skillClicked);
	this.skillButtonList.upArrow.visible = false;
	this.skillButtonList.downArrow.visible = false;
	
};

// REFRESH_SKILL_PANEL:
// ************************************************************************************************
UICharacterMenu.prototype.refreshSkillPanel = function () {
	this.skillPointText.setText('Skill Points: ' + gs.pc.skillPoints);
	
	SKILL_NAMES.forEach(function (skillName, i) {
		this.skillButtonList.buttons[i].text.setText(gs.capitalSplit(skillName));
		this.skillButtonList.buttons[i].numText.setText(gs.pc.skills[skillName]);
		this.skillButtonList.buttons[i].button.skillName = skillName;
	}, this);
};



// CREATE_TALENT_PANEL:
// ************************************************************************************************
UICharacterMenu.prototype.createTalentPanel = function (startX, startY) {
	var buttonSpace = 30;
	
	//this.talentTitle = gs.createText(startX - 54, startY, 'Talents', HUGE_WHITE_FONT, this.group);
	this.talentPointText = gs.createText(startX + 40, startY + 4, 'Talent Points', LARGE_WHITE_FONT, this.group);
	//gs.centerText(this.talentPointText);
	
	gs.createText(startX - 100, startY + 30, 'Known Talents', LARGE_WHITE_FONT, this.group);
	gs.createText(startX + 140, startY + 30, 'Available Talents', LARGE_WHITE_FONT, this.group);
	
	this.talentButtonList = new UITextButtonList(startX, startY + 66, 10, this.group, this, this.talentClicked);
	this.availableTalentButtonList = new UITextButtonList(startX + 240, startY + 66, 10, this.group, this, this.talentClicked);
		
};

// REFRESH_TALENT_PANEL:
// ************************************************************************************************
UICharacterMenu.prototype.refreshTalentPanel = function () {
	var i, str;
	
	// Talent Point Text:
	this.talentPointText.setText('Talent Points: ' + gs.pc.talentPoints);
	
	for (let i = 0; i < this.talentButtonList.buttons.length; i += 1) {
		if (this.talentButtonList.startIndex + i < gs.pc.talents.length) {
			let talentName = gs.pc.talents[this.talentButtonList.startIndex + i].type.name;
			
			this.talentButtonList.buttons[i].button.talentName = talentName;
			this.talentButtonList.buttons[i].text.setText(gs.capitalSplit(talentName));
			this.talentButtonList.buttons[i].numText.setText(gs.pc.getTalent(talentName).level + '/' + gs.talents[talentName].level.length);
			this.talentButtonList.buttons[i].group.visible = true;
			
			// Color learnable talents:
			if (gs.pc.canLearnTalent(talentName)) {
				this.talentButtonList.buttons[i].text.setStyle(SMALL_GREEN_FONT);
				this.talentButtonList.buttons[i].numText.setStyle(SMALL_GREEN_FONT);
			}
			else {
				this.talentButtonList.buttons[i].text.setStyle(SMALL_WHITE_FONT);
				this.talentButtonList.buttons[i].numText.setStyle(SMALL_WHITE_FONT);
			}
			
		}
		else {
			this.talentButtonList.buttons[i].group.visible = false;
		}
	}
	
	this.talentButtonList.upArrow.visible = this.talentButtonList.startIndex > 0;
	this.talentButtonList.downArrow.visible = gs.pc.talents.length > this.talentButtonList.startIndex + this.talentButtonList.buttons.length;
	

	// Set available talent buttons:
	for (let j = 0; j < this.availableTalentButtonList.buttons.length; j += 1) {
		if (this.availableTalentButtonList.startIndex + j < gs.pc.availableTalents.length) {
			let talentName = gs.pc.availableTalents[this.availableTalentButtonList.startIndex + j];
			
			this.availableTalentButtonList.buttons[j].button.talentName = talentName;
			this.availableTalentButtonList.buttons[j].text.setText(gs.capitalSplit(talentName));
			this.availableTalentButtonList.buttons[j].numText.setText('0/' + gs.talents[talentName].level.length);
			this.availableTalentButtonList.buttons[j].group.visible = true;
			
			// Color learnable talents:
			if (gs.pc.canLearnTalent(talentName)) {
				this.availableTalentButtonList.buttons[j].text.setStyle(SMALL_GREEN_FONT);
				this.availableTalentButtonList.buttons[j].numText.setStyle(SMALL_GREEN_FONT);
			}
			else {
				this.availableTalentButtonList.buttons[j].text.setStyle(SMALL_WHITE_FONT);
				this.availableTalentButtonList.buttons[j].numText.setStyle(SMALL_WHITE_FONT);
			}
		}
		else {
			this.availableTalentButtonList.buttons[j].group.visible = false;
		}
	}
	
	this.availableTalentButtonList.upArrow.visible = this.availableTalentButtonList.startIndex > 0;
	this.availableTalentButtonList.downArrow.visible = gs.pc.availableTalents.length > this.availableTalentButtonList.startIndex + this.availableTalentButtonList.buttons.length;
};






// CREATE_INVENTORY_PANEL:
// ************************************************************************************************
UICharacterMenu.prototype.createInventoryPanel = function (startX, startY) {
	// Equipment:
	this.equipmentSlots = new UIItemSlotList(startX, startY, 4, 2, gs.pc.inventory.equipment.itemSlots, this.slotClicked, this, this.group);
	
	// Inventory:
	this.inventorySlots = new UIItemSlotList(startX, startY + 84, INVENTORY_WIDTH, INVENTORY_HEIGHT, gs.pc.inventory.inventory.itemSlots, this.slotClicked, this, this.group);
	
	// Drop Button:
	this.dropButton =  game.add.button(startX + 189, startY + 21, 'Tileset', this.dropClicked, this, 1225, 1224);	
	this.dropButton.scale.setTo(2, 2);
	this.group.add(this.dropButton);
};

// DROP_CLICKED:
// ************************************************************************************************
UICharacterMenu.prototype.dropClicked = function () {
	if (!gs.pc.isAlive) {
		return;
	}
	
	if (!this.itemOnCursor) {
		return;
	}
	
	if (!gs.pc.canDropItem()) {
		return;
	}
	
	gs.pc.dropItem(this.itemOnCursor);
	this.itemOnCursor = null;
};

// REFRESH_INVENTORY:
// ************************************************************************************************
UICharacterMenu.prototype.refreshInventory = function () {
	this.equipmentSlots.refresh();
	this.inventorySlots.refresh();
};

// UPDATE:
// ************************************************************************************************
UICharacterMenu.prototype.update = function () {
	// Rearanging abilities:
	if (this.abilityIndexOnCursor !== -1) {
		this.cursorSprite.visible = true;
		this.cursorSprite.frame = gs.pc.abilities.abilityInSlot(this.abilityIndexOnCursor).type.frame;
		this.cursorSprite.x = game.input.activePointer.x;
		this.cursorSprite.y = game.input.activePointer.y;
	}
	// Item on cursor:
	else if (this.itemOnCursor) {
		this.cursorSprite.visible = true;
		this.cursorSprite.frame = this.itemOnCursor.type.frame;
		this.cursorSprite.x = game.input.activePointer.x;
		this.cursorSprite.y = game.input.activePointer.y;
	}
	else {
		this.cursorSprite.visible = false;
	}
	
	this.refreshStats();
};

// REFRESH:
// ************************************************************************************************
UICharacterMenu.prototype.refresh = function () {
	var i, str;

	// UI Stat Menu:
	this.refreshTalentPanel();
	this.refreshStats();
	this.refreshInventory();
	this.refreshSkillPanel();
};

// CREATE_STAT_PANEL
// ************************************************************************************************
UICharacterMenu.prototype.createStatPanel = function (startX, startY) {
	// Text:
	this.statsNameText = gs.createText(startX, startY, 'Stats', SMALL_WHITE_FONT, this.group);
	this.statsNameText.lineSpacing = -5;
	this.statsText = gs.createText(startX + 116, startY, 'Stats', SMALL_WHITE_FONT, this.group);
	this.statsText.lineSpacing = -5;	
};

// REFRESH_STATS:
// ************************************************************************************************
UICharacterMenu.prototype.refreshStats = function () {
	var nameStr = '', statStr = '';
	
	this.statList = [];
	
	this.statList[0] = 	{name: 'Class:',		val: gs.capitalSplit(gs.pc.characterClass), tag: 'Class'};
	this.statList[1] = 	{name: 'Race:',			val: gs.capitalSplit(gs.pc.race.name), tag: 'Race'};
	this.statList[2] = 	{name: 'God:',			val: (gs.pc.religion ? gs.capitalSplit(gs.pc.religion) : 'None'), tag: 'Religion'};
	this.statList[3] = 	{name: '',				val: ''};
	
	this.statList[4] = 	{name: 'ATTRIBUTES:',	val: ''};
	this.statList[5] = 	{name: 'Strength:',		val: gs.pc.strength, tag: 'Strength'};
	this.statList[6] = 	{name: 'Dexterity:',	val: gs.pc.dexterity, tag: 'Dexterity'};
	this.statList[7] = 	{name: 'Intelligence:',	val: gs.pc.intelligence, tag: 'Intelligence'};
	this.statList[8] = 	{name: '',				val: ''};
	
	this.statList[9] = 	{name: 'DEFENSE:',		val: ''};
	this.statList[10] = {name: 'Protection:',	val: gs.pc.protection, tag: 'Protection'};
	this.statList[11] = {name: 'Evasion:',		val: gs.pc.evasion, tag: 'Evasion'};
	this.statList[12] = {name: 'Reflection:',	val: gs.pc.reflection, tag: 'Reflection'};
	this.statList[13] = {name: 'Stealth:',		val: gs.pc.stealth, tag: 'Stealth'};
	this.statList[14] = {name: '',				val: ''};
	
	this.statList[15] = {name: 'RESISTANCE:',	val: ''};
	this.statList[16] = {name: 'Fire:',			val: gs.pc.resistance.Fire, tag: 'FireResistance'};
	this.statList[17] = {name: 'Cold:',			val: gs.pc.resistance.Cold, tag: 'ColdResistance'};
	this.statList[18] = {name: 'Shock:',		val: gs.pc.resistance.Shock, tag: 'ShockResistance'};
	this.statList[19] = {name: 'Toxic:',		val: gs.pc.resistance.Toxic, tag: 'ToxicResistance'};
	this.statList[20] = {name: '',				val: ''};
	
	this.statList[21] = {name: 'OFFENSE:',		val: ''};
	this.statList[22] = {name: 'Melee:',		val: gs.pc.meleePower, tag: 'MeleePower'};
	this.statList[23] = {name: 'Range:',		val: gs.pc.rangePower, tag: 'RangePower'};
	this.statList[24] = {name: '',				val: ''};
	
	this.statList[25] = {name: 'MAGIC POWER:',	val: ''};
	this.statList[26] = {name: 'Spell:',		val: gs.pc.spellPower, tag: 'SpellPower'};
	
	if (gs.pc.firePower !== gs.pc.spellPower) {
		this.statList.push({name: 'Fire:', val: gs.pc.firePower, tag: 'FirePower'});
	}
	if (gs.pc.coldPower !== gs.pc.spellPower) {
		this.statList.push({name: 'Cold:', val: gs.pc.coldPower, tag: 'ColdPower'});
	}
	if (gs.pc.stormPower !== gs.pc.spellPower) {
		this.statList.push({name: 'Storm:', val: gs.pc.stormPower, tag: 'StormPower'});
	}
	if (gs.pc.toxicPower !== gs.pc.spellPower) {
		this.statList.push({name: 'Toxic:', val: gs.pc.toxicPower, tag: 'ToxicPower'});
	}
	
	
	if (this.isPointerOverStats()) {
		if (this.getStatLineUnderPointer() >= 0 && this.getStatLineUnderPointer() < this.statList.length) {
			this.statList[this.getStatLineUnderPointer()].val += ']';
			this.statList[this.getStatLineUnderPointer()].name = '[' + this.statList[this.getStatLineUnderPointer()].name;
		}
	}
	
	this.statsNameText.setText(this.statList.reduce((pv, nv) => pv + nv.name + '\n', ''));
	this.statsText.setText(this.statList.reduce((pv, nv) => pv + nv.val + '\n', ''));
	
	//this.statsText.setText(statStr);
	
	/*
	nameStr += 'Class:\n';			statStr += gs.capitalSplit(gs.pc.characterClass) + '\n';
	nameStr += 'Race:\n';			statStr += gs.capitalSplit(gs.pc.race.name) + '\n';
	nameStr += 'God:\n';			statStr += (gs.pc.religion ? gs.capitalSplit(gs.pc.religion) : 'None') + '\n';
	nameStr += '\n';				statStr += '\n';
	
	nameStr += 'ATTRIBUTES:\n';		statStr += '\n';
	nameStr += 'Strength:\n'; 		statStr += gs.pc.strength + '\n';
	nameStr += 'Dexterity:\n'; 		statStr += gs.pc.dexterity + '\n';
	nameStr += 'Intelligence:\n'; 	statStr += gs.pc.intelligence + '\n';
	nameStr += '\n';				statStr += '\n';
	
	nameStr += 'DEFENSE:\n';		statStr += '\n';
	nameStr += 'Protection:\n';	 	statStr += gs.pc.protection + '\n';
	nameStr += 'Evasion:\n';		statStr += gs.pc.evasion + '\n';
	nameStr += 'Reflection:\n';		statStr += gs.pc.reflection + '\n';
	nameStr += 'Stealth:\n';		statStr += gs.pc.stealth + '\n';
	nameStr += '\n';				statStr += '\n';
	
	nameStr += 'RESISTANCE:\n';		statStr += '\n';
	nameStr += 'Fire:\n';			statStr += gs.pc.resistance.Fire + '\n';
	nameStr += 'Cold:\n';			statStr += gs.pc.resistance.Cold + '\n';
	nameStr += 'Shock:\n';			statStr += gs.pc.resistance.Shock + '\n';
	nameStr += 'Toxic:\n'; 			statStr += gs.pc.resistance.Toxic + '\n';
	nameStr += '\n';				statStr += '\n';
	
	nameStr += 'OFFENSE:\n';		statStr += '\n';
	nameStr += 'Melee:\n'; 			statStr += gs.pc.meleePower + '\n';
	nameStr += 'Range:\n'; 			statStr += gs.pc.rangePower + '\n';
	
	nameStr += '\n';				statStr += '\n';
	
	nameStr += 'MAGIC POWER:\n';	statStr += '\n';
	nameStr += 'Spell:\n';			statStr += gs.pc.spellPower + '\n';
	
	if (gs.pc.firePower !== gs.pc.spellPower) {
		nameStr += 'Fire:\n'; 			statStr += gs.pc.firePower + '\n';
	}
	if (gs.pc.coldPower !== gs.pc.spellPower) {
		nameStr += 'Cold:\n'; 			statStr += gs.pc.coldPower + '\n';
	}
	if (gs.pc.stormPower !== gs.pc.spellPower) {
		nameStr += 'Storm:\n'; 			statStr += gs.pc.stormPower + '\n';
	}
	if (gs.pc.toxicPower !== gs.pc.spellPower) {
		nameStr += 'Toxic:\n'; 			statStr += gs.pc.toxicPower + '\n';
	}

	this.statsNameText.setText(nameStr);
	this.statsText.setText(statStr);
	*/
};

// GET_STAT_LINE_UNDER_POINTER:
// Returns the line 0->n of the stat text that the cursor is over
// ************************************************************************************************
UICharacterMenu.prototype.getStatLineUnderPointer = function () {
	var lineHeight = this.statsNameText.fontSize + 2;
	
	return Math.floor((game.input.activePointer.y - this.statsNameText.y) / lineHeight);
};

// IS_POINTER_OVER_STATS:
// ************************************************************************************************
UICharacterMenu.prototype.isPointerOverStats = function () {
	return game.input.activePointer.x > this.statsNameText.x
		&& game.input.activePointer.y > this.statsNameText.y
		&& game.input.activePointer.x < 200;
};

// FLAG_STRING:
// ************************************************************************************************
UICharacterMenu.prototype.flagString = function () {
	var str = '';
	str += gs.pc.isFlying ? '- Flying\n' : '';
	str += gs.pc.isTelepathic ? '- Telepathic\n' : '';
	str += gs.pc.hasLifeSaving ? '- Life Saving\n' : '';
	return str;
};

// SKILL_CLICKED:
// ************************************************************************************************
UICharacterMenu.prototype.skillClicked = function (button) {
	if (!gs.pc.isAlive) {
		return;
	}
	
	if (this.abilityIndexOnCursor !== -1) {
		return;
	}
	
	if (gs.pc.canGainSkill(button.skillName)) {
		gs.pc.gainSkill(button.skillName);
		this.refresh();
		gs.playSound(gs.sounds.point);
	}
};

// TALENT_CLICKED:
// ************************************************************************************************
UICharacterMenu.prototype.talentClicked = function (button) {
	if (!gs.pc.isAlive) {
		return;
	}
	
	if (this.abilityIndexOnCursor !== -1) {
		return;
	}
	
	if (gs.pc.canLearnTalent(button.talentName)) {
		gs.pc.learnTalent(button.talentName);
		this.refresh();
		gs.playSound(gs.sounds.point);
	}	
};



// SLOT_CLICKED:
// ************************************************************************************************
UICharacterMenu.prototype.slotClicked = function (slot) {
	if (!gs.pc.isAlive) {
		return;
	}
	
	if (this.abilityIndexOnCursor !== -1) {
		return;
	}
	
	// Pick up item:
	if (slot.hasItem() && !this.itemOnCursor) {
		this.itemOnCursor = slot.item;
		slot.removeItem();
		
		// Unequip Item:
		if (gs.inArray(slot.itemTypeSlot, EQUIPMENT_SLOT_NAMES)) {
			gs.pc.onUnequipItem(this.itemOnCursor);
		}
	}
	// Place Item:
	else if (this.itemOnCursor && slot.isEmpty() && (!slot.itemTypeSlot || slot.itemTypeSlot === this.itemOnCursor.type.slot)) {
		slot.addItem(this.itemOnCursor);
		this.itemOnCursor = null;
		
		// Equip Item:
		if (gs.inArray(slot.itemTypeSlot, EQUIPMENT_SLOT_NAMES)) {
			gs.pc.onEquipItem(slot.item);
		}
	}
	// Swap Item:
	else if (this.itemOnCursor && (!slot.itemTypeSlot || slot.itemTypeSlot === this.itemOnCursor.type.slot)) {
		
		
		// Unequip Item:
		let tempItem = slot.item;
		slot.removeItem();
		if (gs.inArray(slot.itemTypeSlot, EQUIPMENT_SLOT_NAMES)) {
			gs.pc.onUnequipItem(tempItem);
		}
		
		// Equip Item:
		slot.addItem(this.itemOnCursor);
		this.itemOnCursor = tempItem;
		if (gs.inArray(slot.itemTypeSlot, EQUIPMENT_SLOT_NAMES)) {
			gs.pc.onEquipItem(slot.item);
		}
	}
	
	gs.pc.updateStats();
	this.refresh();
	gs.HUD.refresh();
};

// OPEN:
// ************************************************************************************************
UICharacterMenu.prototype.open = function () {
	gs.pc.stopExploring();
	
	gs.pc.updateStats();
	this.refresh();
	gs.state = 'CHARACTER_MENU_STATE';
	this.group.visible = true;
	gs.playSound(gs.sounds.scroll);
};

// CLOSE:
// ************************************************************************************************
UICharacterMenu.prototype.close = function () {
	gs.state = 'GAME_STATE';
	this.group.visible = false;
	gs.playSound(gs.sounds.scroll);
	
	if (this.abilityIndexOnCursor !== -1) {
		gs.HUD.abilityBar.addAbility(this.abilityIndexOnCursor);
		this.abilityIndexOnCursor = -1;
	}

	if (this.itemOnCursor) {
		gs.pc.inventory.addItem(this.itemOnCursor);
		this.itemOnCursor = null;
	}
	
	if (!gs.pc.isAlive) {
		gs.openDeathMenu();
	}
};

// GET_TALENT_DESC_UNDER_POINTER:
// ************************************************************************************************
UICharacterMenu.prototype.getTalentDescUnderPointer = function () {
	var i, str = '';
	for (i = 0; i < this.talentButtonList.buttons.length; i += 1) {
		if (this.talentButtonList.buttons[i].button.input.checkPointerOver(game.input.activePointer) && this.talentButtonList.buttons[i].button.visible) {
			return gs.getTalentDescription(this.talentButtonList.buttons[i].button.talentName);
		}
	}
	
	for (i = 0; i < this.availableTalentButtonList.buttons.length; i += 1) {
		if (this.availableTalentButtonList.buttons[i].button.input.checkPointerOver(game.input.activePointer) && this.availableTalentButtonList.buttons[i].button.visible) {
			return gs.getTalentDescription(this.availableTalentButtonList.buttons[i].button.talentName);
		}
	}
	
	
	
	return null;
};


// GET_SKILL_DESC_UNDER_POINTER:
// ************************************************************************************************
UICharacterMenu.prototype.getSkillDescUnderPointer = function () {
	for (let i = 0; i < this.skillButtonList.buttons.length; i += 1) {
		if (this.skillButtonList.buttons[i].button.input.checkPointerOver(game.input.activePointer) && this.skillButtonList.buttons[i].button.visible) {
			return SKILL_DESC[this.skillButtonList.buttons[i].button.skillName];
		}
	}

	
	
	return null;
};

// GET_EQUIPMENT_DESC_UNDER_POINTER:
// ************************************************************************************************
UICharacterMenu.prototype.getItemUnderPointer = function () {
	if (this.inventorySlots.getItemUnderPointer()) {
		return this.inventorySlots.getItemUnderPointer();
	}
	else if (this.equipmentSlots.getItemUnderPointer()) {
		return this.equipmentSlots.getItemUnderPointer();
	}
	else {
		return null;
	}
};

// GET_STAT_DESC_UNDER_POINTER:
// ************************************************************************************************
UICharacterMenu.prototype.getStatDescUnderPointer = function () {
	var index = this.getStatLineUnderPointer(),
		tag,
		str = '';
	
	if (index < 0 || index >= this.statList.length || !this.statList[index].tag) {
		return '';
	}
	
	return gs.pc.getStatDesc(this.statList[index].tag);
};/*global game, gs, console*/
/*global LARGE_WHITE_FONT, HUGE_WHITE_FONT, SCALE_FACTOR*/
'use strict';

// CONSTRUCTOR
// ************************************************************************************************
function UIOptionsMenu() {
	var startX = 2,
		startY = 10,
		width = 720,
        height = 636,
		sprite;
	
	this.group = game.add.group();
	this.group.fixedToCamera = true;
	
	sprite = gs.createSprite(2, 2, 'Menu', this.group);
	sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	
	this.group.visible = false;
}

// REFRESH:
// ************************************************************************************************
UIOptionsMenu.prototype.refresh = function () {

};

// OPEN:
// ************************************************************************************************
UIOptionsMenu.prototype.open = function () {
	this.refresh();
	gs.state = 'OPTIONS_MENU_STATE';
	this.group.visible = true;
	gs.playSound(gs.sounds.scroll);
};

// CLOSE:
// ************************************************************************************************
UIOptionsMenu.prototype.close = function () {
	gs.state = 'GAME_STATE';
	this.group.visible = false;
	gs.playSound(gs.sounds.scroll);
};/*global game, gs, console*/
/*global SCREEN_HEIGHT, LARGE_WHITE_FONT, INVENTORY_SIZE*/
/*global UIItemSlotList, LARGE_WHITE_FONT, SCALE_FACTOR, ItemSlotList, SELL_ITEM_PERCENT*/
/*global MERCHANT_INVENTORY_WIDTH, MERCHANT_INVENTORY_HEIGHT*/
'use strict';



// CONSTRUCTOR:
// ************************************************************************************************
function UIShopMenu() {
	var width = 560,
        height = 540,
		startX = 80,
		startY = (SCREEN_HEIGHT - height) / 2,
		x,
		y,
		slotSprite,
		text,
		sprite;
	
	this.startX = startX;
	this.startY = startY;
	this.width = width;
	this.height = height;
	this.group = game.add.group();
	this.group.fixedToCamera = true;
	
	// Menu:
    sprite = gs.createSprite(startX, startY, 'SmallMenu', this.group);
	sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	
	// Shop Title:
	this.titleText = gs.createText(startX + width * 0.25, startY + 20, 'Shop Inventory', LARGE_WHITE_FONT, this.group);
	gs.centerText(this.titleText);
	
	// Player Title:
	this.titleText = gs.createText(startX + width * 0.75, startY + 20, 'Player Inventory', LARGE_WHITE_FONT, this.group);
	gs.centerText(this.titleText);
	
	// Shop Inventory Slots:
	this.shopItemSlots = new UIItemSlotList(startX + 10, startY + 30, MERCHANT_INVENTORY_WIDTH, MERCHANT_INVENTORY_HEIGHT, null, this.itemClicked, this, this.group);

	// Player Inventory Slots:
	this.playerInventory = new ItemSlotList(60);
	this.playerItemSlots = new UIItemSlotList(startX + 300, startY + 30, 6, 10, null, this.playerItemClicked, this, this.group);
	
	// Item Description:
	this.nameText = gs.createText(startX + width / 2, startY + 470, '', LARGE_WHITE_FONT, this.group);
	this.costText = gs.createText(startX + width / 2, startY + 490, '', LARGE_WHITE_FONT, this.group);
	
	// Close button:
	this.closeButton = gs.createTextButton(startX + width / 2, startY + 520, 'Close', this.close, this, this.group);
	
	this.group.visible = false;
}

// ITEM_CLICKED:
// Buying an item:
// ************************************************************************************************
UIShopMenu.prototype.itemClicked = function (slot) {
	var cost, item , newItem;
	
	if (!slot || slot.isEmpty()) {
		return;
	}

	item = slot.item;
	
	// Item Cost:
	cost = item.baseValue();
	
	// Buy Item:
	if (gs.pc.inventory.gold >= cost) {
		// Play Item Sound:
		gs.playSound(item.getSound());
		
		// Add item:
		newItem = Object.create(item);
		newItem.amount = 1;
		gs.pc.inventory.addItem(newItem);
		
		// Remove item:
		gs.pc.inventory.gold -= cost;
		
		// Update UI:
		gs.merchantInventory.removeItem(item, 1);
		
		// Refresh both inventories:
		this.open();
		
		this.nameText.setText('');
		this.costText.setText('');
		this.refresh();
	}
};

// PLAYER_ITEM_CLICKED:
// Selling an item:
// ************************************************************************************************
UIShopMenu.prototype.playerItemClicked = function (slot) {
	var cost, item;
	
	if (!slot || slot.isEmpty()) {
		return;
	}
	
	// Play Item Sound:
	gs.playSound(slot.item.getSound());

	// Make a copy of the item w/ amount = 1 to add to merchant:
	item = Object.create(slot.item);
	item.amount = 1;
	
	// Selling Item:
	cost = slot.item.sellValue();
	gs.pc.inventory.removeItem(slot.item, 1);
	gs.pc.inventory.gold += cost;
		
	// Update UI:
	if (gs.merchantInventory.canAddItem(item)) {
		gs.merchantInventory.addItem(item);
	}
	
	// Refresh both inventories:
	this.open();
	
	// Refresh player stats:
	gs.pc.updateStats();
	
	this.nameText.setText('');
	this.costText.setText('');
	this.refresh();
};
// REFRESH:
// ************************************************************************************************
UIShopMenu.prototype.refresh = function () {
	this.shopItemSlots.refresh();
	this.playerItemSlots.refresh();
};


// UPDATE:
// ************************************************************************************************
UIShopMenu.prototype.update = function () {
	var item, str, cost;
	
	// Buying Shop Item:
	if (this.getMerchantItemUnderPointer()) {
		item = this.getMerchantItemUnderPointer();
		str = 'Buy: ';
		if (item.mod > 0) {
			str += '+' + item.mod + ' ';
		}
		str += item.type.niceName;
		this.nameText.setText(str);
		gs.centerText(this.nameText);

		this.costText.setText('Cost: ' + item.baseValue() + (item.amount > 1 ? ' Gold Each' : ' Gold'));
		gs.centerText(this.costText);
	}
	// Selling Player Item:
	else if (this.getPlayerItemUnderPointer()) {
		item = this.getPlayerItemUnderPointer();
		str = 'Sell: ';
		if (item.mod > 0) {
			str += '+' + item.mod + ' ';
		}
		str += item.type.niceName;
		this.nameText.setText(str);
		gs.centerText(this.nameText);
		
		this.costText.setText("I'll give you " + item.sellValue() + (item.amount > 1 ? ' Gold Each' : ' Gold'));
		gs.centerText(this.costText);
	}
	// No Item:
	else {
		this.nameText.setText('');
		this.costText.setText('');
	}
};

// GET_ITEM_UNDER_POINTER:
// Returns either the shop or player item under pointer
// ************************************************************************************************
UIShopMenu.prototype.getItemUnderPointer = function () {
	if (this.shopItemSlots.getItemUnderPointer()) {
		return this.shopItemSlots.getItemUnderPointer();
	}
	else if (this.playerItemSlots.getItemUnderPointer()) {
		return this.playerItemSlots.getItemUnderPointer();
	}
	else {
		return null;
	}
};

// GET_ITEM_UNDER_POINTER:
// Refers to the shops items
// ************************************************************************************************
UIShopMenu.prototype.getMerchantItemUnderPointer = function () {
	return this.shopItemSlots.getItemUnderPointer();
};

// GET_PLAYER_ITEM_UNDER_POINTER:
// Refers to the players items
// ************************************************************************************************
UIShopMenu.prototype.getPlayerItemUnderPointer = function () {
	return this.playerItemSlots.getItemUnderPointer();
};

// CLOSE:
// ************************************************************************************************
UIShopMenu.prototype.close = function () {
	gs.state = 'GAME_STATE';
	this.group.visible = false;
};

// OPEN:
// ************************************************************************************************
UIShopMenu.prototype.open = function () {
	var i, playerItems;
	
	// Set shop to dialogNPC:
	this.shop = gs.dialogNPC;
	this.shopItemSlots.setItemSlots(gs.merchantInventory.allFullItemSlots());
	this.playerItemSlots.setItemSlots(gs.pc.inventory.allFullItemSlots());
	
	this.refresh();
	gs.state = 'SHOP_MENU_STATE';
	this.group.visible = true;
};/*global game, gs, console*/
/*global FONT_NAME, LARGE_WHITE_FONT, SCALE_FACTOR*/
/*jshint esversion: 6, laxbreak: true*/
'use strict';


// CREATE_TEXT_BOX:
// **********************************************************************************
gs.createTextBox = function (position, numLines, group) {
    var textBox = {},
        i,
        sprite;
    
    // Group:
    textBox.group = game.add.group();
	
	if (group) {
		group.add(textBox.group);
	}
	
	
	// Create panel:
	sprite = gs.createSprite(position.x, position.y, 'TextBox', textBox.group);
	sprite.frame = 0;
	sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	
	sprite = gs.createSprite(position.x, position.y + 16, 'TextBox', textBox.group);
	sprite.frame = 1;
	sprite.scale.setTo(SCALE_FACTOR, (numLines - 2) * SCALE_FACTOR);
	
	sprite = gs.createSprite(position.x, position.y + (numLines - 1) * 16, 'TextBox', textBox.group);
	sprite.frame = 2;
	sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	
	// Create text:
	textBox.text = gs.createText(position.x + 8, position.y + 4, 'Default Text', LARGE_WHITE_FONT, textBox.group);
	
	
    textBox.setText = function (text) {
        var i, textArray, textSum = '';
		textArray = gs.wrapText(text, 43);
		
		for (i = 0; i < textArray.length; i += 1) {
			textSum += textArray[i] + '\n';
		}
		
		this.text.setText(textSum);
    };

    return textBox;
};


// UI_RESPONSE_BUTTON:
// *****************************************************************************
function UIResponseButton(x, y, callBack, context, group) {
	var i,
        sprite;
	
	this.group = game.add.group();
	group.add(this.group);
	
	this.x = x;
	this.y = y;
	this.callBack = callBack;
    this.context = context;
	
	// Create panel:
	this.boxTop = gs.createButton(x, y, 'TextBox', this.clicked, this, this.group);
	this.boxTop.frame = 0;
	this.boxTop.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	
	this.boxMid = gs.createButton(x, y + 16, 'TextBox', this.clicked, this, this.group);
	this.boxMid.frame = 1;
	this.boxMid.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	
	this.boxBottom = gs.createButton(x, y + 32, 'TextBox', this.clicked, this, this.group);
	this.boxBottom.frame = 2;
	this.boxBottom.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	
	// Create text:
	this.text = gs.createText(x + 8, y + 2, 'Default Text', LARGE_WHITE_FONT, this.group);
}

// SET_TEXT:
// *****************************************************************************
UIResponseButton.prototype.setText = function (text, y) {
	var i,
		textArray,
		textSum = '';
	
	this.y = y;
	
	// Text:
	textArray = gs.wrapText(text, 44);
	for (i = 0; i < textArray.length; i += 1) {
		textSum += textArray[i] + '\n';
	}
	this.text.setText(textSum);
	this.text.y = this.y + 2;
	
	// Box:
	this.numLines = textArray.length;
	this.boxTop.y = this.y;
	this.boxMid.y = this.y + 16;
	this.boxMid.scale.setTo(SCALE_FACTOR, (this.numLines - 1) * SCALE_FACTOR);
	this.boxBottom.y = this.y + this.numLines * 16;
	
};

// CLICKED:
// *****************************************************************************
UIResponseButton.prototype.clicked = function () {
	this.callBack.call(this.context, this);
};

UIResponseButton.prototype.isPointerOver = function () {
	return this.group.visible &&
		(this.boxTop.input.checkPointerOver(game.input.activePointer)
		|| this.boxMid.input.checkPointerOver(game.input.activePointer)
		|| this.boxBottom.input.checkPointerOver(game.input.activePointer));
};

// UI_DIALOG_MENU:
// *****************************************************************************
function UIDialogMenu() {
	var startX = 100, // 100
		startY = 354, // 120
		width = 440,
        height = 520,
		sprite,
		text,
		numLines = 9;
		 
    // Group:
    this.group = game.add.group();
    this.group.fixedToCamera = true;
    
	// Text Box:
    this.textBox = gs.createTextBox({x: startX + 20, y: startY + 20}, numLines); // 14 lines
    this.group.add(this.textBox.group);

	// Response Buttons:
	this.responseButtonsStartY = startY + numLines * 18 + 4;
	this.buttons = [];
	this.buttons[0] = new UIResponseButton(startX + 20, startY + 260 - 12, this.buttonClicked, this, this.group);
	this.buttons[1] = new UIResponseButton(startX + 20, startY + 360 - 12, this.buttonClicked, this, this.group);
	this.buttons[2] = new UIResponseButton(startX + 20, startY + 380 - 12, this.buttonClicked, this, this.group);
	this.buttons[3] = new UIResponseButton(startX + 20, startY + 440 - 12, this.buttonClicked, this, this.group);
	this.buttons[4] = new UIResponseButton(startX + 20, startY + 500 - 12, this.buttonClicked, this, this.group);
	
	this.buttons[0].index = 0;
	this.buttons[1].index = 1;
	this.buttons[2].index = 2;
	this.buttons[3].index = 3;
	this.buttons[4].index = 4;

	this.group.visible = false;
}

// SET_TITLE:
// ********************************
UIDialogMenu.prototype.setTitle = function (text) {
	//this.titleText.setText(text);
};

// SET_TEXT:
// ********************************
UIDialogMenu.prototype.setText = function (text) {
	this.textBox.setText(text);
};

// OPEN:
// ********************************
UIDialogMenu.prototype.open = function (dialog) {
	var lineIndex = 0;
	
	if (gs.pc) {
		gs.pc.statusEffects.onOpenDialog();
	}
	

	if (dialog) {
		this.setTitle('');
		this.setDialog(dialog[0]);
		
		// this.dialog is refering to the dialog from menus:
		this.dialog = dialog;
		
	} else {
		this.setTitle(gs.dialogNPC.name);

		// NPC Has Dialog:
		if (gs.dialog[gs.dialogNPC.name]) {
			// Has an init function:
			if (gs.dialogInit[gs.dialogNPC.name]) {
				this.setDialog(gs.dialog[gs.dialogNPC.name][gs.dialogInit[gs.dialogNPC.name]()]);

			// Does not have an init function:
			} else {
				this.setDialog(gs.dialog[gs.dialogNPC.name][0]);
			}

		// NPC Has No Dialog:
		} else {
			this.setDialog(gs.dialog.Default[0]);
		}
	}

	gs.state = 'DIALOG_MENU_STATE';
	this.group.visible = true;
};

// CLOSE:
// ********************************
UIDialogMenu.prototype.close = function () {
	gs.state = 'GAME_STATE';
	this.dialog = null;
	this.group.visible = false;
};

// SET_DIALOG:
// ************************************************************************************************
UIDialogMenu.prototype.setDialog = function (dialog) {
	var MAX_RESPONSES = 5,
		i,
		responseButtonIndex = 0,
		buttonY = this.responseButtonsStartY;

	if (!dialog) {
		throw 'No Dialog (did you forget a default in the init function?';
	}
	
	if (!dialog.text) {
		throw 'DialogError: Missing text list, did you spell it wrong AGAIN?';
	}
	
	
	
	this.currentDialog = dialog;
	
	// Setting Text:
	if (typeof dialog.text === 'function') {
		this.setText(dialog.text());
	}
	else {	
		this.setText(dialog.text);
	}

	for (i = 0; i < MAX_RESPONSES; i += 1) {
		this.buttons[i].group.visible = false;
	}

	if (!dialog.responses) {
		throw 'DialogError: Missing responses list, did you spell it wrong AGAIN?';
	}

	// Set Dialog Responses:
	for (i = 0; i < MAX_RESPONSES; i += 1) {
		if (i < dialog.responses.length && (!dialog.responses[i].prereq || dialog.responses[i].prereq())) {
			this.buttons[responseButtonIndex].group.visible = true;
			// Setting Text:
			if (typeof dialog.responses[i].text === 'function') {
				this.buttons[responseButtonIndex].setText(dialog.responses[i].text(), buttonY);
			}
			else {	
				this.buttons[responseButtonIndex].setText(dialog.responses[i].text, buttonY);
			}
			
			this.buttons[responseButtonIndex].index = i;
			
			if (dialog.responses[i].desc) {
				this.buttons[responseButtonIndex].desc = dialog.responses[i].desc;
			}
			else {
				this.buttons[responseButtonIndex].desc = null;
			}
			
			buttonY += (this.buttons[responseButtonIndex].numLines + 1) * 16 + 6;
			responseButtonIndex += 1;
		}
	}

	// Apply dialog function (if it exists):
	if (dialog.func) {
		dialog.func();
	}
};


// BUTTON_CLICKED:
// ********************************
UIDialogMenu.prototype.buttonClicked = function (button) {
	if (this.currentDialog.responses.length <= button.index) {
		return;
	}
	
	if (this.currentDialog.responses[button.index].prereq && !this.currentDialog.responses[button.index].prereq()) {
		return;
	}
	
	// Exiting:
	if (this.currentDialog.responses[button.index].nextLine === 'exit') {
		this.close();
	}
	// Opening Shop:
	else if (this.currentDialog.responses[button.index].nextLine === 'barter') {
		this.close();
		gs.shopMenu.open();
	}
	// Different Line:
	else {
		// Dialog from menus:
		if (this.dialog) {
			this.setDialog(this.dialog[this.currentDialog.responses[button.index].nextLine]);
		} 
		// Dialog from npcs:
		else {
			this.setDialog(gs.dialog[gs.dialogNPC.name][this.currentDialog.responses[button.index].nextLine]);
		}
	}
	
	// Call a function on a response
	if (this.currentDialog.responses[button.index].func) {
		this.currentDialog.responses[button.index].func();
	}
};

UIDialogMenu.prototype.getDescUnderPointer = function () {
	for (let i = 0; i < this.buttons.length; i += 1) {
		if (this.buttons[i].isPointerOver() && this.buttons[i].desc) {
			return this.buttons[i].desc;
		}
	}
	
	return null;
};/*global game, gs, console, Phaser*/
/*global ABILITY_SLOT_FRAME, ABILITY_SLOT_RED_FRAME*/
/*global SMALL_WHITE_FONT, SCALE_FACTOR, TILE_SIZE, SLOT_SELECT_BOX_FRAME, ABILITY_SLOT_GREEN_FRAME*/
/*jshint esversion: 6*/
'use strict';

function UIAbilityBar(startX, startY, numSlotsX, numSlotsY, group) {
	var i = 0,
		x,
		y;

	this.abilityList = gs.pc.abilities.list;
	this.group = game.add.group();
	this.abilitySlots = [];
	this.abilityIcons = [];
	this.abilityText = []; // cooldown
	
	this.numSlotsX = numSlotsX;
	this.numSlotsY = numSlotsY;

	// Create ability slots:
	for (y = 0; y < this.numSlotsY; y += 1) {
        for (x = 0; x < this.numSlotsX; x += 1) {
			
			// AbilitySlots:
			this.abilitySlots[i] = game.add.button(startX + x * (TILE_SIZE + SCALE_FACTOR),
												   startY + y * (TILE_SIZE + SCALE_FACTOR),
												   'Tileset', this.slotClicked, this, ABILITY_SLOT_FRAME + 1, ABILITY_SLOT_FRAME);
			
			this.abilitySlots[i].scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
			this.abilitySlots[i].slot = -1;
			this.group.add(this.abilitySlots[i]);

			// Ability Icons:
			this.abilityIcons[i] = gs.createSprite(startX + x * (TILE_SIZE + SCALE_FACTOR),
												   startY + y * (TILE_SIZE + SCALE_FACTOR),
												   'Tileset', this.group);
			this.abilityIcons[i].scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
			
			// Ability Text:
			this.abilityText[i] = gs.createText(startX + x * (TILE_SIZE + SCALE_FACTOR) + SCALE_FACTOR,
												startY + y * (TILE_SIZE + SCALE_FACTOR) + SCALE_FACTOR + 16,
												'10', SMALL_WHITE_FONT, this.group);
			i += 1;
		}
	}
	
	// Selected Ability Sprite:
	this.selectedAbilitySprite = gs.createSprite(0, 0, 'Tileset', this.group);
    this.selectedAbilitySprite.frame = SLOT_SELECT_BOX_FRAME;
	this.selectedAbilitySprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	this.selectedAbilitySprite.visible = false;

	group.add(this.group);
}

// REFRESH:
// ************************************************************************************************
UIAbilityBar.prototype.refresh = function () {
	var slot;
	
	this.selectedAbilitySprite.visible = false;
	
	for (let i = 0; i < this.abilitySlots.length; i += 1) {
		slot = this.abilitySlots[i].slot;
		
		if (slot !== -1 && this.abilityList[slot]) {
			
			// Sustained on:
			if (this.abilityList[slot].type.isSustained && this.abilityList[slot].isOn) {
				this.abilitySlots[i].setFrames(ABILITY_SLOT_GREEN_FRAME + 1, ABILITY_SLOT_GREEN_FRAME);
			}
			// Red Frame (cannot use):
			else if (gs.pc.cannotUseAbility(slot)) {
				this.abilitySlots[i].setFrames(ABILITY_SLOT_RED_FRAME + 1, ABILITY_SLOT_RED_FRAME);
			}
			else {
				this.abilitySlots[i].setFrames(ABILITY_SLOT_FRAME + 1, ABILITY_SLOT_FRAME);
			}
			
			// Set item icons:
			this.abilityIcons[i].frame = this.abilityList[slot].type.frame;
			this.abilityIcons[i].visible = true;
			
			// Cooldown:
			if (this.abilityList[slot].coolDown > 0) {
				this.abilityText[i].setText(this.abilityList[slot].coolDown);
				this.abilityText[i].visible = true;
			} 
			// Charges:
			else if (this.abilityList[slot].type.itemType) {
				let item = gs.pc.inventory.getCharm();
				this.abilityText[i].setText(item.charges + '/' + item.getModdedStat('maxCharges'));
				this.abilityText[i].visible = true;
			}
			else {
				this.abilityText[i].visible = false;
			}
			
			
			if (gs.state === 'USE_ABILITY_STATE' && this.abilityList[slot] === gs.pc.selectedAbility) {
				this.selectedAbilitySprite.x = this.abilityIcons[i].x;
				this.selectedAbilitySprite.y = this.abilityIcons[i].y;
				this.selectedAbilitySprite.visible = true;
			}
			
			
		} else {
			this.abilityIcons[i].visible = false;
			this.abilityText[i].visible = false;
			this.abilitySlots[i].setFrames(ABILITY_SLOT_FRAME + 1, ABILITY_SLOT_FRAME);
		}
	}
};

// SLOT_CLICKED:
// ************************************************************************************************
UIAbilityBar.prototype.slotClicked = function (button) {

		
	if (gs.state === 'CHARACTER_MENU_STATE') {
		// Picking up ability:
		if (gs.characterMenu.abilityIndexOnCursor === -1 && this.abilityList[button.slot]) {
			gs.characterMenu.abilityIndexOnCursor = button.slot;
			button.slot = -1;
			this.refresh();
		}
		// Placing ability in occupied slot (swap):
		else if (gs.characterMenu.abilityIndexOnCursor !== -1 && this.abilityList[button.slot]) {
			let tempSlot = button.slot;
			button.slot = gs.characterMenu.abilityIndexOnCursor;
			gs.characterMenu.abilityIndexOnCursor = tempSlot;
			this.refresh();
			
		}
		// Placing ability in empty slot:
		else {
			button.slot = gs.characterMenu.abilityIndexOnCursor;
			gs.characterMenu.abilityIndexOnCursor = -1;
			this.refresh();
		}

	}
	else if (this.abilityList[button.slot]){
		gs.pc.clickAbility(button.slot);
	}
};

// ADD_ABILITY:
// Adds ability at abilitySlot to the next open buttonSlot (slot = -1)
// ************************************************************************************************
UIAbilityBar.prototype.addAbility = function (abilitySlot) {
	for (let i = 0; i < this.abilitySlots.length; i += 1) {
		if (this.abilitySlots[i].slot === -1) {
			this.abilitySlots[i].slot = abilitySlot;
			return;
		}
	}
};

// REMOVE_ABILITY:
// Removes the ability at abilitySlot:
// ************************************************************************************************
UIAbilityBar.prototype.removeAbility = function (abilitySlot) {
	for (let i = 0; i < this.abilitySlots.length; i += 1) {
		if (this.abilitySlots[i].slot === abilitySlot) {
			this.abilitySlots[i].slot = -1;
			return;
		}
	}
	
	throw 'Could not remove ability from abilityBar';
};

// GET_ABILITY_UNDER_POINTER:
// ************************************************************************************************
UIAbilityBar.prototype.getAbilityUnderPointer = function () {
	
	var i;
	for (i = 0; i < this.abilitySlots.length; i += 1) {
		if (this.abilitySlots[i].input.checkPointerOver(game.input.activePointer) && this.abilitySlots[i].slot !== -1) {
			return this.abilityList[this.abilitySlots[i].slot];
		}
	}
	return null;
};

// TO_DATA:
// ************************************************************************************************
UIAbilityBar.prototype.toData = function () {
	var data = [];
	
	for (let i = 0; i < this.abilitySlots.length; i += 1) {
		data.push(this.abilitySlots[i].slot);
	}
	
	return data;
};

// LOAD_DATA:
// ************************************************************************************************
UIAbilityBar.prototype.loadData = function (data) {
	for (let i = 0; i < this.abilitySlots.length; i += 1) {
		this.abilitySlots[i].slot = data[i];
	}
};
/*global game, gs, console, util*/
/*global NUM_DAMAGE_TEXT_SPRITES, LARGE_RED_FONT, SCALE_FACTOR, TILE_SIZE, FONT_NAME*/
/*global GREEN_TARGET_BOX_FRAME, RED_SELECT_BOX_FRAME, PURPLE_SELECT_BOX_FRAME, RED_TARGET_BOX_FRAME, X_FRAME*/
/*global FACTION*/
/*jshint laxbreak: true, esversion: 6*/
'use strict';

// CREATE_HUD_SPRITES:
// ************************************************************************************************
gs.createHUDSprites = function () {
    var i;
    
	// DAMAGE TEXT SPRITES:
    // ******************************************************************************************
    this.damageTextSprites = [];
    for (i = 0; i < NUM_DAMAGE_TEXT_SPRITES; i += 1) {
        this.damageTextSprites.push(this.createText(608, 340, '', LARGE_RED_FONT, this.popUpTextSpritesGroup));
        this.damageTextSprites[i].visible = false;
        this.damageTextSprites[i].isAlive = false;
    }
	
	// Mouse Cursor Sprite:
	this.cursorTileIndex = {x: 0, y: 0};
    this.cursorSprite = this.createSprite(0, 0, 'Tileset', this.hudTileSpritesGroup);
	this.cursorSprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
    this.cursorSprite.frame = GREEN_TARGET_BOX_FRAME;
	this.cursorSprite.visible = false;
    
	// Targeting Sprite:
    this.targetSprites = [];
    for (i = 0; i < 30; i += 1) {
        this.targetSprites[i] = this.createSprite(0, 0, 'Tileset', this.hudTileSpritesGroup);
		this.targetSprites[i].scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
        this.targetSprites[i].frame = RED_SELECT_BOX_FRAME;
		this.targetSprites[i].visible = false;
    }
	
	// Targeting Line Sprite:
	this.targetLineSprites = [];
	for (i = 0; i < 50; i += 1) {
		this.targetLineSprites[i] = this.createSprite(0, 0, 'Tileset', this.hudTileSpritesGroup);
		this.targetLineSprites[i].anchor.setTo(0.5, 0.5);
		this.targetLineSprites[i].scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
		this.targetLineSprites[i].frame = X_FRAME;
		this.targetLineSprites[i].visible = false;
	}
};


// UPDATE_HUD_TILE_SPRITES:
// ************************************************************************************************
gs.updateHUDTileSprites = function () {
    var i,
        isNPCTargeted,
        showAxeTarget,
        showSingleTarget,
        showMultiTarget,
        showBoltTarget;
    
    // IS NPC TARGETED:
    // ********************************************************************************************
    isNPCTargeted = function () {
        var tile = gs.getTile(gs.cursorTileIndex);
    
		return gs.isInBounds(gs.cursorTileIndex)
			&& tile.character !== null
			&& tile.character !== this
			&& gs.pc.canSeeCharacter(tile.character)
			&& tile.character.isAlive
			&& tile.character.faction === FACTION.HOSTILE;
    };
    
    // Hide all target sprites:
    for (i = 0; i < 30; i += 1) {
        this.targetSprites[i].visible = false;
    }
	
	// Hide all target line sprites:
	for (i = 0; i < 50; i += 1) {
		this.targetLineSprites[i].visible = false;
	}
	
	// Position the cursor at the tile index of the pointer:
	if (!this.keyBoardMode) {
		this.cursorTileIndex.x = this.pointerTileIndex().x;
		this.cursorTileIndex.y = this.pointerTileIndex().y;
	}
	
	// Position the cursor sprite under the pointer:
	this.cursorSprite.x = this.cursorTileIndex.x * TILE_SIZE;
	this.cursorSprite.y = this.cursorTileIndex.y * TILE_SIZE;
	this.cursorSprite.visible = true;
	
	// If we are in game:
    if ((this.state === 'GAME_STATE' || this.state === 'USE_ABILITY_STATE') && (gs.isPointerInWorld() || this.keyBoardMode)) {
		// USING AN ABILITY:
		if (this.state === 'USE_ABILITY_STATE') {
			this.cursorSprite.visible = false;
			this.pc.selectedAbility.type.showTarget(this.cursorTileIndex);
		}
		// ATTACKING MELEE:
		else if (this.pc.weaponSkill() === 'Melee' && this.pc.canAttack(this.cursorTileIndex)) {
			this.pc.inventory.getWeapon().type.effect.showTarget(this.cursorTileIndex, this.pc.inventory.getWeapon());
        }
		// ATTACKING RANGED:
		else if (this.pc.weaponSkill() === 'Range' && (isNPCTargeted() || this.pc.canAttack(this.cursorTileIndex))) {
			this.pc.inventory.getWeapon().type.effect.showTarget(this.cursorTileIndex, this.pc.inventory.getWeapon());
        }
		// MOVING:
		else if (this.isInBounds(this.cursorTileIndex)
				   && ((this.getTile(this.cursorTileIndex).explored && this.isPassable(this.cursorTileIndex))
				   || this.getChar(this.cursorTileIndex)
				   || this.getObj(this.cursorTileIndex, obj => obj.type.interactFunc))) {
			this.cursorSprite.visible = true;
			this.cursorSprite.frame = GREEN_TARGET_BOX_FRAME;
        } else {
            this.cursorSprite.visible = false;
        }
    } 
	else {
		this.cursorSprite.visible = false;
	}
	
	// Mouse over abilities:
	if (gs.HUD.abilityBar.getAbilityUnderPointer() &&
		gs.HUD.abilityBar.getAbilityUnderPointer().type.useImmediately &&
	    gs.HUD.abilityBar.getAbilityUnderPointer().type.showTarget) {
		gs.HUD.abilityBar.getAbilityUnderPointer().type.showTarget(gs.pc);
	}
	
	// Mouse over consumable:
	if (gs.HUD.consumableList.getItemUnderPointer()
		&& gs.HUD.consumableList.getItemUnderPointer().type.useEffect
	   	&& gs.HUD.consumableList.getItemUnderPointer().type.useEffect.showTarget) {
		
		gs.HUD.consumableList.getItemUnderPointer().type.useEffect.showTarget(gs.pc);
	}
};

// CREATE_DAMAGE_TEXT:
// ************************************************************************************************
gs.createDamageText = function (x, y, text, color) {
    var i;
    for (i = 0; i < NUM_DAMAGE_TEXT_SPRITES; i += 1) {
        if (!this.damageTextSprites[i].isAlive) {
            this.damageTextSprites[i].x = x;
    		this.damageTextSprites[i].y = y;
            this.damageTextSprites[i].setText(text);
            this.damageTextSprites[i].setStyle({font: '18px ' + FONT_NAME, fill: color, stroke: '#000000', strokeThickness: 4});
			this.initPopUpText(this.damageTextSprites[i]);
			this.centerText(this.damageTextSprites[i]);
			this.popUpTextSpritesGroup.bringToTop(this.damageTextSprites[i]);
            return this.damageTextSprites[i];
        }
    }
};

// Use this to start the texts movement
// Can be called again to pop text even higher
gs.initPopUpText = function (text) {
	
	text.life = 70;
	text.isAlive = true;
	text.visible = true;
	text.alpha = 1.0;
};

// UPDATE_DAMAGE_TEXT:
// ************************************************************************************************
gs.updateDamageText = function () {
    var i;
    
    for (i = 0; i < NUM_DAMAGE_TEXT_SPRITES; i += 1) {
        // Disapear:
        if (this.damageTextSprites[i].life === 0) {
            this.damageTextSprites[i].isAlive = false;
            this.damageTextSprites[i].visible = false;
        
		// Pause and fade:
        } else if (this.damageTextSprites[i].life < 20) {
            this.damageTextSprites[i].life -= 1;
        
		// Pause:
        } else if (this.damageTextSprites[i].life < 60) {
            this.damageTextSprites[i].life -= 1;
        
        // Move upwards:
        } else {
            this.damageTextSprites[i].life -= 1;
            this.damageTextSprites[i].y -= 1;
        }
    }
};

// SHOW_TARGET_LINE:
// ************************************************************************************************
gs.showTargetLine = function (tileIndex) {
	var x,
		y,
		stepSize = 20,
		distance = 0,
		finalDistance,
		normal,
		i = 0,
		j = 0;

	x = util.toPosition(gs.pc.tileIndex).x;
	y = util.toPosition(gs.pc.tileIndex).y;
	finalDistance = game.math.distance(x, y, util.toPosition(tileIndex).x, util.toPosition(tileIndex).y);
	normal = gs.getNormal({x: x, y: y}, {x: util.toPosition(tileIndex).x, y: util.toPosition(tileIndex).y});

	while (distance < finalDistance - stepSize) {
		x += normal.x * stepSize;
		y += normal.y * stepSize;
		distance += stepSize;

		gs.targetLineSprites[i].x = x;
		gs.targetLineSprites[i].y = y;
		gs.targetLineSprites[i].visible = true;

		while (gs.targetLineSprites[i].visible) {
			i += 1;
		}
	}
};

/*global game, gs, Phaser, console, */
/*global Item*/
/*global SCALE_FACTOR, HUGE_WHITE_FONT, SCREEN_HEIGHT, NUM_EQUIPMENT_SLOTS*/
/*global UIItemSlotList, ItemSlotList*/
/*jshint laxbreak: true, esversion: 6*/
'use strict';

// CONSTRUCTOR
// ************************************************************************************************
function UIEnchantmentMenu() {
	var startX = 80,
		startY = 120,
		width = 520,
        height = 380,
		sprite;
	
	this.group = game.add.group();
	this.group.fixedToCamera = true;
	
	sprite = gs.createSprite(startX, startY, 'SmallMenu', this.group);
	sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	
	
	// Title Text:
	this.titleText = gs.createText(startX + width / 2, startY + 20, 'Enchant Item', HUGE_WHITE_FONT, this.group);
	gs.centerText(this.titleText);
	
	// List containing all enchantable items:
	this.uiItemSlotList = new UIItemSlotList(startX + width / 2 - 42 * 3, startY + 40, 6, 6, null, this.slotClicked, this, this.group);
	
	// Close button:
	this.closeButton = gs.createTextButton(startX + width / 2, startY + 470, 'Close', this.close, this, this.group);
	
	
	this.group.visible = false;
}

// SLOT_CLICKED:
// ************************************************************************************************
UIEnchantmentMenu.prototype.slotClicked = function (slot) {
	
	slot.item.enchant();
	gs.pc.popUpText('Enchanted ' + gs.capitalSplit(slot.item.type.name), '#ffffff');
	gs.createParticlePoof(gs.pc.tileIndex, 'YELLOW');
	gs.playSound(gs.sounds.cure, gs.pc.tileIndex);
	
	// When using a fountaing:
	if (gs.usingFountain) {
		gs.usingFountain.setIsFull(false);
		gs.usingFountain = null;
	}
	// When using a scroll:
	else {
		gs.pc.inventory.removeItem(gs.pc.inventory.itemOfType(gs.itemTypes.ScrollOfEnchantment), 1);
	}
	
	
	
	this.close();
};

// REFRESH:
// ************************************************************************************************
UIEnchantmentMenu.prototype.refresh = function () {
	this.uiItemSlotList.refresh();
	
	
	// Hide slots which contain no item:
	for (let i = 0; i < this.uiItemSlotList.uiItemSlots.length; i += 1) {
		if (!this.uiItemSlotList.uiItemSlots[i].itemSlot || this.uiItemSlotList.uiItemSlots[i].itemSlot.isEmpty()) {
			this.uiItemSlotList.uiItemSlots[i].slotSprite.visible = false;
		} 
		else {
			this.uiItemSlotList.uiItemSlots[i].slotSprite.visible = true;
		}
	}
};

// OPEN:
// ************************************************************************************************
UIEnchantmentMenu.prototype.open = function () {
	var playerItemSlots;
	
	this.titleText.updateFont(HUGE_WHITE_FONT);
	
	// Get list of all enchantable items:
	playerItemSlots = gs.pc.inventory.allFullItemSlots();
	playerItemSlots = playerItemSlots.filter(slot => slot.item.canEnchant());
	this.uiItemSlotList.setItemSlots(playerItemSlots);

	gs.pc.stopExploring();
	this.refresh();
	gs.state = 'ENCHANTMENT_MENU_STATE';
	this.group.visible = true;
};

// CLOSE:
// ************************************************************************************************
UIEnchantmentMenu.prototype.close = function () {
	gs.state = 'GAME_STATE';
	gs.usingFountain = null;
	this.group.visible = false;
};

// GET_EQUIPMENT_DESC_UNDER_POINTER:
// ************************************************************************************************
UIEnchantmentMenu.prototype.getItemUnderPointer = function () {
	return this.uiItemSlotList.getItemUnderPointer();
};/*global game, gs, Phaser, console, */
/*global Item*/
/*global SCALE_FACTOR, HUGE_WHITE_FONT, SCREEN_HEIGHT, LARGE_WHITE_FONT*/
/*global MAX_ENCHANTMENT*/
/*global UIItemSlotList, ItemSlotList*/
/*jshint laxbreak: true, esversion: 6*/
'use strict';

// CONSTRUCTOR
// ************************************************************************************************
function UIAcquirementMenu() {
	var startX = 80,
		startY = 120,
		width = 520,
        height = 380,
		sprite,
		spacing = 30;
	
	this.group = game.add.group();
	this.group.fixedToCamera = true;
	
	sprite = gs.createSprite(startX, startY, 'SmallMenu', this.group);
	sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	
	// Title Text:
	this.titleText = gs.createText(startX + width / 2, startY + 20, 'Summon Item', HUGE_WHITE_FONT, this.group);
	gs.centerText(this.titleText);
	
	this.buttons = [];
	this.buttons[0] = gs.createTextButton(startX + width / 2, startY + 60, 'Weapon', this.meleeWeaponClicked, this, this.group);
	this.buttons[1] = gs.createTextButton(startX + width / 2, startY + 60 + spacing, 'Staff', this.staffClicked, this, this.group);
	this.buttons[2] = gs.createTextButton(startX + width / 2, startY + 60 + spacing * 2, 'Projectiles', this.rangeWeaponClicked, this, this.group);
	this.buttons[3] = gs.createTextButton(startX + width / 2, startY + 60 + spacing * 3, 'Armor', this.armorClicked, this, this.group);
	this.buttons[4] = gs.createTextButton(startX + width / 2, startY + 60 + spacing * 4, 'Shield', this.shieldClicked, this, this.group);
	this.buttons[5] = gs.createTextButton(startX + width / 2, startY + 60 + spacing * 5, 'Ring', this.ringClicked, this, this.group);
	this.buttons[6] = gs.createTextButton(startX + width / 2, startY + 60 + spacing * 6, 'Charm', this.charmClicked, this, this.group);
	this.buttons[7] = gs.createTextButton(startX + width / 2, startY + 60 + spacing * 7, 'Wand', this.wandClicked, this, this.group);
	this.buttons[8] = gs.createTextButton(startX + width / 2, startY + 60 + spacing * 8, 'Potion', this.potionClicked, this, this.group);
	this.buttons[9] = gs.createTextButton(startX + width / 2, startY + 60 + spacing * 9, 'Scroll', this.scrollClicked, this, this.group);
	this.buttons[10] = gs.createTextButton(startX + width / 2, startY + 60 + spacing * 10, 'Food', this.foodClicked, this, this.group);
	this.buttons[11] = gs.createTextButton(startX + width / 2, startY + 60 + spacing * 11, 'Book', this.summonBook, this, this.group);
	
	this.descText = gs.createText(startX + width / 2, startY + 420, 'Select an item type to randomly summon.', LARGE_WHITE_FONT, this.group);
	gs.centerText(this.descText);
	
	// Close button:
	this.closeButton = gs.createTextButton(startX + width / 2, startY + 470, 'Close', this.close, this, this.group);
	
	
	this.group.visible = false;
}

// REFRESH:
// ************************************************************************************************
UIAcquirementMenu.prototype.refresh = function () {};

// OPEN:
// ************************************************************************************************
UIAcquirementMenu.prototype.open = function () {
	gs.pc.stopExploring();
	
	this.titleText.updateFont(HUGE_WHITE_FONT);
	
	this.refresh();
	gs.state = 'ACQUIREMENT_MENU_STATE';
	this.group.visible = true;
};

// CLOSE:
// ************************************************************************************************
UIAcquirementMenu.prototype.close = function () {
	gs.usingFountain = null;
	gs.state = 'GAME_STATE';
	this.group.visible = false;
};

// CONSUME_SCROLL_OR_FOUNTAIN:
// ************************************************************************************************
UIAcquirementMenu.prototype.consumeScrollOrFountain = function () {
	// Using Scroll:
	if (!gs.usingFountain) {
		gs.pc.inventory.removeItem(gs.pc.inventory.itemOfType(gs.itemTypes.ScrollOfAcquirement), 1);
	}
	// Using Fountain:
	else {
		gs.usingFountain.setIsFull(false);
		gs.usingFountain = null;
	}
};

// SUMMON_BOOK:
// ************************************************************************************************
UIAcquirementMenu.prototype.summonBook = function () {
	var itemName;
	
	while (!itemName) {
		itemName = gs.getRandomItemName('Books');
	}
	
	this.consumeScrollOrFountain();
	
	gs.pc.inventory.addItem(Item.createItem(itemName));
	
	this.close();
	gs.createParticlePoof(gs.pc.tileIndex, 'PURPLE');
	gs.playSound(gs.sounds.cure);
};

// SUMMON_EQUIPMENT:
// ************************************************************************************************
UIAcquirementMenu.prototype.summonEquipment = function (tableName) {
	var itemName, mod, itemType;
	
	while (!itemType) {
		itemType = gs.itemTypes[gs.getRandomItemName(tableName)];
	}
	
	mod = this.getMod();
	if (gs.pc.inventory.itemOfType(itemType) && gs.pc.inventory.itemOfType(itemType).mod >= mod) {
		mod = gs.pc.inventory.itemOfType(itemType).mod + 1;
	}
	
	if (itemType.cantEnchant) {
		mod = 0;
	}
	
	this.consumeScrollOrFountain();
	
	gs.pc.inventory.addItem(Item.createItem(itemType.name, {mod: mod}));
	
	this.close();
	gs.createParticlePoof(gs.pc.tileIndex, 'PURPLE');
	gs.playSound(gs.sounds.cure);
};

// MELEE_WEAPON_CLICKED:
// ************************************************************************************************
UIAcquirementMenu.prototype.meleeWeaponClicked = function () {
	this.summonEquipment('Melee');
};

// STAFF_CLICKED:
// ************************************************************************************************
UIAcquirementMenu.prototype.staffClicked = function () {
	this.summonEquipment('Staves');
};

// ARMOR_CLICKED:
// ************************************************************************************************
UIAcquirementMenu.prototype.armorClicked = function () {
	this.summonEquipment('Armor');
};

// SHIELD_CLICKED:
// ************************************************************************************************
UIAcquirementMenu.prototype.shieldClicked = function () {
	this.summonEquipment('Shields');
};

// RING_CLICKED:
// ************************************************************************************************
UIAcquirementMenu.prototype.ringClicked = function () {
	this.summonEquipment('Rings');
};

// CHARM_CLICKED:
// ************************************************************************************************
UIAcquirementMenu.prototype.charmClicked = function () {
	this.summonEquipment('Charms');
};

// WAND_CLICKED:
// ************************************************************************************************
UIAcquirementMenu.prototype.wandClicked = function () {
	this.summonEquipment('Wands');
};

// RANGE_WEAPON_CLICKED:
// ************************************************************************************************
UIAcquirementMenu.prototype.rangeWeaponClicked = function () {
	var itemName, mod;
	
	while (!itemName) {
		itemName = gs.getRandomItemName('RangedWeapons');
	}
	
	mod = this.getMod();
	
	this.consumeScrollOrFountain();
	
	gs.pc.inventory.addItem(Item.createItem(itemName, {mod: mod, amount: 30}));
	
	this.close();
	gs.createParticlePoof(gs.pc.tileIndex, 'PURPLE');
	gs.playSound(gs.sounds.cure);
};

// POTION_CLICKED:
// ************************************************************************************************
UIAcquirementMenu.prototype.potionClicked = function () {
	var itemName;
	
	while (!itemName) {
		itemName = gs.getRandomItemName('Potions');
	}
	
	this.consumeScrollOrFountain();
	
	if (itemName === 'PotionOfGainAttribute') {
		gs.pc.inventory.addItem(Item.createItem(itemName, {amount: 2}));
	} else {
		gs.pc.inventory.addItem(Item.createItem(itemName, {amount: 3}));
	}
	
	this.close();
	gs.createParticlePoof(gs.pc.tileIndex, 'PURPLE');
	gs.playSound(gs.sounds.cure);
};

// SCROLL_CLICKED:
// ************************************************************************************************
UIAcquirementMenu.prototype.scrollClicked = function () {
	var itemName;
	
	while (!itemName || itemName === 'ScrollOfAcquirement') {
		itemName = gs.getRandomItemName('Scrolls');
	}
	
	this.consumeScrollOrFountain();
	
	if (itemName === 'ScrollOfEnchantment') {
		gs.pc.inventory.addItem(Item.createItem(itemName, {amount: 2}));
	} else {
		gs.pc.inventory.addItem(Item.createItem(itemName, {amount: 3}));
	}
	
	this.close();
	gs.createParticlePoof(gs.pc.tileIndex, 'PURPLE');
	gs.playSound(gs.sounds.cure);
	
};

// FOOD_CLICKED:
// ************************************************************************************************
UIAcquirementMenu.prototype.foodClicked = function () {
	this.consumeScrollOrFountain();
	
	gs.pc.inventory.addItem(Item.createItem('Meat', {amount: 3}));
	
	this.close();
	gs.createParticlePoof(gs.pc.tileIndex, 'PURPLE');
	gs.playSound(gs.sounds.cure);
};

UIAcquirementMenu.prototype.getMod = function () {
	return Math.min(MAX_ENCHANTMENT, Math.ceil(gs.pc.level / 3));
};/*global game, gs, Phaser, console, */
/*global Item*/
/*global SCALE_FACTOR, HUGE_WHITE_FONT, SCREEN_HEIGHT, NUM_EQUIPMENT_SLOTS*/
/*global UIItemSlotList, ItemSlotList, ItemSlot, UIItemSlot*/
/*jshint laxbreak: true, esversion: 6*/
'use strict';

// CONSTRUCTOR
// ************************************************************************************************
function UITransferanceMenu() {
	var startX = 80,
		startY = 120,
		width = 520,
        height = 380,
		sprite;
	
	this.group = game.add.group();
	this.group.fixedToCamera = true;
	
	sprite = gs.createSprite(startX, startY, 'SmallMenu', this.group);
	sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	
	// Title Text:
	this.titleText = gs.createText(startX + width / 2, startY + 20, 'Transfer Enchantment', HUGE_WHITE_FONT, this.group);
	gs.centerText(this.titleText);
	
	// Arrow sprite:
	this.arrowSprite = gs.createSprite(startX + width / 2 - 20, startY + 40, 'Tileset', this.group);
	this.arrowSprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	this.arrowSprite.frame = 1236;
	
	// Transfer UISlots:
	this.uiSlot1 = new UIItemSlot(startX + width / 2 - 60, startY + 40, this.slot1, null, this.slotClicked, this, this.group);
	this.uiSlot2 = new UIItemSlot(startX + width / 2 + 20, startY + 40, this.slot2, null, this.slotClicked, this, this.group);
	
	// Inventory UISlots:
	this.uiItemSlotList = new UIItemSlotList(startX + width / 2 - 42 * 3, startY + 122, 6, 6, null, this.slotClicked, this, this.group);
	
	// Transfer Button:
	this.transferButton = gs.createTextButton(startX + width / 2, startY + 100, 'Transfer', this.transferClicked, this, this.group);
	
	// Close button:
	this.closeButton = gs.createTextButton(startX + width / 2, startY + 470, 'Close', this.close, this, this.group);
	
	// Mouse UISlot:
	this.mouseUISlot = new UIItemSlot(0, 0, null, null, null, null, this.group);
	this.mouseUISlot.slotSprite.visible = false;
	
	
	this.group.visible = false;
}

// TRANSFER_CLICKED:
// ************************************************************************************************
UITransferanceMenu.prototype.transferClicked = function () {
	var item1, item2;
	
	if (this.canTransfer()) {
		item1 = this.uiSlot1.itemSlot.item;
		item2 = this.uiSlot2.itemSlot.item;
		
		// Swapping mods:
		let temp = item1.mod;
		item1.mod = item2.mod;
		item2.mod = temp;
		
		// Recharge wands:
		if (item1.getModdedStat('maxCharges')) {
			item1.charges = item1.getModdedStat('maxCharges');
		}
		if (item2.getModdedStat('maxCharges')) {
			item2.charges = item2.getModdedStat('maxCharges');
		}
		
		gs.createParticlePoof(gs.pc.tileIndex, 'PURPLE');
		gs.playSound(gs.sounds.cure, gs.pc.tileIndex);
		gs.usingFountain.setIsFull(false);
		gs.usingFountain = null;
		this.close();
	}
};

// CAN_TRANSFER:
// ************************************************************************************************
UITransferanceMenu.prototype.canTransfer = function () {
	var item1, item2;
	
	// Must have an item in each slot:
	if (!this.uiSlot1.itemSlot || !this.uiSlot2.itemSlot || this.uiSlot1.itemSlot.isEmpty() || this.uiSlot2.itemSlot.isEmpty()) {
		return false;
	}
	
	item1 = this.uiSlot1.itemSlot.item;
	item2 = this.uiSlot2.itemSlot.item;
	
	// Cannot transfer if mod is the same:
	if (item1.mod === item2.mod) {
		return false;
	}
	
	// Cannot transfer to an item below its base mod:
	if (item1.mod < item2.type.baseMod || item2.mod < item1.type.baseMod) {
		return false;
	}
	
	// Cannot transfer to stackable items (consumable projectiles):
	if (item1.type.stackable || item2.type.stackable) {
		return false;
	}
	
	
	
	return true;
};

// SLOT_CLICKED:
// ************************************************************************************************
UITransferanceMenu.prototype.slotClicked = function (slot, uiSlot) {
	// Pick up item into empty mouse:
	if (slot && slot.hasItem() && !this.mouseUISlot.itemSlot) {
		this.mouseUISlot.itemSlot = slot;
		uiSlot.itemSlot = null;
	}
	// Place mouse into empty slot:
	else if (this.mouseUISlot.itemSlot && !uiSlot.itemSlot) {
		uiSlot.itemSlot = this.mouseUISlot.itemSlot;
		this.mouseUISlot.itemSlot = null;
	}
	// Swap slots:
	else if (slot && slot.hasItem && this.mouseUISlot.itemSlot) {
		let temp = uiSlot.itemSlot;
		uiSlot.itemSlot = this.mouseUISlot.itemSlot;
		this.mouseUISlot.itemSlot = temp;
	}
	
	this.refresh();
};

// UPDATE:
// ************************************************************************************************
UITransferanceMenu.prototype.update = function () {
	this.mouseUISlot.setPosition(game.input.activePointer.x, game.input.activePointer.y);
};

// OPEN:
// ************************************************************************************************
UITransferanceMenu.prototype.open = function () {
	var playerItemSlots;
	
	this.titleText.updateFont(HUGE_WHITE_FONT);
	
	
	// Get list of all enchantable items:
	playerItemSlots = gs.pc.inventory.allFullItemSlots();
	playerItemSlots = playerItemSlots.filter(slot => slot.item.canEnchant() || slot.item.mod > 0);
	this.uiItemSlotList.setItemSlots(playerItemSlots);
	
	// Empty out slots:
	this.mouseUISlot.itemSlot = null;
	this.uiSlot1.itemSlot = null;
	this.uiSlot2.itemSlot = null;
	
	// Hide slots which contain no item:
	for (let i = 0; i < this.uiItemSlotList.uiItemSlots.length; i += 1) {
		if (!this.uiItemSlotList.uiItemSlots[i].itemSlot || this.uiItemSlotList.uiItemSlots[i].itemSlot.isEmpty()) {
			this.uiItemSlotList.uiItemSlots[i].slotSprite.visible = false;
		} 
		else {
			this.uiItemSlotList.uiItemSlots[i].slotSprite.visible = true;
		}
	}
	
	this.refresh();
	gs.state = 'TRANSFERANCE_MENU_STATE';
	this.group.visible = true;
};

// REFRESH:
// ************************************************************************************************
UITransferanceMenu.prototype.refresh = function () {
	this.uiSlot1.refresh();
	this.uiSlot2.refresh();
	this.mouseUISlot.refresh();
	this.uiItemSlotList.refresh();
	
	// Green or red transfer arrow:
	if (this.canTransfer()) {
		this.arrowSprite.frame = 1235;
	}
	else {
		this.arrowSprite.frame = 1236;
	}
};

// CLOSE:
// ************************************************************************************************
UITransferanceMenu.prototype.close = function () {
	gs.state = 'GAME_STATE';
	gs.usingFountain = null;
	this.group.visible = false;
};

// GET_EQUIPMENT_DESC_UNDER_POINTER:
// ************************************************************************************************
UITransferanceMenu.prototype.getItemUnderPointer = function () {
	return this.uiItemSlotList.getItemUnderPointer();
};/*global game, gs, console, Phaser*/
/*global SMALL_WHITE_FONT, SCALE_FACTOR*/
/*jshint esversion: 6*/
'use strict';

// UI_TEXT_BUTTON_LIST
// ************************************************************************************************
function UITextButtonList(startX, startY, numButtons, group, context, callback) {
	var buttonSpace = 30;
	
	this.startIndex = 0;
	this.group = group;
	this.buttons = [];
	
	// Buttons:
	for (let i = 0; i < numButtons; i += 1) {
		this.buttons[i] =  this.createButton(startX, startY + i * buttonSpace, context, callback);
	}
	
	// Arrows:
	this.upArrow = game.add.button(startX + 100, startY - 20, 'Tileset', this.upClicked, this, 1296, 1295);
	this.upArrow.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	this.group.add(this.upArrow);
	
	this.downArrow = game.add.button(startX + 100, startY + (numButtons - 1) * buttonSpace - 20, 'Tileset', this.downClicked, this, 1294, 1293);
	this.downArrow.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	this.group.add(this.downArrow);
	
}

// CREATE_BUTTON:
// ************************************************************************************************
UITextButtonList.prototype.createButton = function (x, y, context, callback) {
	var button = {};
    
    // Create button group:
    button.group = game.add.group();
    
    // Create button:
    button.button = game.add.button(x, y, 'Button', callback, context, 1, 0, 0, 0);
	button.button.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
    button.button.smoothed = false;
    button.button.anchor.setTo(0.5, 0.5);
    button.group.add(button.button);
    
    // Create text:
    button.text = game.add.text(x - button.button.width / 2 + 4, y - button.button.height / 2 + 4, 'Default', SMALL_WHITE_FONT);
    button.group.add(button.text);
	
	// Num Text:
	button.numText = game.add.text(x + button.button.width / 2 - 4, y - button.button.height / 2 + 4, '5/5', SMALL_WHITE_FONT);
	button.numText.anchor.setTo(1, 0);
	button.group.add(button.numText);
	
	this.group.add(button.group);
    
    return button;
};

// DOWN_CLICKED:
// ************************************************************************************************
UITextButtonList.prototype.downClicked = function () {
	this.startIndex += 1;
	gs.characterMenu.refresh();
};

// UP_CLICKED:
// ************************************************************************************************
UITextButtonList.prototype.upClicked = function () {
	if (this.startIndex > 0) {
		this.startIndex -= 1;
		gs.characterMenu.refresh();
	}
};/*global gs, console, game*/
/*global SCREEN_HEIGHT, SCALE_FACTOR, SMALL_WHITE_FONT, HUGE_WHITE_FONT*/
/*jshint esversion: 6, laxbreak: true*/
'use strict';

// UI_HELP_MENU:
// ************************************************************************************************
function UIHelpMenu() {
	var width = 560,
        height = 540,
		startX = 80,
		startY = (SCREEN_HEIGHT - height) / 2,
		sprite,
		str = '';
	
	this.group = game.add.group();
	this.group.fixedToCamera = true;
		
	// Menu:
    sprite = gs.createSprite(startX, startY, 'SmallMenu', this.group);
	sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	
	// Title:
	this.titleText = gs.createText(startX + width / 2, startY + 20, 'Controls', HUGE_WHITE_FONT, this.group);
	gs.centerText(this.titleText);
	
	// Help String:
	str += "- The Num Pad keys can be used for movement\n";
	str += "- Shift + click a tile to move into dangerous terrain\n";
	str += "- Click your character to wait a turn.\n";
	str += "- Shift + clicking your character will perform extended rest\n";
	str += "- Space, Enter, NumPad 5 are hotkeys for clicking yourself\n";
	str += "- 1, 2, 3 etc. are hotkeys for your abilities\n";
	str += "- [a] toggle keyboard targeting mode\n";
	str += "- [w] swap between current and previous weapon\n";
	str += "- [tab] auto attack nearest enemy\n";
	str += "- [q] auto attack nearest enemy with quick slot weapon\n";
	str += "- [esc] closes menus and cancels abilities or items\n";
	str += "- [s] to use any stairs\n";
	str += "- [>] to use down stairs or fast travel to them\n";
	str += "- [<] to use up stairs or fast travel to them\n";
	str += "- [e] to auto explore\n";
	
	// Text:
	let lines = gs.wrapText(str, 61);
	this.text = gs.createText(startX + 4, startY + 40, lines.join('\n'), SMALL_WHITE_FONT, this.group);
	
	// Close button:
	this.closeButton = gs.createTextButton(startX + width / 2, startY + 520, 'Close', this.close, this, this.group);
	
	this.group.visible = false;
}

// OPEN:
// ************************************************************************************************
UIHelpMenu.prototype.open = function () {
	
	this.titleText.updateFont(HUGE_WHITE_FONT);
	
	
	gs.state = 'HELP_MENU_STATE';
	this.group.visible = true;
};

// CLOSE:
// ************************************************************************************************
UIHelpMenu.prototype.close = function () {
	gs.state = 'GAME_STATE';
	this.group.visible = false;
};/*global gs, console, game*/
/*global SCREEN_HEIGHT, SCALE_FACTOR, SMALL_WHITE_FONT, HUGE_WHITE_FONT, CLASS_LIST, PLAYER_FRAMES*/
/*jshint esversion: 6, laxbreak: true*/
'use strict';

// UI_RECORD_MENU:
// ************************************************************************************************
function UIRecordMenu() {
	var width = 720,
        height = 540,
		startX = 2,
		startY = 2,
		sprite;
	
	this.group = game.add.group();
	this.group.fixedToCamera = true;
		
	// Menu:
    sprite = gs.createSprite(2, 2, 'Menu', this.group);
	sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
	
	// Title:
	this.titleText = gs.createText(startX + width / 2, startY + 20, 'Game Records', HUGE_WHITE_FONT, this.group);
	gs.centerText(this.titleText);
	
	// Class Buttons:
	this.classButtons = {};
	['All'].concat(CLASS_LIST.concat(['Challenge'])).forEach(function (className, i) {
		let x = startX + i * 50 + 4,
			y = startY + 40;
		
		let button = gs.createButton(x, y, 'BigSlot', this.classClicked, this, this.group);
		button.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
		button.setFrames(1, 0);
		button.className = className;
		
		this.classButtons[className] = button;
		
		let sprite = gs.createSprite(x + 4, y + 4, 'Tileset',  this.group);
		sprite.scale.setTo(SCALE_FACTOR, SCALE_FACTOR);
		
		
		if (className === 'Challenge') {
			sprite.frame = 1226;
		}
		else if (className === 'All') {
			sprite.frame = 1227;
		}
		else {
			sprite.frame = PLAYER_FRAMES[className];
		}
	}, this);
	
	
	// Text:
	this.text = gs.createText(startX + 4, startY + 100, '', SMALL_WHITE_FONT, this.group);
	
	// Close button:
	this.closeButton = gs.createTextButton(startX + width / 2, SCREEN_HEIGHT - 20, 'Close', this.close, this, this.group);
	
	
	// Start with All selected:
	this.classClicked({className: 'All'});
	
	
	this.group.visible = false;
}

// CLASS_CLICKED:
// ************************************************************************************************
UIRecordMenu.prototype.classClicked = function (button) {
	// Previous button:
	if (this.selectedClass) {
		this.classButtons[this.selectedClass].setFrames(1, 0);
	}
	
	this.selectedClass = button.className;
	this.classButtons[this.selectedClass].setFrames(2, 3);
	
	this.refresh();
};

// REFRESH:
// ************************************************************************************************
UIRecordMenu.prototype.refresh = function () {
	var str = '',
		latestRecords,
		numWins,
		numDeaths;
	
	// WINS_LOSSES_AND_PERCENT:
	if (this.selectedClass === 'All') {
		numWins = gs.totalWins();
		numDeaths = gs.totalDeaths();
	}
	else if (this.selectedClass === 'Challenge') {
		numWins = gs.numChallengeWins();
		numDeaths = gs.numChallengeDeaths();
	}
	else {
		numWins = gs.numWinsWithClass(this.selectedClass);
		numDeaths = gs.numDeathsWithClass(this.selectedClass);
	}
	
	str += 'Total Wins: ' + numWins + '\n';
	str += 'Total Deaths: ' + numDeaths + '\n';

	if (numWins + numDeaths > 0) {
		str += 'Win Percent: ' + gs.toPercentStr(numWins / (numWins + numDeaths)) + '\n';
	}
	
	// FASTEST_TIME:
	if (this.selectedClass === 'All') {
		let obj = gs.fastestWinTime();
		if (obj) {
			str += 'Fastest Win Time: ' + gs.timeToString(obj.time) + ' - ' + gs.capitalSplit(obj.className) + '\n';
		}
		
	}
	else if (this.selectedClass === 'Challenge') {
		
	}
	else {
		if (gs.achievements[this.selectedClass] > 0) {
			str += 'Fastest win Time: ' + gs.timeToString(gs.achievements[this.selectedClass]) + '\n';
		}	
	}

	// WIN_STREAK:
	if (this.selectedClass === 'All') {
		if (gs.highestWinStreak() > 1) {
			str += 'Best Win Streak: ' + gs.highestWinStreak() + ' - ' + gs.highestWinStreakClass() +'\n';
		}
	}
	else if (this.selectedClass === 'Challenge') {
		if (gs.bestChallengeWinStreak() > 1) {
			str += 'Best Win Streak: ' + gs.bestChallengeWinStreak() + '\n';
		}
	}
	else {
		if (gs.bestWinStreakWithClass(this.selectedClass) > 1) {
			str += 'Best Win Streak: ' + gs.bestWinStreakWithClass(this.selectedClass) + '\n';
		}
	}
	str += '\n';
	
	
	// Get the last 7 games:
	if (this.selectedClass === 'All') {
		latestRecords = gs.gameRecords.slice(-7);
	}
	else if (this.selectedClass === 'Challenge') {
		latestRecords = gs.gameRecords.filter(record => record.isChallenge).slice(-7);
	}
	else {
		latestRecords = gs.gameRecords.filter(record => record.playerClass === this.selectedClass).slice(-7);
	}
	
	
	
	
	latestRecords.reverse();
	latestRecords.forEach(function (record) {
		str += record.toString() + '\n\n';
	}, this);
	
	let lines = gs.wrapText(str, 82);
	this.text.setText(lines.join('\n'));
};

// OPEN:
// ************************************************************************************************
UIRecordMenu.prototype.open = function () {
	this.titleText.updateFont(HUGE_WHITE_FONT);
	
	
	this.group.visible = true;
};

// CLOSE:
// ************************************************************************************************
UIRecordMenu.prototype.close = function () {
	this.group.visible = false;
};